<!DOCTYPE html>
<html data-clipboard-buttons="" data-code-prettify="" data-code-sidebar="" data-hide-show-guide="" data-sts-import="" data-mobile-support="" data-search="">
<head>
<title>Topical Guide · Spring Boot Docker</title>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no" id="Viewport" name="viewport" />
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png" />
<link href="https://fonts.googleapis.com/css?family=Varela+Round|Montserrat:400,700" rel="stylesheet" type="text/css" />
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css" />
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M" name="google-site-verification" />

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link rel="stylesheet" type="text/css" href="/css/gsguide-cce08ab7a9f46db88819a14148e45bad.css" />

<meta property="og:title" content="Spring Boot Docker" />
<meta property="og:image" content="/img/spring-by-pivotal-9066b55828deb3c10e27e609af322c40.png" />
<meta property="og:description" content="this topical is designed to be read and comprehended in under an hour, it provides broad coverage of a topic that is possibly nuanced or requires deeper understanding than you would get from a getting started guide" />
</head>
<body>

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" style="display:none;visibility:hidden" width="0"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">Projects</a>
</li>
<li class="navbar-link active">
<a href="/guides">Guides</a>
</li>
<li class="navbar-link">
<a href="/blog">Blog</a>
</li>
<li class="navbar-link">
<a href="/services">Training & Certification</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form action="/search" class="form-inline form-search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search for documentation, guides, and posts..." type="text" value="" />
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form action="/search" class="form-inline form-search" method="get">
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search..." type="text" value="" />
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">
Home
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">
Projects
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/guides">
Guides
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/blog">
Blog
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">
Training & Certification
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<main class="main-body--wrapper">
<div class="row-fluid">
<div class="span8 mobile-left-pane">
<div class="content--title desktop-only">Topical Guide</div>
<article class="content--container">
<h1 class="title">Spring Boot Docker</h1>
<div class="article-body"><div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Many people are using containers to wrap their Spring Boot applications, and building containers is not a simple thing to do. This is a guide for developers of Spring Boot applications, and containers are not always a good abstraction for developers - they force you to learn about and think about very low level concerns - but you will on occasion be called on to create or use a container, so it pays to understand the building blocks. Here we aim to show you some of the choices you can make if you are faced with the prospect of needing to create your own container.</p>
</div>
<div class="paragraph">
<p>We will assume that you know how to create and build a basic Spring Boot application. If you don’t, go to one of the <a href="https://spring.io/guides">Getting Started Guides</a>, for example the one on building a <a href="https://spring.io/guides/gs/rest-service/">REST Service</a>. Copy the code from there and practise with some of the ideas below.</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="Note"></i> </td>
<td class="content"> There is also a Getting Started Guide on <a href="https://spring.io/guides/gs/spring-boot-docker">Docker</a>, which would also be a good starting point, but it doesn’t cover the range of choices that we have here, or in as much detail. </td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_basic_dockerfile">A Basic Dockerfile</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A Spring Boot application is easy to convert into an executable JAR file. All the <a href="https://spring.io/guides">Getting Started Guides</a> do this, and every app that you download from <a href="https://start.spring.io">Spring Initializr</a> will have a build step to create an executable JAR. With Maven you <code>./mvnw install</code> and with Gradle you <code>./gradlew build</code>. A basic Dockerfile to run that JAR would then look like this, at the top level of your project:</p>
</div>
<div class="paragraph">
<p><code>Dockerfile</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>FROM openjdk:8-jdk-alpine
VOLUME /tmp
ARG JAR_FILE
COPY ${JAR_FILE} app.jar
ENTRYPOINT ["java","-jar","/app.jar"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>JAR_FILE</code> could be passed in as part of the <code>docker</code> command (it will be different for Maven and Gradle). E.g. for Maven:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ docker build --build-arg=target/*.jar -t myorg/myapp .</code></pre>
</div>
</div>
<div class="paragraph">
<p>and for Gradle:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ docker build --build-arg=build/libs/*.jar -t myorg/myapp .</code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course, once you have chosen a build system, you don’t need the <code>ARG</code> - you can just hard code the jar location. E.g. for Maven:</p>
</div>
<div class="paragraph">
<p><code>Dockerfile</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>FROM openjdk:8-jdk-alpine
VOLUME /tmp
COPY target/*.jar app.jar
ENTRYPOINT ["java","-jar","/app.jar"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then we can simply build an image with</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ docker build -t myorg/myapp .</code></pre>
</div>
</div>
<div class="paragraph">
<p>and run it like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ docker run -p 8080:8080 myorg/myapp
  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v2.0.2.RELEASE)

Nov 06, 2018 2:45:16 PM org.springframework.boot.StartupInfoLogger logStarting
INFO: Starting Application v0.1.0 on b8469cdc9b87 with PID 1 (/app.jar started by root in /)
Nov 06, 2018 2:45:16 PM org.springframework.boot.SpringApplication logStartupProfileInfo
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to poke around inside the image you can open a shell in it like this (the base image does not have <code>bash</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ docker run -ti --entrypoint /bin/sh myorg/myapp
/ # ls
app.jar  dev      home     media    proc     run      srv      tmp      var
bin      etc      lib      mnt      root     sbin     sys      usr
/ #</code></pre>
</div>
</div>
<div class="paragraph">
<p>The docker configuration is very simple so far, and the generated image is not very efficient. The docker image has a single filesystem layer with the fat jar in it, and every change we make to the application code changes that layer, which might be 10MB or more (even as much as 50MB for some apps). We can improve on that by splitting the JAR up into multiple layers.</p>
</div>
<div class="sect2">
<h3 id="_smaller_images">Smaller Images</h3>
<div class="paragraph">
<p>Notice that the base image in the example above is <code>openjdk:8-jdk-alpine</code>. The <code>alpine</code> images are smaller than the standard <code>openjdk</code> library images from <a href="https://hub.docker.com/_/openjdk/">Dockerhub</a>. There is no official alpine image for Java 11 yet (AdoptOpenJDK had one for a while but it no longer appears on their <a href="https://hub.docker.com/r/adoptopenjdk/openjdk11/">Dockerhub page</a>). You can also save about 20MB in the base image by using the "jre" label instead of "jdk". Not all apps work with a JRE (as opposed to a JDK), but most do, and indeed some organizations enforce a rule that every app has to because of the risk of misuse of some of the JDK features (like compilation).</p>
</div>
<div class="paragraph">
<p>Another trick that could get you a smaller image is to use <a href="https://openjdk.java.net/projects/jigsaw/quick-start#linker">JLink</a>, which is bundled with OpenJDK 11. JLink allows you to build a custom JRE distribution from a subset of modules in the full JDK, so you don’t need a JRE or JDK in the base image. In principle this would get you a smaller total image size than using the <code>openjdk</code> official docker images. In practice, you won’t (yet) be able to use the <code>alpine</code> base image with JDK 11, so your choice of base image will be limited and will probably result in a larger final image size. Also, a custom JRE in your own base image cannot be shared amongst other applications, since they would need different customizations. So you might have smaller images for all your applications, but they still take longer to start because they don’t benefit from caching the JRE layer.</p>
</div>
<div class="paragraph">
<p>That last point highlights a really important concern for image builders: the goal is not necessarily always going to be to build the smallest image possible. Smaller images are generally a good idea because they take less time to upload and download, but only if none of the layers in them are already cached. Image registries are quite sophisticated these days and you can easily lose the benefit of those features by trying to be clever with the image construction. If you use common base layers, the total size of an image is less of a concern, and will probably become even less of one as the registries and platforms evolve. Having said that, it is still important, and useful, to try and optimize the layers in our application image, but the goal should always be to put the fastest changing stuff in the highest layers, and to share as many of the large, lower layers as possible with other applications.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_better_dockerfile">A Better Dockerfile</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A Spring Boot fat jar naturally has "layers" because of the way that the jar itself is packaged. If we unpack it first it will already be divided into external and internal dependencies. To do this in one step in the docker build, we need to unpack the jar first. For example (sticking with Maven, but the Gradle version is pretty similar):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ mkdir target/dependency
$ (cd target/dependency; jar -xf ../*.jar)
$ docker build -t myorg/myapp .</code></pre>
</div>
</div>
<div class="paragraph">
<p>with this <code>Dockerfile</code></p>
</div>
<div class="paragraph">
<p><code>Dockerfile</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>FROM openjdk:8-jdk-alpine
VOLUME /tmp
ARG DEPENDENCY=target/dependency
COPY ${DEPENDENCY}/BOOT-INF/lib /app/lib
COPY ${DEPENDENCY}/META-INF /app/META-INF
COPY ${DEPENDENCY}/BOOT-INF/classes /app
ENTRYPOINT ["java","-cp","app:app/lib/*","hello.Application"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are now 3 layers, with all the application resources in the later 2 layers. If the application dependencies don’t change, then the first layer (from <code>BOOT-INF/lib</code>) will not change, so the build will be faster, and so will the startup of the container at runtime as long as the base layers are already cached.</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="Note"></i> </td>
<td class="content"> We used a hard-coded main application class <code>hello.Application</code>. This will probably be different for your application. You could parameterize it with another <code>ARG</code> if you wanted. You could also copy the Spring Boot fat <code>JarLauncher</code> into the image and use it to run the app - it would work and you wouldn’t need to specify the main class, but it would be a bit slower on startup. </td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tweaks">Tweaks</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If you want to start your app as quickly as possible (most people do) there are some tweaks you might consider. Here are some ideas:</p>
</div>
<div class="ulist">
<ul>
<li> <p>Use the <code>spring-context-indexer</code> (<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-scanning-index">link to docs</a>). It’s not going to add much for small apps, but every little helps.</p> </li>
<li> <p>Don’t use <a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#production-ready">actuators</a> if you can afford not to.</p> </li>
<li> <p>Use Spring Boot 2.1 and Spring 5.1.</p> </li>
<li> <p>Fix the location of the <a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-external-config-application-property-files">Spring Boot config file(s)</a> with <code>spring.config.location</code> (command line argument or System property etc.).</p> </li>
<li> <p>Switch off JMX - you probably don’t need it in a container - with <code>spring.jmx.enabled=false</code></p> </li>
<li> <p>Run the JVM with <code>-noverify</code>. Also consider <code>-XX:TieredStopAtLevel=1</code> (that will slow down the JIT later at the expense of the saved startup time).</p> </li>
<li> <p>Use the container memory hints for Java 8: <code>-XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap</code>. With Java 11 this is automatic by default.</p> </li>
</ul>
</div>
<div class="paragraph">
<p>Your app might not need a full CPU at runtime, but it will need multiple CPUs to start up as quickly as possible (at least 2, 4 are better). If you don’t mind a slower startup you could throttle the CPUs down below 4. If you are forced to start with less than 4 CPUs it might help to set <code>-Dspring.backgroundpreinitializer.ignore=true</code> since it prevents Spring Boot from creating a new thread that it probably won’t be able to use (this works with Spring Boot 2.1.0 and above).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_multi_stage_build">Multi-Stage Build</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>Dockerfile</code> above assumed that the fat JAR was already built on the command line. You can also do that step in docker using a multi-stage build, copying the result from one image to another. Example, using Maven:</p>
</div>
<div class="paragraph">
<p><code>Dockerfile</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>FROM openjdk:8-jdk-alpine as build
WORKDIR /workspace/app

COPY mvnw .
COPY .mvn .mvn
COPY pom.xml .
COPY src src

RUN ./mvnw install -DskipTests
RUN mkdir -p target/dependency &amp;&amp; (cd target/dependency; jar -xf ../*.jar)

FROM openjdk:8-jdk-alpine
VOLUME /tmp
ARG DEPENDENCY=/workspace/app/target/dependency
COPY --from=build ${DEPENDENCY}/BOOT-INF/lib /app/lib
COPY --from=build ${DEPENDENCY}/META-INF /app/META-INF
COPY --from=build ${DEPENDENCY}/BOOT-INF/classes /app
ENTRYPOINT ["java","-cp","app:app/lib/*","hello.Application"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first image is labelled "build" and it is used to run Maven and build the fat jar, then unpack it. The unpacking could also be done by Maven or Gradle (this is the approach taken in the Getting Started Guide) - there really isn’t much difference, except that the build configuration would have to be edited and a plugin added.</p>
</div>
<div class="paragraph">
<p>Notice that the source code has been split into 4 layers. The later layers contain the build configuration and the source code for the app, and the earlier layers contain the build system itself (the Maven wrapper). This is a small optimization, and it also means that we don’t have to copy the <code>target</code> directory to a docker image, even a temporary one used for the build.</p>
</div>
<div class="paragraph">
<p>Every build where the source code changes will be slow because the Maven cache has to be re-created in the first <code>RUN</code> section. But you have a completely standalone build that anyone can run to get your application running as long as they have docker. That can be quite useful in some environments, e.g. where you need to share your code with people who don’t know Java.</p>
</div>
<div class="sect2">
<h3 id="_experimental_features">Experimental Features</h3>
<div class="paragraph">
<p>Docker 18.06 comes with some <a href="https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/experimental.md">"experimental" features</a> that includes a way to cache build dependencies. To switch them on you need a flag in the daemon (<code>dockerd</code>) and also an environment variable when you run the client, and then you can add a magic first line to your <code>Dockerfile</code>:</p>
</div>
<div class="paragraph">
<p><code>Dockerfile</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code># syntax=docker/dockerfile:experimental</code></pre>
</div>
</div>
<div class="paragraph">
<p>and the <code>RUN</code> directive then accepts a new flag <code>--mount</code>. Here’s a full example:</p>
</div>
<div class="paragraph">
<p><code>Dockerfile</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code># syntax=docker/dockerfile:experimental
FROM openjdk:8-jdk-alpine as build
WORKDIR /workspace/app

COPY mvnw .
COPY .mvn .mvn
COPY pom.xml .
COPY src src

RUN --mount=type=cache,target=/root/.m2 ./mvnw install -DskipTests
RUN mkdir -p target/dependency &amp;&amp; (cd target/dependency; jar -xf ../*.jar)

FROM openjdk:8-jdk-alpine
VOLUME /tmp
ARG DEPENDENCY=/workspace/app/target/dependency
COPY --from=build ${DEPENDENCY}/BOOT-INF/lib /app/lib
COPY --from=build ${DEPENDENCY}/META-INF /app/META-INF
COPY --from=build ${DEPENDENCY}/BOOT-INF/classes /app
ENTRYPOINT ["java","-cp","app:app/lib/*","hello.Application"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then run it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ DOCKER_BUILDKIT=1 docker build -t myorg/myapp .
...
 =&gt; /bin/sh -c ./mvnw install -DskipTests              5.7s
 =&gt; exporting to image                                 0.0s
 =&gt; =&gt; exporting layers                                0.0s
 =&gt; =&gt; writing image sha256:3defa...
 =&gt; =&gt; naming to docker.io/myorg/myapp</code></pre>
</div>
</div>
<div class="paragraph">
<p>With the experimental features you get a different output on the console, but you can see that a Maven build now only takes a few seconds instead of minutes, once the cache is warm.</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="Note"></i> </td>
<td class="content"> While these features are in the experimental phase, the options for switching buildkit on and off depend on the version of <code>docker</code> that you are using. Check the documentation for the version you have (the example above is correct for <code>docker</code> 18.0.6). </td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_security_aspects">Security Aspects</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Just as in classic VM-deployments, processes should not be run with root permissions. Instead the image should contain a non-root user that runs the app.</p>
</div>
<div class="paragraph">
<p>In a <code>Dockerfile</code>, this can be achieved by adding another layer that adds a (system) user and group, then set it as the current user (instead of the default, root):</p>
</div>
<div class="paragraph">
<p><code>Dockerfile</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>FROM openjdk:8-jdk-alpine

RUN addgroup -S demo &amp;&amp; adduser -S demo -G demo
USER demo

...</code></pre>
</div>
</div>
<div class="paragraph">
<p>In case someone manages to break out of your app and run system commands inside the container, this will limit their capabilities (principle of least privilege).</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="Note"></i> </td>
<td class="content"> Some of the further <code>Dockerfile</code> commands only work as root, so maybe you have to move the USER command further down (e.g. if you plan to install more packages into the container, which only works as root). </td>
</tr>
</tbody>
</table>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="Note"></i> </td>
<td class="content"> Other approaches, not using a <code>Dockerfile</code>, might be more amenable. For instance, in the buildpack approach described later, most implementations will use a non-root user by default. </td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_build_plugins">Build Plugins</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If you don’t want to call <code>docker</code> directly in your build, there is quite a rich set of plugins for Maven and Gradle that can do that work for you. Here are just a few.</p>
</div>
<div class="sect2">
<h3 id="_spotify_maven_plugin">Spotify Maven Plugin</h3>
<div class="paragraph">
<p>The <a href="https://github.com/spotify/dockerfile-maven">Spotify Maven Plugin</a> is a popular choice. It requires the application developer to write a <code>Dockerfile</code> and then runs <code>docker</code> for you, just as if you were doing it on the command line. There are some configuration options for the docker image tag and other stuff, but it keeps the docker knowledge in your application concentrated in a <code>Dockerfile</code>, which many people like.</p>
</div>
<div class="paragraph">
<p>For really basic usage it will work out of the box with no extra configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ mvn com.spotify:dockerfile-maven-plugin:build
...
[INFO] Building Docker context /home/dsyer/dev/demo/workspace/myapp
[INFO]
[INFO] Image will be built without a name
[INFO]
...
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 7.630 s
[INFO] Finished at: 2018-11-06T16:03:16+00:00
[INFO] Final Memory: 26M/595M
[INFO] ------------------------------------------------------------------------</code></pre>
</div>
</div>
<div class="paragraph">
<p>That builds an anonymous docker image. We can tag it with <code>docker</code> on the command line now, or use Maven configuration to set it as the <code>repository</code>. Example (without changing the <code>pom.xml</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ mvn com.spotify:dockerfile-maven-plugin:build -Ddockerfile.repository=myorg/myapp</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or in the <code>pom.xml</code>:</p>
</div>
<div class="paragraph">
<p><code>pom.xml</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;com.spotify&lt;/groupId&gt;
            &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt;
            &lt;version&gt;1.4.8&lt;/version&gt;
            &lt;configuration&gt;
                &lt;repository&gt;myorg/${project.artifactId}&lt;/repository&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_palantir_gradle_plugin">Palantir Gradle Plugin</h3>
<div class="paragraph">
<p>The <a href="https://github.com/palantir/gradle-docker">Palantir Gradle Plugin</a> works with a <code>Dockerfile</code> and it also is able to generate a <code>Dockerfile</code> for you, and then it runs <code>docker</code> as if you were running it on the command line.</p>
</div>
<div class="paragraph">
<p>First you need to import the plugin into your <code>build.gradle</code>:</p>
</div>
<div class="paragraph">
<p><code>build.gradle</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">buildscript {
    ...
    dependencies {
        ...
        classpath('gradle.plugin.com.palantir.gradle.docker:gradle-docker:0.13.0')
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and then finally you apply the plugin and call its task:</p>
</div>
<div class="paragraph">
<p><code>build.gradle</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">apply plugin: 'com.palantir.docker'

group = 'myorg'

bootJar {
    baseName = 'myapp'
    version =  '0.1.0'
}

task unpack(type: Copy) {
    dependsOn bootJar
    from(zipTree(tasks.bootJar.outputs.files.singleFile))
    into("build/dependency")
}
docker {
    name "${project.group}/${bootJar.baseName}"
    copySpec.from(tasks.unpack.outputs).into("dependency")
    buildArgs(['DEPENDENCY': "dependency"])
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example we have chosen to unpack the Spring Boot fat jar in a specific location in the <code>build</code> directory, which is the root for the docker build. Then the multi-layer (not multi-stage) <code>Dockerfile</code> from above will work.</p>
</div>
</div>
<div class="sect2">
<h3 id="_jib_maven_and_gradle_plugins">Jib Maven and Gradle Plugins</h3>
<div class="paragraph">
<p>Google has an open source tool called <a href="https://github.com/GoogleContainerTools/jib">Jib</a> that is relatively new, but quite interesting for a number of reasons. Probably the most interesting thing is that you don’t need docker to run it - it builds the image using the same standard output as you get from <code>docker build</code> but doesn’t use <code>docker</code> unless you ask it to - so it works in environments where docker is not installed (not uncommon in build servers). You also don’t need a <code>Dockerfile</code> (it would be ignored anyway), or anything in your <code>pom.xml</code> to get an image built in Maven (Gradle would require you to at least install the plugin in <code>build.gradle</code>).</p>
</div>
<div class="paragraph">
<p>Another interesting feature of Jib is that it is opinionated about layers, and it optimizes them in a slightly different way than the multi-layer <code>Dockerfile</code> created above. Just like in the fat jar, Jib separates local application resources from dependencies, but it goes a step further and also puts snapshot dependencies into a separate layer, since they are more likely to change. There are configuration options for customizing the layout further.</p>
</div>
<div class="paragraph">
<p>Example with Maven (without changing the <code>pom.xml</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ mvn com.google.cloud.tools:jib-maven-plugin:build -Dimage=myorg/myapp</code></pre>
</div>
</div>
<div class="paragraph">
<p>To run the above command you will need to have permission to push to Dockerhub under the <code>myorg</code> repository prefix. If you have authenticated with <code>docker</code> on the command line, that will work from your local <code>~/.docker</code> configuration. You can also set up a Maven "server" authentication in your <code>~/.m2/settings.xml</code> (the <code>id</code> of the repository is significant):</p>
</div>
<div class="paragraph">
<p><code>settings.xml</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>    &lt;server&gt;
      &lt;id&gt;registry.hub.docker.com&lt;/id&gt;
      &lt;username&gt;myorg&lt;/username&gt;
      &lt;password&gt;...&lt;/password&gt;
    &lt;/server&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are other options, e.g. you can build locally against a docker daemon (like running <code>docker</code> on the command line), using the <code>dockerBuild</code> goal instead of <code>build</code>. Other container registries are also supported and for each one you will need to set up local authentication via docker or Maven settings.</p>
</div>
<div class="paragraph">
<p>The gradle plugin has similar features, once you have it in your <code>build.gradle</code>, e.g.</p>
</div>
<div class="paragraph">
<p><code>build.gradle</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">plugins {
  ...
  id 'com.google.cloud.tools.jib' version '0.9.11'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>or in the older style used in the Getting Started Guides:</p>
</div>
<div class="paragraph">
<p><code>build.gradle</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">buildscript {
    repositories {
      maven {
        url "https://plugins.gradle.org/m2/"
      }
      mavenCentral()
    }
    dependencies {
        classpath('org.springframework.boot:spring-boot-gradle-plugin:2.0.5.RELEASE')
        classpath('com.google.cloud.tools.jib:com.google.cloud.tools.jib.gradle.plugin:0.9.11')
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and then you can build an image with</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ ./gradlew jib --image=myorg/myapp</code></pre>
</div>
</div>
<div class="paragraph">
<p>As with the Maven build, if you have authenticated with <code>docker</code> on the command line, the image push will authenticate from your local <code>~/.docker</code> configuration.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_continuous_integration">Continuous Integration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Automation is part of every application lifecycle these days (or should be). The tools that people use to do the automation tend to be quite good at just invoking the build system from the source code. So if that gets you a docker image, and the environment in the build agents is sufficiently aligned with developer’s own environment, that might be good enough. Authenticating to the docker registry is likely to be the biggest challenge, but there are features in all the automation tools to help with that.</p>
</div>
<div class="paragraph">
<p>However, sometimes it is better to leave container creation completely to an automation layer, in which case the user’s code might not need to be polluted. Container creation is tricky, and developers sometimes don’t really care about it. If the user code is cleaner there is more chance that a different tool can "do the right thing", applying security fixes, optimizing caches etc. There are multiple options for automation and they will all come with some features related to containers these days. We are just going to look at a couple.</p>
</div>
<div class="sect2">
<h3 id="_concourse">Concourse</h3>
<div class="paragraph">
<p><a href="https://concourse-ci.org">Concourse</a> is a pipeline-based automation platform that can be used for CI and CD. It is heavily used inside Pivotal and the main authors of the project work there. Everything in Concourse is stateless and everything runs in a container, except the CLI. Since running containers is the main order of business for the automation pipelines, creating containers is well supported. The <a href="https://github.com/concourse/docker-image-resource">Docker Image Resource</a> is responsible for keeping the output state of your build up to date, if it is a container image.</p>
</div>
<div class="paragraph">
<p>Here’s an example pipeline that builds a docker image for the sample above, assuming it is in github at <code>myorg/myapp</code> and has a <code>Dockerfile</code> at the root and a build task declaration in <code>src/main/ci/build.yml</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>resources:
- name: myapp
  type: git
  source:
    uri: https://github.com/myorg/myapp.git
- name: myapp-image
  type: docker-image
  source:
    email: {{docker-hub-email}}
    username: {{docker-hub-username}}
    password: {{docker-hub-password}}
    repository: myorg/myapp

jobs:
- name: main
  plan:
  - task: build
    file: myapp/src/main/ci/build.yml
  - put: myapp-image
    params:
      build: myapp</code></pre>
</div>
</div>
<div class="paragraph">
<p>The structure of a pipeline is very declarative: you define "resources" (which are either input or output or both), and "jobs" (which use and apply actions to resources). If any of the input resources changes a new build is triggered. If any of the output resources changes during a job, then it is updated.</p>
</div>
<div class="paragraph">
<p>The pipeline could be defined in a different place than the application source code. And for a generic build setup the task declarations could be centralized or externalized as well. This allows some separation of concerns between development and automation, if that’s the way you roll.</p>
</div>
</div>
<div class="sect2">
<h3 id="_jenkins">Jenkins</h3>
<div class="paragraph">
<p><a href="https://jenkins.io">Jenkins</a> is another popular automation server. It has a huge range of features, but one that is the closest to the other automation samples here is the <a href="https://jenkins.io/doc/book/pipeline/docker/">pipeline</a> feature. Here’s a <code>Jenkinsfile</code> that builds a Spring Boot project with Maven and then uses a <code>Dockerfile</code> to build an image and push it to a repository:</p>
</div>
<div class="paragraph">
<p><code>Jenkinsfile</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>node {
    checkout scm
    sh './mvnw -B -DskipTests clean package'
    docker.build("myorg/myapp").push()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For a (realistic) docker repository that needs authentication in the build server, you can add credentials to the <code>docker</code> object above using <code>docker.withCredentials(…​)</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_buildpacks">Buildpacks</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://www.cloudfoundry.org/">Cloud Foundry</a> has used containers internally for many years now, and part of the technology used to transform user code into containers is Build Packs, an idea originally borrowed from <a href="https://www.heroku.com/">Heroku</a>. The current generation of buildpacks (v2) generates generic binary output that is assembled into a container by the platform. The <a href="https://buildpacks.io/">new generation of buildpacks</a> (v3) is a collaboration between Heroku and other companies including Pivotal, and it builds container images directly and explicitly. This is very interesting for developers and operators. Developers don’t need to care so much about the details of how to build a container, but they can easily create one if they need to. Buildpacks also have lots of features for caching build results and dependencies, so often a buildpack will run much quicker than a native docker build. Operators can scan the containers to audit their contents and transform them to patch them for security updates. And you can run the buildpacks locally (e.g. on a developer machine, or in a CI service), or in a platform like Cloud Foundry.</p>
</div>
<div class="paragraph">
<p>The output from a buildpack lifecycle is a container image, but you don’t need docker or a <code>Dockerfile</code>, so it’s CI and automation friendly. The filesystem layers in the output image are controlled by the buildpack, and typically many optimizations will be made without the developer having to know or care about them. There is also an <a href="https://en.wikipedia.org/wiki/Application_binary_interface">Application Binary Interface</a> between the lower level layers, like the base image containing the operating system, and the upper layers, containing middleware and language specific dependencies. This makes it possible for a platform, like Cloud Foundry, to patch lower layers if there are security updates without affecting the integrity and functionality of the application.</p>
</div>
<div class="paragraph">
<p>To give you an idea of the features of a buildpack here is an example using the <a href="https://github.com/buildpack/pack">Pack CLI</a> from the command line (it would work with the sample app we have been using in thus guide, no need for a <code>Dockerfile</code> or any special build configuration):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ pack build myorg/myapp --builder=cloudfoundry/cnb:bionic --path=.
2018/11/07 09:54:48 Pulling builder image 'cloudfoundry/cnb:bionic' (use --no-pull flag to skip this step)
2018/11/07 09:54:49 Selected run image 'packs/run' from stack 'io.buildpacks.stacks.bionic'
2018/11/07 09:54:49 Pulling run image 'packs/run' (use --no-pull flag to skip this step)
*** DETECTING:
2018/11/07 09:54:52 Group: Cloud Foundry OpenJDK Buildpack: pass | Cloud Foundry Build System Buildpack: pass | Cloud Foundry JVM Application Buildpack: pass
*** ANALYZING: Reading information from previous image for possible re-use
*** BUILDING:
-----&gt; Cloud Foundry OpenJDK Buildpack 1.0.0-BUILD-SNAPSHOT
-----&gt; OpenJDK JDK 1.8.192: Reusing cached dependency
-----&gt; OpenJDK JRE 1.8.192: Reusing cached launch layer

-----&gt; Cloud Foundry Build System Buildpack 1.0.0-BUILD-SNAPSHOT
-----&gt; Using Maven wrapper
       Linking Maven Cache to /home/pack/.m2
-----&gt; Building application
       Running /workspace/app/mvnw -Dmaven.test.skip=true package
...
---&gt; Running in e6c4a94240c2
---&gt; 4f3a96a4f38c
---&gt; 4f3a96a4f38c
Successfully built 4f3a96a4f38c
Successfully tagged myorg/myapp:latest
$ docker run -p 8080:8080 myorg/myapp
  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v2.0.5.RELEASE)

2018-11-07 09:41:06.390  INFO 1 --- [main] hello.Application: Starting Application on 1989fb9a00a4 with PID 1 (/workspace/app/BOOT-INF/classes started by pack in /workspace/app)
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>--builder</code> is a docker image that runs the buildpack lifecycle - typically it would be a shared resource for all developers, or all developers on a single platform. You can set the default builder on the command line (creates a file in <code>~/.pack</code>) and then omit that flag from subsequesnt builds.</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="Note"></i> </td>
<td class="content"> The <code>cloudfoundry/cnb:bionic</code> builder also knows how to build an image from an executable jar file, so you can build using <code>mvnw</code> first and then point the <code>--path</code> to the jar file for the same result. </td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_knative">Knative</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Another new project in the container and platform space is <a href="https://cloud.google.com/knative/">Knative</a>. Knative is a lot of things, but if you are not familiar with it you can think of it as a building block for building a serverless platform. It is built on <a href="https://kubernetes.io">Kubernetes</a> so ultimately it consumes container images, and turns them into applications or "services" on the platform. One of the main features it has, though, is the ability to consume source code and build the container for you, making it more developer and operator friendly. <a href="https://github.com/knative/build">Knative Build</a> is the component that does this and is itself a flexible platform for transforming user code into containers - you can do it in pretty much any way you like. Some templates are provided with common patterns like Maven and Gradle builds, and multi-stage docker builds using <a href="https://github.com/GoogleContainerTools/kaniko">Kaniko</a>. There is also a template that use <a href="https://github.com/knative/build-templates/tree/master/buildpack">Buildpacks</a> which is very interesting for us, since buildpacks have always had good support for Spring Boot. Buildpacks on Knative are also a choice that users can make with <a href="https://projectriff.io">Riff</a> and <a href="https://pivotal.io/platform/pivotal-function-service">Pivotal Function Service</a> for transforming user functions into running serverless apps.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_closing">Closing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This guide has presented a lot of options for building container images for Spring Boot applications. All of them are completely valid choices, and it is now up to you to decide which one you need. Your first question should be "do I really need to build a container image?" If the answer is "yes" then your choices will likely be driven by efficiency and cacheability, and by separation of concerns. Do you want to insulate developers from needing to know too much about how container images are created? Do you want to make developers responsible for updating images when operating system and middleware vulnerabilities neeed to be patched? Or maybe developers need complete control over the whole process and they have all the tools and knowledge they need.</p>
</div>
</div>
</div>
</div>
</article>
</div>
<aside class="span4 content-right-pane--container mobile-left-pane" id="sidebar">
<a class="ci-status desktop-only" href="https://travis-ci.org/spring-guides/top-spring-boot-docker">
<img src="https://travis-ci.org/spring-guides/top-spring-boot-docker.svg?branch=master" />
</a>
<div class="right-pane-widget--container desktop-only">
<div class="github-actions https">
<h2>Get the Code</h2>
<div class="btn-group">
<button class="btn" data-protocol="https">HTTPS</button>
<button class="btn" data-protocol="ssh">SSH</button>
</div>
<div class="clone-url https">
<input id="clone-url-https" readonly="readonly" type="text" value="https://github.com/spring-guides/top-spring-boot-docker.git" />
<button class="copy-button github" data-toggle="tooltip" data-clipboard-text="https://github.com/spring-guides/top-spring-boot-docker.git"></button>
</div>
<div class="clone-url ssh">
<input id="clone-url-ssh" readonly="readonly" type="text" value="git@github.com:spring-guides/top-spring-boot-docker.git" />
<button class="copy-button github" data-toggle="tooltip" data-clipboard-text="git@github.com:spring-guides/top-spring-boot-docker.git"></button>
</div>
<a class="github_download btn btn-black uppercase" href="https://github.com/spring-guides/top-spring-boot-docker/archive/master.zip">Download ZIP</a>
<a class="gs-guide-import" href="https://github.com/spring-guides/top-spring-boot-docker.git">Import into STS</a>
<div class="go-to-repo--container">
<a href="https://github.com/spring-guides/top-spring-boot-docker"><i class="icon-github"></i>Go To Repo</a>
</div>
<div class="go-to-repo--container">
</div>
</div>
</div>
<div class="right-pane-widget--container">
<div>
<h3><a class="anchor" href="#table-of-contents" name="table-of-contents"></a>Table of contents</h3>
<div><ul class="sectlevel1">
<li><a href="#_a_basic_dockerfile">A Basic Dockerfile</a> </li>
<li><a href="#_a_better_dockerfile">A Better Dockerfile</a></li>
<li><a href="#_tweaks">Tweaks</a></li>
<li><a href="#_multi_stage_build">Multi-Stage Build</a> </li>
<li><a href="#_security_aspects">Security Aspects</a></li>
<li><a href="#_build_plugins">Build Plugins</a> </li>
<li><a href="#_continuous_integration">Continuous Integration</a> </li>
<li><a href="#_buildpacks">Buildpacks</a></li>
<li><a href="#_knative">Knative</a></li>
<li><a href="#_closing">Closing</a></li>
</ul></div>
</div>
</div>
</aside>
</div>
</main>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">Tools</a></li>
<li><a href="https://store.pivotal.io/">Store</a></li>
<li><a href="/blog">Newsletter</a></li>
</ul>
</div>
</div>
&copy; <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a>, Inc. All Rights Reserved.
<a href="https://pivotal.io/terms-of-use">Terms of Use</a> &bullet;
<a href="https://pivotal.io/privacy-policy">Privacy</a> &bullet;
<a href="/trademarks">Trademark Guidelines</a>
<div id="teconsent" style="display:inline-block;"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>