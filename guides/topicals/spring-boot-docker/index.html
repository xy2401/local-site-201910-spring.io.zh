<html  data-clipboard-buttons="" data-code-prettify="" data-code-sidebar="" data-hide-show-guide="" data-sts-import="" data-mobile-support="" data-search=""><head>
<title>主题指南·Spring Boot Docker</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link rel="stylesheet" type="text/css" href="/css/gsguide-cce08ab7a9f46db88819a14148e45bad.css">

<meta property="og:title" content="Spring Boot Docker">
<meta property="og:image" content="/img/spring-by-pivotal-9066b55828deb3c10e27e609af322c40.png">
<meta property="og:description" content="this topical is designed to be read and comprehended in under an hour, it provides broad coverage of a topic that is possibly nuanced or requires deeper understanding than you would get from a getting started guide">
</head>
<body >

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link active">
<a href="/guides">导游</a>
</li>
<li class="navbar-link">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<main class="main-body--wrapper">
<div class="row-fluid">
<div class="span8 mobile-left-pane">
<div class="content--title desktop-only">专题指南</div>
<article class="content--container">
<h1 class="title">Spring BootDocker</h1>
<div class="article-body"><div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>许多人正在使用容器包装他们的Spring Boot应用程序，而构建容器并不是一件容易的事。这是针对Spring Boot应用程序开发人员的指南，容器对于开发人员而言并不总是一个很好的抽象-它们迫使您学习和思考非常低级的问题-但是有时您会被要求创建或使用容器，因此有必要了解这些基本要素。在这里，我们旨在向您展示一些您需要创建自己的容器时可以做出的选择。</p>
</div>
<div class="paragraph">
<p>我们将假定您知道如何创建和构建基本的Spring Boot应用程序。如果你不这样做，去到一个<a href="https://spring.io/guides">入门指南</a> ，例如关于构建一个<a href="https://spring.io/guides/gs/rest-service/">REST服务</a> 。从此处复制代码，并使用以下一些想法进行练习。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">在<a href="https://spring.io/guides/gs/spring-boot-docker">Docker</a>上也有一个入门指南，这也是一个很好的起点，但是它没有涵盖我们在此所做的选择范围，也没有详细介绍。</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_basic_dockerfile">基本的Dockerfile</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot应用程序很容易转换为可执行的JAR文件。所有<a href="https://spring.io/guides">入门指南</a>都这样做，从<a href="https://start.spring.io">Spring Initializr</a>下载的每个应用程序都将具有一个构建步骤来创建可执行的JAR。使用Maven可以<code>./mvnw install</code> ，使用Gradle可以<code>./mvnw install</code> <code>./gradlew build</code> 。然后，在项目的顶层，运行该JAR的基本Dockerfile如下所示：</p>
</div>
<div class="paragraph">
<p><code>Dockerfile</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>FROM openjdk:8-jdk-alpine
VOLUME /tmp
ARG JAR_FILE
COPY ${JAR_FILE} app.jar
ENTRYPOINT ["java","-jar","/app.jar"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>所述<code>JAR_FILE</code>可以在作为的一部分被传递<code>docker</code>命令（这将是Maven和摇篮不同）。例如Maven：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ docker build --build-arg=target/*.jar -t myorg/myapp .</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于Gradle：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ docker build --build-arg=build/libs/*.jar -t myorg/myapp .</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然，一旦选择了构建系统，就不需要<code>ARG</code>您只需对jar位置进行硬编码即可。例如Maven：</p>
</div>
<div class="paragraph">
<p><code>Dockerfile</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>FROM openjdk:8-jdk-alpine
VOLUME /tmp
COPY target/*.jar app.jar
ENTRYPOINT ["java","-jar","/app.jar"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后我们可以简单地用</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ docker build -t myorg/myapp .</code></pre>
</div>
</div>
<div class="paragraph">
<p>并像这样运行它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ docker run -p 8080:8080 myorg/myapp
  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v2.0.2.RELEASE)

Nov 06, 2018 2:45:16 PM org.springframework.boot.StartupInfoLogger logStarting
INFO: Starting Application v0.1.0 on b8469cdc9b87 with PID 1 (/app.jar started by root in /)
Nov 06, 2018 2:45:16 PM org.springframework.boot.SpringApplication logStartupProfileInfo
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果要在图像内部四处浏览，可以像这样打开其中的外壳（基本图像没有<code>bash</code> ）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ docker run -ti --entrypoint /bin/sh myorg/myapp
/ # ls
app.jar  dev      home     media    proc     run      srv      tmp      var
bin      etc      lib      mnt      root     sbin     sys      usr
/ #</code></pre>
</div>
</div>
<div class="paragraph">
<p>到目前为止，docker配置非常简单，并且生成的映像不是很有效。docker映像只有一个文件系统层，其中包含胖子罐，我们对应用程序代码进行的每一次更改都会更改该层，该层可能为10MB或更多（对于某些应用程序甚至可能为50MB）。我们可以通过将JAR分为多个层来改善这一点。</p>
</div>
<div class="sect2">
<h3 id="_smaller_images">较小的图像</h3>
<div class="paragraph">
<p>请注意，上面示例中的基本映像是<code>openjdk:8-jdk-alpine</code> 。<code>alpine</code>映像比<a href="https://hub.docker.com/_/openjdk/">Dockerhub</a>的标准<code>openjdk</code>库映像<a href="https://hub.docker.com/_/openjdk/">小</a> 。尚无Java 11的正式高山图像（AdoptOpenJDK已有一段时间，但不再出现在其<a href="https://hub.docker.com/r/adoptopenjdk/openjdk11/">Dockerhub页面上</a> ）。您还可以使用“ jre”标签而不是“ jdk”在基本映像中节省大约20MB。并非所有的应用程序都可以与JRE一起使用（而不是JDK），但是大多数的应用程序都可以，并且确实有些组织会强制执行每个应用程序必须遵循的规则，因为存在滥用某些JDK功能（例如编译）的风险。</p>
</div>
<div class="paragraph">
<p>可以使您缩小图像的另一个技巧是使用<a href="https://openjdk.java.net/projects/jigsaw/quick-start#linker">JLink</a> ，它与OpenJDK 11捆绑在一起。JLink允许您从完整JDK中的模块子集构建自定义JRE分发，因此在基本映像中不需要JRE或JDK。原则上，与使用<code>openjdk</code>官方docker映像相比，这将使您具有较小的总映像大小。实际上，您还不能（在）JDK 11上使用<code>alpine</code>基础图像，因此您对基础图像的选择将受到限制，并且最终结果可能会更大。另外，您自己的基本映像中的自定义JRE无法在其他应用程序之间共享，因为它们将需要不同的自定义。因此，对于您所有的应用程序来说，它们的映像可能都较小，但是它们的启动时间仍然较长，因为它们无法从缓存JRE层中受益。</p>
</div>
<div class="paragraph">
<p>最后一点突出了图像构建者的一个真正重要的担忧：目标不一定总是要构建尽可能小的图像。较小的图像通常是一个好主意，因为它们只需要花费较少的时间就可以上传和下载，但是前提是它们中的所有层都没有被缓存。如今，图像注册表非常复杂，通过尝试巧妙地构建图像，您很容易失去这些功能的优势。如果使用公共基础层，则图像的总大小将不再是问题，随着注册管理机构和平台的发展，图像的总大小可能甚至会减少。话虽如此，尝试和优化我们的应用程序映像中的各层仍然是重要且有用的，但是目标始终应该是将变化最快的东西放置在最高层中，并共享尽可能多的大型低层。其他应用程序尽可能地使用层。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_better_dockerfile">更好的Dockerfile</h2>
<div class="sectionbody">
<div class="paragraph">
<p>由于罐子本身的包装方式，Spring Boot胖子罐子自然具有“层”。如果我们先拆包，它将已经分为内部和外部依赖关系。为了在Docker构建中一步一步做到这一点，我们需要首先解压jar。例如（坚持使用Maven，但Gradle版本非常相似）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ mkdir target/dependency
$ (cd target/dependency; jar -xf ../*.jar)
$ docker build -t myorg/myapp .</code></pre>
</div>
</div>
<div class="paragraph">
<p>与此<code>Dockerfile</code></p>
</div>
<div class="paragraph">
<p><code>Dockerfile</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>FROM openjdk:8-jdk-alpine
VOLUME /tmp
ARG DEPENDENCY=target/dependency
COPY ${DEPENDENCY}/BOOT-INF/lib /app/lib
COPY ${DEPENDENCY}/META-INF /app/META-INF
COPY ${DEPENDENCY}/BOOT-INF/classes /app
ENTRYPOINT ["java","-cp","app:app/lib/*","hello.Application"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在有3层，所有应用程序资源都位于后面的2层中。如果应用程序依存关系不变，那么第一层（来自<code>BOOT-INF/lib</code> ）将不会改变，因此构建会更快，因此只要基础层已经存在，容器在运行时的启动也将更快已缓存。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">我们使用了硬编码的主应用程序类<code>hello.Application</code> 。对于您的应用程序，这可能会有所不同。如果需要，可以使用另一个<code>ARG</code>对其进行参数化。您还可以将Spring Boot胖子<code>JarLauncher</code>复制到映像中，然后使用它来运行应用程序-它可以工作，并且您不需要指定主类，但是启动时会慢一些。</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tweaks">调整</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果您想尽快启动应用程序（大多数人都这样做），则可以考虑一些调整。这里有一些想法：</p>
</div>
<div class="ulist">
<ul>
<li> <p>使用<code>spring-context-indexer</code> （ <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-scanning-index">链接到docs</a> ）。对于小型应用程序而言，它不会增加太多，但对您有所帮助。</p> </li>
<li> <p>如果负担不起，请不要使用<a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#production-ready">执行器</a> 。</p> </li>
<li> <p>使用Spring Boot 2.1和Spring 5.1。</p> </li>
<li> <p>使用<code>spring.config.location</code> （命令行参数或System属性等）修复<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-external-config-application-property-files">Spring Boot配置文件</a>的位置。</p> </li>
<li> <p>使用<code>spring.jmx.enabled=false</code>关闭JMX-您可能不需要在容器中使用它</p> </li>
<li> <p>使用<code>-noverify</code>运行JVM。还要考虑<code>-XX:TieredStopAtLevel=1</code> （这将在以后降低JIT速度，但会节省启动时间）。</p> </li>
<li> <p>使用Java 8的容器内存提示： <code>-XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap</code> 。对于Java 11，默认情况下是自动的。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>您的应用程序在运行时可能不需要完整的CPU，但需要多个CPU才能尽快启动（至少2、4个更好）。如果您不介意启动速度较慢，则可以将CPU速度控制在4以下。如果您被迫从少于4个CPU开始，则可能会有助于设置<code>-Dspring.backgroundpreinitializer.ignore=true</code>因为它会阻止Spring Boot创建可能无法使用的新线程（这适用于Spring Boot 2.1.0及更高版本）。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_multi_stage_build">多阶段构建</h2>
<div class="sectionbody">
<div class="paragraph">
<p>上面的<code>Dockerfile</code>假设胖JAR已在命令行上构建。您也可以使用多阶段构建在Docker中执行此步骤，将结果从一个映像复制到另一个映像。使用Maven的示例：</p>
</div>
<div class="paragraph">
<p><code>Dockerfile</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>FROM openjdk:8-jdk-alpine as build
WORKDIR /workspace/app

COPY mvnw .
COPY .mvn .mvn
COPY pom.xml .
COPY src src

RUN ./mvnw install -DskipTests
RUN mkdir -p target/dependency &amp;&amp; (cd target/dependency; jar -xf ../*.jar)

FROM openjdk:8-jdk-alpine
VOLUME /tmp
ARG DEPENDENCY=/workspace/app/target/dependency
COPY --from=build ${DEPENDENCY}/BOOT-INF/lib /app/lib
COPY --from=build ${DEPENDENCY}/META-INF /app/META-INF
COPY --from=build ${DEPENDENCY}/BOOT-INF/classes /app
ENTRYPOINT ["java","-cp","app:app/lib/*","hello.Application"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一个图像标记为“ build”，它用于运行Maven并构建胖罐，然后解压缩它。拆包也可以由Maven或Gradle完成（这是《入门指南》中采用的方法）-确实没有太大区别，只是必须编辑构建配置并添加插件。</p>
</div>
<div class="paragraph">
<p>请注意，源代码已分为4层。后面的层包含构建配置和应用程序的源代码，而前面的层包含构建系统本身（Maven包装器）。这是一个很小的优化，这也意味着我们不必将<code>target</code>目录复制到Docker映像，即使是用于构建的临时目录也是如此。</p>
</div>
<div class="paragraph">
<p>因为必须在第一个<code>RUN</code>部分中重新创建Maven缓存，所以每个更改源代码的构建都会很慢。但是您拥有一个完全独立的构建，只要拥有docker，任何人都可以运行它来使您的应用程序运行。在某些环境中，例如在需要与不懂Java的人共享代码的环境中，这很有用。</p>
</div>
<div class="sect2">
<h3 id="_experimental_features">实验功能</h3>
<div class="paragraph">
<p>Docker 18.06带有一些<a href="https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/experimental.md">“实验性”功能</a> ，其中包括一种缓存构建依赖项的方法。要打开它们，您需要在守护程序中使用一个标志（ <code>dockerd</code> ），并且在运行客户端时还需要一个环境变量，然后可以在<code>Dockerfile</code>添加第一行魔术：</p>
</div>
<div class="paragraph">
<p><code>Dockerfile</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code># syntax=docker/dockerfile:experimental</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后<code>RUN</code>指令接受一个新的标志<code>--mount</code> 。这是一个完整的示例：</p>
</div>
<div class="paragraph">
<p><code>Dockerfile</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code># syntax=docker/dockerfile:experimental
FROM openjdk:8-jdk-alpine as build
WORKDIR /workspace/app

COPY mvnw .
COPY .mvn .mvn
COPY pom.xml .
COPY src src

RUN --mount=type=cache,target=/root/.m2 ./mvnw install -DskipTests
RUN mkdir -p target/dependency &amp;&amp; (cd target/dependency; jar -xf ../*.jar)

FROM openjdk:8-jdk-alpine
VOLUME /tmp
ARG DEPENDENCY=/workspace/app/target/dependency
COPY --from=build ${DEPENDENCY}/BOOT-INF/lib /app/lib
COPY --from=build ${DEPENDENCY}/META-INF /app/META-INF
COPY --from=build ${DEPENDENCY}/BOOT-INF/classes /app
ENTRYPOINT ["java","-cp","app:app/lib/*","hello.Application"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后运行它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ DOCKER_BUILDKIT=1 docker build -t myorg/myapp .
...
 =&gt; /bin/sh -c ./mvnw install -DskipTests              5.7s
 =&gt; exporting to image                                 0.0s
 =&gt; =&gt; exporting layers                                0.0s
 =&gt; =&gt; writing image sha256:3defa...
 =&gt; =&gt; naming to docker.io/myorg/myapp</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用实验性功能，您可以在控制台上获得不同的输出，但是可以看到，一旦缓存变热，Maven构建现在只需要几秒钟而不是几分钟。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">虽然这些功能在实验阶段，接通buildkit和关闭选项取决于版本<code>docker</code>所使用。检查你有版本的文档（上面的例子是正确的<code>docker</code> 18.0.6）。</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_security_aspects">安全方面</h2>
<div class="sectionbody">
<div class="paragraph">
<p>就像在传统的VM部署中一样，不应使用root权限运行进程。相反，映像应包含运行该应用程序的非root用户。</p>
</div>
<div class="paragraph">
<p>在<code>Dockerfile</code> ，这可以通过添加另一层来添加（系统）用户和组，然后将其设置为当前用户（而不是默认用户root）来实现：</p>
</div>
<div class="paragraph">
<p><code>Dockerfile</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>FROM openjdk:8-jdk-alpine

RUN addgroup -S demo &amp;&amp; adduser -S demo -G demo
USER demo

...</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果有人设法突破您的应用程序并在容器内运行系统命令，这将限制他们的功能（最小特权原则）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">一些其他的<code>Dockerfile</code>命令仅以root身份运行，因此也许您必须将USER命令进一步向下移动（例如，如果您计划将更多软件包安装到仅以root身份运行的容器中）。</td>
</tr>
</tbody>
</table>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">不使用<code>Dockerfile</code>其他方法可能更合适。例如，在稍后描述的buildpack方法中，大多数实现默认情况下将使用非root用户。</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_build_plugins">构建插件</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果您不想直接在构建中调用<code>docker</code> ，则可以使用Maven和Gradle丰富的插件集来为您工作。这里仅仅是少数。</p>
</div>
<div class="sect2">
<h3 id="_spotify_maven_plugin">Spotify Maven插件</h3>
<div class="paragraph">
<p><a href="https://github.com/spotify/dockerfile-maven">Spotify Maven插件</a>是一个受欢迎的选择。它需要应用程序开发人员编写<code>Dockerfile</code> ，然后运行<code>docker</code>为你，就好像你在做它的命令行上。docker image标签和其他内容有一些配置选项，但它使应用程序中的<code>Dockerfile</code>知识集中在<code>Dockerfile</code> ，这是许多人喜欢的。</p>
</div>
<div class="paragraph">
<p>对于真正的基本用法，它无需额外配置即可直接使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ mvn com.spotify:dockerfile-maven-plugin:build
...
[INFO] Building Docker context /home/dsyer/dev/demo/workspace/myapp
[INFO]
[INFO] Image will be built without a name
[INFO]
...
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 7.630 s
[INFO] Finished at: 2018-11-06T16:03:16+00:00
[INFO] Final Memory: 26M/595M
[INFO] ------------------------------------------------------------------------</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将构建一个匿名docker镜像。我们现在可以在命令行上使用<code>docker</code>对其进行标记，或者使用Maven配置将其设置为<code>repository</code> 。示例（不更改<code>pom.xml</code> ）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ mvn com.spotify:dockerfile-maven-plugin:build -Ddockerfile.repository=myorg/myapp</code></pre>
</div>
</div>
<div class="paragraph">
<p>或在<code>pom.xml</code> ：</p>
</div>
<div class="paragraph">
<p><code>pom.xml</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;com.spotify&lt;/groupId&gt;
            &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt;
            &lt;version&gt;1.4.8&lt;/version&gt;
            &lt;configuration&gt;
                &lt;repository&gt;myorg/${project.artifactId}&lt;/repository&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_palantir_gradle_plugin">Palantir Gradle插件</h3>
<div class="paragraph">
<p>该<a href="https://github.com/palantir/gradle-docker">真知晶球摇篮插件</a>工作与<code>Dockerfile</code> ，它也能产生<code>Dockerfile</code>你，然后它运行<code>docker</code> ，如果你是在命令行中运行它。</p>
</div>
<div class="paragraph">
<p>首先，您需要将插件导入到<code>build.gradle</code> ：</p>
</div>
<div class="paragraph">
<p><code>build.gradle</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">buildscript {
    ...
    dependencies {
        ...
        classpath('gradle.plugin.com.palantir.gradle.docker:gradle-docker:0.13.0')
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后最后应用插件并调用其任务：</p>
</div>
<div class="paragraph">
<p><code>build.gradle</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">apply plugin: 'com.palantir.docker'

group = 'myorg'

bootJar {
    baseName = 'myapp'
    version =  '0.1.0'
}

task unpack(type: Copy) {
    dependsOn bootJar
    from(zipTree(tasks.bootJar.outputs.files.singleFile))
    into("build/dependency")
}
docker {
    name "${project.group}/${bootJar.baseName}"
    copySpec.from(tasks.unpack.outputs).into("dependency")
    buildArgs(['DEPENDENCY': "dependency"])
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此示例中，我们选择在<code>build</code>目录中的特定位置解压缩Spring Boot胖子罐，该目录是docker构建的根目录。然后，上面的多层（不是多阶段） <code>Dockerfile</code>将起作用。</p>
</div>
</div>
<div class="sect2">
<h3 id="_jib_maven_and_gradle_plugins">Jib Maven和Gradle插件</h3>
<div class="paragraph">
<p>Google有一个名为<a href="https://github.com/GoogleContainerTools/jib">Jib的</a>开源工具，它相对较新，但出于多种原因却很有趣。可能最有趣的事情是您不需要docker来运行它-它使用与从<code>docker build</code>获得的相同的标准输出来构建映像，但是除非您要求，否则不使用<code>docker</code>因此它可以在以下环境中工作没有安装docker（在构建服务器中并不罕见）。您也不需要<code>Dockerfile</code> （无论如何都会被忽略）或<code>pom.xml</code>任何内容来获取在Maven中构建的映像（Gradle要求您至少将插件安装在<code>build.gradle</code> ）。</p>
</div>
<div class="paragraph">
<p>Jib的另一个有趣的功能是，它对层有<code>Dockerfile</code> ，并且以与上面创建的多层<code>Dockerfile</code>稍有不同的方式优化了它们。就像在胖子罐中一样，Jib将本地应用程序资源与依赖项分离开来，但它走得更远，而且还将快照依赖项放入一个单独的层中，因为它们更容易发生变化。有一些配置选项可用于进一步自定义布局。</p>
</div>
<div class="paragraph">
<p>Maven的示例（不更改<code>pom.xml</code> ）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ mvn com.google.cloud.tools:jib-maven-plugin:build -Dimage=myorg/myapp</code></pre>
</div>
</div>
<div class="paragraph">
<p>要运行上述命令，您将需要具有在<code>myorg</code>存储库前缀下推送到Dockerhub的权限。如果您有认证<code>docker</code>在命令行上，将从您的本地工作<code>~/.docker</code>配置。您也可以在<code>~/.m2/settings.xml</code> Maven“服务器”身份验证（存储库的<code>id</code>很重要）：</p>
</div>
<div class="paragraph">
<p><code>settings.xml</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>    &lt;server&gt;
      &lt;id&gt;registry.hub.docker.com&lt;/id&gt;
      &lt;username&gt;myorg&lt;/username&gt;
      &lt;password&gt;...&lt;/password&gt;
    &lt;/server&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>还有其他的选择，比如，你可以对一个码头工人守护本地构建（就像跑<code>docker</code>在命令行），使用<code>dockerBuild</code>目标，而不是<code>build</code> 。还支持其他容器注册表，对于每个容器注册表，您将需要通过docker或Maven设置来设置本地身份验证。</p>
</div>
<div class="paragraph">
<p>该插件的Gradle也有类似的功能，一旦你拥有了它在你<code>build.gradle</code> ，如</p>
</div>
<div class="paragraph">
<p><code>build.gradle</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">plugins {
  ...
  id 'com.google.cloud.tools.jib' version '0.9.11'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或使用入门指南中使用的较旧样式：</p>
</div>
<div class="paragraph">
<p><code>build.gradle</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">buildscript {
    repositories {
      maven {
        url "https://plugins.gradle.org/m2/"
      }
      mavenCentral()
    }
    dependencies {
        classpath('org.springframework.boot:spring-boot-gradle-plugin:2.0.5.RELEASE')
        classpath('com.google.cloud.tools.jib:com.google.cloud.tools.jib.gradle.plugin:0.9.11')
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后您可以用</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ ./gradlew jib --image=myorg/myapp</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于与Maven构建，如果已经使用认证<code>docker</code>在命令行上，图像推将从本地认证<code>~/.docker</code>配置。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_continuous_integration">持续集成</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如今（或应该如此），自动化已成为每个应用程序生命周期的一部分。人们用来实现自动化的工具往往非常擅长从源代码调用构建系统。因此，如果您得到一个docker映像，并且构建代理中的环境与开发人员自己的环境充分对齐，则可能就足够了。向Docker注册表进行身份验证可能是最大的挑战，但是所有自动化工具中都有一些功能可以帮助实现这一点。</p>
</div>
<div class="paragraph">
<p>但是，有时最好将容器创建完全留给自动化层，在这种情况下，可能不需要污染用户的代码。容器创建非常棘手，开发人员有时并不真正在意它。如果用户代码更干净，则其他工具更有可能“做正确的事”，应用安全修复程序，优化缓存等。有多种自动化选项，并且这些天它们都具有与容器相关的某些功能。我们只看几个。</p>
</div>
<div class="sect2">
<h3 id="_concourse">大堂</h3>
<div class="paragraph">
<p><a href="https://concourse-ci.org">Concourse</a>是基于管道的自动化平台，可用于CI和CD。它在Pivotal内部大量使用，该项目的主要作者在那里工作。除CLI外，Concourse中的所有内容都是无状态的，并且所有内容都在容器中运行。由于运行容器是自动化管道的主要业务顺序，因此很好地支持创建容器。如果它是容器映像，则<a href="https://github.com/concourse/docker-image-resource">Docker Image Resource</a>负责使构建的输出状态保持最新。</p>
</div>
<div class="paragraph">
<p>这是一个示例管道，为上面的示例构建一个docker映像，假设它位于<code>myorg/myapp</code> github中，并且在根目录下有一个<code>Dockerfile</code> ，并且在<code>src/main/ci/build.yml</code>具有一个构建任务声明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>resources:
- name: myapp
  type: git
  source:
    uri: https://github.com/myorg/myapp.git
- name: myapp-image
  type: docker-image
  source:
    email: {{docker-hub-email}}
    username: {{docker-hub-username}}
    password: {{docker-hub-password}}
    repository: myorg/myapp

jobs:
- name: main
  plan:
  - task: build
    file: myapp/src/main/ci/build.yml
  - put: myapp-image
    params:
      build: myapp</code></pre>
</div>
</div>
<div class="paragraph">
<p>管道的结构非常具有声明性：您定义“资源”（输入或输出或两者），以及“作业”（使用并向资源应用操作）。如果任何输入资源发生更改，则会触发新的构建。如果作业期间任何输出资源发生更改，则将对其进行更新。</p>
</div>
<div class="paragraph">
<p>可以在与应用程序源代码不同的位置定义管道。对于通用构建设置，任务声明也可以集中或外部化。如果这是滚动的方式，则可以将开发和自动化之间的关注点分离开。</p>
</div>
</div>
<div class="sect2">
<h3 id="_jenkins">詹金斯</h3>
<div class="paragraph">
<p><a href="https://jenkins.io">Jenkins</a>是另一种流行的自动化服务器。它具有广泛的功能，但此处最接近其他自动化示例的功能是<a href="https://jenkins.io/doc/book/pipeline/docker/">管道</a>功能。这是一个<code>Jenkinsfile</code> ，它使用Maven构建Spring Boot项目，然后使用<code>Dockerfile</code>构建映像并将其推送到存储库：</p>
</div>
<div class="paragraph">
<p><code>Jenkinsfile</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>node {
    checkout scm
    sh './mvnw -B -DskipTests clean package'
    docker.build("myorg/myapp").push()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于需要在构建服务器验证的（现实的）泊坞窗库，你可以添加凭据<code>docker</code>使用上述目的<code>docker.withCredentials(…​)</code></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_buildpacks">构建包</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://www.cloudfoundry.org/">Cloud Foundry</a>多年来一直在内部使用容器，用于将用户代码转换为容器的技术的一部分是Build Packs，该思想最初是从<a href="https://www.heroku.com/">Heroku</a>借来的。当前的buildpacks（v2）生成通用二进制输出，该输出由平台组装到容器中。<a href="https://buildpacks.io/">新一代的buildpack</a> （v3）是Heroku与其他公司（包括Pivotal）之间的合作，可以直接且显式地构建容器映像。这对于开发人员和运营商来说非常有趣。开发人员不需要太在乎如何构建容器的细节，但是如果需要，他们可以轻松地创建一个容器。Buildpacks还具有许多用于缓存生成结果和依赖项的功能，因此，Buildpack的运行速度要比本地Docker构建快得多。操作员可以扫描容器以审核其内容并进行转换以修补它们以进行安全更新。您可以在本地（例如，在开发人员机器上或在CI服务中）或在Cloud Foundry之类的平台上运行构建包。</p>
</div>
<div class="paragraph">
<p>buildpack生命周期的输出是一个容器映像，但是您不需要<code>Dockerfile</code>或<code>Dockerfile</code> ，因此它是CI和自动化友好的。输出映像中的文件系统层由buildpack控制，通常，将进行许多优化而无需开发人员知道或关心它们。在较低层（如包含操作系统的基础映像）与较高层（如包含中间件和特定于语言的依赖关系）之间还有一个<a href="https://en.wikipedia.org/wiki/Application_binary_interface">应用程序二进制接口</a> 。如果存在安全更新，则Cloud Foundry这样的平台可以修补较低的层，而不会影响应用程序的完整性和功能。</p>
</div>
<div class="paragraph">
<p>为了让您了解buildpack的功能，这里是一个从命令行使用<a href="https://github.com/buildpack/pack">Pack CLI</a>的示例（它将与我们在本指南中使用的示例应用程序一起使用，不需要<code>Dockerfile</code>或任何特殊的构建配置） ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ pack build myorg/myapp --builder=cloudfoundry/cnb:bionic --path=.
2018/11/07 09:54:48 Pulling builder image 'cloudfoundry/cnb:bionic' (use --no-pull flag to skip this step)
2018/11/07 09:54:49 Selected run image 'packs/run' from stack 'io.buildpacks.stacks.bionic'
2018/11/07 09:54:49 Pulling run image 'packs/run' (use --no-pull flag to skip this step)
*** DETECTING:
2018/11/07 09:54:52 Group: Cloud Foundry OpenJDK Buildpack: pass | Cloud Foundry Build System Buildpack: pass | Cloud Foundry JVM Application Buildpack: pass
*** ANALYZING: Reading information from previous image for possible re-use
*** BUILDING:
-----&gt; Cloud Foundry OpenJDK Buildpack 1.0.0-BUILD-SNAPSHOT
-----&gt; OpenJDK JDK 1.8.192: Reusing cached dependency
-----&gt; OpenJDK JRE 1.8.192: Reusing cached launch layer

-----&gt; Cloud Foundry Build System Buildpack 1.0.0-BUILD-SNAPSHOT
-----&gt; Using Maven wrapper
       Linking Maven Cache to /home/pack/.m2
-----&gt; Building application
       Running /workspace/app/mvnw -Dmaven.test.skip=true package
...
---&gt; Running in e6c4a94240c2
---&gt; 4f3a96a4f38c
---&gt; 4f3a96a4f38c
Successfully built 4f3a96a4f38c
Successfully tagged myorg/myapp:latest
$ docker run -p 8080:8080 myorg/myapp
  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v2.0.5.RELEASE)

2018-11-07 09:41:06.390  INFO 1 --- [main] hello.Application: Starting Application on 1989fb9a00a4 with PID 1 (/workspace/app/BOOT-INF/classes started by pack in /workspace/app)
...</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>--builder</code>是运行buildpack生命周期的<code>--builder</code>映像-通常，它将是所有开发人员或单个平台上所有开发人员的共享资源。您可以在命令行上设置默认构建器（在<code>~/.pack</code>创建一个文件），然后从后续构建中省略该标志。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content"><code>cloudfoundry/cnb:bionic</code>器还知道如何从可执行jar文件构建映像，因此您可以先使用<code>mvnw</code>进行构建，然后将<code>--path</code>指向jar文件以得到相同的结果。</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_knative">基尼特语</h2>
<div class="sectionbody">
<div class="paragraph">
<p>容器和平台领域的另一个新项目是<a href="https://cloud.google.com/knative/">Knative</a> 。Knative有很多东西，但是如果您不熟悉Knative，则可以将其视为构建无服务器平台的基础。它基于<a href="https://kubernetes.io">Kubernetes</a>构建，因此最终它会使用容器映像，并在平台上将它们转换为应用程序或“服务”。但是，它的主要功能之一是能够使用源代码并为您构建容器，从而使其对开发人员和操作员更友好。<a href="https://github.com/knative/build">Knative Build</a>是执行此操作的组件，它本身就是一个将用户代码转换为容器的灵活平台-您几乎可以按照自己喜欢的任何方式进行操作。一些模板提供了常见的模式，例如Maven和Gradle构建，以及使用<a href="https://github.com/GoogleContainerTools/kaniko">Kaniko的</a>多阶段<a href="https://github.com/GoogleContainerTools/kaniko">docker</a>构建。还有一个使用<a href="https://github.com/knative/build-templates/tree/master/buildpack">Buildpacks</a>的模板，这对我们来说很有趣，因为buildpacks一直对Spring Boot具有良好的支持。用户还可以使用<a href="https://projectriff.io">Riff</a>和<a href="https://pivotal.io/platform/pivotal-function-service">Pivotal Function Service</a>在Knative上进行构建包选择，以将用户功能转换为运行的无服务器应用程序。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_closing">闭幕</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本指南提供了许多用于为Spring Boot应用程序构建容器映像的选项。所有这些都是完全有效的选择，现在由您决定需要哪一个。您的第一个问题应该是“我真的需要构建容器映像吗？如果答案是“是”，那么您的选择可能会受到效率和可缓存性以及关注点分离的影响。您是否希望使开发人员不必过多地了解如何创建容器映像？当需要修补操作系统和中间件漏洞时，是否要让开发人员负责更新映像？也许开发人员需要对整个过程进行完全控制，并且他们拥有所需的所有工具和知识。</p>
</div>
</div>
</div>
</div>
</article>
</div>
<aside class="span4 content-right-pane--container mobile-left-pane" id="sidebar">
<a class="ci-status desktop-only" href="https://travis-ci.org/spring-guides/top-spring-boot-docker">
<img src="https://travis-ci.org/spring-guides/top-spring-boot-docker.svg?branch=master">
</a>
<div class="right-pane-widget--container desktop-only">
<div class="github-actions https">
<h2>获取代码</h2>
<div class="btn-group">
<button class="btn" data-protocol="https">HTTPS</button>
<button class="btn" data-protocol="ssh">SSH协议</button>
</div>
<div class="clone-url https">
<input id="clone-url-https" type="text" value="https://github.com/spring-guides/top-spring-boot-docker.git" readonly>
<button class="copy-button github" data-toggle="tooltip" data-clipboard-text="https://github.com/spring-guides/top-spring-boot-docker.git"></button>
</div>
<div class="clone-url ssh">
<input id="clone-url-ssh" type="text" value="git@github.com:spring-guides/top-spring-boot-docker.git" readonly>
<button class="copy-button github" data-toggle="tooltip" data-clipboard-text="git@github.com:spring-guides/top-spring-boot-docker.git"></button>
</div>
<a class="github_download btn btn-black uppercase" href="https://github.com/spring-guides/top-spring-boot-docker/archive/master.zip">下载ZIP</a> <a class="gs-guide-import" href="https://github.com/spring-guides/top-spring-boot-docker.git">导入到STS</a>
<div class="go-to-repo--container">
<a href="https://github.com/spring-guides/top-spring-boot-docker"><i class="icon-github"></i>Go To Repo</a>
</div>
<div class="go-to-repo--container">
</div>
</div>
</div>
<div class="right-pane-widget--container">
<div>
<h3><a class="anchor" href="#table-of-contents" name="table-of-contents"></a>目录</h3>
<div><ul class="sectlevel1">
<li><a href="#_a_basic_dockerfile">基本的Dockerfile</a> </li>
<li><a href="#_a_better_dockerfile">更好的Dockerfile</a></li>
<li><a href="#_tweaks">调整</a></li>
<li><a href="#_multi_stage_build">多阶段构建</a> </li>
<li><a href="#_security_aspects">安全方面</a></li>
<li><a href="#_build_plugins">构建插件</a> </li>
<li><a href="#_continuous_integration">持续集成</a> </li>
<li><a href="#_buildpacks">构建包</a></li>
<li><a href="#_knative">基尼特语</a></li>
<li><a href="#_closing">闭幕</a></li>
</ul></div>
</div>
</div>
</aside>
</div>
</main>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>