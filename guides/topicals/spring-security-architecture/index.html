<html  data-clipboard-buttons="" data-code-prettify="" data-code-sidebar="" data-hide-show-guide="" data-sts-import="" data-mobile-support="" data-search=""><head>
<title>主题指南·Spring安全体系结构</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link rel="stylesheet" type="text/css" href="/css/gsguide-cce08ab7a9f46db88819a14148e45bad.css">

<meta property="og:title" content="Spring Security Architecture">
<meta property="og:image" content="/img/spring-by-pivotal-9066b55828deb3c10e27e609af322c40.png">
<meta property="og:description" content="this topical is designed to be read and comprehended in under an hour, it provides broad coverage of a topic that is possibly nuanced or requires deeper understanding than you would get from a getting started guide">
</head>
<body >

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link active">
<a href="/guides">导游</a>
</li>
<li class="navbar-link">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<main class="main-body--wrapper">
<div class="row-fluid">
<div class="span8 mobile-left-pane">
<div class="content--title desktop-only">专题指南</div>
<article class="content--container">
<h1 class="title">春季安全架构</h1>
<div class="article-body"><div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>本指南是Spring Security的入门，它提供了对该框架的设计和基本构建块的见解。我们仅介绍了应用程序安全性的最基本知识，但是这样做可以清除使用Spring Security的开发人员所遇到的一些困惑。为此，我们看一下使用过滤器（更通常是使用方法注释）在Web应用程序中应用安全性的方式。当您需要从高层次上了解安全应用程序的工作方式，如何自定义它，或者仅需要学习如何考虑应用程序安全性时，请使用本指南。</p>
</div>
<div class="paragraph">
<p>本指南的目的不是用来解决最基本的问题（还有其他来源）的手册或食谱，但对于初学者和专家都可能有用。Spring Boot之所以被广泛引用，是因为它为安全的应用程序提供了一些默认行为，并且有助于理解它与整个体系结构之间的关系。所有这些原则同样适用于不使用Spring Boot的应用程序。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_authentication_and_access_control">身份验证和访问控制</h2>
<div class="sectionbody">
<div class="paragraph">
<p>应用程序安全性可以归结为两个或多或少的独立问题：身份验证（您是谁？）和授权（您被允许做什么？）。有时人们会说“访问控制”而不是“授权”，这可能会造成混淆，但是以这种方式思考可能会有所帮助，因为“授权”在其他地方超载。Spring Security的体系结构旨在将身份验证与授权分开，并具有策略和扩展点。</p>
</div>
<div class="sect2">
<h3 id="_authentication">认证方式</h3>
<div class="paragraph">
<p>身份<code data-markx="106">AuthenticationManager</code>的主要策略接口是<code data-markx="106">AuthenticationManager</code> ，它只有一种方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface AuthenticationManager {

  Authentication authenticate(Authentication authentication)
    throws AuthenticationException;

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code data-markx="113">AuthenticationManager</code>可以在<code data-markx="114">authenticate()</code>方法中执行以下三项操作之一：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li> <p>如果它可以验证输入是否代表有效的主体，则返回<code data-markx="119">Authentication</code> （通常使用<code data-markx="120">authenticated=true</code> ）。</p> </li>
<li> <p>如果认为输入代表无效的主体，则抛出<code data-markx="123">AuthenticationException</code> 。</p> </li>
<li> <p>如果无法确定，则返回<code data-markx="126">null</code> 。</p> </li>
</ol>
</div>
<div class="paragraph">
<p><code data-markx="129">AuthenticationException</code>是运行时异常。它通常由应用程序以通用方式处理，具体取决于应用程序的样式或目的。换句话说，通常不希望用户代码捕获并处理它。例如，一个Web UI将呈现一个页面，该页面指出身份验证失败，而后端HTTP服务将发送401响应，取决于上下文，带有或不带有<code data-markx="130">WWW-Authenticate</code>标头。</p>
</div>
<div class="paragraph">
<p><code data-markx="133">AuthenticationManager</code>最常用的实现是<code data-markx="134">ProviderManager</code> ，它委派了<code data-markx="135">AuthenticationProvider</code>实例链。<code data-markx="136">AuthenticationProvider</code>有点像<code data-markx="137">AuthenticationManager</code>但是它还有一个额外的方法，允许调用者查询是否支持给定的<code data-markx="138">Authentication</code>类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface AuthenticationProvider {

	Authentication authenticate(Authentication authentication)
			throws AuthenticationException;

	boolean supports(Class&lt;?&gt; authentication);

}</code></pre>
</div>
</div>
<div class="paragraph" gtc:encodedoriginal="PGRpdiBjbGFzcz0icGFyYWdyYXBoIj4=">
<p>The <code data-markx="145" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTQ1Ij4=">Class<?></code> <code data-markx="146">supports()</code>方法中的<code class="language-java" data-lang="java" data-markx="142">public interface AuthenticationProvider { Authentication authenticate(Authentication authentication) throws AuthenticationException; boolean supports(Class <?> authentication);

}</code></pre>
</div>
</div>
<div class="paragraph" gtc:encodedoriginal="PGRpdiBjbGFzcz0icGFyYWdyYXBoIj4=">
<p>The <code data-markx="145" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTQ1Ij4=">Class<?></code>参数实际上是<code data-markx="147">Class <? extends Authentication gtc:encodedoriginal="PD8gZXh0ZW5kcyBBdXRoZW50aWNhdGlvbj4="></code> (it will only ever be asked if it supports something that will be passed into the <code data-markx="148" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTQ4Ij4=">authenticate()</code> method). A <code data-markx="149" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTQ5Ij4=">ProviderManager</code> can support multiple different authentication mechanisms in the same application by delegating to a chain of <code data-markx="150" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTUwIj4=">AuthenticationProviders</code>. If a <code data-markx="151" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTUxIj4=">ProviderManager</code> doesn’t recognise a particular <code data-markx="152" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTUyIj4=">Authentication</code> instance type it will be skipped.</p>
</div>
<div class="paragraph" gtc:encodedoriginal="PGRpdiBjbGFzcz0icGFyYWdyYXBoIj4=">
<p>A <code data-markx="155" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTU1Ij4=">ProviderManager</code> has an optional parent, which it can consult if all providers return <code data-markx="156" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTU2Ij4=">null</code>. If the parent is not available then a <code data-markx="157" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTU3Ij4=">null</code> <code data-markx="158" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTU4Ij4=">Authentication</code> results in an <code data-markx="159" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTU5Ij4=">AuthenticationException</code>.</p>
</div>
<div class="paragraph" gtc:encodedoriginal="PGRpdiBjbGFzcz0icGFyYWdyYXBoIj4=">
<p>Sometimes an application has logical groups of protected resources (e.g. all web resources that match a path pattern <code data-markx="162" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTYyIj4=">/api/**</code>), and each group can have its own dedicated <code data-markx="163" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTYzIj4=">AuthenticationManager</code>. Often, each of those is a <code data-markx="164" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTY0Ij4=">ProviderManager</code>, and they share a parent. The parent is then a kind of "global" resource, acting as a fallback for all providers.</p>
</div>
<div class="imageblock" gtc:encodedoriginal="PGRpdiBjbGFzcz0iaW1hZ2VibG9jayI-">
<div class="content" gtc:encodedoriginal="PGRpdiBjbGFzcz0iY29udGVudCI-">
<img src="https://github.com/spring-guides/top-spring-security-architecture/raw/master/images/authentication.png" alt="ProviderManagers with a common parent" width="70%" gtc:encodedoriginal="PGltZyBzcmM9Imh0dHBzOi8vZ2l0aHViLmNvbS9zcHJpbmctZ3VpZGVzL3RvcC1zcHJpbmctc2VjdXJpdHktYXJjaGl0ZWN0dXJlL3Jhdy9tYXN0ZXIvaW1hZ2VzL2F1dGhlbnRpY2F0aW9uLnBuZyIgYWx0PSJQcm92aWRlck1hbmFnZXJzIHdpdGggYSBjb21tb24gcGFyZW50IiB3aWR0aD0iNzAlIj4=">
</div>
<div class="title" gtc:encodedoriginal="PGRpdiBjbGFzcz0idGl0bGUiPg==">
Figure 1. An
<code data-markx="169" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTY5Ij4=">AuthenticationManager</code> hierarchy using
<code data-markx="170" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTcwIj4=">ProviderManager</code>
</div>
</div>
</div>
<div class="sect2" gtc:encodedoriginal="PGRpdiBjbGFzcz0ic2VjdDIiPg==">
<h3 id="_customizing_authentication_managers" gtc:encodedoriginal="PGgzIGlkPSJfY3VzdG9taXppbmdfYXV0aGVudGljYXRpb25fbWFuYWdlcnMiPg==">Customizing Authentication Managers</h3>
<div class="paragraph" gtc:encodedoriginal="PGRpdiBjbGFzcz0icGFyYWdyYXBoIj4=">
<p>Spring Security provides some configuration helpers to quickly get common authentication manager features set up in your application. The most commonly used helper is the <code data-markx="175" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTc1Ij4=">AuthenticationManagerBuilder</code> which is great for setting up in-memory, JDBC or LDAP user details, or for adding a custom <code data-markx="176" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTc2Ij4=">UserDetailsService</code>. Here’s an example of an application configuring the global (parent) <code data-markx="177" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTc3Ij4=">AuthenticationManager</code>:</p>
</div>
<div class="listingblock" gtc:encodedoriginal="PGRpdiBjbGFzcz0ibGlzdGluZ2Jsb2NrIj4=">
<div class="content" gtc:encodedoriginal="PGRpdiBjbGFzcz0iY29udGVudCI-">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
public class ApplicationSecurity extends WebSecurityConfigurerAdapter {

   ... // web stuff here

  @Autowired
  public void initialize(AuthenticationManagerBuilder builder, DataSource dataSource) {
    builder.jdbcAuthentication().dataSource(dataSource).withUser("dave")
      .password("secret").roles("USER");
  }

}</code></pre>
</div>
</div>
<div class="paragraph" gtc:encodedoriginal="PGRpdiBjbGFzcz0icGFyYWdyYXBoIj4=">
<p>This example relates to a web application, but the usage of <code data-markx="184" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTg0Ij4=">AuthenticationManagerBuilder</code> is more widely applicable (see below for more detail on how web application security is implemented). Note that the <code data-markx="185" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTg1Ij4=">AuthenticationManagerBuilder</code> is <code data-markx="186" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTg2Ij4=">@Autowired</code> into a method in a <code data-markx="187" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTg3Ij4=">@Bean</code> - that is what makes it build the global (parent) <code data-markx="188" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTg4Ij4=">AuthenticationManager</code>. In contrast if we had done it this way:</p>
</div>
<div class="listingblock" gtc:encodedoriginal="PGRpdiBjbGFzcz0ibGlzdGluZ2Jsb2NrIj4=">
<div class="content" gtc:encodedoriginal="PGRpdiBjbGFzcz0iY29udGVudCI-">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
public class ApplicationSecurity extends WebSecurityConfigurerAdapter {

  @Autowired
  DataSource dataSource;

   ... // web stuff here

  @Override
  public void configure(AuthenticationManagerBuilder builder) {
    builder.jdbcAuthentication().dataSource(dataSource).withUser("dave")
      .password("secret").roles("USER");
  }

}</code></pre>
</div>
</div>
<div class="paragraph" gtc:encodedoriginal="PGRpdiBjbGFzcz0icGFyYWdyYXBoIj4=">
<p>(using an <code data-markx="195" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTk1Ij4=">@Override</code> of a method in the configurer) then the <code data-markx="196" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTk2Ij4=">AuthenticationManagerBuilder</code> is only used to build a "local" <code data-markx="197" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTk3Ij4=">AuthenticationManager</code>, which is a child of the global one. In a Spring Boot application you can <code data-markx="198" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTk4Ij4=">@Autowired</code> the global one into another bean, but you can’t do that with the local one unless you explicitly expose it yourself.</p>
</div>
<div class="paragraph" gtc:encodedoriginal="PGRpdiBjbGFzcz0icGFyYWdyYXBoIj4=">
<p>Spring Boot provides a default global <code data-markx="201" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjAxIj4=">AuthenticationManager</code> (with just one user) unless you pre-empt it by providing your own bean of type <code data-markx="202" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjAyIj4=">AuthenticationManager</code>. The default is secure enough on its own for you not to have to worry about it much, unless you actively need a custom global <code data-markx="203" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjAzIj4=">AuthenticationManager</code>. If you do any configuration that builds an <code data-markx="204" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjA0Ij4=">AuthenticationManager</code> you can often do it locally to the resources that you are protecting and not worry about the global default.</p>
</div>
</div>
<div class="sect2" gtc:encodedoriginal="PGRpdiBjbGFzcz0ic2VjdDIiPg==">
<h3 id="_authorization_or_access_control" gtc:encodedoriginal="PGgzIGlkPSJfYXV0aG9yaXphdGlvbl9vcl9hY2Nlc3NfY29udHJvbCI-">Authorization or Access Control</h3>
<div class="paragraph" gtc:encodedoriginal="PGRpdiBjbGFzcz0icGFyYWdyYXBoIj4=">
<p>Once authentication is successful, we can move on to authorization, and the core strategy here is <code data-markx="209" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjA5Ij4=">AccessDecisionManager</code>. There are three implementations provided by the framework and all three delegate to a chain of <code data-markx="210" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjEwIj4=">AccessDecisionVoter</code>, a bit like the <code data-markx="211" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjExIj4=">ProviderManager</code> delegates to <code data-markx="212" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjEyIj4=">AuthenticationProviders</code>.</p>
</div>
<div class="paragraph" gtc:encodedoriginal="PGRpdiBjbGFzcz0icGFyYWdyYXBoIj4=">
<p>An <code data-markx="215" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjE1Ij4=">AccessDecisionVoter</code> considers an <code data-markx="216" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjE2Ij4=">Authentication</code> (representing a principal) and a secure <code data-markx="217" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjE3Ij4=">Object</code> which as been decorated with <code data-markx="218" gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjE4Ij4=">ConfigAttributes</code>:</p>
</div>
<div class="listingblock" gtc:encodedoriginal="PGRpdiBjbGFzcz0ibGlzdGluZ2Jsb2NrIj4=">
<div class="content" gtc:encodedoriginal="PGRpdiBjbGFzcz0iY29udGVudCI-">
<pre class="highlight"><code class="language-java" data-lang="java">boolean supports(ConfigAttribute attribute);

boolean supports(Class&lt;?&gt; clazz);

int vote(Authentication authentication, S object,
        Collection&lt;ConfigAttribute&gt; attributes);</code></pre>
</div>
</div>
<div class="paragraph">
<p>该<code data-markx="225">Object</code>在<code data-markx="226">AccessDecisionManager</code>和<code data-markx="227">AccessDecisionVoter</code>的签名中是完全通用的-它表示用户可能要访问的任何内容（两种常见的情况是Web资源或Java类中的方法）。<code data-markx="228">ConfigAttributes</code>也相当通用，用一些元数据来表示安全<code data-markx="229">Object</code>的修饰，这些元数据确定访问它所需的权限级别。<code data-markx="230">ConfigAttribute</code>是一个接口，但是它只有一个非常通用的方法并返回<code data-markx="231">String</code> ，因此这些字符串以某种方式编码资源所有者的意图，表达有关允许谁访问它的规则。典型的<code data-markx="232">ConfigAttribute</code>是用户角色的名称（例如<code data-markx="233">ROLE_ADMIN</code>或<code data-markx="234">ROLE_AUDIT</code> ），并且它们通常具有特殊的格式（例如<code data-markx="235">ROLE_</code>前缀）或表示需要求值的表达式。</p>
</div>
<div class="paragraph">
<p>大多数人只是使用默认的<code data-markx="238">AccessDecisionManager</code> ，它是<code data-markx="239">AffirmativeBased</code> （如果任何选民肯定地返回，那么将授予访问权限）。任何定制都倾向于在选民中发生，要么增加新选民，要么修改现有选民的工作方式。</p>
</div>
<div class="paragraph">
<p>使用Spring表达式语言（SpEL）表达式的<code data-markx="242">ConfigAttributes</code>非常常见，例如<code data-markx="243">isFullyAuthenticated() &amp;&amp; hasRole('FOO')</code> 。<code data-markx="244">AccessDecisionVoter</code>支持此功能，可以处理表达式并为其创建上下文。要扩展可处理的表达式范围，需要<code data-markx="245">SecurityExpressionRoot</code>的自定义实现，有时还需要<code data-markx="246">SecurityExpressionHandler</code> 。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_web_security">网络安全</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Web层（用于UI和HTTP后端）中的Spring Security基于Servlet <code data-markx="252">Filters</code> ，因此通常首先了解<code data-markx="253">Filters</code>的作用会很有帮助。下图显示了单个HTTP请求的处理程序的典型分层。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://github.com/spring-guides/top-spring-security-architecture/raw/master/images/filters.png" alt="委托给Servlet的过滤器链" width="70%">
</div>
</div>
<div class="paragraph">
<p>客户端向应用程序发送请求，然后容器根据请求URI的路径确定对它应用哪些过滤器和哪个servlet。一个servlet最多只能处理一个请求，但是过滤器形成一个链，因此它们是有序的，实际上，如果过滤器要处理请求本身，则可以否决链的其余部分。过滤器还可以修改下游过滤器和Servlet中使用的请求和/或响应。过滤器链的顺序非常重要，Spring Boot通过两种机制对其进行管理：一种是<code data-markx="260">Filter</code>类型的<code data-markx="259">@Beans</code>可以具有<code data-markx="261">@Order</code>或实现<code data-markx="262">Ordered</code> ，另一种是它们可以成为<code data-markx="263">FilterRegistrationBean</code>本身的一部分订单是其API的一部分。一些现成的过滤器定义了它们自己的常量，以帮助表明它们相对于彼此的顺序（例如，来自Spring Session的<code data-markx="264">SessionRepositoryFilter</code>的<code data-markx="265">DEFAULT_ORDER</code>为<code data-markx="266">Integer.MIN_VALUE + 50</code> ，这告诉我们它喜欢处于链中的早期，但不排除其他过滤器在此之前。</p>
</div>
<div class="paragraph">
<p>Spring Security作为链中的单个<code data-markx="269">Filter</code>安装，其隐秘类型为<code data-markx="270">FilterChainProxy</code> ，其原因很快就会变得显而易见。在Spring Boot应用程序中，安全过滤器是<code data-markx="272">ApplicationContext</code>的<code data-markx="271">@Bean</code> ，并且默认情况下已安装它，以便将其应用于每个请求。它安装在<code data-markx="273">SecurityProperties.定义的位置<code data-markx="273">SecurityProperties.DEFAULT_FILTER_ORDER</code> ，它又由<code data-markx="274">FilterRegistrationBean.锚定<code data-markx="274">FilterRegistrationBean.REQUEST_WRAPPER_FILTER_MAX_ORDER</code> （Spring Boot应用程序希望过滤器包装请求并修改其行为时期望的最大顺序）。但是，还有更多的功能：从容器的角度来看，Spring Security是单个过滤器，但是在内部有其他过滤器，每个过滤器都扮演着特殊的角色。这是一张照片：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://github.com/spring-guides/top-spring-security-architecture/raw/master/images/security-filters.png" alt="弹簧安全过滤器" width="70%">
</div>
<div class="title">图2。Spring Security是一个物理<code data-markx="279">Filter</code>但将处理委托给一系列内部过滤器</div>
</div>
<div class="paragraph">
<p>实际上，安全过滤器中甚至还有一层间接层：它通常以<code data-markx="282">DelegatingFilterProxy</code>形式安装在容器中，而不必是Spring <code data-markx="283">@Bean</code> 。代理委托给一个始终为<code data-markx="285">@Bean</code>的<code data-markx="284">FilterChainProxy</code> ，通常使用固定名称<code data-markx="286">springSecurityFilterChain</code> 。它是<code data-markx="287">FilterChainProxy</code> ，其中包含所有内部安全逻辑，这些安全逻辑在内部排列为一个或多个过滤器链。所有过滤器都具有相同的API（它们都实现了Servlet Spec中的<code data-markx="288">Filter</code>接口），并且它们都有机会否决该链的其余部分。</p>
</div>
<div class="paragraph">
<p>可以有多个过滤器链，这些链均由Spring Security在同一顶级<code data-markx="291">FilterChainProxy</code> ，而对于容器来说都是未知的。Spring Security过滤器包含一个过滤器链列表，并向与其匹配的第一个链发送请求。下图显示了基于匹配请求路径（ <code data-markx="292">/foo/**</code>在<code data-markx="293">/**</code>之前匹配）发生的调度。这是很常见的，但不是匹配请求的唯一方法。此调度过程的最重要特征是，只有一个链处理过请求。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://github.com/spring-guides/top-spring-security-architecture/raw/master/images/security-filters-dispatch.png" alt="安全过滤器派遣" width="70%">
</div>
<div class="title">图3。Spring Security <code data-markx="298">FilterChainProxy</code>将请求分派到匹配的第一个链。
</div>
</div>
<div class="paragraph">
<p>没有自定义安全配置的普通Spring Boot应用程序具有多个（称为n）过滤器链，其中通常n = 6。前（n-1）个链仅用于忽略静态资源模式，例如<code data-markx="301">/css/**</code>和<code data-markx="302">/images/**</code>和错误视图<code data-markx="303">/error</code> （路径可以由用户以<code data-markx="304">security.ignored</code>控制路径。 <code data-markx="305">SecurityProperties</code>配置bean）。最后一个链与捕获所有路径<code data-markx="306">/**</code>匹配，并且更活跃，包含用于身份验证，授权，异常处理，会话处理，标头写入等的逻辑。默认情况下，该链中共有11个过滤器，但通常情况下用户不必担心使用哪个过滤器以及何时使用。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">注意</div> </td>
<td class="content">该内部通过Spring Security的所有过滤器是未知的容器中的事实是很重要的，尤其是在春季启动应用程序，所有<code data-markx="314">@Beans</code>类型的<code data-markx="315">Filter</code>会自动与默认的容器中注册。因此，如果要向安全链中添加自定义过滤器，则无需将其设置为<code data-markx="316">@Bean</code>或将其包装在明确禁用容器注册的<code data-markx="317">FilterRegistrationBean</code>中。</td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_creating_and_customizing_filter_chains">创建和定制过滤器链</h3>
<div class="paragraph">
<p>Spring Boot应用程序（带有<code data-markx="322">/**</code>请求匹配器的应用程序）中的默认后备过滤器链具有<code data-markx="323">SecurityProperties.的预定义顺序<code data-markx="323">SecurityProperties.BASIC_AUTH_ORDER</code> 。您可以通过设置<code data-markx="324">security.basic.enabled=false</code>完全关闭它，也可以将其用作后备并仅以较低的顺序定义其他规则。要做到这一点只需添加一个<code data-markx="325">@Bean</code>类型的<code data-markx="326">WebSecurityConfigurerAdapter</code> （或<code data-markx="327">WebSecurityConfigurer</code> ）和装饰与类<code data-markx="328">@Order</code> 。例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
@Order(SecurityProperties.BASIC_AUTH_ORDER - 10)
public class ApplicationConfigurerAdapter extends WebSecurityConfigurerAdapter {
  @Override
  protected void configure(HttpSecurity http) throws Exception {
    http.antMatcher("/foo/**")
     ...;
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个bean将导致Spring Security添加一个新的过滤器链并在回退之前对其进行排序。</p>
</div>
<div class="paragraph">
<p>与一组资源相比，许多应用程序对一组资源的访问规则完全不同。例如，承载UI和支持API的应用程序可能支持基于cookie的身份验证以及对UI部件的登录页面的重定向，以及基于令牌的身份验证以及对API部件的未经身份验证的请求的401响应。每组资源都有其自己的<code data-markx="337">WebSecurityConfigurerAdapter</code>以及唯一的顺序和自己的请求匹配器。如果匹配规则重叠，则最早的有序过滤器链将获胜。</p>
</div>
</div>
<div class="sect2">
<h3 id="_request_matching_for_dispatch_and_authorization">请求匹配以进行调度和授权</h3>
<div class="paragraph">
<p>安全筛选器链（或等效的<code data-markx="342">WebSecurityConfigurerAdapter</code> ）具有一个请求匹配器，该请求匹配器用于确定是否将其应用于HTTP请求。一旦决定应用特定的过滤器链，就不再应用其他过滤器链。但是在过滤器链中，可以通过在<code data-markx="343">HttpSecurity</code>配置器中设置其他匹配器来对授权进行更精细的控制。例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
@Order(SecurityProperties.BASIC_AUTH_ORDER - 10)
public class ApplicationConfigurerAdapter extends WebSecurityConfigurerAdapter {
  @Override
  protected void configure(HttpSecurity http) throws Exception {
    http.antMatcher("/foo/**")
      .authorizeRequests()
        .antMatchers("/foo/bar").hasRole("BAR")
        .antMatchers("/foo/spam").hasRole("SPAM")
        .anyRequest().isAuthenticated();
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>配置Spring Security时最容易犯的一个错误是忘记这些匹配器适用于不同的流程，一个是整个过滤器链的请求匹配器，另一个是仅选择要应用的访问规则。</p>
</div>
</div>
<div class="sect2">
<h3 id="_combining_application_security_rules_with_actuator_rules">将应用程序安全规则与执行器规则相结合</h3>
<div class="paragraph">
<p>如果您将Spring Boot Actuator用于管理端点，则可能希望它们是安全的，默认情况下将是安全的。实际上，将执行器添加到安全应用程序后，您会获得一条仅适用于执行器端点的附加过滤器链。它由仅匹配执行器端点的请求匹配器定义，并且具有<code data-markx="354">ManagementServerProperties.的顺序<code data-markx="354">ManagementServerProperties.BASIC_AUTH_ORDER</code>比默认的<code data-markx="355">SecurityProperties</code>后备过滤器少5，因此在进行后备检查之前请先咨询它。</p>
</div>
<div class="paragraph">
<p>如果您希望将应用程序安全规则应用于执行器端点，则可以添加一个比执行器顺序更早订购的过滤器链，并带有一个包括所有执行器端点的请求匹配器。如果您喜欢执行器端点的默认安全性设置，那么最简单的方法是在执行器端点之后但在回退之前（例如<code data-markx="358">ManagementServerProperties.添加自己的过滤器<code data-markx="358">ManagementServerProperties.BASIC_AUTH_ORDER + 1</code> ）。例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
@Order(ManagementServerProperties.BASIC_AUTH_ORDER + 1)
public class ApplicationConfigurerAdapter extends WebSecurityConfigurerAdapter {
  @Override
  protected void configure(HttpSecurity http) throws Exception {
    http.antMatcher("/foo/**")
     ...;
  }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">注意</div> </td>
<td class="content">Web层中的Spring Security当前与Servlet API绑定，因此仅在以嵌入式或其他方式在Servlet容器中运行应用程序时才真正适用。但是，它不依赖于Spring MVC或Spring Web堆栈的其余部分，因此可以在任何servlet应用程序中使用，例如使用JAX-RS的servlet应用程序。</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_method_security">方法安全性</h2>
<div class="sectionbody">
<div class="paragraph">
<p>除了支持Web应用程序安全外，Spring Security还提供了将访问规则应用于Java方法执行的支持。对于Spring Security，这只是“保护资源”的另一种类型。对于用户来说，这意味着使用相同的<code data-markx="375">ConfigAttribute</code>字符串格式（例如角色或表达式）声明访问规则，但是在代码中的不同位置。第一步是启用方法安全性，例如在应用程序的顶级配置中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@EnableGlobalMethodSecurity(securedEnabled = true)
public class SampleSecureApplication {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后我们可以直接修饰方法资源，例如</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Service
public class MyService {

  @Secured("ROLE_USER")
  public String secure() {
    return "Hello Security";
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此示例是一种使用安全方法的服务。如果Spring创建了这种类型的<code data-markx="388">@Bean</code> ，则它将被代理，并且在实际执行该方法之前，调用者必须经过安全拦截器。如果访问被拒绝，则调用者将获得<code data-markx="389">AccessDeniedException</code>而不是实际的方法结果。</p>
</div>
<div class="paragraph">
<p>有可以在方法中使用以执行安全性约束，特别是其他注释<code data-markx="392">@PreAuthorize</code>和<code data-markx="393">@PostAuthorize</code> ，这允许你写含有以分别方法参数和返回值引用的表达式。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody>
<tr>
<td class="icon">
<div class="title">小费</div> </td>
<td class="content">结合Web安全性和方法安全性并不少见。筛选器链提供了用户体验功能，例如身份验证和重定向到登录页面等，并且方法安全性在更精细的级别上提供了保护。</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_working_with_threads">使用线程</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security从根本上讲是线程绑定的，因为它需要使当前经过身份验证的主体可供各种下游使用者使用。基本构造块是<code data-markx="406">SecurityContext</code> ，它可以包含<code data-markx="407">Authentication</code> （并且当用户登录时，它将是经过显式<code data-markx="409">authenticated</code>的<code data-markx="408">Authentication</code> ）。您始终可以通过<code data-markx="410">SecurityContext</code>静态便捷方法来访问和操作<code data-markx="411">SecurityContextHolder</code> ，该方法又可以简单地操作<code data-markx="412">TheadLocal</code> ，例如</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">SecurityContext context = SecurityContextHolder.getContext();
Authentication authentication = context.getAuthentication();
assert(authentication.isAuthenticated);</code></pre>
</div>
</div>
<div class="paragraph">
<p>用户应用程序代码执行此操作<strong>并不</strong>常见，但是例如在您需要编写自定义身份验证过滤器时可能会很有用（尽管即使如此，Spring Security中也可以使用基类来避免需要使用<code data-markx="420">SecurityContextHolder</code> ）。</p>
</div>
<div class="paragraph">
<p>如果您需要访问Web端点中当前经过身份验证的用户，则可以在<code data-markx="423">@RequestMapping</code>使用method参数。例如</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@RequestMapping("/foo")
public String foo(@AuthenticationPrincipal User user) {
  ... // do stuff with user
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该注释将当前的<code data-markx="430">Authentication</code>从<code data-markx="431">SecurityContext</code>拉出，并对其调用<code data-markx="432">getPrincipal()</code>方法以产生method参数。该类型的<code data-markx="433">Principal</code>在<code data-markx="434">Authentication</code>依赖于<code data-markx="435">AuthenticationManager</code>用于验证的认证，所以这可能是一个有用的小窍门得到一个类型安全的引用到你的用户数据。</p>
</div>
<div class="paragraph">
<p>如果使用Spring Security，则<code data-markx="439">HttpServletRequest</code>的<code data-markx="438">Principal</code>的类型将为<code data-markx="440">Authentication</code> ，因此您也可以直接使用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@RequestMapping("/foo")
public String foo(Principal principal) {
  Authentication authentication = (Authentication) principal;
  User = (User) authentication.getPrincipal();
  ... // do stuff with user
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您需要编写在不使用Spring Security时可以工作的代码，那么这有时很有用（您需要在装入<code data-markx="447">Authentication</code>类时更具防御性）。</p>
</div>
<div class="sect2">
<h3 id="_processing_secure_methods_asynchronously">异步处理安全方法</h3>
<div class="paragraph">
<p>由于<code data-markx="452">SecurityContext</code>是线程绑定的，因此，如果要执行任何调用安全方法的后台处理，例如使用<code data-markx="453">@Async</code> ，则需要确保传播上下文。这归结为将<code data-markx="454">SecurityContext</code>与在后台执行的任务（ <code data-markx="455">Runnable</code> ， <code data-markx="456">Callable</code>等）包装在一起。Spring Security提供了一些帮助程序，例如<code data-markx="457">Runnable</code>和<code data-markx="458">Callable</code>包装器。要将<code data-markx="459">SecurityContext</code>传播到<code data-markx="460">@Async</code>方法，您需要提供<code data-markx="461">AsyncConfigurer</code>并确保<code data-markx="462">Executor</code>具有正确的类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
public class ApplicationConfiguration extends AsyncConfigurerSupport {

  @Override
  public Executor getAsyncExecutor() {
    return new DelegatingSecurityContextExecutorService(Executors.newFixedThreadPool(5));
  }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</article>
</div>
<aside class="span4 content-right-pane--container mobile-left-pane" id="sidebar">
<a class="ci-status desktop-only" href="https://travis-ci.org/spring-guides/top-spring-security-architecture">
<img src="https://travis-ci.org/spring-guides/top-spring-security-architecture.svg?branch=master">
</a>
<div class="right-pane-widget--container desktop-only">
<div class="github-actions https">
<h2>获取代码</h2>
<div class="btn-group">
<button class="btn" data-protocol="https">HTTPS</button>
<button class="btn" data-protocol="ssh">SSH协议</button>
</div>
<div class="clone-url https">
<input id="clone-url-https" type="text" value="https://github.com/spring-guides/top-spring-security-architecture.git" readonly="">
<button class="copy-button github" data-toggle="tooltip" data-clipboard-text="https://github.com/spring-guides/top-spring-security-architecture.git"></button>
</div>
<div class="clone-url ssh">
<input id="clone-url-ssh" type="text" value="git@github.com：spring-guides / top-spring-security-architecture.git" readonly="">
<button class="copy-button github" data-toggle="tooltip" data-clipboard-text="git@github.com:spring-guides/top-spring-security-architecture.git"></button>
</div>
<a class="github_download btn btn-black uppercase" href="https://github.com/spring-guides/top-spring-security-architecture/archive/master.zip">下载ZIP</a> <a class="gs-guide-import" href="https://github.com/spring-guides/top-spring-security-architecture.git">导入到STS</a>
<div class="go-to-repo--container">
<a href="https://github.com/spring-guides/top-spring-security-architecture"><i class="icon-github"></i>去回购</a>
</div>
<div class="go-to-repo--container">
</div>
</div>
</div>
<div class="right-pane-widget--container">
<div>
<h3><a class="anchor" href="#table-of-contents" name="table-of-contents"></a>目录</h3>
<div><ul class="sectlevel1">
<li><a href="#_authentication_and_access_control">身份验证和访问控制</a> </li>
<li><a href="#_web_security">网络安全</a> </li>
<li><a href="#_method_security">方法安全性</a></li>
<li><a href="#_working_with_threads">使用线程</a> </li>
</ul></div>
</div>
</div>
</aside>
</div>
</main>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>