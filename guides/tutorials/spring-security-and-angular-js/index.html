<html  data-clipboard-buttons="" data-code-prettify="" data-code-sidebar="" data-hide-show-guide="" data-sts-import="" data-mobile-support="" data-search=""><head>
<title>教程·Spring安全性和Angular</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link rel="stylesheet" type="text/css" href="/css/gsguide-cce08ab7a9f46db88819a14148e45bad.css">

<meta property="og:title" content="Spring Security and Angular">
<meta property="og:image" content="/img/spring-by-pivotal-9066b55828deb3c10e27e609af322c40.png">
<meta property="og:description" content="this tutorial is designed to be completed in 2-3 hours, it provides deeper, in-context explorations of enterprise application development topics, leaving you ready to implement real-world solutions.">
</head>
<body >

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link active">
<a href="/guides">导游</a>
</li>
<li class="navbar-link">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<main class="main-body--wrapper">
<div class="row-fluid">
<div class="span8 mobile-left-pane">
<div class="content--title desktop-only">讲解</div>
<article class="content--container">
<h1 class="title">Spring Security和Angular</h1>
<div class="article-body"><div class="sect1">
<h2 id="_spring_and_angular_js_a_secure_single_page_application">安全的单页应用程序</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在本教程中，我们将展示Spring Security，Spring Boot和Angular的一些不错的功能，共同提供令人愉悦和安全的用户体验。Spring和Angular的初学者应该可以使用它，但是在这两个方面的专家都将使用很多细节。实际上，这是有关Spring Security和Angular的系列文章中的第一部分，每个部分都陆续公开了新功能。我们将在<a href="#_the_login_page_angular_js_and_spring_security_part_ii">第二期</a>及以后的文章中对应用程序进行改进，但是此后的主要更改是体系结构而不是功能。</p>
</div>
<div class="sect2">
<h3 id="_spring_and_the_single_page_application">Spring和单页应用程序</h3>
<div class="paragraph">
<p>HTML5，丰富的基于浏览器的功能和“单页应用程序”对于现代开发人员来说是非常有价值的工具，但是任何有意义的交互都将涉及后端服务器，以及静态内容（HTML，CSS和JavaScript）需要一个后端服务器。后端服务器可以扮演许多角色中的任何一个或全部：提供静态内容，有时（但最近不多）提供动态HTML，验证用户身份，保护对受保护资源的访问，以及（最后但并非最不重要的）交互作用在浏览器中通过HTTP和JSON（有时称为REST API）。</p>
</div>
<div class="paragraph">
<p>Spring一直是构建后端功能的一种流行技术（特别是在企业中），并且随着<a href="https://projects.spring.io/spring-boot">Spring Boot</a>的出现，从未如此简单。让我们看一下如何使用Spring Boot，Angular和Twitter Bootstrap从零开始构建新的单页应用程序。没有特别的理由选择特定的堆栈，但是它非常流行，尤其是在企业Java商店中的核心Spring用户群体中，因此这是一个值得的起点。</p>
</div>
</div>
<div class="sect2">
<h3 id="_create_a_new_project">创建一个新项目</h3>
<div class="paragraph">
<p>我们将逐步详细地创建此应用程序，以便对Spring和Angular不完全满意的任何人都可以了解正在发生的事情。如果您喜欢紧追其后，则可以<a href="#how-does-it-work">跳到</a>应用程序运行<a href="#how-does-it-work">的末尾</a> ，然后查看它们如何组合在一起。创建新项目有多种选择：</p>
</div>
<div class="ulist">
<ul>
<li> <p><a href="#using-curl">在命令行上使用curl</a></p> </li>
<li> <p><a href="#using-spring-boot-cli">使用Spring Boot CLI</a></p> </li>
<li> <p><a href="#using-the-initializr-website">使用Spring Initializr网站</a></p> </li>
<li> <p><a href="#using-spring-tool-suite">使用Spring Tool Suite</a></p> </li>
</ul>
</div>
<div class="paragraph">
<p>我们将要构建的完整项目的源代码在<a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/tree/master/basic">此处的Github中</a> ，因此您可以克隆项目并直接从那里进行工作。然后跳到<a href="#add-a-home-page">下一部分</a> 。</p>
</div>
<div class="sect3">
<h4 id="using-curl">使用卷曲</h4>
<div class="paragraph">
<p>创建新项目开始的最简单方法是通过<a href="https://start.spring.io">Spring Boot Initializr</a> 。例如在类似UN * X的系统上使用curl：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ mkdir ui &amp;&amp; cd ui
$ curl https://start.spring.io/starter.tgz -d style=web \
-d style=security -d name=ui | tar -xzvf -</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，您可以将该项目（默认情况下是普通的Maven Java项目）导入您喜欢的IDE中，或者仅在命令行上使用文件和“ mvn”。然后跳到<a href="#add-a-home-page">下一部分</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="using-spring-boot-cli">使用Spring Boot CLI</h4>
<div class="paragraph">
<p>您可以使用<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#getting-started-installing-the-cli">Spring Boot CLI</a>创建相同的项目，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ spring init --dependencies web,security ui/ &amp;&amp; cd ui</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后跳到<a href="#add-a-home-page">下一部分</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="using-the-initializr-website">使用Initializr网站</h4>
<div class="paragraph">
<p>如果你愿意，你也可以直接得到相同的代码从一个.zip文件<a href="https://start.spring.io">春季启动Initializr</a> 。只需在浏览器中打开它，然后选择依赖项“ Web”和“安全性”，然后单击“生成项目”即可。.zip文件在根目录中包含一个标准的Maven或Gradle项目，因此您可能要在解压缩之前创建一个空目录。然后跳到<a href="#add-a-home-page">下一部分</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="using-spring-tool-suite">使用Spring Tool Suite</h4>
<div class="paragraph">
<p>在<a href="https://spring.io/tools/sts">Spring Tool Suite</a> （一组Eclipse插件）中，您还可以使用<code>File->New->Spring Starter Project</code>的向导来创建和导入<code>File->New->Spring Starter Project</code> 。然后跳到<a href="#add-a-home-page">下一部分</a> 。IntelliJ IDEA和NetBeans具有相似的功能。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="add-a-home-page">添加一个Angular应用</h3>
<div class="paragraph">
<p>如今，Angular（或任何现代前端框架）中单页应用程序的核心将是Node.js构建。Angular有一些工具可以快速进行设置，因此可以使用它们，并且像其他任何Spring Boot应用程序一样，保留使用Maven进行构建的选项。如何设置Angular应用程序的详细信息在<a href="https://github.com/dsyer/spring-boot-angular">其他地方介绍</a> ，或者您可以从github签出本教程的代码。</p>
</div>
<div class="sect3">
<h4 id="_running_the_application">运行应用程序</h4>
<div class="paragraph">
<p>Angular应用程序启动后，您的应用程序将可在浏览器中加载（即使并没有做很多事情）。在命令行上，您可以执行此操作</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ mvn spring-boot:run</code></pre>
</div>
</div>
<div class="paragraph">
<p>并转到位于<a href="http://localhost:8080">http://localhost:8080</a>的浏览器。加载主页时，应该会出现一个浏览器对话框，询问用户名和密码（用户名是“ user”，密码在启动时在控制台日志中打印）。实际上还没有任何内容（或者<code>ng</code> CLI中可能是默认的“英雄”教程内容），因此您应该基本上得到一个空白页。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-tip" title="小费"></i> </td>
<td class="content">如果您不希望为密码刮取控制台日志，只需将其添加到“ application.properties”（在“ src / main / resources”中）： <code>security.user.password=password</code> （然后选择您自己的密码）。我们在示例代码中使用“ application.yml”进行了此操作。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>在IDE中，只需在应用程序类中运行<code>main()</code>方法（只有一个类，如果使用上面的“ curl”命令，则称为<code>UiApplication</code> ）。</p>
</div>
<div class="paragraph">
<p>要打包并作为独立的JAR运行，您可以执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ mvn package
$ java -jar target/*.jar</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_customize_the_angular_application">自定义Angular应用程序</h3>
<div class="paragraph">
<p>让我们自定义“ app-root”组件（在“ src / app / app.component.ts”中）。</p>
</div>
<div class="paragraph">
<p>最小的Angular应用程序如下所示：</p>
</div>
<div class="listingblock">
<div class="title">app.component.ts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title = 'Demo';
  greeting = {'id': 'XXX', 'content': 'Hello World'};
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此TypeScript中的大多数代码都是样板。有趣的东西全都放在<code>AppComponent</code> ，我们在其中定义“选择器”（HTML元素的名称）和一个HTML片段，以通过<code>@Component</code>annotation呈现。我们还需要编辑HTML模板（“ app.component.html”）：</p>
</div>
<div class="listingblock">
<div class="title">app.component.html</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;div style="text-align:center"class="container"&gt;
  &lt;h1&gt;
    Welcome {{title}}!
  &lt;/h1&gt;
  &lt;div class="container"&gt;
    &lt;p&gt;Id: &lt;span&gt;{{greeting.id}}&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;Message: &lt;span&gt;{{greeting.content}}!&lt;/span&gt;&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您将这些文件添加到“ src / app”下并重建了您的应用程序，则该应用程序现在应该安全且可以正常运行，并且会显示“ Hello World！”。<code>greeting</code>由HTML中的Angular使用车把占位符<code>{{greeting.id}}</code>和<code>{{greeting.content}}</code>呈现。</p>
</div>
</div>
<div class="sect2">
<h3 id="dynamic-content">添加动态内容</h3>
<div class="paragraph">
<p>到目前为止，我们已经有了一个带有硬编码的问候语的应用程序。这对于了解事物如何组合很有用，但实际上我们希望内容来自后端服务器，因此让我们创建一个HTTP端点，可以用来获取问候。在您的<a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/blob/master/basic/src/main/java/demo/UiApplication.java">应用程序类中</a> （在“ src / main / java / demo”中），添加<code>@RestController</code>annotation并定义一个新的<code>@RequestMapping</code> ：</p>
</div>
<div class="listingblock">
<div class="title">UiApplication.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@RestController
public class UiApplication {

  @RequestMapping("/resource")
  public Map&lt;String,Object&gt; home() {
    Map&lt;String,Object&gt; model = new HashMap&lt;String,Object&gt;();
    model.put("id", UUID.randomUUID().toString());
    model.put("content", "Hello World");
    return model;
  }

  public static void main(String[] args) {
    SpringApplication.run(UiApplication.class, args);
  }

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">根据创建新项目的方式，它可能不称为<code>UiApplication</code> 。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>运行该应用程序并尝试卷曲“ / resource”端点，默认情况下您会发现它是安全的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ curl localhost:8080/resource
{"timestamp":1420442772928,"status":401,"error":"Unauthorized","message":"Full authentication is required to access this resource","path":"/resource"}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_loading_a_dynamic_resource_from_angular">从Angular加载动态资源</h4>
<div class="paragraph">
<p>因此，让我们在浏览器中获取该消息。修改<code>AppComponent</code>以使用XHR加载受保护的资源：</p>
</div>
<div class="listingblock">
<div class="title">app.component.ts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">import { Component } from '@angular/core';
import { HttpClient } from '@angular/common/http';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title = 'Demo';
  greeting = {};
  constructor(private http: HttpClient) {
    http.get('resource').subscribe(data =&gt; this.greeting = data);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们注入了Angular通过<code>http</code>模块提供的<a href="https://angular.io/guide/http"><code>http</code>服务</a> ，并使用它获取我们的资源。Angular将响应传递给我们，然后我们提取JSON并将其分配给问候语。</p>
</div>
<div class="paragraph">
<p>为了将<code>http</code>服务依赖注入到我们的自定义组件中，我们需要在包含该组件的<code>AppModule</code>中对其进行声明（与初始草案相比，它在<code>imports</code>仅占一行）：</p>
</div>
<div class="listingblock">
<div class="title">app.module.ts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';

import { AppComponent } from './app.component';
import { HttpClientModule } from '@angular/common/http';

@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
    HttpClientModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>再次运行该应用程序（或只是在浏览器中重新加载主页），您将看到带有唯一ID的动态消息。因此，即使资源受到保护并且您不能直接卷曲它，浏览器仍能够访问内容。我们有不到一百行代码的安全单页应用程序！</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">更改静态资源后，可能需要强制浏览器重新加载静态资源。在Chrome（以及带有插件的Firefox）中，您可以使用“开发人员工具”（F12），这可能就足够了。或者，您可能必须使用CTRL + F5。</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="how-does-it-work">它是如何工作的？</h3>
<div class="paragraph">
<p>如果您使用某些开发人员工具，则可以在浏览器中看到浏览器与后端之间的交互（通常F12会打开它，默认情况下在Chrome中运行，可能需要Firefox中的插件）。总结如下：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">动词</th>
<th class="tableblock halign-left valign-top">路径</th>
<th class="tableblock halign-left valign-top">状态</th>
<th class="tableblock halign-left valign-top">响应</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">401</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">浏览器提示进行身份验证</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">index.html</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/*.js</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">来自角度的第三资产负荷</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/main.bundle.js</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应用逻辑</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/资源</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JSON问候</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>您可能不会看到401，因为浏览器将主页加载视为单个交互，并且可能会看到两个对“ / resource”的请求，因为存在<a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing">CORS</a>协商。</p>
</div>
<div class="paragraph">
<p>仔细查看请求，您将看到所有请求都有一个“ Authorization”标头，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>Authorization: Basic dXNlcjpwYXNzd29yZA==</code></pre>
</div>
</div>
<div class="paragraph">
<p>浏览器会在每个请求中发送用户名和密码（因此请记住在生产环境中仅使用HTTPS）。没有什么“ Angular”，因此它可以与您的JavaScript框架或非框架选择一起使用。</p>
</div>
<div class="sect3">
<h4 id="_whats_wrong_with_that">怎么了</h4>
<div class="paragraph">
<p>从表面上看，我们似乎做得很好，简洁，易于实施，所有数据都由一个秘密密码保护，并且如果我们更改前端或后端技术，它仍然可以工作。但是有一些问题。</p>
</div>
<div class="ulist">
<ul>
<li> <p>基本身份验证仅限于用户名和密码身份验证。</p> </li>
<li> <p>身份验证用户界面无处不在，但很丑陋（浏览器对话框）。</p> </li>
<li> <p>没有<a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery">跨站请求伪造</a> （CSRF）的保护。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>CSRF并不是我们的应用程序真正存在的问题，因为它只需要获取后端资源（即服务器中的任何状态都不会更改）。一旦您的应用程序中包含POST，PUT或DELETE，就无法通过任何合理的现代措施来保护它了。</p>
</div>
<div class="paragraph">
<p>在<a href="#_the_login_page_angular_js_and_spring_security_part_ii">本系列</a>的<a href="#_the_login_page_angular_js_and_spring_security_part_ii">下一部分中，</a>我们将扩展应用程序以使用基于表单的身份验证，它比HTTP Basic灵活得多。一旦有了表单，我们将需要CSRF保护，并且Spring Security和Angular都具有一些很好的即用型功能来帮助完成此任务。剧透：我们将需要使用<code>HttpSession</code> 。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>谢谢：我要感谢所有帮助我开发本系列文章的人，尤其是<a href="https://spring.io/team/rwinch">Rob Winch</a>和<a href="https://twitter.com/thspaeth">Thorsten Spaeth</a>对文本和源代码的仔细审查，并教了我一些我不知道的技巧我以为我最熟悉。</p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_login_page_angular_js_and_spring_security_part_ii">登录页面</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在本节中，我们继续<a href="#_spring_and_angular_js_a_secure_single_page_application">讨论</a>如何在“单页应用程序”中将<a href="https://projects.spring.io/spring-security">Spring Security</a>与<a href="https://angular.io/">Angular</a>一起使用。在这里，我们展示了如何使用Angular通过表单对用户进行身份验证以及如何获取安全资源以在UI中呈现。这是本系列文章的第二部分，您可以了解应用程序的基本构建模块，也可以通过阅读<a href="#_spring_and_angular_js_a_secure_single_page_application">第一部分</a>从头开始构建它，或者直接进入<a href="https://github.com/dsyer/spring-security-angular/tree/master/single">Github中</a>的<a href="https://github.com/dsyer/spring-security-angular/tree/master/single">源代码</a> 。在第一部分中，我们构建了一个简单的应用程序，该应用程序使用HTTP Basic身份验证来保护后端资源。在此表单中，我们添加了一个登录表单，使用户可以控制是否进行身份验证，并解决第一次迭代中的问题（主要是缺少CSRF保护）。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>提醒：如果您正在使用示例应用程序来完成本节，请确保清除浏览器的cookie和HTTP Basic凭据缓存。在Chrome中，对单个服务器执行此操作的最佳方法是打开一个新的隐身窗口。</p>
</div>
</blockquote>
</div>
<div class="sect2">
<h3 id="_add_navigation_to_the_home_page">将导航添加到主页</h3>
<div class="paragraph">
<p>Angular应用程序的核心是用于基本页面布局的HTML模板。我们已经有了一个非常基本的功能，但是对于此应用程序，我们需要提供一些导航功能（登录，注销，主页），因此让我们对其进行修改（在<code>src/app</code> ）：</p>
</div>
<div class="listingblock">
<div class="title">app.component.html</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;div class="container"&gt;
  &lt;ul class="nav nav-pills"&gt;
    &lt;li&gt;&lt;a routerLinkActive="active" routerLink="/home"&gt;Home&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a routerLinkActive="active" routerLink="/login"&gt;Login&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a (click)="logout()"&gt;Logout&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;
&lt;div class="container"&gt;
  &lt;router-outlet&gt;&lt;/router-outlet&gt;
&lt;/div&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>主要内容是<code><router-outlet/></code>还有一个带有登录和注销链接的导航栏。</p>
</div>
<div class="paragraph">
<p>的<code><router-outlet/></code>选择器由Angular提供，需要将其连接到主模块中的组件。每个路由（每个菜单链接）将只有一个组件，并且需要一个帮助程序服务将它们粘合在一起并共享某些状态（ <code>AppService</code> ）。这是将所有部分组合在一起的模块的实现：</p>
</div>
<div class="listingblock">
<div class="title">app.module.ts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { HttpClientModule } from '@angular/common/http';
import { RouterModule, Routes } from '@angular/router';
import { AppService } from './app.service';
import { HomeComponent } from './home.component';
import { LoginComponent } from './login.component';
import { AppComponent } from './app.component';

const routes: Routes = [
  { path: '', pathMatch: 'full', redirectTo: 'home'},
  { path: 'home', component: HomeComponent},
  { path: 'login', component: LoginComponent}
];

@NgModule({
  declarations: [
    AppComponent,
    HomeComponent,
    LoginComponent
  ],
  imports: [
    RouterModule.forRoot(routes),
    BrowserModule,
    HttpClientModule,
    FormsModule
  ],
  providers: [AppService]
  bootstrap: [AppComponent]
})
export class AppModule { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们添加了对名为<a href="https://angular.io/guide/router">“ RouterModule”</a>的Angular模块的依赖，这使我们能够将魔术<code>router</code>注入到<code>AppComponent</code>的构造函数中。该<code>routes</code>均采用的进口内<code>AppModule</code>建立链接“/”（“家”控制器）和“/登录”（以下简称“登陆”控制器）。</p>
</div>
<div class="paragraph">
<p>我们还在其中<code>FormsModule</code>了<code>FormsModule</code> ，因为稍后需要使用它将数据绑定到我们要在用户登录时提交的表单。</p>
</div>
<div class="paragraph">
<p>UI组件都是“声明”，服务胶水是“提供者”。<code>AppComponent</code>实际上并没有做很多事情。应用程序根目录随附的TypeScript组件在此处：</p>
</div>
<div class="listingblock">
<div class="title">app.component.ts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">import { Component } from '@angular/core';
import { AppService } from './app.service';
import { HttpClient } from '@angular/common/http';
import { Router } from '@angular/router';
import 'rxjs/add/operator/finally';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  constructor(private app: AppService, private http: HttpClient, private router: Router) {
      this.app.authenticate(undefined, undefined);
    }
    logout() {
      this.http.post('logout', {}).finally(() =&gt; {
          this.app.authenticated = false;
          this.router.navigateByUrl('/login');
      }).subscribe();
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>主要特点：</p>
</div>
<div class="ulist">
<ul>
<li> <p>这次有更多的依赖注入，这是<code>AppService</code></p> </li>
<li> <p>有一个注销功能作为组件的属性公开，稍后我们可以使用该功能将注销请求发送到后端。它在<code>app</code>服务中设置一个标志，然后将用户发送回登录屏幕（并通过<code>finally()</code>回调无条件地执行此操作）。</p> </li>
<li> <p>我们正在使用<code>templateUrl</code>将模板HTML外部化为单独的文件。</p> </li>
<li> <p>加载控制器时，将调用<code>authenticate()</code>函数，以查看用户是否实际上已经过身份验证（例如，如果他在会话中间刷新了浏览器）。我们需要<code>authenticate()</code>函数进行远程调用，因为实际的身份验证是由服务器完成的，并且我们不想信任浏览器来跟踪它。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>我们在上面注入的<code>app</code>服务需要一个布尔标志，以便我们可以判断用户当前是否已通过身份验证，以及一个函数<code>authenticate()</code> ，可用于通过后端服务器进行身份验证，或仅向其查询用户详细信息：</p>
</div>
<div class="listingblock">
<div class="title">app.service.ts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';

@Injectable()
export class AppService {

  authenticated = false;

  constructor(private http: HttpClient) {
  }

  authenticate(credentials, callback) {

        const headers = new HttpHeaders(credentials ? {
            authorization : 'Basic ' + btoa(credentials.username + ':' + credentials.password)
        } : {});

        this.http.get('user', {headers: headers}).subscribe(response =&gt; {
            if (response['name']) {
                this.authenticated = true;
            } else {
                this.authenticated = false;
            }
            return callback &amp;&amp; callback();
        });

    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>authenticated</code>标志很简单。<code>authenticate()</code>函数发送HTTP基本身份验证凭据（如果提供的话），否则不发送。它还有一个可选的<code>callback</code>参数，如果身份验证成功，我们可以用来执行一些代码。</p>
</div>
<div class="sect3">
<h4 id="_the_greeting">打招呼</h4>
<div class="paragraph">
<p>旧主页的问候内容可以直接位于“ src / app”中“ app.component.html”的旁边：</p>
</div>
<div class="listingblock">
<div class="title">home.component.html</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;h1&gt;Greeting&lt;/h1&gt;
&lt;div [hidden]="!authenticated()"&gt;
	&lt;p&gt;The ID is {{greeting.id}}&lt;/p&gt;
	&lt;p&gt;The content is {{greeting.content}}&lt;/p&gt;
&lt;/div&gt;
&lt;div [hidden]="authenticated()"&gt;
	&lt;p&gt;Login to see your greeting&lt;/p&gt;
&lt;/div&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于用户现在可以选择是否登录（在全部由浏览器控制之前），因此我们需要在UI中区分安全内容和不安全内容。我们通过添加对（尚不存在的） <code>authenticated()</code>函数的引用来预料到这一点。</p>
</div>
<div class="paragraph">
<p><code>HomeComponent</code>必须获取问候语，还必须提供<code>authenticated()</code>实用程序功能，以将标志从<code>AppService</code>中拉出：</p>
</div>
<div class="listingblock">
<div class="title">home.component.ts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">import { Component, OnInit } from '@angular/core';
import { AppService } from './app.service';
import { HttpClient } from '@angular/common/http';

@Component({
  templateUrl: './home.component.html'
})
export class HomeComponent {

  title = 'Demo';
  greeting = {};

  constructor(private app: AppService, private http: HttpClient) {
    http.get('resource').subscribe(data =&gt; this.greeting = data);
  }

  authenticated() { return this.app.authenticated; }

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_the_login_form">登录表格</h4>
<div class="paragraph">
<p>登录表单也有自己的组件：</p>
</div>
<div class="listingblock">
<div class="title">login.component.html</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;div class="alert alert-danger" [hidden]="!error"&gt;
	There was a problem logging in. Please try again.
&lt;/div&gt;
&lt;form role="form" (submit)="login()"&gt;
	&lt;div class="form-group"&gt;
		&lt;label for="username"&gt;Username:&lt;/label&gt; &lt;input type="text"
			class="form-control" id="username" name="username" [(ngModel)]="credentials.username"/&gt;
	&lt;/div&gt;
	&lt;div class="form-group"&gt;
		&lt;label for="password"&gt;Password:&lt;/label&gt; &lt;input type="password"
			class="form-control" id="password" name="password" [(ngModel)]="credentials.password"/&gt;
	&lt;/div&gt;
	&lt;button type="submit" class="btn btn-primary"&gt;Submit&lt;/button&gt;
&lt;/form&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个非常标准的登录表单，具有2个用于输入用户名和密码的输入，以及一个用于通过Angular事件处理程序<code>(submit)</code>提交表单的按钮。您不需要对form标记执行任何操作，因此最好不要完全放入其中。还有一个错误消息，仅当角度模型包含<code>error</code> 。表单控件使用<a href="https://angular.io/guide/reactive-forms">Angular Forms中的</a> <code>ngModel</code>在HTML和Angular控制器之间传递数据，在这种情况下，我们使用<code>credentials</code>对象保存用户名和密码。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_authentication_process">认证过程</h3>
<div class="paragraph">
<p>为了支持我们刚刚添加的登录表单，我们需要添加一些其他功能。在客户端，这些将在<code>LoginComponent</code>实现，而在服务器上将是Spring Security配置。</p>
</div>
<div class="sect3">
<h4 id="_submitting_the_login_form">提交登录表格</h4>
<div class="paragraph">
<p>要提交表单，我们需要定义已经通过<code>ng-submit</code>在表单中引用的<code>login()</code>函数，以及通过<code>ng-model</code>引用的<code>credentials</code>对象。让我们充实“登录”组件：</p>
</div>
<div class="listingblock">
<div class="title">login.component.ts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">import { Component, OnInit } from '@angular/core';
import { AppService } from './app.service';
import { HttpClient } from '@angular/common/http';
import { Router } from '@angular/router';

@Component({
  templateUrl: './login.component.html'
})
export class LoginComponent {

  credentials = {username: '', password: ''};

  constructor(private app: AppService, private http: HttpClient, private router: Router) {
  }

  login() {
    this.app.authenticate(this.credentials, () =&gt; {
        this.router.navigateByUrl('/');
    });
    return false;
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>除了初始化<code>credentials</code>对象之外，它还定义了表单中所需的<code>login()</code> 。</p>
</div>
<div class="paragraph">
<p><code>authenticate()</code>对相对资源（相对于应用程序的部署根目录）“ / user”进行GET。当从<code>login()</code>函数调用时，它将在标题中添加Base64编码的凭据，以便在服务器上进行身份验证并接受cookie作为回报。当我们获得身份验证结果时， <code>login()</code>函数还将相应地设置本地<code>$scope.error</code>标志，该标志用于控制登录表单上方错误消息的显示。</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_currently_authenticated_user">当前认证的用户</h4>
<div class="paragraph">
<p>为了服务<code>authenticate()</code>函数，我们需要向后端添加一个新的端点：</p>
</div>
<div class="listingblock">
<div class="title">UiApplication.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@RestController
public class UiApplication {

  @RequestMapping("/user")
  public Principal user(Principal user) {
    return user;
  }

  ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是Spring Security应用程序中的一个有用技巧。如果“ / user”资源可访问，那么它将返回当前已认证的用户（一个<a href="https://github.com/spring-projects/spring-security/blob/master/core/src/main/java/org/springframework/security/core/Authentication.java"><code>Authentication</code></a> ），否则Spring Security将拦截该请求并通过<a href="https://github.com/spring-projects/spring-security/blob/master/web/src/main/java/org/springframework/security/web/AuthenticationEntryPoint.java"><code>AuthenticationEntryPoint</code></a>发送401响应。</p>
</div>
</div>
<div class="sect3">
<h4 id="_handling_the_login_request_on_the_server">在服务器上处理登录请求</h4>
<div class="paragraph">
<p>Spring Security使处理登录请求变得容易。我们只需要向我们的<a href="https://github.com/dsyer/spring-security-angular/blob/master/single/src/main/java/demo/UiApplication.java">主应用程序类中</a>添加一些配置（例如，作为一个内部类）：</p>
</div>
<div class="listingblock">
<div class="title">UiApplication.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@RestController
public class UiApplication {

  ...

  @Configuration
  @Order(SecurityProperties.ACCESS_OVERRIDE_ORDER)
  protected static class SecurityConfiguration extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
      http
        .httpBasic()
      .and()
        .authorizeRequests()
          .antMatchers("/index.html", "/", "/home", "/login").permitAll()
          .anyRequest().authenticated();
    }
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是具有Spring Security定制功能的标准Spring Boot应用程序，仅允许匿名访问静态（HTML）资源。HTML资源需要供匿名用户使用，而不仅仅是Spring Security会忽略的原因，原因将变得显而易见。</p>
</div>
<div class="paragraph">
<p>我们需要记住的最后一件事是使Angular提供的JavaScript组件对应用程序匿名可用。我们可以在上面的<code>HttpSecurity</code>配置中执行此操作，但是由于它是静态内容，因此最好直接忽略它：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-yaml" data-lang="yaml">security:
  ignored:
  - "*.bundle.*"</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_adding_default_http_request_headers">添加默认的HTTP请求标头</h3>
<div class="paragraph">
<p>如果此时运行该应用程序，您会发现浏览器会弹出一个基本身份验证对话框（用于用户名和密码）。之所以这样做，是因为它看到XHR请求对<code>/user</code>和<code>/resource</code>的401响应带有“ WWW-Authenticate”标头。抑制此弹出窗口的方法是抑制标头，该标头来自Spring Security。抑制响应标头的方法是发送特殊的常规请求标头“ X-Requested-With = XMLHttpRequest”。它曾经是Angular中的默认设置，但他们<a href="https://github.com/angular/angular.js/issues/1004">在1.3.0中将其删除</a> 。因此，这是在Angular XHR请求中设置默认标头的方法。</p>
</div>
<div class="paragraph">
<p>首先扩展Angular HTTP模块提供的默认<code>RequestOptions</code> ：</p>
</div>
<div class="listingblock">
<div class="title">app.module.ts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">@Injectable()
export class XhrInterceptor implements HttpInterceptor {

  intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler) {
    const xhr = req.clone({
      headers: req.headers.set('X-Requested-With', 'XMLHttpRequest')
    });
    return next.handle(xhr);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的语法是样板。<code>Class</code>的<code>implements</code>属性是它的基类，除了构造函数之外，我们真正需要做的就是重写Angular始终调用并可以用来添加其他标头的<code>intercept()</code>函数。</p>
</div>
<div class="paragraph">
<p>要安装这个新的<code>RequestOptions</code>工厂，我们需要在<code>AppModule</code>的<code>providers</code>中对其进行<code>AppModule</code> ：</p>
</div>
<div class="listingblock">
<div class="title">app.module.ts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">@NgModule({
  ...
  providers: [AppService, { provide: HTTP_INTERCEPTORS, useClass: XhrInterceptor, multi: true }],
  ...
})
export class AppModule { }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_logout">登出</h3>
<div class="paragraph">
<p>该应用程序几乎在功能上完成了。我们需要做的最后一件事就是实现我们在主页中绘制的注销功能。如果用户通过了身份验证，那么我们将显示一个“注销”链接，并将其挂钩到<code>AppComponent</code>的<code>logout()</code>函数。记住，它将HTTP POST发送到“ / logout”，我们现在需要在服务器上实现。这很简单，因为Spring Security已经为我们添加了它（即，对于这个简单的用例，我们不需要做任何事情）。在过去的注销您可以使用行为的更多控制<code>HttpSecurity</code>回调在<code>WebSecurityAdapter</code>到，例如注销后执行一些业务逻辑。</p>
</div>
</div>
<div class="sect2">
<h3 id="_csrf_protection">CSRF保护</h3>
<div class="paragraph">
<p>该应用程序几乎可以使用了，实际上，如果您运行它，您会发现到目前为止我们构建的所有内容都可以正常工作，除了注销链接。尝试使用它，然后在浏览器中查看响应，您将看到原因：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>POST /logout HTTP/1.1
...
Content-Type: application/x-www-form-urlencoded

username=user&amp;password=password

HTTP/1.1 403 Forbidden
Set-Cookie: JSESSIONID=3941352C51ABB941781E1DF312DA474E; Path=/; HttpOnly
Content-Type: application/json;charset=UTF-8
Transfer-Encoding: chunked
...

{"timestamp":1420467113764,"status":403,"error":"Forbidden","message":"Expected CSRF token not found. Has your session expired?","path":"/login"}</code></pre>
</div>
</div>
<div class="paragraph">
<p>很好，因为这意味着Spring Security内置的CSRF保护功能已开始发挥作用，以防止我们用脚射击。它所需的只是在名为“ X-CSRF”的标头中发送给它的令牌。CSRF令牌的值是服务器端在加载主页的初始请求中的<code>HttpRequest</code>属性中可用的值。为了将其提供给客户端，我们可以使用服务器上的动态HTML页面来呈现它，或者通过自定义端点公开它，否则我们可以将其作为cookie发送。最后一个选择是最好的，因为Angular已基于cookie <a href="https://angular.io/guide/http#security-xsrf-protection">内置了对CSRF</a> （称为“ XSRF”）的支持。</p>
</div>
<div class="paragraph">
<p>因此，在服务器上，我们需要一个自定义过滤器来发送Cookie。Angular希望cookie名称为“ XSRF-TOKEN”，Spring Security默认将其作为请求属性提供，因此我们只需要将值从request属性转移到cookie。幸运的是，Spring Security（从4.1.0版本开始）提供了一个特殊的<code>CsrfTokenRepository</code>来精确地做到这一点：</p>
</div>
<div class="listingblock">
<div class="title">UiApplication.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Configuration
@Order(SecurityProperties.ACCESS_OVERRIDE_ORDER)
protected static class SecurityConfiguration extends WebSecurityConfigurerAdapter {
  @Override
  protected void configure(HttpSecurity http) throws Exception {
    http
      ...
      .and().csrf()
        .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse());
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>完成这些更改后，我们无需在客户端执行任何操作，并且登录表单现在可以使用了。</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_does_it_work">它是如何工作的？</h3>
<div class="paragraph">
<p>如果您使用某些开发人员工具，则可以在浏览器中看到浏览器与后端之间的交互（通常F12会打开它，默认情况下在Chrome中运行，可能需要Firefox中的插件）。总结如下：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">动词</th>
<th class="tableblock halign-left valign-top">路径</th>
<th class="tableblock halign-left valign-top">状态</th>
<th class="tableblock halign-left valign-top">响应</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">index.html</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/*.js</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">角度资产</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/用户</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">401</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">未经授权（忽略）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/家</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">主页</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/用户</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">401</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">未经授权（忽略）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/资源</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">401</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">未经授权（忽略）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/用户</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">发送凭据并获取JSON</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/资源</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JSON问候</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>上面标记为“已忽略”的响应是Angular在XHR调用中收到的HTML响应，并且由于我们没有处理该数据，因此HTML掉在了地板上。在“ / user”资源的情况下，我们确实会寻找经过身份验证的用户，但是由于在第一次调用中不存在经过身份验证的用户，因此该响应将被丢弃。</p>
</div>
<div class="paragraph">
<p>仔细查看请求，您将看到它们都有cookie。如果你开始用干净的浏览器（例如隐姓埋名在Chrome），第一个请求没有饼干去上的服务器，但是服务器发回“的Set-Cookie”为“JSESSIONID”（常规<code>HttpSession</code> ）和“X- XSRF-TOKEN”（我们在上面设置的CRSF cookie）。后续请求都具有这些cookie，它们很重要：没有它们，应用程序将无法运行，并且它们提供了一些真正的基本安全功能（身份验证和CSRF保护）。当用户进行身份验证时（在POST之后），cookie的值会更改，这是另一个重要的安全功能（防止<a href="https://en.wikipedia.org/wiki/Session_fixation">会话固定攻击</a> ）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">这是不足够CSRF保护依靠一个cookie被发送回服务器，因为浏览器会自动发送，即使你是不是在你的应用程序加载的页面（跨站脚本攻击，否则称为<a href="https://en.wikipedia.org/wiki/Cross-site_scripting">XSS</a> ）。标头不会自动发送，因此源在控制之下。您可能会看到，在我们的应用程序中，CSRF令牌以cookie的形式发送到客户端，因此我们将看到浏览器将其自动发送回去，但是提供保护的是标头。</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_help_how_is_my_application_going_to_scale">帮助，我的应用程序如何扩展？</h3>
<div class="paragraph">
<p>“但是等等……”您说，“在单页应用程序中使用会话状态不是真的很糟糕吗？这个问题的答案将必须是“大部分”，因为使用会话进行身份验证和CSRF保护绝对是一件好事。该状态必须存储在某个位置，如果您将其从会话中删除，则必须将其放置在其他位置，然后自己在服务器和客户端上手动对其进行管理。那只是更多的代码和可能更多的维护，并且通常会重新发明一个完美的轮子。</p>
</div>
<div class="paragraph">
<p>``但是，但是...''您将回答，``现在如何水平扩展应用程序？“这是您在上面提出的“真实”问题，但往往会简化为“会话状态不好，我必须是无状态的”。不要惊慌这里要考虑的主要点是安全性<em>是</em>有状态的。您不能拥有安全的无状态应用程序。那么，您将在哪里存储状态？这里的所有都是它的。<a href="https://spring.io/team/rwinch">Rob Winch</a>在<a href="https://skillsmatter.com/skillscasts/5398-the-state-of-securing-restful-apis-with-spring">Spring Exchange 2014上</a>进行了非常有用且有见地的演讲，解释了对状态的需求（以及它的普遍性-TCP和SSL是有状态的，因此无论您是否了解，系统都是有状态的），这可能值得一看。如果您想更深入地研究这个主题。</p>
</div>
<div class="paragraph">
<p>好消息是您可以选择。最简单的选择是将会话数据存储在内存中，并依靠负载均衡器中的粘性会话将请求从同一会话路由回同一JVM（它们都以某种方式支持）。这是个好足以让你掉在地上，将一个<em>真正</em>大量使用情况下工作。另一个选择是在应用程序实例之间共享会话数据。只要您严格并且仅存储安全性数据，它就很小并且很少更改（仅当用户登录和注销或他们的会话超时时），因此应该不会有任何主要的基础结构问题。使用<a href="https://github.com/spring-projects/spring-session/">Spring Session</a>也很容易。我们将在本系列的下一部分中使用Spring Session，因此无需在此处进行设置的任何细节，但这实际上是几行代码和一个Redis服务器，这是非常快的。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-tip" title="小费"></i> </td>
<td class="content">设置共享会话状态的另一种简便方法是将应用程序作为WAR文件部署到Cloud Foundry <a href="https://run.pivotal.io">Pivotal Web服务</a>并将其绑定到Redis服务。</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_but_what_about_my_custom_token_implementation_its_stateless_look">但是，我的自定义令牌实现又如何呢（看似无状态）？</h3>
<div class="paragraph">
<p>如果那是您对上一节的答复，请重新阅读，因为您可能是第一次没有得到它。如果将令牌存储在某个地方，这可能不是无状态的，但是即使您没有（例如，使用JWT编码的令牌），也将如何提供CSRF保护？这一点很重要。这是一条经验法则（归因于Rob Winch）：如果浏览器将访问您的应用程序或API，则需要CSRF保护。这并不是说如果没有会话就无法做到这一点，只是您必须自己编写所有代码，这很重要，因为它已经实现并且可以很好地在<code>HttpSession</code>之上运行（这反过来又是一部分）从一开始就使用了哪个容器并烘焙成规格）？即使您决定不需要CSRF，并且拥有完美的“无状态”（基于非会话）令牌实现，您仍然必须在客户端中编写额外的代码以使用和使用它，而您可能只是委托给浏览器和服务器自身的内置功能：浏览器始终发送cookie，并且服务器始终具有会话（除非您将其关闭）。该代码不是业务逻辑，它不会为您赚钱，只是开销，所以更糟的是，它会花费您金钱。</p>
</div>
</div>
<div class="sect2">
<h3 id="_conclusion">结论</h3>
<div class="paragraph">
<p>我们现在拥有的应用程序接近用户在实时环境中的“真实”应用程序中可能期望的应用程序，并且它可以用作构建该功能更丰富的应用程序的模板（具有静态功能的单个服务器）。内容和JSON资源）。我们正在使用<code>HttpSession</code>来存储安全数据，依靠我们的客户来尊重和使用我们发送给他们的cookie，对此我们感到满意，因为它使我们能够专注于自己的业务领域。<a href="#_the_resource_server_angular_js_and_spring_security_part_iii">在下一部分中，</a>我们将架构扩展到单独的身份验证和UI服务器，以及用于JSON的独立资源服务器。显然，这很容易推广到多个资源服务器。我们还将把Spring Session引入堆栈，并展示如何将其用于共享身份验证数据。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_resource_server_angular_js_and_spring_security_part_iii">资源服务器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在本节中，我们继续<a href="#_the_login_page_angular_js_and_spring_security_part_ii">讨论</a>如何在“单页应用程序”中将<a href="https://projects.spring.io/spring-security">Spring Security</a>与<a href="https://angular.io">Angular</a>一起使用。在这里，我们首先将正在用作应用程序中动态内容的“问候”资源分解到单独的服务器中，首先作为不受保护的资源，然后由不透明的令牌保护。这是本系列文章的第三部分，您可以了解应用程序的基本构建模块，也可以通过阅读<a href="#_spring_and_angular_js_a_secure_single_page_application">第一部分</a>从头开始构建它，也可以直接转到Github中的源代码，该文件位于分为两部分：一部分<a href="https://github.com/dsyer/spring-security-angular/tree/master/vanilla">不受资源保护</a> ，另一部分<a href="https://github.com/dsyer/spring-security-angular/tree/master/spring-session">由令牌保护</a> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-tip" title="小费"></i> </td>
<td class="content">如果您正在使用示例应用程序来完成本节，请确保清除浏览器的cookie和HTTP Basic凭据缓存。在Chrome中，对单个服务器执行此操作的最佳方法是打开一个新的隐身窗口。</td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_a_separate_resource_server">单独的资源服务器</h3>
<div class="sect3">
<h4 id="_client_side_changes">客户端更改</h4>
<div class="paragraph">
<p>在客户端，没有太多要做的事情可以将资源移动到另一个后端。这是<a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/blob/master/single/src/app/home/component.ts">最后一部分中</a>的“家庭”组件：</p>
</div>
<div class="listingblock">
<div class="title">home.component.ts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">@Component({
  templateUrl: './home.component.html'
})
export class HomeComponent {

  title = 'Demo';
  greeting = {};

  constructor(private app: AppService, private http: HttpClient) {
    http.get('resource').subscribe(data =&gt; this.greeting = data);
  }

  authenticated() { return this.app.authenticated; }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们要做的就是更改URL。例如，如果我们要在localhost上运行新资源，则它看起来可能像这样：</p>
</div>
<div class="listingblock">
<div class="title">home.component.ts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">        http.get('http://localhost:9000').subscribe(data =&gt; this.greeting = data);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_server_side_changes">服务器端更改</h4>
<div class="paragraph">
<p><a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/blob/master/vanilla/ui/src/main/java/demo/UiApplication.java">UI服务器的</a>更改很简单：我们只需要删除问候资源的<code>@RequestMapping</code> （它是“ / resource”）。然后，我们需要创建一个新的资源服务器，我们可以像使用<a href="https://start.spring.io">Spring Boot Initializr</a>在<a href="#_spring_and_angular_js_a_secure_single_page_application">第一部分中</a>所做的那样进行操作。例如在类似UN * X的系统上使用curl：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ mkdir resource &amp;&amp; cd resource
$ curl https://start.spring.io/starter.tgz -d style=web \
-d name=resource | tar -xzvf -</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，您可以将该项目（默认情况下是普通的Maven Java项目）导入您喜欢的IDE中，或者仅在命令行上使用文件和“ mvn”。</p>
</div>
<div class="paragraph">
<p>只需在<a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/blob/master/vanilla/resource/src/main/java/demo/ResourceApplication.java">主应用程序类中</a>添加<code>@RequestMapping</code> ，然后从<a href="https://github.com/dsyer/spring-security-angular/blob/master/single/src/main/java/demo/UiApplication.java">旧版UI</a>复制实现：</p>
</div>
<div class="listingblock">
<div class="title">ResourceApplication.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@RestController
class ResourceApplication {

  @RequestMapping("/")
  public Message home() {
    return new Message("Hello World");
  }

  public static void main(String[] args) {
    SpringApplication.run(ResourceApplication.class, args);
  }

}

class Message {
  private String id = UUID.randomUUID().toString();
  private String content;
  public Message(String content) {
    this.content = content;
  }
  // ... getters and setters and default constructor
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>完成后，您的应用程序将可以在浏览器中加载。在命令行上，您可以执行此操作</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ mvn spring-boot:run -Dserver.port=9000</code></pre>
</div>
</div>
<div class="paragraph">
<p>并转到位于<a href="http://localhost:9000">http：// localhost：9000</a>的浏览器，您应该看到带有问候语的JSON。您可以在<code>application.properties</code>烘烤端口更改（在“ src / main / resources”中）：</p>
</div>
<div class="listingblock">
<div class="title">application.properties</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-properties" data-lang="properties">server.port: 9000</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果尝试从浏览器中的UI（在端口8080上）加载该资源，则会发现该资源不起作用，因为浏览器不允许XHR请求。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_cors_negotiation">CORS谈判</h3>
<div class="paragraph">
<p>浏览器尝试与我们的资源服务器进行协商，以根据<a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing">交叉源资源共享</a>协议来确定是否允许其访问它。这不是Angular的责任，因此就像cookie合同一样，它将与浏览器中的所有JavaScript一样工作。这两个服务器没有声明它们具有相同的来源，因此浏览器拒绝发送请求，并且UI损坏。</p>
</div>
<div class="paragraph">
<p>要解决此问题，我们需要支持CORS协议，该协议涉及“预检” OPTIONS请求和一些标头，以列出调用者的允许行为。Spring 4.2有一些不错<a href="https://jira.spring.io/browse/SPR-9278">的CORS支持</a> ，因此我们可以在控制器映射中添加一个注释，例如：</p>
</div>
<div class="listingblock">
<div class="title">ResourceApplication.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@RequestMapping("/")
@CrossOrigin(origins="*", maxAge=3600)
public Message home() {
  return new Message("Hello World");
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">巧妙地使用<code>origins=*</code>既快速又肮脏，并且可以使用，但是它并不安全，因此不建议使用。</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_securing_the_resource_server">保护资源服务器</h3>
<div class="paragraph">
<p>大！我们有一个具有新架构的可运行应用程序。唯一的问题是资源服务器没有安全性。</p>
</div>
<div class="sect3">
<h4 id="_adding_spring_security">增加Spring安全性</h4>
<div class="paragraph">
<p>我们还可以研究如何像UI服务器一样，将安全性作为过滤器层添加到资源服务器。第一步真的很简单：只需将Spring Security添加到Maven POM中的类路径中即可：</p>
</div>
<div class="listingblock">
<div class="title">pom.xml</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
  &lt;/dependency&gt;
  ...
&lt;/dependencies&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>重新启动资源服务器，嘿！是安全的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ curl -v localhost:9000
&lt; HTTP/1.1 302 Found
&lt; Location: http://localhost:9000/login
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们正在重定向到（whitelabel）登录页面，因为curl没有发送与Angular客户端相同的标头。修改命令以发送更多类似的标头：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ curl -v -H "Accept: application/json" \
    -H "X-Requested-With: XMLHttpRequest" localhost:9000
&lt; HTTP/1.1 401 Unauthorized
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，我们需要做的就是教客户在每个请求中发送凭据。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_token_authentication">令牌认证</h3>
<div class="paragraph">
<p>互联网和人们的Spring后端项目到处都是基于令牌的定制身份验证解决方案。Spring Security提供了准系统的<code>Filter</code>实现，让您自己开始（例如，参见<a href="https://github.com/spring-projects/spring-security/blob/master/web/src/main/java/org/springframework/security/web/authentication/preauth/AbstractPreAuthenticatedProcessingFilter.java"><code>AbstractPreAuthenticatedProcessingFilter</code></a>和<a href="https://github.com/spring-projects/spring-security/blob/master/core/src/main/java/org/springframework/security/core/token/TokenService.java"><code>TokenService</code></a> ）。但是，Spring Security中没有规范的实现，这可能是有一种更简单的方法的原因之一。</p>
</div>
<div class="paragraph">
<p>请记住，在本系列的<a href="#_the_login_page_angular_js_and_spring_security_part_ii">第二部分</a>中，Spring Security默认使用<code>HttpSession</code>来存储认证数据。但是它并不直接与会话交互：在它们之间有一个抽象层（ <a href="https://github.com/spring-projects/spring-security/blob/master/web/src/main/java/org/springframework/security/web/context/SecurityContextRepository.java"><code>SecurityContextRepository</code></a> ），可以用来更改存储后端。如果我们可以将资源库中的该存储库指向经过UI验证的身份验证的商店，那么我们就可以在两个服务器之间共享身份验证。UI服务器已经有一个这样的存储（ <code>HttpSession</code> ），因此，如果我们可以分发该存储并将其打开到资源服务器，则可以使用大多数解决方案。</p>
</div>
<div class="sect3">
<h4 id="_spring_session">春季会议</h4>
<div class="paragraph">
<p>解决方案的这一部分对于<a href="https://github.com/spring-projects/spring-session/">Spring Session</a>来说非常容易。我们需要的是一个共享数据存储（开箱即用地支持Redis和JDBC），以及服务器中的几行配置以设置<code>Filter</code> 。</p>
</div>
<div class="paragraph">
<p>在UI应用程序中，我们需要向<a href="https://github.com/dsyer/spring-security-angular/blob/master/spring-session/ui/pom.xml">POM</a>添加一些依赖项：</p>
</div>
<div class="listingblock">
<div class="title">pom.xml</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;
  &lt;artifactId&gt;spring-session&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Boot和Spring Session协同工作以连接到Redis并集中存储会话数据。</p>
</div>
<div class="paragraph">
<p>有了这行代码并在本地主机上运行Redis服务器，就可以运行UI应用程序，使用一些有效的用户凭据登录，会话数据（身份验证）将存储在redis中。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-tip" title="小费"></i> </td>
<td class="content">如果您没有本地运行的Redis服务器，则可以使用<a href="https://www.docker.com/">Docker</a>轻松启动它（在Windows或MacOS上，这需要VM）。<a href="https://github.com/dsyer/spring-security-angular/tree/master/spring-session/docker-compose.yml">Github</a>的<a href="https://github.com/dsyer/spring-security-angular/tree/master/spring-session/docker-compose.yml">源代码中</a>有一个<a href="https://docs.docker.com/compose/"><code>docker-compose.yml</code></a>文件，您可以通过<code>docker-compose up</code>在命令行上轻松地运行<code>docker-compose up</code> 。如果在VM中执行此操作，则Redis服务器将在与localhost不同的主机上运行，因此您需要将其通过隧道传输到localhost，或将应用程序配置为指向<code>application.properties</code>正确的<code>spring.redis.host</code> 。</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sending_a_custom_token_from_the_ui">从UI发送自定义令牌</h3>
<div class="paragraph">
<p>唯一缺少的部分是存储中数据密钥的传输机制。密钥是<code>HttpSession</code> ID，因此，如果我们可以在UI客户端中获得该密钥，则可以将其作为自定义标头发送到资源服务器。因此，“ home”控制器将需要更改，以便它将标头作为问候资源的HTTP请求的一部分发送。例如：</p>
</div>
<div class="listingblock">
<div class="title">home.component.ts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">  constructor(private app: AppService, private http: HttpClient) {
    http.get('token').subscribe(data =&gt; {
      const token = data['token'];
      http.get('http://localhost:9000', {headers : new HttpHeaders().set('X-Auth-Token', token)})
        .subscribe(response =&gt; this.greeting = response);
    }, () =&gt; {});
  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>（一个更优雅的解决方案可能是根据需要获取令牌，并使用我们的<code>RequestOptionsService</code>将标头添加到对资源服务器的每个请求中。）</p>
</div>
<div class="paragraph">
<p>我们没有直接转到“ http：// localhost：9000 [ <a href="http://localhost:9000" class="bare">http：// localhost：9000</a> ]”，而是将该调用包装在对“ / token”上的UI服务器上的新自定义端点的调用的成功回调中。实现起来很简单：</p>
</div>
<div class="listingblock">
<div class="title">UiApplication.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@RestController
public class UiApplication {

  public static void main(String[] args) {
    SpringApplication.run(UiApplication.class, args);
  }

  ...

  @RequestMapping("/token")
  public Map&lt;String,String&gt; token(HttpSession session) {
    return Collections.singletonMap("token", session.getId());
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，UI应用程序已准备就绪，并将在所有对后端的调用中将会话ID包含在名为“ X-Auth-Token”的标头中。</p>
</div>
</div>
<div class="sect2">
<h3 id="_authentication_in_the_resource_server">资源服务器中的身份验证</h3>
<div class="paragraph">
<p>资源服务器有一个微小的变化，使其能够接受自定义标头。CORS配置必须从远程客户端（例如，</p>
</div>
<div class="listingblock">
<div class="title">ResourceApplication.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@RequestMapping("/")
@CrossOrigin(origins = "*", maxAge = 3600,
    allowedHeaders={"x-auth-token", "x-requested-with", "x-xsrf-token"})
public Message home() {
  return new Message("Hello World");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，Spring MVC将处理来自浏览器的飞行前检查，但是我们需要告诉Spring Security，允许它通过：</p>
</div>
<div class="listingblock">
<div class="title">ResourceApplication.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public class ResourceApplication extends WebSecurityConfigurerAdapter {

  @Override
  protected void configure(HttpSecurity http) throws Exception {
    http.cors().and().authorizeRequests()
      .anyRequest().authenticated();
  }

  ...</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">不需要<code>permitAll()</code>访问所有资源，并且可能有一个处理程序无意中发送了敏感数据，因为它不知道该请求是预执行的。<code>cors()</code>配置实用程序通过处理过滤器层中的所有飞行前请求来缓解这种情况。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>剩下的就是在资源服务器中获取自定义令牌，并使用它来验证我们的用户。事实证明这很简单，因为我们需要做的就是告诉Spring Security会话存储库在哪里，以及在传入请求中在哪里寻找令牌（会话ID）。首先，我们需要添加Spring Session和Redis依赖项，然后可以设置<code>Filter</code> ：</p>
</div>
<div class="listingblock">
<div class="title">ResourceApplication.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@RestController
class ResourceApplication {

  ...

  @Bean
  HeaderHttpSessionStrategy sessionStrategy() {
    return new HeaderHttpSessionStrategy();
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>创建的此<code>Filter</code>是UI服务器中一个<code>Filter</code>的镜像，因此它将Redis建立为会话存储。唯一的区别是，它使用了自定义<code>HttpSessionStrategy</code> ，它在标头（默认情况下为“ X-Auth-Token”）中查找，而不是默认值（名为“ JSESSIONID”的cookie）。我们还需要防止浏览器在未经<code>WWW-Authenticate: Basic</code>验证的客户端中弹出对话框-该应用程序是安全的，但默认情况下会发送带有<code>WWW-Authenticate: Basic</code>的401消息，因此浏览器会以对话框提示用户名和密码。有多种方法可以实现此目的，但是我们已经使Angular发送了“ X-Requested-With”标头，因此Spring Security默认为我们处理它。</p>
</div>
<div class="paragraph">
<p>对资源服务器进行了最后的更改，以使其与我们的新身份验证方案一起使用。Spring Boot的默认安全性是无状态的，我们希望它在会话中存储身份验证，因此我们需要在<code>application.yml</code> （或<code>application.properties</code> ）中明确声明：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-yaml" data-lang="yaml">security:
  sessions: NEVER</code></pre>
</div>
</div>
<div class="paragraph">
<p>这对Spring Security来说，“从不创建会话，但如果存在则使用一个会话”（由于UI中的身份验证，该会话已经存在）。</p>
</div>
<div class="paragraph">
<p>重新启动资源服务器，并在新的浏览器窗口中打开UI。</p>
</div>
</div>
<div class="sect2">
<h3 id="_why_doesnt_it_all_work_with_cookies">为什么不全部使用Cookie？</h3>
<div class="paragraph">
<p>我们必须使用自定义标头并在客户端中编写代码来填充标头，这并不十分复杂，但是似乎与<a href="#_the_login_page_angular_js_and_spring_security_part_ii">第二部分中</a>的建议尽可能使用cookie和会话相矛盾。有人争辩说，不这样做会带来额外的不必要的复杂性，并且可以肯定的是，我们现在所实现的实现是迄今为止我们所见过的最复杂的：解决方案的技术部分远远超过了业务逻辑（公认的很小）。这绝对是一种公平的批评（我们计划在本系列的下一部分中解决），但是让我们简要地看一下为什么它不像对所有内容使用cookie和会话那样简单。</p>
</div>
<div class="paragraph">
<p>至少我们仍在使用会话，这是有道理的，因为Spring Security和Servlet容器知道如何做到这一点。但是我们不能继续使用cookie来传输身份验证令牌吗？本来不错，但是有一个原因它不起作用，那就是浏览器不允许我们这样做。您可以从JavaScript客户端浏览浏览器的cookie存储，但是有一些限制，这是有充分理由的。特别是，您无权访问服务器以“ HttpOnly”形式发送的cookie（默认情况下，您将看到会话cookie）。您也不能在传出的请求中设置cookie，因此我们无法设置“ SESSION” cookie（这是Spring Session的默认cookie名称），我们必须使用自定义的“ X-Session”标头。这两个限制都是为了保护您自己，因此恶意脚本无法在未经适当授权的情况下访问您的资源。</p>
</div>
<div class="paragraph">
<p>TL; DR UI和资源服务器没有相同的来源，因此它们无法共享Cookie（即使我们可以使用Spring Session强制它们共享会话）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_conclusion_2">结论</h3>
<div class="paragraph">
<p>我们在<a href="#_the_login_page_angular_js_and_spring_security_part_ii">本系列的第二部分中</a>重复了该应用程序的功能：从远程后端获取带有问候语的主页，并在导航栏中显示登录和注销链接。区别在于，问候语来自独立的资源服务器，而不是嵌入在UI服务器中。这给实现增加了相当大的复杂性，但是好消息是我们有一个主要基于配置的（实际上是100％声明式）解决方案。通过将所有新代码提取到库中（Spring配置和Angular自定义指令），我们甚至可以使解决方案具有100％声明性。在接下来的两期中，我们将推迟这项有趣的任务。在<a href="#_the_api_gateway_pattern_angular_js_and_spring_security_part_iv">下一节中，</a>我们将探讨降低当前实现中所有复杂性的另一种非常有效的方法：API网关模式（客户端将其所有请求发送到一个地方，然后在此处进行身份验证）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">我们在这里使用Spring Session在逻辑上不是同一应用程序的2台服务器之间共享会话。这是一个巧妙的技巧，使用“常规” JEE分布式会话是不可能的。</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_api_gateway_pattern_angular_js_and_spring_security_part_iv">API网关</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在本节中，我们继续<a href="#_the_resource_server_angular_js_and_spring_security_part_iii">讨论</a>如何在“单页应用程序”中将<a href="https://projects.spring.io/spring-security">Spring Security</a>与<a href="https://angular.io">Angular</a>一起使用。在这里，我们展示了如何构建一个API网关来使用<a href="https://projects.spring.io/spring-cloud/">Spring Cloud</a>控制身份验证和对后端资源的访问。这是本系列文章的第四部分，您可以了解应用程序的基本构建块，也可以通过阅读<a href="#_spring_and_angular_js_a_secure_single_page_application">第一部分</a>从头开始构建它，或者直接进入<a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/tree/master/proxy">Github中</a>的<a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/tree/master/proxy">源代码</a> 。在上<a href="#_the_resource_server_angular_js_and_spring_security_part_iii">一节中，</a>我们构建了一个简单的分布式应用程序，该应用程序使用<a href="https://github.com/spring-projects/spring-session/">Spring Session</a>来验证后端资源。在本教程中，我们将UI服务器作为后端资源服务器的反向代理，解决了上一个实现的问题（自定义令牌身份验证引入的技术复杂性），并为我们提供了许多新的选项来控制来自浏览器客户端的访问。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>提醒：如果您正在使用示例应用程序来完成本节，请确保清除浏览器的cookie和HTTP Basic凭据缓存。在Chrome中，对单个服务器执行此操作的最佳方法是打开一个新的隐身窗口。</p>
</div>
</blockquote>
</div>
<div class="sect2">
<h3 id="_creating_an_api_gateway">创建一个API网关</h3>
<div class="paragraph">
<p>API网关是前端客户端的单入口（和控制），可以是基于浏览器的（如本节中的示例）或移动的。客户端只需要知道一台服务器的URL，就可以不进行任何更改就可以随意重构后端，这是一个很大的优势。在集中化和控制方面还有其他优势：速率限制，认证，审计和日志记录。使用<a href="https://projects.spring.io/spring-cloud/">Spring Cloud</a>实现简单的反向代理非常简单。</p>
</div>
<div class="paragraph">
<p>如果您按照代码进行操作，您将知道<a href="#_the_resource_server_angular_js_and_spring_security_part_iii">上一节</a>末尾的应用程序实现有些复杂，因此并不是迭代的好地方。但是，有一个中间点，我们可以更轻松地开始，因为Spring Security尚未保护后端资源。源代码是<a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/tree/master/vanilla">Github中的</a>一个单独项目<a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/tree/master/vanilla">，</a>因此我们将从那里开始。它具有一个UI服务器和一个资源服务器，并且它们正在互相通信。资源服务器还没有Spring Security，因此我们可以先使系统工作，然后再添加该层。</p>
</div>
<div class="sect3">
<h4 id="_declarative_reverse_proxy_in_one_line">一行声明式反向代理</h4>
<div class="paragraph">
<p>要将其转变为API网关，UI服务器需要进行一些小的调整。在Spring配置的某个地方，我们需要添加一个<code>@EnableZuulProxy</code>annotation，例如在主（仅） <a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/blob/master/proxy/ui/src/main/java/demo/UiApplication.java">应用程序类中</a> ：</p>
</div>
<div class="listingblock">
<div class="title">UiApplication.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@RestController
@EnableZuulProxy
public class UiApplication {
  ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在外部配置文件中，我们需要将UI服务器中的本地资源映射到<a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/blob/master/proxy/ui/src/main/resources/application.yml">外部配置中</a>的远程资源（“ application.yml”）：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-yaml" data-lang="yaml">security:
  ...
zuul:
  routes:
    resource:
      path: /resource/**
      url: http://localhost:9000</code></pre>
</div>
</div>
<div class="paragraph">
<p>这表示“将此服务器中具有/ resource / **模式的路径映射到远程服务器上localhost：9000的相同路径”。简单而有效（可以，所以包括YAML在内，它只有6行，但是您并不总是需要这样）！</p>
</div>
<div class="paragraph">
<p>我们要做的就是在类路径上做正确的事情。为此，我们在Maven POM中增加了几行：</p>
</div>
<div class="listingblock">
<div class="title">pom.xml</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;dependencyManagement&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
      &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
      &lt;version&gt;Dalston.SR4&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
      &lt;scope&gt;import&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;

&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;
  &lt;/dependency&gt;
  ...
&lt;/dependencies&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意“ spring-cloud-starter-zuul”的使用-它像Spring Boot的启动器一样是启动器POM，但是它控制着我们需要此Zuul代理的依赖项。我们也在使用<code><dependencyManagement></code>因为我们希望能够依赖传递性依赖关系的所有版本都是正确的。</p>
</div>
</div>
<div class="sect3">
<h4 id="_consuming_the_proxy_in_the_client">在客户端中使用代理</h4>
<div class="paragraph">
<p>完成这些更改后，我们的应用程序仍然可以运行，但是直到我们修改客户端之前，我们才真正使用过新的代理。幸运的是，这很简单。我们只需要将<a href="#_the_resource_server_angular_js_and_spring_security_part_iii">上一节中</a>从“单个”样本更改为“香草”样本所做的更改即可：</p>
</div>
<div class="listingblock">
<div class="title">home.component.ts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">constructor(private app: AppService, private http: HttpClient) {
  http.get('resource').subscribe(data =&gt; this.greeting = data);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，当我们启动服务器时，一切正常，并且通过UI（API网关）将请求代理到资源服务器。</p>
</div>
</div>
<div class="sect3">
<h4 id="_further_simplifications">进一步简化</h4>
<div class="paragraph">
<p>更好的是：我们不再需要资源服务器中的CORS筛选器。无论如何，我们很快就将它扔到了一起，应该以手动方式（特别是在涉及安全性的情况下）进行技术集中处理时，应该是一个红灯。幸运的是，它现在是多余的，因此我们可以将其丢弃，然后回到晚上睡觉！</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_securing_the_resource_server_2">保护资源服务器</h3>
<div class="paragraph">
<p>您可能还记得处于中间状态的情况，即我们是从资源服务器没有安全性开始的。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>此外：如果您的网络体系结构反映了应用程序体系结构，那么缺乏软件安全性甚至可能不是问题（您可以使资源服务器在物理上无法访问，但UI服务器除外）。作为一个简单的演示，我们可以使资源服务器只能在localhost上访问。只需将其添加到资源服务器中的<code>application.properties</code> ：</p>
</div>
</blockquote>
</div>
<div class="listingblock">
<div class="title">application.properties</div>
<div class="content">
<pre class="prettyprint highlight"><code>server.address: 127.0.0.1</code></pre>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>哇，那很容易！使用仅在数据中心中可见的网络地址来执行此操作，并且您拥有适用于所有资源服务器和所有用户桌面的安全解决方案。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>假设我们确定我们确实需要软件级别的安全性（出于多种原因，很可能）。这不会有问题，因为我们要做的就是添加Spring Security作为依赖项（在<a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/blob/master/proxy/resource/pom.xml">资源服务器POM中</a> ）：</p>
</div>
<div class="listingblock">
<div class="title">pom.xml</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这就足以为我们提供一个安全的资源服务器，但由于我们在<a href="#_the_resource_server_angular_js_and_spring_security_part_iii">第III部分中</a>没有提到的原因，它还不能使我们的应用程序正常工作：两个服务器之间没有共享的身份验证状态。</p>
</div>
</div>
<div class="sect2">
<h3 id="_sharing_authentication_state">共享认证状态</h3>
<div class="paragraph">
<p>我们可以使用与上次（即<a href="https://github.com/spring-projects/spring-session/">Spring Session</a> ）相同的机制来共享身份验证（和CSRF）状态。我们像以前一样将依赖关系添加到两个服务器：</p>
</div>
<div class="listingblock">
<div class="title">pom.xml</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;
  &lt;artifactId&gt;spring-session&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>但这一次的配置要简单得多，因为我们可以向两者都添加相同的<code>Filter</code>声明。首先，UI服务器明确声明我们希望转发所有标头（即，没有标头是“敏感的”）：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-properties" data-lang="properties">zuul:
  routes:
    resource:
      sensitive-headers:</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后我们可以继续到资源服务器。有两个小的更改：一个是在资源服务器中显式禁用HTTP Basic（以防止浏览器弹出身份验证对话框）：</p>
</div>
<div class="listingblock">
<div class="title">ResourceApplication.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@RestController
class ResourceApplication extends WebSecurityConfigurerAdapter {

  ...

  @Override
  protected void configure(HttpSecurity http) throws Exception {
    http.httpBasic().disable();
    http.authorizeRequests().anyRequest().authenticated();
  }

}</code></pre>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>另外：一种替代方法（也将阻止身份验证对话框）将保留HTTP Basic，但将401质询更改为“基本”以外的内容，这也将阻止身份验证对话框。您可以通过<code>HttpSecurity</code>配置回调中的<code>AuthenticationEntryPoint</code>的单行实现来实现。</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>另一种是在<code>application.properties</code>显式地请求非无状态会话创建策略：</p>
</div>
<div class="listingblock">
<div class="title">application.properties</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-properties" data-lang="properties">security.sessions: NEVER</code></pre>
</div>
</div>
<div class="paragraph">
<p>只要redis仍在后台运行（如果您想启动它，则使用<a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/tree/master/proxy/docker-compose.yml"><code>docker-compose.yml</code></a> ），系统便可以运行。在<a href="http://localhost:8080">http://localhost:8080上</a>加载UI的主页并登录，您将在主页上看到来自后端的消息。</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_does_it_work_2">它是如何工作的？</h3>
<div class="paragraph">
<p>现在幕后发生了什么？首先，我们可以查看UI服务器（和API网关）中的HTTP请求：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">动词</th>
<th class="tableblock halign-left valign-top">路径</th>
<th class="tableblock halign-left valign-top">状态</th>
<th class="tableblock halign-left valign-top">响应</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">index.html</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/*.js</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">资产形式角度</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/用户</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">401</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">未经授权（忽略）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/资源</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">401</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">未经授权的资源访问</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/用户</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JSON认证用户</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/资源</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">（代理）JSON问候</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>这与<a href="#_the_login_page_angular_js_and_spring_security_part_ii">第二部分</a>末尾的顺序相同，除了cookie名称略有不同（“ SESSION”而不是“ JSESSIONID”）是因为我们使用的是Spring Session。但是体系结构是不同的，对“ /资源”的最后一个请求是特殊的，因为它被代理到资源服务器。</p>
</div>
<div class="paragraph">
<p>通过查看UI服务器中的“ / trace”端点（从Spring Boot Actuator中，我们添加了Spring Cloud依赖项），我们可以看到反向代理的作用。在新的浏览器中转到<a href="http://localhost:8080/trace">http://localhost:8080/trace</a> （如果您还没有一个用于浏览器的JSON插件，以使其美观且可读）。您将需要使用HTTP Basic（浏览器弹出窗口）进行身份验证，但是与登录表单相同的凭据有效。在开始或接近开始时，您应该会看到一对类似这样的请求：</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">尝试使用其他浏览器，以确保没有身份验证交叉的机会（例如，如果您使用Chrome浏览器来测试UI，则使用Firefox）-不会阻止该应用程序正常运行，但是如果其中包含这些痕迹，则将更难以阅读来自同一浏览器的混合身份验证。</td>
</tr>
</tbody>
</table>
</div>
<div class="listingblock">
<div class="title">/跟踪</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">{
  "timestamp": 1420558194546,
  "info": {
    "method": "GET",
    "path": "/",
    "query": ""
    "remote": true,
    "proxy": "resource",
    "headers": {
      "request": {
        "accept": "application/json, text/plain, */*",
        "x-xsrf-token": "542c7005-309c-4f50-8a1d-d6c74afe8260",
        "cookie": "SESSION=c18846b5-f805-4679-9820-cd13bd83be67; XSRF-TOKEN=542c7005-309c-4f50-8a1d-d6c74afe8260",
        "x-forwarded-prefix": "/resource",
        "x-forwarded-host": "localhost:8080"
      },
      "response": {
        "Content-Type": "application/json;charset=UTF-8",
        "status": "200"
      }
    },
  }
},
{
  "timestamp": 1420558200232,
  "info": {
    "method": "GET",
    "path": "/resource/",
    "headers": {
      "request": {
        "host": "localhost:8080",
        "accept": "application/json, text/plain, */*",
        "x-xsrf-token": "542c7005-309c-4f50-8a1d-d6c74afe8260",
        "cookie": "SESSION=c18846b5-f805-4679-9820-cd13bd83be67; XSRF-TOKEN=542c7005-309c-4f50-8a1d-d6c74afe8260"
      },
      "response": {
        "Content-Type": "application/json;charset=UTF-8",
        "status": "200"
      }
    }
  }
},</code></pre>
</div>
</div>
<div class="paragraph">
<p>第二个条目是客户端到“ / resource”上的网关的请求，您可以看到cookie（由浏览器添加）和CSRF标头（由Angular添加，如<a href="second">第二部分所述</a> ）。第一个条目具有<code>remote: true</code> ，这意味着它正在跟踪对资源服务器的调用。您可以看到它已发送到uri路径“ /”，并且可以看到（至关重要地）cookie和CSRF标头也已发送。如果没有Spring Session，这些标头对资源服务器将毫无意义，但是我们对其进行设置的方式现在可以使用这些标头来重新构造具有身份验证和CSRF令牌数据的会话。因此，该请求被允许，我们可以开展业务！</p>
</div>
</div>
<div class="sect2">
<h3 id="_conclusion_3">结论</h3>
<div class="paragraph">
<p>在本节中，我们讨论了很多内容，但是我们到达了一个非常不错的地方，我们的两台服务器中的样板代码数量很少，它们都非常安全，并且不会损害用户体验。仅此一个原因便是使用API网关模式的原因，但实际上我们只是摸索了可能用于此目的的表面（Netflix <a href="https://github.com/Netflix/zuul/wiki/How-We-Use-Zuul-At-Netflix">在很多方面都</a>使用了它）。在<a href="https://projects.spring.io/spring-cloud/">Spring Cloud</a>上阅读有关更多信息，以了解如何轻松地向网关添加更多功能。在<a href="#_sso_with_oauth2_angular_js_and_spring_security_part_v">下一节</a>在这个系列将通过提取认证责任到一个单独的服务器（单点登录模式）扩展了应用程序的架构位。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sso_with_oauth2_angular_js_and_spring_security_part_v">使用OAuth2单点登录</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在本节中，我们继续<a href="#_the_api_gateway_pattern_angular_js_and_spring_security_part_iv">讨论</a>如何在“单页应用程序”中将<a href="https://projects.spring.io/spring-security">Spring Security</a>与<a href="https://angular.io">Angular</a>一起使用。在这里，我们展示了如何结合使用<a href="https://projects.spring.io/spring-security-oauth/">Spring Security OAuth</a>和<a href="https://projects.spring.io/spring-cloud/">Spring Cloud</a>来扩展我们的API网关以执行单一登录和OAuth2令牌身份验证以后端资源。这是本系列文章的第五部分，您可以了解应用程序的基本构建模块，也可以通过阅读<a href="#_spring_and_angular_js_a_secure_single_page_application">第一部分</a>从头开始构建它，或者直接进入<a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/tree/master/oauth2">Github中</a>的<a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/tree/master/oauth2">源代码</a> 。在上<a href="#_the_api_gateway_pattern_angular_js_and_spring_security_part_iv">一节中，</a>我们构建了一个小型分布式应用程序，该应用程序使用<a href="https://github.com/spring-projects/spring-session/">Spring Session</a>认证后端资源，并使用<a href="https://projects.spring.io/spring-cloud/">Spring Cloud</a>在UI服务器中实现嵌入式API网关。在本节中，我们将身份验证职责提取到单独的服务器，以使我们的UI服务器成为授权服务器中潜在的许多Single Sign On应用程序中的第一个。在企业和社交创业公司中，这是当今许多应用程序中的常见模式。我们将使用OAuth2服务器作为身份验证器，以便我们也可以使用它为后端资源服务器授予令牌。Spring Cloud将自动将访问令牌中继到我们的后端，并使我们能够进一步简化UI和资源服务器的实现。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>提醒：如果您正在使用示例应用程序来完成本节，请确保清除浏览器的cookie和HTTP Basic凭据缓存。在Chrome中，对单个服务器执行此操作的最佳方法是打开一个新的隐身窗口。</p>
</div>
</blockquote>
</div>
<div class="sect2">
<h3 id="_creating_an_oauth2_authorization_server">创建OAuth2授权服务器</h3>
<div class="paragraph">
<p>我们的第一步是创建一个新服务器来处理身份验证和令牌管理。按照<a href="#_spring_and_angular_js_a_secure_single_page_application">第一部分中</a>的步骤，我们可以从<a href="https://start.spring.io">Spring Boot Initializr</a>开始。例如在类似UN * X的系统上使用curl：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ curl https://start.spring.io/starter.tgz -d style=web \
-d style=security -d name=authserver | tar -xzvf -</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，您可以将该项目（默认情况下是普通的Maven Java项目）导入您喜欢的IDE中，或者仅在命令行上使用文件和“ mvn”。</p>
</div>
<div class="sect3">
<h4 id="_adding_the_oauth2_dependencies">添加OAuth2依赖项</h4>
<div class="paragraph">
<p>我们需要添加<a href="https://projects.spring.io/spring-security-oauth">Spring OAuth</a>依赖项，因此在我们的<a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/blob/master/oauth2/authserver/pom.xml">POM中</a>添加：</p>
</div>
<div class="listingblock">
<div class="title">pom.xml</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.security.oauth&lt;/groupId&gt;
  &lt;artifactId&gt;spring-security-oauth2&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>授权服务器非常容易实现。最低版本如下所示：</p>
</div>
<div class="listingblock">
<div class="title">AuthserverApplication.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@EnableAuthorizationServer
public class AuthserverApplication extends WebMvcConfigurerAdapter {

  public static void main(String[] args) {
    SpringApplication.run(AuthserverApplication.class, args);
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们只需要再做1件事（添加<code>@EnableAuthorizationServer</code> ）：</p>
</div>
<div class="listingblock">
<div class="title">application.properties</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-properties" data-lang="properties">---
...
security.oauth2.client.clientId: acme
security.oauth2.client.clientSecret: acmesecret
security.oauth2.client.authorized-grant-types: authorization_code,refresh_token,password
security.oauth2.client.scope: openid
---</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将使用秘密和一些授权的授权类型（包括“ authorization_code”）注册客户端“ acme”。</p>
</div>
<div class="paragraph">
<p>现在，让它在端口9999上运行，并使用可预测的密码进行测试：</p>
</div>
<div class="listingblock">
<div class="title">application.properties</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-properties" data-lang="properties">server.port=9999
security.user.password=password
server.contextPath=/uaa
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们还设置了上下文路径，以使其不使用默认值（“ /”），因为否则，您可以将本地主机上其他服务器的Cookie发送到错误的服务器。因此，使服务器运行，我们可以确保其正常工作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ mvn spring-boot:run</code></pre>
</div>
</div>
<div class="paragraph">
<p>或在您的IDE中启动<code>main()</code>方法。</p>
</div>
</div>
<div class="sect3">
<h4 id="_testing_the_authorization_server">测试授权服务器</h4>
<div class="paragraph">
<p>我们的服务器使用的是Spring Boot的默认安全设置，因此像<a href="#_spring_and_angular_js_a_secure_single_page_application">第I部分中</a>的服务器一样，它将受到HTTP Basic身份验证的保护。要启动<a href="https://tools.ietf.org/html/rfc6749#section-1.3.1">授权代码令牌授予，</a>您可以访问授权端点，例如，访问<a href="http://localhost:9999/uaa/oauth/authorize?response_type=code&client_id=acme&redirect_uri=http://example.com">http：// localhost：9999 / uaa / oauth / authorize？response_type = code＆client_id = acme＆redirect_uri = http：//example.com</a>即可，重定向到附带授权码的example.com，例如<a href="http://example.com/?code=jYWioI">http://example.com/?code=jYWioI</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">出于此示例应用程序的目的，我们创建了一个没有注册重定向的客户端“ acme”，这使我们能够获得example.com的重定向。在生产应用程序中，您应始终注册重定向（并使用HTTPS）。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>可以使用令牌端点上的“ acme”客户端凭据将代码交换为访问令牌：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ curl acme:<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="442527292137212736213004282b2725282c2b3730">[email&#160;protected]</a>:9999/uaa/oauth/token  \
-d grant_type=authorization_code -d client_id=acme     \
-d redirect_uri=http://example.com -d code=jYWioI
{"access_token":"2219199c-966e-4466-8b7e-12bb9038c9bb","token_type":"bearer","refresh_token":"d193caf4-5643-4988-9a4a-1c03c9d657aa","expires_in":43199,"scope":"openid"}</code></pre>
</div>
</div>
<div class="paragraph">
<p>访问令牌是UUID（“ 2219199c…”），由服务器中的内存中令牌存储支持。我们还获得了刷新令牌，当当前令牌过期时，我们可以使用它来获取新的访问令牌。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">因为我们允许“ acme”客户端获得“密码”授予，所以我们还可以使用curl和用户凭据（而不是授权码）直接从令牌端点获取令牌。这不适用于基于浏览器的客户端，但对测试很有用。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>如果您点击上面的链接，您将会看到Spring OAuth提供的whitelabel UI。首先，我们将使用它，稍后我们可以像在<a href="#_the_login_page_angular_js_and_spring_security_part_ii">第二部分</a>中对自包含服务器所做的那样来完善它。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="changing-the-resource-server">更改资源服务器</h3>
<div class="paragraph">
<p>如果我们继续<a href="#_the_api_gateway_pattern_angular_js_and_spring_security_part_iv">第IV部分</a> ，我们的资源服务器将使用<a href="https://github.com/spring-projects/spring-session/">Spring Session</a>进行身份验证，因此我们可以将其删除并用Spring OAuth代替。我们还需要删除Spring Session和Redis依赖项，因此请替换为：</p>
</div>
<div class="listingblock">
<div class="title">pom.xml</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;
  &lt;artifactId&gt;spring-session&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>有了这个：</p>
</div>
<div class="listingblock">
<div class="title">pom.xml</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.security.oauth&lt;/groupId&gt;
  &lt;artifactId&gt;spring-security-oauth2&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后从<a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/blob/master/vanilla-oauth2/resource/src/main/java/demo/ResourceApplication.java">主应用程序类中</a>删除会话<code>Filter</code> ，将其替换为方便的<code>@EnableResourceServer</code>annotation（来自Spring Security OAuth2）：</p>
</div>
<div class="listingblock">
<div class="title">ResourceApplication.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@RestController
@EnableResourceServer
class ResourceApplication {

  @RequestMapping("/")
  public Message home() {
    return new Message("Hello World");
  }

  public static void main(String[] args) {
    SpringApplication.run(ResourceApplication.class, args);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>做出这一更改后，应用程序就可以挑战访问令牌而不是HTTP Basic，但是我们需要对配置进行更改才能真正完成该过程。我们将添加少量的外部配置（在“ application.properties”中），以允许资源服务器解码所给的令牌并验证用户身份：</p>
</div>
<div class="listingblock">
<div class="title">application.properties</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-properties" data-lang="properties">...
security.oauth2.resource.userInfoUri: http://localhost:9999/uaa/user</code></pre>
</div>
</div>
<div class="paragraph">
<p>这告诉服务器它可以使用令牌来访问“ /用户”端点，并使用该令牌来派生身份验证信息（有点类似于Facebook API中的<a href="https://developers.facebook.com/docs/graph-api/reference/v2.2/user/?locale=en_GB">“ / me”端点</a> ）。有效地，它为资源服务器提供了一种解码令牌的方法，如Spring OAuth2中的<code>ResourceServerTokenServices</code>接口所表示的。</p>
</div>
<div class="paragraph">
<p>运行该应用程序，并使用命令行客户端访问主页：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ curl -v localhost:9000
&gt; GET / HTTP/1.1
&gt; User-Agent: curl/7.35.0
&gt; Host: localhost:9000
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 401 Unauthorized
...
&lt; WWW-Authenticate: Bearer realm="null", error="unauthorized", error_description="An Authentication object was not found in the SecurityContext"
&lt; Content-Type: application/json;charset=UTF-8
{"error":"unauthorized","error_description":"An Authentication object was not found in the SecurityContext"}</code></pre>
</div>
</div>
<div class="paragraph">
<p>并且您将看到带有“ WWW-Authenticate”标头的401，指示它需要承载令牌。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">到目前为止， <code>userInfoUri</code>并不是将资源服务器与令牌解码方式挂钩的唯一方法。实际上，它是最低的公分母（不是规范的一部分），但是通常可以从OAuth2提供程序（例如Facebook，Cloud Foundry，Github）获得，也可以使用其他选择。例如，您可以在令牌本身中编码用户身份验证（例如，使用<a href="http://jwt.io/">JWT</a> ），或使用共享的后端存储。CloudFoundry中还有一个<code>/token_info</code>终结点，该终结点提供的信息比用户信息终结点更详细，但需要更彻底的身份验证。不同的选择（自然地）会提供不同的好处和取舍，但是对这些选择的完整讨论不在本节的范围之内。</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_implementing_the_user_endpoint">实施用户端点</h3>
<div class="paragraph">
<p>在授权服务器上，我们可以轻松地添加该端点</p>
</div>
<div class="listingblock">
<div class="title">AuthserverApplication.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@RestController
@EnableAuthorizationServer
@EnableResourceServer
public class AuthserverApplication {

  @RequestMapping("/user")
  public Principal user(Principal user) {
    return user;
  }

  ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们在<a href="#_the_login_page_angular_js_and_spring_security_part_ii">第II部分中</a>添加了与UI服务器相同的<code>@RequestMapping</code>以及Spring OAuth中的<code>@EnableResourceServer</code>annotation，该annotation默认情况下可保护授权服务器中除“ / oauth / *”端点之外的所有内容。</p>
</div>
<div class="paragraph">
<p>有了该端点，我们可以测试它和问候资源，因为它们现在都接受由授权服务器创建的承载令牌：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ TOKEN=2219199c-966e-4466-8b7e-12bb9038c9bb
$ curl -H "Authorization: Bearer $TOKEN" localhost:9000
{"id":"03af8be3-2fc3-4d75-acf7-c484d9cf32b1","content":"Hello World"}
$ curl -H "Authorization: Bearer $TOKEN" localhost:9999/uaa/user
{"details":...,"principal":{"username":"user",...},"name":"user"}</code></pre>
</div>
</div>
<div class="paragraph">
<p>（用从您自己的授权服务器获取的访问令牌的值替换为自己可以使用的令牌）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_ui_server">UI服务器</h3>
<div class="paragraph">
<p>我们需要完成的该应用程序的最后一部分是UI服务器，提取身份验证部分并委托给授权服务器。因此，与<a href="#changing-the-resource-server">资源服务器一样</a> ，我们首先需要删除Spring Session和Redis依赖项并将其替换为Spring OAuth2。因为我们在UI层中使用Zuul，所以实际上实际上是使用<code>spring-cloud-starter-oauth2</code>而不是<code>spring-security-oauth2</code> （这为通过代理中继令牌设置了一些自动配置）。</p>
</div>
<div class="paragraph">
<p>完成此操作后，我们还可以删除会话过滤器和“ / user”端点，并设置应用程序以重定向到授权服务器（使用<code>@EnableOAuth2Sso</code>annotation）：</p>
</div>
<div class="listingblock">
<div class="title">UiApplication.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@EnableZuulProxy
@EnableOAuth2Sso
public class UiApplication {

  public static void main(String[] args) {
    SpringApplication.run(UiApplication.class, args);
  }

...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>回顾<a href="#_the_api_gateway_pattern_angular_js_and_spring_security_part_iv">第四部分</a> ，UI服务器借助于<code>@EnableZuulProxy</code>充当API网关，我们可以在YAML中声明路由映射。因此，可以将“ /用户”端点代理到授权服务器：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-yaml" data-lang="yaml">zuul:
  routes:
    resource:
      path: /resource/**
      url: http://localhost:9000
    user:
      path: /user/**
      url: http://localhost:9999/uaa/user</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，我们需要将应用程序更改为<code>WebSecurityConfigurerAdapter</code>因为现在它将用于修改<code>@EnableOAuth2Sso</code>设置的SSO过滤器链中的默认值：</p>
</div>
<div class="listingblock">
<div class="title">SecurityConfiguration.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@EnableZuulProxy
@EnableOAuth2Sso
public class UiApplication extends WebSecurityConfigurerAdapter {
    @Override
    public void configure(HttpSecurity http) throws Exception {
      http
          .logout().logoutSuccessUrl("/").and()
          .authorizeRequests().antMatchers("/index.html", "/app.html", "/")
          .permitAll().anyRequest().authenticated().and()
          .csrf()
            .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse());
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>主要的变化（除了基类名称之外）是匹配器进入了自己的方法，并且不再需要<code>formLogin()</code>了。显式的<code>logout()</code>配置显式添加了未受保护的成功URL，因此对<code>/logout</code>的XHR请求将成功返回。</p>
</div>
<div class="paragraph">
<p><code>@EnableOAuth2Sso</code>annotation还具有一些必需的外部配置属性，以便能够与正确的授权服务器联系并进行身份验证。因此，我们需要在这个<code>application.yml</code> ：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-yaml" data-lang="yaml">security:
  ...
  oauth2:
    client:
      accessTokenUri: http://localhost:9999/uaa/oauth/token
      userAuthorizationUri: http://localhost:9999/uaa/oauth/authorize
      clientId: acme
      clientSecret: acmesecret
    resource:
      userInfoUri: http://localhost:9999/uaa/user</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中大部分与OAuth2客户端（“ acme”）和授权服务器位置有关。还有一个<code>userInfoUri</code> （就像在资源服务器中一样），以便可以在UI应用程序本身中对用户进行身份验证。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">如果希望UI应用程序能够自动刷新过期的访问令牌，则必须将<code>OAuth2RestOperations</code>注入到执行中继的Zuul过滤器中。您可以通过仅创建该类型的Bean来做到这一点（有关详细信息，请检查<code>OAuth2TokenRelayFilter</code> ）：</td>
</tr>
</tbody>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Bean
protected OAuth2RestTemplate OAuth2RestTemplate(
    OAuth2ProtectedResourceDetails resource, OAuth2ClientContext context) {
  return new OAuth2RestTemplate(resource, context);
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_in_the_client">在客户中</h4>
<div class="paragraph">
<p>我们仍然需要对前端UI应用程序进行一些调整，以触发重定向到授权服务器。在这个简单的演示中，我们可以将Angular应用程序剥离到其基本要点，以便您可以更清楚地了解正在发生的事情。因此，我们暂时不再使用表单或路线，而是回到单个Angular组件：</p>
</div>
<div class="listingblock">
<div class="title">app.component.ts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">import { Component } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import 'rxjs/add/operator/finally';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {

  title = 'Demo';
  authenticated = false;
  greeting = {};

  constructor(private http: HttpClient) {
    this.authenticate();
  }

  authenticate() {

    this.http.get('user').subscribe(response =&gt; {
        if (response['name']) {
            this.authenticated = true;
            this.http.get('resource').subscribe(data =&gt; this.greeting = data);
        } else {
            this.authenticated = false;
        }
    }, () =&gt; { this.authenticated = false; });

  }
  logout() {
      this.http.post('logout', {}).finally(() =&gt; {
          this.authenticated = false;
      }).subscribe();
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>AppComponent</code>处理所有事情，获取用户详细信息，如果成功，则获取问候语。它还提供<code>logout</code>功能。</p>
</div>
<div class="paragraph">
<p>现在我们需要为这个新组件创建模板：</p>
</div>
<div class="paragraph">
<p>app.component.html</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;div class="container"&gt;
  &lt;ul class="nav nav-pills"&gt;
    &lt;li&gt;&lt;a&gt;Home&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="login"&gt;Login&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a (click)="logout()"&gt;Logout&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;
&lt;div class="container"&gt;
&lt;h1&gt;Greeting&lt;/h1&gt;
&lt;div [hidden]="!authenticated"&gt;
	&lt;p&gt;The ID is {{greeting.id}}&lt;/p&gt;
	&lt;p&gt;The content is {{greeting.content}}&lt;/p&gt;
&lt;/div&gt;
&lt;div [hidden]="authenticated"&gt;
	&lt;p&gt;Login to see your greeting&lt;/p&gt;
&lt;/div&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>并将其包含在首页中<code><app-root/></code> 。</p>
</div>
<div class="paragraph">
<p>请注意，“登录”的导航链接是带有<code>href</code> （不是Angular路线）的常规链接。Spring Security处理该端点的“ / login”端点，如果用户未通过身份验证，将导致重定向到授权服务器。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_how_does_it_work_3">它是如何工作的？</h3>
<div class="paragraph">
<p>现在一起运行所有服务器，并在浏览器中通过<a href="http://localhost:8080">http://localhost:8080</a>访问UI。单击“登录”链接，您将被重定向到授权服务器进行身份验证（HTTP Basic弹出窗口）并批准令牌授予（whitelabel HTML），然后使用从OAuth2获取的问候语重定向到UI中的主页。资源服务器使用与我们验证UI相同的令牌。</p>
</div>
<div class="paragraph">
<p>如果您使用某些开发人员工具，则可以在浏览器中看到浏览器与后端之间的交互（通常F12会打开它，默认情况下在Chrome中运行，可能需要Firefox中的插件）。总结如下：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">动词</th>
<th class="tableblock halign-left valign-top">路径</th>
<th class="tableblock halign-left valign-top">状态</th>
<th class="tableblock halign-left valign-top">响应</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">index.html</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/*.js</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">角度资产</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/用户</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">302</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">重定向到登录页面</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/登录</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">302</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">重定向到身份验证服务器</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">（uaa）/ oauth / authorize</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">401</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">（忽略）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/登录</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">302</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">重定向到身份验证服务器</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">（uaa）/ oauth / authorize</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HTTP基本身份验证发生在此处</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">开机自检</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">（uaa）/ oauth / authorize</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">302</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用户批准授予，重定向到/ login</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/登录</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">302</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">重定向到首页</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/用户</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">（代理）JSON身份验证用户</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/app.html</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">主页的HTML部分</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/资源</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">（代理）JSON问候</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>带有（uaa）前缀的请求将发送到授权服务器。标记为“忽略”的响应是Angular在XHR调用中收到的响应，并且由于我们没有处理这些数据，因此它们被丢弃在地板上。在“ / user”资源的情况下，我们确实会寻找经过身份验证的用户，但是由于在第一次调用中不存在经过身份验证的用户，因此该响应将被丢弃。</p>
</div>
<div class="paragraph">
<p>在UI的“ / trace”端点（向下滚动至底部）中，您将看到对<code>remote:true</code>代理“ / user”和“ / resource”的后端请求，其中包含<code>remote:true</code>和Bearer令牌而不是cookie（因为它会在<a href="#_the_api_gateway_pattern_angular_js_and_spring_security_part_iv">第IV部分</a>中使用）进行身份验证。Spring Cloud Security已为我们解决了这一问题：通过认识到我们拥有<code>@EnableOAuth2Sso</code>和<code>@EnableZuulProxy</code>它发现（默认情况下）我们希望将令牌中继到代理后端。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">与前面的部分一样，尝试对“ / trace”使用其他浏览器，以免进行身份验证交叉（例如，如果您使用Chrome来测试UI，则使用Firefox）。</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_the_logout_experience">登出体验</h3>
<div class="paragraph">
<p>如果单击“注销”链接，您将看到主页更改（不再显示问候语），因此不再通过UI服务器对用户进行身份验证。单击后退的“登陆”，虽然和你其实<em>并不</em>需要通过在授权服务器的认证和审批周期要回去（因为你已经不是已注销）。关于这是否是理想的用户体验，这是一个非常棘手的问题（Single Sign Out： <a href="https://www.sciencedirect.com/science/article/pii/S2214212614000179">Science Direct文章</a>和<a href="https://wiki.shibboleth.net/confluence/display/SHIB2/SLOIssues">Shibboleth docs</a> ），将有不同的意见。理想的用户体验在技术上可能不可行，并且有时您还必须怀疑用户确实想要他们想要的内容。 “我要'注销'注销我”听起来很简单，但显而易见的回答是，“注销了什么？您是否要从此SSO服务器控制的<em>所有</em>系统中注销，还是只单击单击“注销”链接的系统？“如果您有兴趣，那么可以在本教程<a href="#_oauth2_logout_angular_js_and_spring_security_part_ix">的后面部分</a>进行更深入的讨论。</p>
</div>
</div>
<div class="sect2">
<h3 id="_conclusion_4">结论</h3>
<div class="paragraph">
<p>这是我们通过Spring Security和Angular堆栈进行的简短浏览的结尾将近结束。现在，我们有了一个不错的架构，在三个独立的组件（UI / API网关，资源服务器和授权服务器/令牌授予者）中明确职责。现在，所有层中的非业务代码数量已降至最低，并且很容易看到使用更多业务逻辑在何处扩展和改进实现。下一步将整理授权服务器中的UI，并可能添加更多测试，包括JavaScript客户端上的测试。另一个有趣的任务是提取所有样板代码并将其放入一个库（例如“ spring-security-angular”）中，该库包含Spring Security和Spring Session自动配置以及Angular中用于导航控制器的一些webjar资源。阅读了本系列的各个部分后，任何希望学习Angular或Spring Security的内部工作原理的人都可能会感到失望，但是如果您想了解它们如何能够很好地协同工作以及如何进行一些配置，很长的路要走，那么希望您会有一个很好的经验。<a href="https://projects.spring.io/spring-cloud/">Spring Cloud</a>是新的，这些示例在编写时需要快照，但是有可用的候选版本以及即将发布的GA版本，因此请检查并<a href="https://github.com/spring-cloud">通过Github</a>或<a href="https://gitter.im/spring-cloud/spring-cloud">gitter.im</a>发送一些反馈。</p>
</div>
<div class="paragraph">
<p>本系列的<a href="#_multiple_ui_applications_and_a_gateway_single_page_application_with_spring_and_angular_js_part_vi">下一部分</a>将讨论访问决策（除了身份验证之外），并将在同一代理后面使用多个UI应用程序。</p>
</div>
</div>
<div class="sect2">
<h3 id="_addendum_bootstrap_ui_and_jwt_tokens_for_the_authorization_server">附录：授权服务器的Bootstrap UI和JWT令牌</h3>
<div class="paragraph">
<p>您可以<a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/tree/master/oauth2">在Github</a>的<a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/tree/master/oauth2">源代码中</a>找到该应用程序的另一个版本，该版本具有漂亮的登录页面和用户批准页面，其实现方式与我们在<a href="#_the_login_page_angular_js_and_spring_security_part_ii">第二部分中</a>所做的相似。它还使用<a href="http://jwt.io/">JWT</a>来对令牌进行编码，因此资源服务器可以使用令牌中的足够多的信息来进行简单的身份验证，而不是使用“ / user”端点。浏览器客户端仍通过UI服务器使用它，以便可以确定用户是否已通过身份验证（与真实应用程序中对资源服务器的可能调用次数相比，它不需要非常频繁地进行身份验证）。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_multiple_ui_applications_and_a_gateway_single_page_application_with_spring_and_angular_js_part_vi">多个UI应用程序和一个网关</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在本节中，我们继续<a href="#_sso_with_oauth2_angular_js_and_spring_security_part_v">讨论</a>如何在“单页应用程序”中将<a href="https://projects.spring.io/spring-security">Spring Security</a>与<a href="https://angular.io">Angular</a>一起使用。在这里，我们展示了如何将<a href="https://projects.spring.io/spring-security-oauth/">Spring Session</a>与<a href="https://projects.spring.io/spring-cloud/">Spring Cloud</a>结合使用，以结合我们在第II部分和第IV部分中构建的系统的功能，并最终结束构建3个职责完全不同的单页应用程序。目的是构建一个网关（类似于<a href="#_the_api_gateway_pattern_angular_js_and_spring_security_part_iv">第IV部分</a> ），该网关不仅用于API资源，还可以从后端服务器加载UI。通过使用网关将身份验证传递到后端，我们简化了<a href="#_the_login_page_angular_js_and_spring_security_part_ii">第二部分</a>的令牌争用位。然后，我们扩展系统以显示如何在后端中做出本地的，细粒度的访问决策，同时仍在网关上控制身份和认证。通常，这是用于构建分布式系统的非常强大的模型，在引入所构建代码的功能时，我们可以探索许多好处。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>提醒：如果您正在使用示例应用程序来完成本节，请确保清除浏览器的cookie和HTTP Basic凭据缓存。在Chrome中，最好的方法是打开一个新的隐身窗口。</p>
</div>
</blockquote>
</div>
<div class="sect2">
<h3 id="_target_architecture">目标架构</h3>
<div class="paragraph">
<p>这是我们将要开始构建的基本系统的图片：</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://raw.githubusercontent.com/spring-guides/tut-spring-security-and-angular-js/master/double/double-simple.png" alt="系统组成"></span></p>
</div>
<div class="paragraph">
<p>像本系列中的其他示例应用程序一样，它具有一个UI（HTML和JavaScript）和一个资源服务器。像<a href="#_the_api_gateway_pattern_angular_js_and_spring_security_part_iv">第四节中</a>的示例一样，它具有一个网关，但是在这里它是独立的，而不是UI的一部分。 UI有效地成为了后端的一部分，为我们提供了更多选择来重新配置和重新实现功能，并且还带来了我们将看到的其他好处。</p>
</div>
<div class="paragraph">
<p>浏览器可以访问网关的所有内容，而不必了解后端的体系结构（从根本上讲，它不知道有后端）。浏览器在此Gateway中要做的一件事就是身份验证，例如，它像<a href="#_the_login_page_angular_js_and_spring_security_part_ii">第II节中</a>一样发送用户名和密码，并获取cookie作为回报。在随后的请求中，它会自动显示cookie，然后网关会将其传递到后端。无需在客户端上编写任何代码即可启用Cookie。后端使用cookie进行身份验证，并且由于所有组件共享一个会话，因此它们共享有关用户的相同信息。将其与<a href="#_sso_with_oauth2_angular_js_and_spring_security_part_v">第V节进行</a>对比，在<a href="#_sso_with_oauth2_angular_js_and_spring_security_part_v">第V节</a>中，必须将Cookie转换为网关中的访问令牌，然后所有后端组件都必须对访问令牌进行独立解码。</p>
</div>
<div class="paragraph">
<p>与<a href="#_the_api_gateway_pattern_angular_js_and_spring_security_part_iv">第四节中一样</a> ，网关简化了客户端和服务器之间的交互，并且它呈现了一个很小的，定义明确的表面来处理安全性。例如，我们不必担心<a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing">跨源资源共享</a> ，这很容易解决，因为它很容易出错。</p>
</div>
<div class="paragraph">
<p>我们将要构建的完整项目的源代码在<a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/tree/master/double">此处的Github中</a> ，因此您可以克隆项目并直接从那里进行工作。该系统的最终状态还有一个额外的组件（“ double-admin”），因此暂时忽略它。</p>
</div>
</div>
<div class="sect2">
<h3 id="_building_the_backend">建立后端</h3>
<div class="paragraph">
<p>在这种体系结构中，后端与我们在<a href="#_the_resource_server_angular_js_and_spring_security_part_iii">第三节中</a>构建的<a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/tree/master/spring-session">“ spring-session”</a>示例非常相似，不同之<a href="#_the_resource_server_angular_js_and_spring_security_part_iii">处</a>在于它实际上不需要登录页面。到达这里想要的最简单的方法可能是从第III节中复制“资源”服务器，并从<a href="#_spring_and_angular_js_a_secure_single_page_application">第I节中</a>的<a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/tree/master/basic">“基本”</a>示例中获取UI。要从“基本” UI转到我们想要的UI，我们只需要添加几个依赖项（例如，当我们在第III节中首次使用<a href="https://github.com/spring-projects/spring-session/">Spring Session</a>时）：</p>
</div>
<div class="listingblock">
<div class="title">pom.xml</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;
  &lt;artifactId&gt;spring-session&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于现在是UI，因此不需要“ / resource”端点。完成后，您将拥有一个非常简单的Angular应用程序（与“基本”示例中的应用程序相同），该应用程序大大简化了有关其行为的测试和推理。</p>
</div>
<div class="paragraph">
<p>最后，我们希望该服务器作为后台运行，所以我们给它一个非默认端口上监听（在<code>application.properties</code> ）：</p>
</div>
<div class="listingblock">
<div class="title">application.properties</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-properties" data-lang="properties">server.port: 8081
security.sessions: NEVER</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果这是<em>整个</em>内容<code>application.properties</code>的内容，则该应用程序将是安全的，并且名为“ user”的用户可以使用随机密码来访问该应用程序，但该密码在启动时会打印在控制台上（日志级别为INFO）。“ security.sessions”设置意味着Spring Security将接受cookie作为身份验证令牌，但是除非它们已经存在，否则不会创建它们。</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_resource_server">资源服务器</h3>
<div class="paragraph">
<p>资源服务器很容易从我们现有的样本之一中生成。它与<a href="#_the_resource_server_angular_js_and_spring_security_part_iii">第III节中</a>的“ spring-session”资源服务器相同：只是一个“ / resource”端点，用于获取分布式会话数据的Spring Session。我们希望该服务器具有一个非默认端口以进行侦听，并且希望能够在会话中查找身份验证，因此我们需要这样做（在<code>application.properties</code> ）：</p>
</div>
<div class="listingblock">
<div class="title">application.properties</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-properties" data-lang="properties">server.port: 9000
security.sessions: NEVER</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将要发布对消息资源的更改，这是本教程的新功能。这意味着我们将在后端需要CSRF保护，并且我们需要做一些通常的技巧来使Spring Security与Angular很好地配合使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Override
protected void configure(HttpSecurity http) throws Exception {
	http.csrf()
			.csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您想看一眼，完整的示例<a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/tree/master/double/resource">在github中</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_gateway">门户</h3>
<div class="paragraph">
<p>对于网关的初始实现（可能可行的最简单的事情），我们可以仅使用一个空的Spring Boot Web应用程序并添加<code>@EnableZuulProxy</code>annotation。正如我们在<a href="#_spring_and_angular_js_a_secure_single_page_application">第一部分中</a>看到的，有几种方法可以做到这一点，一种方法是使用<a href="https://start.spring.io">Spring Initializr</a>生成框架项目。甚至更容易的是，使用<a href="https://cloud-start.spring.io">Spring Cloud Initializr</a>也是一样，只是用于<a href="https://cloud.spring.io">Spring Cloud</a>应用程序。使用与第一节相同的命令行操作顺序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ mkdir gateway &amp;&amp; cd gateway
$ curl https://cloud-start.spring.io/starter.tgz -d style=web \
  -d style=security -d style=cloud-zuul -d name=gateway \
  -d style=redis | tar -xzvf -</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，您可以将该项目（默认情况下是普通的Maven Java项目）导入您喜欢的IDE中，或者仅在命令行上使用文件和“ mvn”。如果您想从<a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/tree/master/double/gateway">github中找到</a>一个版本<a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/tree/master/double/gateway">，</a>那么它还有一些我们不需要的额外功能。</p>
</div>
<div class="paragraph">
<p>从空白的Initializr应用程序开始，我们添加Spring Session依赖项（如上面的UI）。网关是准备好运行，但它还不知道我们的后端服务，所以我们只设置了在其<code>application.yml</code> （从改名<code>application.properties</code>如果你没有卷曲事上）：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="prettyprint highlight"><code>zuul:
  sensitive-headers:
  routes:
    ui:
      url: http://localhost:8081
   resource:
      url: http://localhost:9000
security:
  user:
    password:
      password
  sessions: ALWAYS</code></pre>
</div>
</div>
<div class="paragraph">
<p>代理中有2条路由，每条路由都使用<code>sensitive-headers</code>属性将cookie传递给下游，UI和资源服务器各传递一条cookie，并且我们已经设置了默认密码和会话持久性策略（告诉Spring Security始终创建身份验证会话）。最后一点很重要，因为我们希望进行身份验证，因此需要在网关中管理会话。</p>
</div>
</div>
<div class="sect2">
<h3 id="_up_and_running">启动并运行</h3>
<div class="paragraph">
<p>现在，我们有三个组件，在三个端口上运行。如果将浏览器指向<a href="http://localhost:8080/ui/">http://localhost:8080/ui /</a> ，则应该遇到HTTP基本挑战，并且可以将身份验证为“用户/密码”（您在网关中的凭据），一旦执行此操作，您应该会看到通过代理服务器到资源服务器的后端调用在UI中打招呼。</p>
</div>
<div class="paragraph">
<p>如果您使用某些开发人员工具，则可以在浏览器中看到浏览器与后端之间的交互（通常F12会打开它，默认情况下在Chrome中运行，可能需要Firefox中的插件）。总结如下：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
<col style="width:25%">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">动词</th>
<th class="tableblock halign-left valign-top">路径</th>
<th class="tableblock halign-left valign-top">状态</th>
<th class="tableblock halign-left valign-top">响应</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/ ui /</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">401</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">浏览器提示进行身份验证</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/ ui /</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">index.html</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/ui/*.js</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">有角资产</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/ui/js/hello.js</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应用逻辑</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/ ui /用户</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">认证方式</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">得到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/资源/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JSON问候</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>您可能看不到401，因为浏览器将主页加载视为单个交互。所有请求都被代理（网关中没有内容，除了用于管理的Actuator端点之外）。</p>
</div>
<div class="paragraph">
<p>呼啦，行得通！您有两个后端服务器，其中一个是UI，每个服务器具有独立的功能并且可以隔离进行测试，并且它们与您控制并为其配置了身份验证的安全网关连接在一起。如果浏览器无法访问后端，则没关系（事实上，这可能是一个优势，因为它使您可以更好地控制物理安全性）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_adding_a_login_form">添加登录表单</h3>
<div class="paragraph">
<p>就像在<a href="#_spring_and_angular_js_a_secure_single_page_application">第一节</a>中的“基本”示例中一样，我们现在可以向网关添加登录表单，例如，通过复制<a href="#_the_login_page_angular_js_and_spring_security_part_ii">第二节中</a>的代码。当我们这样做时，我们还可以在网关中添加一些基本的导航元素，因此用户不必知道代理中UI后端的路径。因此，我们首先将静态资产从“单个” UI复制到网关，删除消息呈现并将登录表单插入我们的主页（在<code><app/></code>某处）：</p>
</div>
<div class="listingblock">
<div class="title">app.html</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;div class="container" [hidden]="authenticated"&gt;
	&lt;form role="form" (submit)="login()"&gt;
		&lt;div class="form-group"&gt;
			&lt;label for="username"&gt;Username:&lt;/label&gt; &lt;input type="text"
				class="form-control" id="username" name="username"
				[(ngModel)]="credentials.username" /&gt;
		&lt;/div&gt;
		&lt;div class="form-group"&gt;
			&lt;label for="password"&gt;Password:&lt;/label&gt; &lt;input type="password"
				class="form-control" id="password" name="password"
				[(ngModel)]="credentials.password" /&gt;
		&lt;/div&gt;
		&lt;button type="submit" class="btn btn-primary"&gt;Submit&lt;/button&gt;
	&lt;/form&gt;
&lt;/div&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>代替消息呈现，我们将有一个不错的大导航按钮：</p>
</div>
<div class="listingblock">
<div class="title">index.html</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;div class="container" [hidden]="!authenticated"&gt;
	&lt;a class="btn btn-primary" href="/ui/"&gt;Go To User Interface&lt;/a&gt;
&lt;/div&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您在github中查看示例，则它还有一个带有“注销”按钮的最小导航栏。这是屏幕截图中的登录表单：</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://raw.githubusercontent.com/spring-guides/tut-spring-security-and-angular-js/master/double/login.png" alt="登录页面"></span></p>
</div>
<div class="paragraph">
<p>为了支持登录表单，我们需要一些打字稿与实施的组件<code>login()</code>我们在声明的函数<code><form/></code></p><form></form> ，我们需要设置<code>authenticated</code>标志，以便主页根据用户是否通过身份验证而呈现不同的外观。例如：<p></p>
</div>
<div class="listingblock">
<div class="title">app.component.ts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">include::src/app/app.component.ts</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中<code>login()</code>函数的实现与<a href="#_the_login_page_angular_js_and_spring_security_part_ii">第二节</a>类似。</p>
</div>
<div class="paragraph">
<p>我们可以使用<code>self</code>来存储<code>authenticated</code>标志，因为在此简单应用程序中只有一个组件。</p>
</div>
<div class="paragraph">
<p>如果我们运行此增强的网关，则不必记住UI的URL，只需加载主页并单击链接即可。这是经过身份验证的用户的主页：</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://raw.githubusercontent.com/spring-guides/tut-spring-security-and-angular-js/master/double/home.png" alt="主页"></span></p>
</div>
</div>
<div class="sect2">
<h3 id="_granular_access_decisions_in_the_backend">后端中的细粒度访问决策</h3>
<div class="paragraph">
<p>到目前为止，我们的应用程序在功能上与<a href="#_the_resource_server_angular_js_and_spring_security_part_iii">第III</a> <a href="#_the_api_gateway_pattern_angular_js_and_spring_security_part_iv">节</a>或<a href="#_the_api_gateway_pattern_angular_js_and_spring_security_part_iv">第IV</a> <a href="#_the_resource_server_angular_js_and_spring_security_part_iii">节中的</a>应用程序非常相似，但是具有一个额外的专用网关。额外层的优势可能尚不明显，但是我们可以通过扩展系统来强调它。假设我们要使用该网关公开另一个后端UI，以便用户“管理”主UI中的内容，并且我们希望将具有特定角色的用户的访问权限限制在此范围内。因此，我们将在代理后面添加一个“ Admin”应用程序，系统将如下所示：</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://raw.githubusercontent.com/spring-guides/tut-spring-security-and-angular-js/master/double/double-components.png" alt="系统组成"></span></p>
</div>
<div class="paragraph">
<p>在<code>application.yml</code>的网关中有一个新组件（管理员）和一条新路由：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-yaml" data-lang="yaml">zuul:
  sensitive-headers:
  routes:
    ui:
      url: http://localhost:8081
    admin:
      url: http://localhost:8082
    resource:
      url: http://localhost:9000</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的框图中的“网关”框（绿色字母）中指出了现有用户界面以“用户”角色提供给用户的事实，以及进入管理应用程序需要“管理员”角色的事实。可以在网关中应用“ ADMIN”角色的访问决策，在这种情况下，它可以显示在<code>WebSecurityConfigurerAdapter</code> ，也可以应用在Admin应用程序本身中（我们将在下面看到如何做）。</p>
</div>
<div class="paragraph">
<p>因此，首先，创建一个新的Spring Boot应用程序，或复制UI并对其进行编辑。除了名称开头，您无需在UI应用程序中进行太多更改。完成的应用程序在<a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/tree/master/double/admin">此处的Github中</a> 。</p>
</div>
<div class="paragraph">
<p>假设在Admin应用程序中，我们想区分“ READER”和“ WRITER”角色，以便我们允许（例如）审核员用户查看主要admin用户所做的更改。这是一个精细的访问决策，其中该规则仅在后端应用程序中是已知的，并且应该仅在该应用程序中是已知的。在网关中，我们只需要确保我们的用户帐户具有所需的角色，并且此信息可用，但是网关不需要知道如何解释它。在网关中，我们创建用户帐户以使示例应用程序保持独立：</p>
</div>
<div class="listingblock">
<div class="title">SecurityConfiguration.class</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">@Configuration
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {

  @Autowired
  public void globalUserDetails(AuthenticationManagerBuilder auth) throws Exception {
    auth.inMemoryAuthentication()
      .withUser("user").password("password").roles("USER")
    .and()
      .withUser("admin").password("admin").roles("USER", "ADMIN", "READER", "WRITER")
    .and()
      .withUser("audit").password("audit").roles("USER", "ADMIN", "READER");
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中“管理员”用户已通过3个新角色（“ ADMIN”，“ READER”和“ WRITER”）得到了增强，并且我们还添加了具有“ ADMIN”访问权限的“ audit”用户，但未添加“ WRITER”访问权限。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-tip" title="小费"></i> </td>
<td class="content">在生产系统中，用户帐户数据将在后端数据库（很可能是目录服务）中进行管理，而不是在Spring Configuration中进行硬编码。连接到这样的数据库的示例应用程序很容易在Internet上找到，例如在<a href="https://github.com/spring-projects/spring-security/tree/master/samples">Spring Security Samples中</a> 。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>访问决策在Admin应用程序中。对于“ ADMIN”角色（此后端在全球范围内是必需的），我们在Spring Security中执行此操作：</p>
</div>
<div class="listingblock">
<div class="title">SecurityConfiguration.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Configuration
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {

@Override
  protected void configure(HttpSecurity http) throws Exception {
    http
    ...
      .authorizeRequests()
        .antMatchers("/index.html", "/").permitAll()
        .antMatchers("/admin/**").hasRole("ADMIN")
        .anyRequest().authenticated()
    ...
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于“ READER”和“ WRITER”角色，应用程序本身是分开的，并且由于应用程序是用JavaScript实现的，因此我们需要在其中做出访问决策。一种方法是通过路由器在其中嵌入一个带有计算视图的主页：</p>
</div>
<div class="listingblock">
<div class="title">app.component.html</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;div class="container"&gt;
	&lt;h1&gt;Admin&lt;/h1&gt;
	&lt;router-outlet&gt;&lt;/router-outlet&gt;
&lt;/div&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在组件加载时计算路线：</p>
</div>
<div class="listingblock">
<div class="title">app.component.ts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {

  user: {};

  constructor(private app: AppService, private http: HttpClient, private router: Router) {
    app.authenticate(response =&gt; {
      this.user = response;
      this.message();
    });
  }

  logout() {
    this.http.post('logout', {}).subscribe(function() {
        this.app.authenticated = false;
        this.router.navigateByUrl('/login');
    });
  }

  message() {
    if (!this.app.authenticated) {
      this.router.navigate(['/unauthenticated']);
    } else {
      if (this.app.writer) {
        this.router.navigate(['/write']);
      } else {
        this.router.navigate(['/read']);
      }
    }
  }
...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>应用程序要做的第一件事是查看用户是否已通过身份验证，并通过查看用户数据来计算路由。路由在主模块中声明：</p>
</div>
<div class="listingblock">
<div class="title">app.module.ts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">const routes: Routes = [
  { path: '', pathMatch: 'full', redirectTo: 'read'},
  { path: 'read', component: ReadComponent},
  { path: 'write', component: WriteComponent},
  { path: 'unauthenticated', component: UnauthenticatedComponent},
  { path: 'changes', component: ChangesComponent}
];</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些组件中的每个组件（每个路由一个组件）都必须分别实现。这里以<code>ReadComponent</code>为例：</p>
</div>
<div class="listingblock">
<div class="title">read.component.ts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">import { Component } from '@angular/core';
import { HttpClient } from '@angular/common/http';

@Component({
  templateUrl: './read.component.html'
})
export class ReadComponent {

  greeting = {};

  constructor(private http: HttpClient) {
    http.get('/resource').subscribe(data =&gt; this.greeting = data);
  }

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">read.component.html</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;h1&gt;Greeting&lt;/h1&gt;
&lt;div&gt;
	&lt;p&gt;The ID is {{greeting.id}}&lt;/p&gt;
	&lt;p&gt;The content is {{greeting.content}}&lt;/p&gt;
&lt;/div&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>WriteComponent</code>类似，但是具有更改后端消息的形式：</p>
</div>
<div class="listingblock">
<div class="title">write.component.ts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">import { Component } from '@angular/core';
import { HttpClient } from '@angular/common/http';

@Component({
  templateUrl: './write.component.html'
})
export class WriteComponent {

  greeting = {};

  constructor(private http: HttpClient) {
    this.http.get('http://localhost:9000').subscribe(data =&gt; this.greeting = data);
  }

  update() {
    this.http.post('/resource', {content: this.greeting['content']}).subscribe(response =&gt; {
      this.greeting = response;
    });
  }

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">write.component.html</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;form (submit)="update()"&gt;
	&lt;p&gt;The ID is {{greeting.id}}&lt;/p&gt;
	&lt;div class="form-group"&gt;
		&lt;label for="username"&gt;Content:&lt;/label&gt; &lt;input type="text"
			class="form-control" id="content" name="content" [(ngModel)]="greeting.content"/&gt;
	&lt;/div&gt;
	&lt;button type="submit" class="btn btn-primary"&gt;Submit&lt;/button&gt;
&lt;/form&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>AppService</code>还需要提供数据以计算路线，因此在<code>authenticate()</code>函数中，我们看到以下内容：</p>
</div>
<div class="listingblock">
<div class="title">app.service.ts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">        http.get('/user').subscribe(function(response) {
            var user = response.json();
            if (user.name) {
                self.authenticated = true;
                self.writer = user.roles &amp;&amp; user.roles.indexOf("ROLE_WRITER")&gt;0;
            } else {
                self.authenticated = false;
                self.writer = false;
            }
            callback &amp;&amp; callback(response);
        })</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了在后端支持此功能，我们需要<code>/user</code>端点，例如在我们的主应用程序类中：</p>
</div>
<div class="listingblock">
<div class="title">AdminApplication.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@RestController
public class AdminApplication {

  @RequestMapping("/user")
  public Map&lt;String, Object&gt; user(Principal user) {
    Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();
    map.put("name", user.getName());
    map.put("roles", AuthorityUtils.authorityListToSet(((Authentication) user)
        .getAuthorities()));
    return map;
  }

  public static void main(String[] args) {
    SpringApplication.run(AdminApplication.class, args);
  }

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">角色名称从带有前缀“ ROLE_”的“ / user”端点返回，因此我们可以将它们与其他类型的权限区分开来（这是Spring Security的事情）。因此，JavaScript中需要“ ROLE_”前缀，而Spring Security配置中则不需要。从方法名称中可以清楚地看出，“角色”是操作的重点。</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_changes_in_the_gateway_to_support_admin_ui">网关支持管理员界面中的更改</h3>
<div class="paragraph">
<p>我们还将使用这些角色在网关中做出访问决定（因此我们可以有条件地显示指向管理UI的链接），因此我们也应在网关的“ /用户”端点中添加“角色” 。设置好之后，我们可以添加一些JavaScript来设置一个标志，以指示当前用户是“ ADMIN”。在<code>authenticated()</code>函数中：</p>
</div>
<div class="listingblock">
<div class="title">app.component.ts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">this.http.get('user', {headers: headers}).subscribe(data =&gt; {
  this.authenticated = data &amp;&amp; data['name'];
  this.user = this.authenticated ? data['name'] : '';
  this.admin = this.authenticated &amp;&amp; data['roles'] &amp;&amp; data['roles'].indexOf('ROLE_ADMIN') &gt; -1;
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>并且当用户注销时，我们还需要将<code>admin</code>标志重置为<code>false</code> ：</p>
 </div>
<div class="listingblock">
<div class="title">app.component.ts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">this.logout = function() {
    http.post('logout', {}).subscribe(function() {
        self.authenticated = false;
        self.admin = false;
    });
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后在HTML中，我们可以有条件地显示一个新链接：</p>
</div>
<div class="listingblock">
<div class="title">app.component.html</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;div class="container" [hidden]="!authenticated"&gt;
	&lt;a class="btn btn-primary" href="/ui/"&gt;Go To User Interface&lt;/a&gt;
&lt;/div&gt;
&lt;br /&gt;
&lt;div class="container" [hidden]="!authenticated || !admin"&gt;
	&lt;a class="btn btn-primary" href="/admin/"&gt;Go To Admin Interface&lt;/a&gt;
&lt;/div&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行所有应用程序，然后转到<a href="http://localhost:8080" class="bare">http://localhost:8080</a>以查看结果。一切都应该正常工作，并且UI应该根据当前经过身份验证的用户进行更改。</p>
</div>
</div>
<div class="sect2">
<h3 id="_why_are_we_here">我们为什么在这里？</h3>
<div class="paragraph">
<p>现在，我们有了一个不错的小型系统，它具有2个独立的用户界面和一个后端资源服务器，所有这些都由网关中的相同身份验证保护。网关充当微型代理，这一事实使后端安全问题的实现极为简单，并且他们可以自由地专注于自己的业务问题。Spring Session的使用（再次）避免了很多麻烦和潜在的错误。</p>
</div>
<div class="paragraph">
<p>强大的功能是后端可以独立地拥有他们喜欢的任何身份验证（例如，如果您知道UI的物理地址和一组本地凭据，则可以直接进入UI）。网关施加一组完全不相关的约束，只要它可以验证用户并向他们分配满足后端访问规则的元数据。这是一个出色的设计，能够独立开发和测试后端组件。如果愿意，我们可以返回到外部OAuth2服务器（如<a href="#_sso_with_oauth2_angular_js_and_spring_security_part_v">第V节中的内容</a> ，甚至是完全不同的东西），以在网关上进行身份验证，而无需触摸后端。</p>
</div>
<div class="paragraph">
<p>该体系结构的一个额外功能（单个网关控制身份验证，以及所有组件之间的共享会话令牌）是“单点注销”（我们在<a href="#_sso_with_oauth2_angular_js_and_spring_security_part_v">第V部分中</a>难以实现的一项功能）免费提供。更准确地说，在我们完成的系统中会自动提供一种用于单次注销的用户体验的特殊方法：如果用户从任何UI（网关，UI后端或Admin后端）注销，则他将从所有UI中注销。其他情况，假设每个单独的UI以相同的方式（使会话无效）实现“注销”功能。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>谢谢：我要再次感谢所有帮助我开发本系列文章的人，尤其是<a href="https://spring.io/team/rwinch">Rob Winch</a>和<a href="https://twitter.com/thspaeth">ThorstenSpäth</a>对本节和源代码的认真评论。自从<a href="#_spring_and_angular_js_a_secure_single_page_application">第一部分</a>出版以来，它并没有太大变化，但是所有其他部分都是根据读者的评论和见解而发展的，因此，也感谢那些阅读本部分并费心参与讨论的人。</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_testing_angular_js_and_spring_security_part_viii">测试角度应用</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在本节中，我们继续<a href="#_modular_angular_js_and_spring_security_part_vii">讨论</a>如何在“单页应用程序”中将<a href="https://projects.spring.io/spring-security">Spring Security</a>与<a href="https://angular.io">Angular</a>一起使用。在这里，我们展示了如何使用Angular测试框架为客户端代码编写和运行单元测试。您可以了解应用程序的基本构建块，也可以通过阅读<a href="#_spring_and_angular_js_a_secure_single_page_application">第一部分</a>从头开始构建它，或者直接进入<a href="https://github.com/dsyer/spring-security-angular/tree/master/basic">Github中</a>的源代码（与第I部分相同的源代码，但现在添加了测试）。 。本节实际上使用Spring或Spring Security的代码很少，但是它涵盖了客户端测试，而这种方式在通常的Angular社区资源中可能不那么容易找到，对于大多数人来说，我们感到很满意Spring用户。</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>提醒：如果您正在使用示例应用程序来完成本节，请确保清除浏览器的cookie和HTTP Basic凭据缓存。在Chrome中，对单个服务器执行此操作的最佳方法是打开一个新的隐身窗口。</p>
</div>
</blockquote>
</div>
<div class="sect2">
<h3 id="_writing_a_specification">编写规范</h3>
<div class="paragraph">
<p>我们在“基本”应用程序中的“应用程序”组件非常简单，因此无需花费很多时间即可对其进行全面测试。这里是对代码的提醒：</p>
</div>
<div class="listingblock">
<div class="title">app.component.ts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">include::basic/src/app/app.component.ts</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们面临的主要挑战是在测试中提供<code>http</code>对象，因此我们可以断言它们在组件中的使用方式。实际上，即使在我们面临挑战之前，我们也需要能够创建一个组件实例，以便我们可以测试它加载时发生的情况。这是您可以执行的操作。</p>
</div>
<div class="paragraph">
<p>由<code>ng new</code>创建的应用程序中的Angular构建已经具有运行它的规范和一些配置。生成的规范位于“ src / app”中，其开始方式如下：</p>
</div>
<div class="listingblock">
<div class="title">app.component.ts</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">import { TestBed, async } from '@angular/core/testing';
import { AppComponent } from './app.component';
describe('AppComponent', () =&gt; {
  beforeEach(async(() =&gt; {
    TestBed.configureTestingModule({
      imports: [],
      declarations: [
        AppComponent
      ]
    }).compileComponents();
  }));
  it('should create the app', async(() =&gt; {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.debugElement.componentInstance;
    expect(app).toBeTruthy();
  }));
  ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个非常基本的测试套件中，我们具有以下重要元素：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li> <p>我们使用函数<code>describe()</code>要测试的事物（在本例中为“ AppComponent”）。</p> </li>
<li> <p>在该函数内部，我们提供了<code>beforeEach()</code>回调，该回调加载Angular组件。</p> </li>
<li> <p>行为是通过调用<code>it()</code>来表达的，在行为中我们用言语陈述了期望是什么，然后提供了一个进行断言的函数。</p> </li>
<li> <p>在任何其他事情发生之前，都要初始化测试环境。这是大多数Angular应用程序的样板。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>这里的测试功能微不足道，它实际上仅断言该组件存在，因此，如果失败，则测试将失败。</p>
</div>
</div>
<div class="sect2">
<h3 id="_improving_the_unit_test_mocking_http_backend">改善单元测试：模拟HTTP后端</h3>
<div class="paragraph">
<p>为了将规格提高到生产级，我们实际上需要断言控制器加载时会发生什么。由于它调用了<code>http.get()</code>我们需要模拟该调用，以避免只为进行单元测试而运行整个应用程序。为此，我们使用Angular <code>HttpClientTestingModule</code> ：</p>
</div>
<div class="listingblock">
<div class="title">app.component.spec</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">Unresolved directive in testing.adoc - include::basic/src/app/app.component.spec[indent=0]</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的新作品是：</p>
</div>
<div class="ulist">
<ul>
<li> <p><code>HttpClientTestingModule</code>的声明作为<code>beforeEach()</code>中的<code>TestBed</code>中的<code>beforeEach()</code> 。</p> </li>
<li> <p>在测试功能中，我们在创建组件之前为后端设置了期望值，告诉它期望对“ resource /”的调用以及响应应该是什么。</p> </li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_running_the_specs">运行规格</h3>
<div class="paragraph">
<p>要运行“测试”代码，我们可以使用项目建立时创建的便捷脚本进行<code>./ng test</code> （或<code>./ng build</code> ）。它也作为Maven生命周期的一部分运行，因此<code>./mvnw install</code>也是运行测试的好方法，这就是CI构建中会发生的情况。</p>
</div>
</div>
<div class="sect2">
<h3 id="_end_to_end_tests">端到端测试</h3>
<div class="paragraph">
<p>Angular还使用浏览器和生成的JavaScript为“端到端测试”建立了标准构建。这些在顶级<code>e2e</code>目录中被写为“规范”。本教程中的所有示例都包含一个非常简单的端到端测试，该测试在Maven生命周期中运行（因此，如果您在任何“ ui”应用中运行<code>mvn install</code> ，则将看到一个浏览器窗口弹出窗口）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_conclusion_5">结论</h3>
<div class="paragraph">
<p>在现代Web应用程序中，能够运行Java的单元测试非常重要，这是本系列到目前为止我们一直忽略（或躲避）的主题。在本期中，我们介绍了如何编写测试，如何在开发时以及如何在持续集成设置中运行这些测试的基本要素。我们采用的方法并不适合所有人，因此请不要以其他方式感到不好，但请确保您拥有所有这些要素。我们在这里做的方式可能会让传统的Java企业开发人员感到舒服，并且可以与他们现有的工具和流程很好地集成在一起，因此，如果您属于该类别，我希望您将从中找到有用的起点。可以在Internet上的很多地方找到更多使用Angular和Jasmine进行测试的示例，但首先要注意的是本系列中的<a href="https://github.com/dsyer/spring-security-angular/tree/master/single">“单个”示例</a> ，该<a href="https://github.com/dsyer/spring-security-angular/tree/master/single">示例</a>现在具有一些最新的测试代码，但该代码要少一些比本教程中为“基本”示例编写的代码简单。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_oauth2_logout_angular_js_and_spring_security_part_ix">从OAuth2客户端应用程序注销</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在本节中，我们继续<a href="#_testing_angular_js_and_spring_security_part_viii">讨论</a>如何在“单页应用程序”中将<a href="https://projects.spring.io/spring-security">Spring Security</a>与<a href="https://angular.io">Angular</a>一起使用。在这里，我们展示了如何获取OAuth2示例并添加不同的注销体验。许多实施OAuth2单点登录的人发现他们有一个难题要解决，即如何“干净地”注销？令人困惑的原因是，没有唯一正确的方法来执行此操作，而您选择的解决方案将取决于您所寻找的用户体验以及您愿意承担的复杂性。复杂性的原因是由于系统中可能存在多个浏览器会话，而这些会话都具有不同的后端服务器，因此，当用户从其中一个注销时，其他用户应该怎么办？这是本教程的第9部分，您可以了解应用程序的基本构建块，也可以通过阅读<a href="#_spring_and_angular_js_a_secure_single_page_application">第一部分</a>从头开始构建它，或者直接进入<a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/tree/master/oauth2-logout">Github中</a>的<a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/tree/master/oauth2-logout">源代码</a> 。</p>
</div>
<div class="sect2">
<h3 id="_logout_patterns">登出模式</h3>
<div class="paragraph">
<p>在本教程中，注销<code>oauth2</code>示例的用户体验是您注销UI应用程序，而不是从authserver注销，因此，当您重新登录UI应用程序时，autheserver不会再次要求提供凭据。当autheserver是外部服务器时，这是完全预期的，正常的和合乎需要的-Google和其他外部authserver提供程序既不希望也不允许您从不受信任的应用程序从其服务器中注销-但是如果authserver确实是最佳用户体验与UI相同的系统的一部分。</p>
</div>
<div class="paragraph">
<p>从广义上讲，存在三种从经过身份验证为OAuth2客户端的UI应用注销的模式：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li> <p>外部Authserver（EA，原始示例）。用户将身份验证服务器视为第三方（例如，使用Facebook或Google进行身份验证）。当应用程序会话结束时，您不想注销authserver。您确实希望批准所有赠款。本教程中的<code>oauth2</code> （和<code>oauth2-vanilla</code> ）示例实现了这种模式。</p> </li>
<li> <p>网关和内部Authserver（GIA）。您仅需要注销2个应用程序，并且用户认为它们属于同一系统。通常，您要自动批准所有拨款。</p> </li>
<li> <p>单一注销（SL）。一台authserver和多个UI应用程序都具有自己的身份验证，并且当用户注销其中一个时，您希望它们全部照搬。由于网络分区和服务器故障，天真的实现可能会失败-您基本上需要全局一致的存储。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>有时，即使您具有外部身份验证服务器，也希望控制身份验证并添加内部访问控制层（例如，身份验证服务器不支持的作用域或角色）。然后，最好使用EA进行身份验证，但要有一个内部authserver，可以将所需的其他详细信息添加到令牌中。其他<a href="https://github.com/spring-guides/tut-spring-boot-oauth2">OAuth2教程</a>中的<code>auth-server</code>示例向您展示了如何以一种非常简单的方式进行操作。然后，您可以将GIA或SL模式应用于包含内部authserver的系统。</p>
</div>
<div class="paragraph">
<p>如果您不希望使用EA，可以使用以下选项：</p>
</div>
<div class="ulist">
<ul>
<li> <p>从authserver以及浏览器客户端中的UI应用注销。简单的方法，并与一些仔细的CRSF和CORS配置一起使用。没有SL。</p> </li>
<li> <p>令牌可用后，立即从authserver注销。很难在获取令牌的UI中实现，因为那里没有authserver的会话cookie。<a href="https://github.com/spring-projects/spring-security-oauth/issues/140">Spring OAuth中</a>有一个<a href="https://github.com/spring-projects/spring-security-oauth/issues/140">功能请求，</a>它显示了一种有趣的方法：生成身份验证代码后，使身份验证服务器中的会话无效。Github问题包含实现会话无效的一个方面，但是作为<code>HandlerInterceptor</code>容易实现。没有SL。</p> </li>
<li> <p>通过与UI相同的网关进行代理authserver，并希望一个cookie足以管理整个系统的状态。这是行不通的，因为除非存在一个共享会话，否则它将在某种程度上破坏对象（否则，authserver将没有会话存储）。仅在所有应用程序之间共享会话时才使用SL。</p> </li>
<li> <p>网关中的Cookie中继。您将网关用作身份验证的真实来源，并且authserver具有所需的所有状态，因为网关管理cookie而不是浏览器。浏览器永远不会有来自多个服务器的cookie。没有SL。</p> </li>
<li> <p>将令牌用作全局身份验证，并在用户注销UI应用程序时使令牌无效。缺点：要求令牌必须由客户端应用程序使之无效，这实际上并不是其设计目的。可能使用SL，但通常会受到限制。</p> </li>
<li> <p>在authserver中创建和管理全局会话令牌（除了用户令牌）。这是<a href="https://openid.net">OpenId Connect</a>采取的方法，它确实为SL提供了一些选项，但要花一些额外的钱。没有一种选择可以避免通常的分布式系统限制：如果网络和应用程序节点不稳定，则不能保证在需要时所有参与者之间共享注销信号。所有注销规范仍处于草稿形式，这里有一些规范链接： <a href="https://openid.net/specs/openid-connect-session-1_0.html">Session Management</a> ， <a href="https://openid.net/specs/openid-connect-frontchannel-1_0.html">Front Channel Logout</a>和<a href="https://openid.net/specs/openid-connect-backchannel-1_0.html">Back Channel Logout</a> 。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>请注意，在难以执行或无法执行SL的情况下，最好还是将所有UI放在单个网关后面。然后，您可以使用更简单的GIA来控制整个资产的注销。</p>
</div>
<div class="paragraph">
<p>可以在本教程示例中如下实现最简单的两个选项，它们很好地适用于GIA模式：（使用<code>oauth2</code>示例并从那里开始工作）。</p>
</div>
</div>
<div class="sect2">
<h3 id="_logout_of_both_servers_from_browser">从浏览器注销两个服务器</h3>
<div class="paragraph">
<p>在注销UI应用程序后，很容易将几行代码添加到从authserver注销的浏览器客户端。例如</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">logout() {
    this.http.post('logout', {}).finally(() =&gt; {
        self.authenticated = false;
        this.http.post('http://localhost:9999/uaa/logout', {}, {withCredentials:true})
            .subscribe(() =&gt; {
                console.log('Logged out');
        });
    }).subscribe();
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此示例中，我们将authserver注销端点URL硬编码到JavaScript中，但是如果需要，可以很容易地将其外部化。它必须是直接发送到authserver的POST，因为我们也希望会话cookie也能够通过。如果我们明确要求<code>withCredentials:true</code> ，则XHR请求将仅从浏览器中发出并附带一个cookie。</p>
</div>
<div class="paragraph">
<p>相反，在服务器上，我们需要一些CORS配置，因为请求来自其他域。例如在<code>WebSecurityConfigurerAdapter</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Override
protected void configure(HttpSecurity http) throws Exception {
  http
	.requestMatchers().antMatchers("/login", "/logout", "/oauth/authorize", "/oauth/confirm_access")
  .and()
    .cors().configurationSource(configurationSource())
    ...
}

private CorsConfigurationSource configurationSource() {
  UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
  CorsConfiguration config = new CorsConfiguration();
  config.addAllowedOrigin("*");
  config.setAllowCredentials(true);
  config.addAllowedHeader("X-Requested-With");
  config.addAllowedHeader("Content-Type");
  config.addAllowedMethod(HttpMethod.POST);
  source.registerCorsConfiguration("/logout", config);
  return source;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>已对“ / logout”端点进行了一些特殊处理。允许从任何来源调用它，并明确允许发送凭据（例如cookie）。允许的标头只是Angular在示例应用程序中发送的标头。</p>
</div>
<div class="paragraph">
<p>除了CORS配置，我们还需要为注销端点禁用CSRF，因为Angular不会在跨域请求中发送<code>X-XSRF-TOKEN</code>标头。 authserver之前不需要任何CSRF配置，但是很容易为注销端点添加忽略：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Override
protected void configure(HttpSecurity http) throws Exception {
  http
    .csrf()
      .ignoringAntMatchers("/logout/**")
    ...
}</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-warning" title="警告"></i> </td>
<td class="content">确实不建议放弃CSRF保护，但是对于这种受限的使用情况，您可能已经准备好容忍它了。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>通过这两个简单的更改，一个在UI应用程序客户端中，一个在身份验证服务器中，您将发现注销UI应用程序后，再次登录时，总是会提示您输入密码。</p>
</div>
<div class="paragraph">
<p>另一个有用的更改是将OAuth2客户端设置为自动批准，这样用户就不必批准令牌授予。这在内部身份验证服务器中很常见，在该服务器中，用户不会将其视为独立的系统。在<code>AuthorizationServerConfigurerAdapter</code>中，初始化客户端时只需要一个标志：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Override
public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
  clients.inMemory().withClient("acme")
    ...
  .autoApprove(true);
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_invalidate_session_in_authserver">使Authserver中的会话无效</h3>
<div class="paragraph">
<p>如果您不想放弃注销端点上的CSRF保护，则可以尝试另一种简单的方法，即在授予令牌后立即使authserver中的用户会话失效（实际上是在获得auth代码后立即失效）生成）。这也是超级容易实现的：从<code>oauth2</code>示例开始，只需将<code>HandlerInterceptor</code>添加到OAuth2端点即可。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Override
public void configure(AuthorizationServerEndpointsConfigurer endpoints)
    throws Exception {
  ...
  endpoints.addInterceptor(new HandlerInterceptorAdapter() {
    @Override
    public void postHandle(HttpServletRequest request,
        HttpServletResponse response, Object handler,
        ModelAndView modelAndView) throws Exception {
      if (modelAndView != null
          &amp;&amp; modelAndView.getView() instanceof RedirectView) {
        RedirectView redirect = (RedirectView) modelAndView.getView();
        String url = redirect.getUrl();
        if (url.contains("code=") || url.contains("error=")) {
          HttpSession session = request.getSession(false);
          if (session != null) {
            session.invalidate();
          }
        }
      }
    }
  });
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该拦截器将查找<code>RedirectView</code> ，这是一个信号，表明用户正在被重定向回客户端应用程序，并检查该位置是否包含授权码或错误。如果还使用隐式授予，则可以添加“ token =“。</p>
</div>
<div class="paragraph">
<p>通过此简单的更改，您一进行身份验证，身份验证服务器中的会话就已经失效，因此无需尝试从客户端进行管理。当您注销UI应用程序，然后重新登录时，authserver无法识别您，并提示您输入凭据。该模式是由本教程的<a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/tree/master/oauth2-logout">源代码中</a>的<code>oauth2-logout</code>示例实现的。这种方法的缺点是您再也没有真正的单一登录-系统中的任何其他应用程序都将发现authserver会话已死，而他们必须再次提示进行身份验证-这不是如果有多个应用程序，则可提供出色的用户体验。</p>
</div>
</div>
<div class="sect2">
<h3 id="_conclusion_6">结论</h3>
<div class="paragraph">
<p>在本节中，我们已经看到了如何从OAuth2客户端应用程序中实现几种不同的注销模式（以本教程<a href="#_sso_with_oauth2_angular_js_and_spring_security_part_v">第五节中</a>的应用程序为起点），并讨论了其他模式的一些选项。这些选项并不详尽，但是应该使您对所涉及的折衷有所了解，并提供一些工具来考虑针对您的用例的最佳解决方案。本节只有几行JavaScript，并不是真正针对Angular的（它向XHR请求添加了一个标志），因此所有课程和模式都适用于本指南中示例应用程序的狭窄范围。 。一个反复出现的主题是，存在多个UI应用程序和一个authserver的所有单一登录（SL）方法在某种程度上都存在缺陷：您能做的最好的就是选择使您的用户感到最不舒服的方法。如果您有一个内部身份验证服务器和一个由许多组件组成的系统，则可能使用户感觉像单个系统的唯一体系结构是所有用户交互的网关。</p>
</div>
<div class="paragraph">
<p>是否要编写新指南或为现有指南做出贡献？看看我们的<a href="https://github.com/spring-guides/getting-started-guides/wiki">贡献准则</a> 。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-important" title="重要"></i> </td>
<td class="content">所有的导游都发布了一个ASLv2许可证的代码，一个<a href="https://creativecommons.org/licenses/by-nd/3.0/">Attribution, NoDerivatives creative commons license</a>的写作。</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div>
</article>
</div>
<aside class="span4 content-right-pane--container mobile-left-pane" id="sidebar">
<a class="ci-status desktop-only" href="https://travis-ci.org/spring-guides/tut-spring-security-and-angular-js">
<img src="https://travis-ci.org/spring-guides/tut-spring-security-and-angular-js.svg?branch=master">
</a>
<div class="right-pane-widget--container desktop-only">
<div class="github-actions https">
<h2>获取代码</h2>
<div class="btn-group">
<button class="btn" data-protocol="https">HTTPS</button>
<button class="btn" data-protocol="ssh">SSH协议</button>
</div>
<div class="clone-url https">
<input id="clone-url-https" type="text" value="https://github.com/spring-guides/tut-spring-security-and-angular-js.git" readonly>
<button class="copy-button github" data-toggle="tooltip" data-clipboard-text="https://github.com/spring-guides/tut-spring-security-and-angular-js.git"></button>
</div>
<div class="clone-url ssh">
<input id="clone-url-ssh" type="text" value="git@github.com:spring-guides/tut-spring-security-and-angular-js.git" readonly>
<button class="copy-button github" data-toggle="tooltip" data-clipboard-text="git@github.com:spring-guides/tut-spring-security-and-angular-js.git"></button>
</div>
<a class="github_download btn btn-black uppercase" href="https://github.com/spring-guides/tut-spring-security-and-angular-js/archive/master.zip">下载ZIP</a> <a class="gs-guide-import" href="https://github.com/spring-guides/tut-spring-security-and-angular-js.git">导入到STS</a>
<div class="go-to-repo--container">
<a href="https://github.com/spring-guides/tut-spring-security-and-angular-js"><i class="icon-github"></i>Go To Repo</a>
</div>
<div class="go-to-repo--container">
</div>
</div>
</div>
<div class="right-pane-widget--container">
<div>
<h3><a class="anchor" href="#table-of-contents" name="table-of-contents"></a>目录</h3>
<div><ul class="sectlevel1">
<li><a href="#_spring_and_angular_js_a_secure_single_page_application">安全的单页应用程序</a> </li>
<li><a href="#_the_login_page_angular_js_and_spring_security_part_ii">登录页面</a> </li>
<li><a href="#_the_resource_server_angular_js_and_spring_security_part_iii">资源服务器</a> </li>
<li><a href="#_the_api_gateway_pattern_angular_js_and_spring_security_part_iv">API网关</a> </li>
<li><a href="#_sso_with_oauth2_angular_js_and_spring_security_part_v">使用OAuth2单点登录</a> </li>
<li><a href="#_multiple_ui_applications_and_a_gateway_single_page_application_with_spring_and_angular_js_part_vi">多个UI应用程序和一个网关</a> </li>
<li><a href="#_testing_angular_js_and_spring_security_part_viii">测试角度应用</a> </li>
<li><a href="#_oauth2_logout_angular_js_and_spring_security_part_ix">从OAuth2客户端应用程序注销</a> </li>
</ul></div>
</div>
</div>
</aside>
</div>
</main>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
 <div class="container">
 <ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
<script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script></body></html>