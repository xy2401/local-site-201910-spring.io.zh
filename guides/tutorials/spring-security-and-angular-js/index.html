<!DOCTYPE html>
<html data-clipboard-buttons="" data-code-prettify="" data-code-sidebar="" data-hide-show-guide="" data-sts-import="" data-mobile-support="" data-search="">
<head>
<title>Tutorial · Spring Security and Angular</title>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no" id="Viewport" name="viewport" />
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png" />
<link href="https://fonts.googleapis.com/css?family=Varela+Round|Montserrat:400,700" rel="stylesheet" type="text/css" />
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css" />
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M" name="google-site-verification" />

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link rel="stylesheet" type="text/css" href="/css/gsguide-cce08ab7a9f46db88819a14148e45bad.css" />

<meta property="og:title" content="Spring Security and Angular" />
<meta property="og:image" content="/img/spring-by-pivotal-9066b55828deb3c10e27e609af322c40.png" />
<meta property="og:description" content="this tutorial is designed to be completed in 2-3 hours, it provides deeper, in-context explorations of enterprise application development topics, leaving you ready to implement real-world solutions." />
</head>
<body>

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" style="display:none;visibility:hidden" width="0"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">Projects</a>
</li>
<li class="navbar-link active">
<a href="/guides">Guides</a>
</li>
<li class="navbar-link">
<a href="/blog">Blog</a>
</li>
<li class="navbar-link">
<a href="/services">Training & Certification</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form action="/search" class="form-inline form-search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search for documentation, guides, and posts..." type="text" value="" />
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form action="/search" class="form-inline form-search" method="get">
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search..." type="text" value="" />
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">
Home
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">
Projects
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/guides">
Guides
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/blog">
Blog
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">
Training & Certification
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<main class="main-body--wrapper">
<div class="row-fluid">
<div class="span8 mobile-left-pane">
<div class="content--title desktop-only">Tutorial</div>
<article class="content--container">
<h1 class="title">Spring Security and Angular</h1>
<div class="article-body"><div class="sect1">
<h2 id="_spring_and_angular_js_a_secure_single_page_application">A Secure Single Page Application</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this tutorial we show some nice features of Spring Security, Spring Boot and Angular working together to provide a pleasant and secure user experience. It should be accessible to beginners with Spring and Angular, but there also is plenty of detail that will be of use to experts in either. This is actually the first in a series of sections on Spring Security and Angular, with new features exposed in each one successively. We’ll improve on the application in the <a href="#_the_login_page_angular_js_and_spring_security_part_ii">second</a> and subsequent installments, but the main changes after this are architectural rather than functional.</p>
</div>
<div class="sect2">
<h3 id="_spring_and_the_single_page_application">Spring and the Single Page Application</h3>
<div class="paragraph">
<p>HTML5, rich browser-based features, and the "single page application" are extremely valuable tools for modern developers, but any meaningful interactions will involve a backend server, so as well as static content (HTML, CSS and JavaScript) we are going to need a backend server. The backend server can play any or all of a number of roles: serving static content, sometimes (but not so often these days) rendering dynamic HTML, authenticating users, securing access to protected resources, and (last but not least) interacting with JavaScript in the browser through HTTP and JSON (sometimes referred to as a REST API).</p>
</div>
<div class="paragraph">
<p>Spring has always been a popular technology for building the backend features (especially in the enterprise), and with the advent of <a href="https://projects.spring.io/spring-boot">Spring Boot</a> things have never been easier. Let’s have a look at how to build a new single page application from nothing using Spring Boot, Angular and Twitter Bootstrap. There’s no particular reason to choose that specific stack, but it is quite popular, especially with the core Spring constituency in enterprise Java shops, so it’s a worthwhile starting point.</p>
</div>
</div>
<div class="sect2">
<h3 id="_create_a_new_project">Create a New Project</h3>
<div class="paragraph">
<p>We are going to step through creating this application in some detail, so that anyone who isn’t completely au fait with Spring and Angular can follow what is happening. If you prefer to cut to the chase, you can <a href="#how-does-it-work">skip to the end</a> where the application is working, and see how it all fits together. There are various options for creating a new project:</p>
</div>
<div class="ulist">
<ul>
<li> <p><a href="#using-curl">Using curl on the command line</a></p> </li>
<li> <p><a href="#using-spring-boot-cli">Using Spring Boot CLI</a></p> </li>
<li> <p><a href="#using-the-initializr-website">Using the Spring Initializr website</a></p> </li>
<li> <p><a href="#using-spring-tool-suite">Using Spring Tool Suite</a></p> </li>
</ul>
</div>
<div class="paragraph">
<p>The source code for the complete project we are going to build is in <a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/tree/master/basic">Github here</a>, so you can just clone the project and work directly from there if you want. Then jump to the <a href="#add-a-home-page">next section</a>.</p>
</div>
<div class="sect3">
<h4 id="using-curl">Using Curl</h4>
<div class="paragraph">
<p>The easiest way to create a new project to get started is via the <a href="https://start.spring.io">Spring Boot Initializr</a>. E.g. using curl on a UN*X like system:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ mkdir ui &amp;&amp; cd ui
$ curl https://start.spring.io/starter.tgz -d style=web \
-d style=security -d name=ui | tar -xzvf -</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can then import that project (it’s a normal Maven Java project by default) into your favourite IDE, or just work with the files and "mvn" on the command line. Then jump to the <a href="#add-a-home-page">next section</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="using-spring-boot-cli">Using Spring Boot CLI</h4>
<div class="paragraph">
<p>You can create the same project using the <a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#getting-started-installing-the-cli">Spring Boot CLI</a>, like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ spring init --dependencies web,security ui/ &amp;&amp; cd ui</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then jump to the <a href="#add-a-home-page">next section</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="using-the-initializr-website">Using the Initializr Website</h4>
<div class="paragraph">
<p>If you prefer you can also get the same code directly as a .zip file from the <a href="https://start.spring.io">Spring Boot Initializr</a>. Just open it up in your browser and select dependencies "Web" and "Security", then click on "Generate Project". The .zip file contains a standard Maven or Gradle project in the root directory, so you might want to create an empty directory before you unpack it. Then jump to the <a href="#add-a-home-page">next section</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="using-spring-tool-suite">Using Spring Tool Suite</h4>
<div class="paragraph">
<p>In <a href="https://spring.io/tools/sts">Spring Tool Suite</a> (a set of Eclipse plugins) you can also create and import a project using a wizard at <code>File-&gt;New-&gt;Spring Starter Project</code>. Then jump to the <a href="#add-a-home-page">next section</a>. IntelliJ IDEA and NetBeans have similar features.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="add-a-home-page">Add an Angular App</h3>
<div class="paragraph">
<p>The core of a single page application in Angular (or any modern front-end framework) these days is going to be a Node.js build. Angular has some tools for setting this up quickly, so lets use those, and also keep the option of building with Maven, like any other Spring Boot application. The details of how to set up the Angular app are covered <a href="https://github.com/dsyer/spring-boot-angular">elsewhere</a>, or you can just checkout the code for this tutorial from github.</p>
</div>
<div class="sect3">
<h4 id="_running_the_application">Running the Application</h4>
<div class="paragraph">
<p>Once the Angular app is primed, your application will be loadable in a browser (even though it doesn’t do much yet). On the command line you can do this</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ mvn spring-boot:run</code></pre>
</div>
</div>
<div class="paragraph">
<p>and go to a browser at <a href="http://localhost:8080">http://localhost:8080</a>. When you load the home page you should get a browser dialog asking for username and password (the username is "user" and the password is printed in the console logs on startup). There’s actually no content yet (or maybe the default "hero" tutorial content from the <code>ng</code> CLI), so you should get essentially a blank page.</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-tip" title="Tip"></i> </td>
<td class="content"> If you don’t like scraping the console log for the password just add this to the "application.properties" (in "src/main/resources"): <code>security.user.password=password</code> (and choose your own password). We did this in the sample code using "application.yml". </td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>In an IDE, just run the <code>main()</code> method in the application class (there is only one class, and it is called <code>UiApplication</code> if you used the "curl" command above).</p>
</div>
<div class="paragraph">
<p>To package and run as a standalone JAR, you can do this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ mvn package
$ java -jar target/*.jar</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_customize_the_angular_application">Customize the Angular Application</h3>
<div class="paragraph">
<p>Let’s customize the "app-root" component (in "src/app/app.component.ts").</p>
</div>
<div class="paragraph">
<p>A minimal Angular application looks like this:</p>
</div>
<div class="listingblock">
<div class="title">
app.component.ts
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title = 'Demo';
  greeting = {'id': 'XXX', 'content': 'Hello World'};
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Most of the code in this TypeScript is boiler plate. The interesting stuff is all going to be in the <code>AppComponent</code> where we define the "selector" (the name of the HTML element) and a snippet of HTML to render via the <code>@Component</code> annotation. We also need to edit the HTML template ("app.component.html"):</p>
</div>
<div class="listingblock">
<div class="title">
app.component.html
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;div style="text-align:center"class="container"&gt;
  &lt;h1&gt;
    Welcome {{title}}!
  &lt;/h1&gt;
  &lt;div class="container"&gt;
    &lt;p&gt;Id: &lt;span&gt;{{greeting.id}}&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;Message: &lt;span&gt;{{greeting.content}}!&lt;/span&gt;&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you added those files under "src/app" and rebuilt your app it should now be secure and functional, and it will say "Hello World!". The <code>greeting</code> is rendered by Angular in the HTML using the handlebar placeholders, <code>{{greeting.id}}</code> and <code>{{greeting.content}}</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="dynamic-content">Adding Dynamic Content</h3>
<div class="paragraph">
<p>So far we have an application with a greeting that is hard coded. That’s useful for learning how things fit together, but really we expect content to come from a backend server, so let’s create an HTTP endpoint that we can use to grab a greeting. In your <a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/blob/master/basic/src/main/java/demo/UiApplication.java">application class</a> (in "src/main/java/demo"), add the <code>@RestController</code> annotation and define a new <code>@RequestMapping</code>:</p>
</div>
<div class="listingblock">
<div class="title">
UiApplication.java
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@RestController
public class UiApplication {

  @RequestMapping("/resource")
  public Map&lt;String,Object&gt; home() {
    Map&lt;String,Object&gt; model = new HashMap&lt;String,Object&gt;();
    model.put("id", UUID.randomUUID().toString());
    model.put("content", "Hello World");
    return model;
  }

  public static void main(String[] args) {
    SpringApplication.run(UiApplication.class, args);
  }

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="Note"></i> </td>
<td class="content"> Depending on the way you created your new project it might not be called <code>UiApplication</code>. </td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>Run that application and try to curl the "/resource" endpoint and you will find that it is secure by default:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ curl localhost:8080/resource
{"timestamp":1420442772928,"status":401,"error":"Unauthorized","message":"Full authentication is required to access this resource","path":"/resource"}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_loading_a_dynamic_resource_from_angular">Loading a Dynamic Resource from Angular</h4>
<div class="paragraph">
<p>So let’s grab that message in the browser. Modify the <code>AppComponent</code> to load the protected resource using XHR:</p>
</div>
<div class="listingblock">
<div class="title">
app.component.ts
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">import { Component } from '@angular/core';
import { HttpClient } from '@angular/common/http';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title = 'Demo';
  greeting = {};
  constructor(private http: HttpClient) {
    http.get('resource').subscribe(data =&gt; this.greeting = data);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We injected an <a href="https://angular.io/guide/http"><code>http</code> service</a>, which is provided by Angular through the <code>http</code> module, and used it to GET our resource. Angular passes us the response and we pull out JSON and assign it to the greeting.</p>
</div>
<div class="paragraph">
<p>To enable the dependency injection of the <code>http</code> service into our custom component, we need to declare it in the <code>AppModule</code> that includes the component (it’s just one more line in the <code>imports</code> compared to the initial draft):</p>
</div>
<div class="listingblock">
<div class="title">
app.module.ts
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';

import { AppComponent } from './app.component';
import { HttpClientModule } from '@angular/common/http';

@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
    HttpClientModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Run the application again (or just reload the home page in the browser), and you will see the dynamic message with its unique ID. So, even though the resource is protected and you can’t curl it directly, the browser was able to access the content. We have a secure single page application in less than a hundred lines of code!</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="Note"></i> </td>
<td class="content"> You might need to force your browser to reload the static resources after you change them. In Chrome (and Firefox with a plugin) you can use "developer tools" (F12), and that might be enough. Or you might have to use CTRL+F5. </td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="how-does-it-work">How Does it Work?</h3>
<div class="paragraph">
<p>The interactions between the browser and the backend can be seen in your browser if you use some developer tools (usually F12 opens this up, works in Chrome by default, may require a plugin in Firefox). Here’s a summary:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Verb</th>
<th class="tableblock halign-left valign-top">Path</th>
<th class="tableblock halign-left valign-top">Status</th>
<th class="tableblock halign-left valign-top">Response</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">401</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Browser prompts for authentication</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">index.html</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/*.js</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Loads of third assets from angular</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/main.bundle.js</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Application logic</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/resource</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JSON greeting</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>You might not see the 401 because the browser treats the home page load as a single interaction, and you might see 2 requests for "/resource" because there is a <a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing">CORS</a> negotiation.</p>
</div>
<div class="paragraph">
<p>Look more closely at the requests and you will see that all of them have an "Authorization" header, something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>Authorization: Basic dXNlcjpwYXNzd29yZA==</code></pre>
</div>
</div>
<div class="paragraph">
<p>The browser is sending the username and password with every request (so remember to use HTTPS exclusively in production). There’s nothing "Angular" about that, so it works with your JavaScript framework or non-framework of choice.</p>
</div>
<div class="sect3">
<h4 id="_whats_wrong_with_that">What’s Wrong with That?</h4>
<div class="paragraph">
<p>On the face of it, it seems like we did a pretty good job, it’s concise, easy to implement, all our data are secured by a secret password, and it would still work if we changed the front end or backend technologies. But there are some issues.</p>
</div>
<div class="ulist">
<ul>
<li> <p>Basic authentication is restricted to username and password authentication.</p> </li>
<li> <p>The authentication UI is ubiquitous but ugly (browser dialog).</p> </li>
<li> <p>There is no protection from <a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery">Cross Site Request Forgery</a> (CSRF).</p> </li>
</ul>
</div>
<div class="paragraph">
<p>CSRF isn’t really an issue with our application as it stands since it only needs to GET the backend resources (i.e. no state is changed in the server). As soon as you have a POST, PUT or DELETE in your application it simply isn’t secure any more by any reasonable modern measure.</p>
</div>
<div class="paragraph">
<p>In the <a href="#_the_login_page_angular_js_and_spring_security_part_ii">next section in this series</a> we will extend the application to use form-based authentication, which is a lot more flexible than HTTP Basic. Once we have a form we will need CSRF protection, and both Spring Security and Angular have some nice out-of-the box features to help with this. Spoiler: we are going to need to use the <code>HttpSession</code>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Thanks: I would like to thank everyone who helped me develop this series, and in particular <a href="https://spring.io/team/rwinch">Rob Winch</a> and <a href="https://twitter.com/thspaeth">Thorsten Spaeth</a> for their careful reviews of the text and source code, and for teaching me a few tricks I didn’t know even about the parts I thought I was most familiar with.</p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_login_page_angular_js_and_spring_security_part_ii">The Login Page</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this section we continue <a href="#_spring_and_angular_js_a_secure_single_page_application">our discussion</a> of how to use <a href="https://projects.spring.io/spring-security">Spring Security</a> with <a href="https://angular.io/">Angular</a> in a "single page application". Here we show how to use Angular to authenticate a user via a form and fetch a secure resource to render in the UI. This is the second in a series of sections, and you can catch up on the basic building blocks of the application or build it from scratch by reading the <a href="#_spring_and_angular_js_a_secure_single_page_application">first section</a>, or you can just go straight to the <a href="https://github.com/dsyer/spring-security-angular/tree/master/single">source code in Github</a>. In the first section we built a simple application that used HTTP Basic authentication to protect the backend resources. In this one we add a login form, give the user some control over whether to authenticate or not, and fix the issues with the first iteration (principally lack of CSRF protection).</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Reminder: if you are working through this section with the sample application, be sure to clear your browser cache of cookies and HTTP Basic credentials. In Chrome the best way to do that for a single server is to open a new incognito window.</p>
</div>
</blockquote>
</div>
<div class="sect2">
<h3 id="_add_navigation_to_the_home_page">Add Navigation to the Home Page</h3>
<div class="paragraph">
<p>The core of an Angular application is an HTML template for the basic page layout. We already had a really basic one, but for this application we need to offer some navigation features (login, logout, home), so let’s modify it (in <code>src/app</code>):</p>
</div>
<div class="listingblock">
<div class="title">
app.component.html
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;div class="container"&gt;
  &lt;ul class="nav nav-pills"&gt;
    &lt;li&gt;&lt;a routerLinkActive="active" routerLink="/home"&gt;Home&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a routerLinkActive="active" routerLink="/login"&gt;Login&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a (click)="logout()"&gt;Logout&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;
&lt;div class="container"&gt;
  &lt;router-outlet&gt;&lt;/router-outlet&gt;
&lt;/div&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The main content is a <code>&lt;router-outlet/&gt;</code> and there is a navigation bar with login and logout links.</p>
</div>
<div class="paragraph">
<p>The <code>&lt;router-outlet/&gt;</code> selector is provided by Angular, and it needs to be wired up to a component in the main module. There is going to be one component per route (per menu link), and a helper service to glue them together, and share some state (<code>AppService</code>). Here’s the implementation of the module that pulls all the pieces together:</p>
</div>
<div class="listingblock">
<div class="title">
app.module.ts
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { HttpClientModule } from '@angular/common/http';
import { RouterModule, Routes } from '@angular/router';
import { AppService } from './app.service';
import { HomeComponent } from './home.component';
import { LoginComponent } from './login.component';
import { AppComponent } from './app.component';

const routes: Routes = [
  { path: '', pathMatch: 'full', redirectTo: 'home'},
  { path: 'home', component: HomeComponent},
  { path: 'login', component: LoginComponent}
];

@NgModule({
  declarations: [
    AppComponent,
    HomeComponent,
    LoginComponent
  ],
  imports: [
    RouterModule.forRoot(routes),
    BrowserModule,
    HttpClientModule,
    FormsModule
  ],
  providers: [AppService]
  bootstrap: [AppComponent]
})
export class AppModule { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>We added a dependency on an Angular module called <a href="https://angular.io/guide/router">"RouterModule"</a> and this allowed us to inject a magic <code>router</code> into the constructor of the <code>AppComponent</code>. The <code>routes</code> are used inside the imports of the <code>AppModule</code> to set up links to "/" (the "home" controller) and "/login" (the "login" controller).</p>
</div>
<div class="paragraph">
<p>We also sneaked the <code>FormsModule</code> in there, because it will be needed later for binding data to a form that we want to submit when the user logs in.</p>
</div>
<div class="paragraph">
<p>The UI components are all "declarations" and the service glue is a "provider". The <code>AppComponent</code> actually doesn’t do very much. The TypeScript component that goes with the app root is here:</p>
</div>
<div class="listingblock">
<div class="title">
app.component.ts
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">import { Component } from '@angular/core';
import { AppService } from './app.service';
import { HttpClient } from '@angular/common/http';
import { Router } from '@angular/router';
import 'rxjs/add/operator/finally';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  constructor(private app: AppService, private http: HttpClient, private router: Router) {
      this.app.authenticate(undefined, undefined);
    }
    logout() {
      this.http.post('logout', {}).finally(() =&gt; {
          this.app.authenticated = false;
          this.router.navigateByUrl('/login');
      }).subscribe();
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Salient features:</p>
</div>
<div class="ulist">
<ul>
<li> <p>There is some more dependency injection, this time of the <code>AppService</code></p> </li>
<li> <p>There is a logout function exposed as a property of the component, which we can use later to send a logout request to the backend. It sets a flag in the <code>app</code> service, and sends the user back to the login screen (and it does this unconditionally via a <code>finally()</code> callback).</p> </li>
<li> <p>We are using <code>templateUrl</code> to externalize the template HTML into a separate file.</p> </li>
<li> <p>The <code>authenticate()</code> function is called when the controller is loaded to see if the user is actually already authenticated (e.g. if he had refreshed the browser in the middle of a session). We need the <code>authenticate()</code> function to make a remote call because the actual authentication is done by the server, and we don’t want to trust the browser to keep track of it.</p> </li>
</ul>
</div>
<div class="paragraph">
<p>The <code>app</code> service that we injected above needs a boolean flag so we can tell if the user is currently authenticated, and a function <code>authenticate()</code> that can be used to authenticate with the back end server, or just to query it for the user details:</p>
</div>
<div class="listingblock">
<div class="title">
app.service.ts
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">import { Injectable } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';

@Injectable()
export class AppService {

  authenticated = false;

  constructor(private http: HttpClient) {
  }

  authenticate(credentials, callback) {

        const headers = new HttpHeaders(credentials ? {
            authorization : 'Basic ' + btoa(credentials.username + ':' + credentials.password)
        } : {});

        this.http.get('user', {headers: headers}).subscribe(response =&gt; {
            if (response['name']) {
                this.authenticated = true;
            } else {
                this.authenticated = false;
            }
            return callback &amp;&amp; callback();
        });

    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>authenticated</code> flag is simple. The <code>authenticate()</code> function sends HTTP Basic authentication credentials if they are provided, and otherwise not. It also has an optional <code>callback</code> argument that we can use to execute some code if the authentication is successful.</p>
</div>
<div class="sect3">
<h4 id="_the_greeting">The Greeting</h4>
<div class="paragraph">
<p>The greeting content from the old home page can go right next to the "app.component.html" in "src/app":</p>
</div>
<div class="listingblock">
<div class="title">
home.component.html
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;h1&gt;Greeting&lt;/h1&gt;
&lt;div [hidden]="!authenticated()"&gt;
	&lt;p&gt;The ID is {{greeting.id}}&lt;/p&gt;
	&lt;p&gt;The content is {{greeting.content}}&lt;/p&gt;
&lt;/div&gt;
&lt;div [hidden]="authenticated()"&gt;
	&lt;p&gt;Login to see your greeting&lt;/p&gt;
&lt;/div&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since the user now has the choice whether to login or not (before it was all controlled by the browser), we need to distinguish in the UI between content that is secure and that which is not. We have anticipated this by adding references to an (as yet non-existent) <code>authenticated()</code> function.</p>
</div>
<div class="paragraph">
<p>The <code>HomeComponent</code> has to fetch the greeting, and also provide the <code>authenticated()</code> utility function that pulls the flag out of the <code>AppService</code>:</p>
</div>
<div class="listingblock">
<div class="title">
home.component.ts
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">import { Component, OnInit } from '@angular/core';
import { AppService } from './app.service';
import { HttpClient } from '@angular/common/http';

@Component({
  templateUrl: './home.component.html'
})
export class HomeComponent {

  title = 'Demo';
  greeting = {};

  constructor(private app: AppService, private http: HttpClient) {
    http.get('resource').subscribe(data =&gt; this.greeting = data);
  }

  authenticated() { return this.app.authenticated; }

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_the_login_form">The Login Form</h4>
<div class="paragraph">
<p>The login form also gets its own component:</p>
</div>
<div class="listingblock">
<div class="title">
login.component.html
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;div class="alert alert-danger" [hidden]="!error"&gt;
	There was a problem logging in. Please try again.
&lt;/div&gt;
&lt;form role="form" (submit)="login()"&gt;
	&lt;div class="form-group"&gt;
		&lt;label for="username"&gt;Username:&lt;/label&gt; &lt;input type="text"
			class="form-control" id="username" name="username" [(ngModel)]="credentials.username"/&gt;
	&lt;/div&gt;
	&lt;div class="form-group"&gt;
		&lt;label for="password"&gt;Password:&lt;/label&gt; &lt;input type="password"
			class="form-control" id="password" name="password" [(ngModel)]="credentials.password"/&gt;
	&lt;/div&gt;
	&lt;button type="submit" class="btn btn-primary"&gt;Submit&lt;/button&gt;
&lt;/form&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a very standard login form, with 2 inputs for username and password and a button for submitting the form via an Angular event handler <code>(submit)</code>. You don’t need an action on the form tag, so it’s probably better not to put one in at all. There is also an error message, shown only if the angular model contains an <code>error</code>. The form controls use <code>ngModel</code> from <a href="https://angular.io/guide/reactive-forms">Angular Forms</a> to pass data between the HTML and the Angular controller, and in this case we are using a <code>credentials</code> object to hold the username and pasword.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_authentication_process">The Authentication Process</h3>
<div class="paragraph">
<p>To support the login form we just added we need to add some more features. On the client side these will be implemented in the <code>LoginComponent</code>, and on the server it will be Spring Security configuration.</p>
</div>
<div class="sect3">
<h4 id="_submitting_the_login_form">Submitting the Login Form</h4>
<div class="paragraph">
<p>To submit the form we need to define the <code>login()</code> function that we referenced already in the form via <code>ng-submit</code>, and the <code>credentials</code> object that we referenced via <code>ng-model</code>. Let’s flesh out the "login" component:</p>
</div>
<div class="listingblock">
<div class="title">
login.component.ts
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">import { Component, OnInit } from '@angular/core';
import { AppService } from './app.service';
import { HttpClient } from '@angular/common/http';
import { Router } from '@angular/router';

@Component({
  templateUrl: './login.component.html'
})
export class LoginComponent {

  credentials = {username: '', password: ''};

  constructor(private app: AppService, private http: HttpClient, private router: Router) {
  }

  login() {
    this.app.authenticate(this.credentials, () =&gt; {
        this.router.navigateByUrl('/');
    });
    return false;
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In addition to initializing the <code>credentials</code> object, it defines the <code>login()</code> that we need in the form.</p>
</div>
<div class="paragraph">
<p>The <code>authenticate()</code> makes a GET to a relative resource (relative to the deployment root of your application) "/user". When called from the <code>login()</code> function it adds the Base64-encoded credentials in the headers so on the server it does an authentication and accepts a cookie in return. The <code>login()</code> function also sets a local <code>$scope.error</code> flag accordingly when we get the result of the authentication, which is used to control the display of the error message above the login form.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_currently_authenticated_user">The Currently Authenticated User</h4>
<div class="paragraph">
<p>To service the <code>authenticate()</code> function we need to add a new endpoint to the backend:</p>
</div>
<div class="listingblock">
<div class="title">
UiApplication.java
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@RestController
public class UiApplication {

  @RequestMapping("/user")
  public Principal user(Principal user) {
    return user;
  }

  ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a useful trick in a Spring Security application. If the "/user" resource is reachable then it will return the currently authenticated user (an <a href="https://github.com/spring-projects/spring-security/blob/master/core/src/main/java/org/springframework/security/core/Authentication.java"><code>Authentication</code></a>), and otherwise Spring Security will intercept the request and send a 401 response through an <a href="https://github.com/spring-projects/spring-security/blob/master/web/src/main/java/org/springframework/security/web/AuthenticationEntryPoint.java"><code>AuthenticationEntryPoint</code></a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_handling_the_login_request_on_the_server">Handling the Login Request on the Server</h4>
<div class="paragraph">
<p>Spring Security makes it easy to handle the login request. We just need to add some configuration to our <a href="https://github.com/dsyer/spring-security-angular/blob/master/single/src/main/java/demo/UiApplication.java">main application class</a> (e.g. as an inner class):</p>
</div>
<div class="listingblock">
<div class="title">
UiApplication.java
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@RestController
public class UiApplication {

  ...

  @Configuration
  @Order(SecurityProperties.ACCESS_OVERRIDE_ORDER)
  protected static class SecurityConfiguration extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
      http
        .httpBasic()
      .and()
        .authorizeRequests()
          .antMatchers("/index.html", "/", "/home", "/login").permitAll()
          .anyRequest().authenticated();
    }
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a standard Spring Boot application with Spring Security customization, just allowing anonymous access to the static (HTML) resources. The HTML resources need to be available to anonymous users, not just ignored by Spring Security, for reasons that will become clear.</p>
</div>
<div class="paragraph">
<p>The last thing we need to remember is to make the JavaScript components provided by Angular available anonymously to the application. We could do that in the <code>HttpSecurity</code> configuration above, but since it is static content, it’s better to simply ignore it:</p>
</div>
<div class="listingblock">
<div class="title">
application.yml
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-yaml" data-lang="yaml">security:
  ignored:
  - "*.bundle.*"</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_adding_default_http_request_headers">Adding Default HTTP Request Headers</h3>
<div class="paragraph">
<p>If you run the app at this point you will find that the browser pops up a Basic authentication dialogue (for user and password). It does this because it sees a 401 reponse from the XHR requests to <code>/user</code> and <code>/resource</code> with a "WWW-Authenticate" header. The way to suppress this popup is to suppress the header, which is coming from Spring Security. And the way to suppress the reponse header is to send a special, conventional request header "X-Requested-With=XMLHttpRequest". It used to be the default in Angular but they <a href="https://github.com/angular/angular.js/issues/1004">took it out in 1.3.0</a>. So here’s how to set default headers in an Angular XHR request.</p>
</div>
<div class="paragraph">
<p>First extend the default <code>RequestOptions</code> provided by the Angular HTTP module:</p>
</div>
<div class="listingblock">
<div class="title">
app.module.ts
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">@Injectable()
export class XhrInterceptor implements HttpInterceptor {

  intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler) {
    const xhr = req.clone({
      headers: req.headers.set('X-Requested-With', 'XMLHttpRequest')
    });
    return next.handle(xhr);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The syntax here is boilerplate. The <code>implements</code> property of the <code>Class</code> is its base class, and in addition to the constructor, all we really need to do is override the <code>intercept()</code> function which is always called by Angular and can be used to add additional headers.</p>
</div>
<div class="paragraph">
<p>To install this new <code>RequestOptions</code> factory we need to declare it in the <code>providers</code> of the <code>AppModule</code>:</p>
</div>
<div class="listingblock">
<div class="title">
app.module.ts
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">@NgModule({
  ...
  providers: [AppService, { provide: HTTP_INTERCEPTORS, useClass: XhrInterceptor, multi: true }],
  ...
})
export class AppModule { }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_logout">Logout</h3>
<div class="paragraph">
<p>The application is almost finished functionally. The last thing we need to do is implement the logout feature that we sketched in the home page. If the user is authenticated then we show a "logout" link and hook it to a <code>logout()</code> function in the <code>AppComponent</code>. Remember, it sends an HTTP POST to "/logout" which we now need to implement on the server. This is straightforward because it is added for us already by Spring Security (i.e. we don’t need to do anything for this simple use case). For more control over the behaviour of logout you could use the <code>HttpSecurity</code> callbacks in your <code>WebSecurityAdapter</code> to, for instance execute some business logic after logout.</p>
</div>
</div>
<div class="sect2">
<h3 id="_csrf_protection">CSRF Protection</h3>
<div class="paragraph">
<p>The application is almost ready to use, and in fact if you run it you will find that everything we built so far actually works except the logout link. Try using it and look at the responses in the browser and you will see why:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>POST /logout HTTP/1.1
...
Content-Type: application/x-www-form-urlencoded

username=user&amp;password=password

HTTP/1.1 403 Forbidden
Set-Cookie: JSESSIONID=3941352C51ABB941781E1DF312DA474E; Path=/; HttpOnly
Content-Type: application/json;charset=UTF-8
Transfer-Encoding: chunked
...

{"timestamp":1420467113764,"status":403,"error":"Forbidden","message":"Expected CSRF token not found. Has your session expired?","path":"/login"}</code></pre>
</div>
</div>
<div class="paragraph">
<p>That’s good because it means that Spring Security’s built-in CSRF protection has kicked in to prevent us from shooting ourselves in the foot. All it wants is a token sent to it in a header called "X-CSRF". The value of the CSRF token was available server side in the <code>HttpRequest</code> attributes from the initial request that loaded the home page. To get it to the client we could render it using a dynamic HTML page on the server, or expose it via a custom endpoint, or else we could send it as a cookie. The last choice is the best because Angular has <a href="https://angular.io/guide/http#security-xsrf-protection">built in support for CSRF</a> (which it calls "XSRF") based on cookies.</p>
</div>
<div class="paragraph">
<p>So on the server we need a custom filter that will send the cookie. Angular wants the cookie name to be "XSRF-TOKEN" and Spring Security provides it as a request attribute by default, so we just need to transfer the value from a request attribute to a cookie. Fortunately, Spring Security (since 4.1.0) provides a special <code>CsrfTokenRepository</code> that does precisely this:</p>
</div>
<div class="listingblock">
<div class="title">
UiApplication.java
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Configuration
@Order(SecurityProperties.ACCESS_OVERRIDE_ORDER)
protected static class SecurityConfiguration extends WebSecurityConfigurerAdapter {
  @Override
  protected void configure(HttpSecurity http) throws Exception {
    http
      ...
      .and().csrf()
        .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse());
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>With those changes in place we don’t need to do anything on the client side and the login form is now working.</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_does_it_work">How Does it Work?</h3>
<div class="paragraph">
<p>The interactions between the browser and the backend can be seen in your browser if you use some developer tools (usually F12 opens this up, works in Chrome by default, may require a plugin in Firefox). Here’s a summary:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Verb</th>
<th class="tableblock halign-left valign-top">Path</th>
<th class="tableblock halign-left valign-top">Status</th>
<th class="tableblock halign-left valign-top">Response</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">index.html</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/*.js</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Assets from angular</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/user</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">401</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Unauthorized (ignored)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/home</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Home page</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/user</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">401</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Unauthorized (ignored)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/resource</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">401</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Unauthorized (ignored)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/user</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Send credentials and get JSON</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/resource</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JSON greeting</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The responses that are marked "ignored" above are HTML responses received by Angular in an XHR call, and since we aren’t processing that data the HTML is dropped on the floor. We do look for an authenticated user in the case of the "/user" resource, but since it isn’t there in the first call, that response is dropped.</p>
</div>
<div class="paragraph">
<p>Look more closely at the requests and you will see that they all have cookies. If you start with a clean browser (e.g. incognito in Chrome), the very first request has no cookies going off to the server, but the server sends back "Set-Cookie" for "JSESSIONID" (the regular <code>HttpSession</code>) and "X-XSRF-TOKEN" (the CRSF cookie that we set up above). Subsequent requests all have those cookies, and they are important: the application doesn’t work without them, and they are providing some really basic security features (authentication and CSRF protection). The values of the cookies change when the user authenticates (after the POST) and this is another important security feature (preventing <a href="https://en.wikipedia.org/wiki/Session_fixation">session fixation attacks</a>).</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="Note"></i> </td>
<td class="content"> It is not adequate for CSRF protection to rely on a cookie being sent back to the server because the browser will automatically send it even if you are not in a page loaded from your application (a Cross Site Scripting attack, otherwise known as <a href="https://en.wikipedia.org/wiki/Cross-site_scripting">XSS</a>). The header is not automatically sent, so the origin is under control. You might see that in our application the CSRF token is sent to the client as a cookie, so we will see it being sent back automatically by the browser, but it is the header that provides the protection. </td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_help_how_is_my_application_going_to_scale">Help, How is My Application Going to Scale?</h3>
<div class="paragraph">
<p>"But wait…​" you are saying, "isn’t it Really Bad to use session state in a single-page application?" The answer to that question is going to have to be "mostly", because it very definitely is a Good Thing to use the session for authentication and CSRF protection. That state has to be stored somewhere, and if you take it out of the session, you are going to have to put it somewhere else and manage it manually yourself, on both the server and the client. That’s just more code and probably more maintenance, and generally re-inventing a perfectly good wheel.</p>
</div>
<div class="paragraph">
<p>"But, but…​" you are going to respond, "how do I scale my application horizontally now?" This is the "real" question you were asking above, but it tends to get shortened to "session state is bad, I must be stateless". Don’t panic. The main point to take on board here is that security <em>is</em> stateful. You can’t have a secure, stateless application. So where are you going to store the state? That’s all there is to it. <a href="https://spring.io/team/rwinch">Rob Winch</a> gave a very useful and insightful talk at <a href="https://skillsmatter.com/skillscasts/5398-the-state-of-securing-restful-apis-with-spring">Spring Exchange 2014</a> explaining the need for state (and the ubiquity of it - TCP and SSL are stateful, so your system is stateful whether you knew it or not), which is probably worth a look if you want to look into this topic in more depth.</p>
</div>
<div class="paragraph">
<p>The good news is you have a choice. The easiest choice is to store the session data in-memory, and rely on sticky sessions in your load balancer to route requests from the same session back to the same JVM (they all support that somehow). That’s good enough to get you off the ground and will work for a <em>really</em> large number of use cases. The other choice is to share the session data between instances of your application. As long as you are strict and only store the security data, it is small and changes infrequently (only when users log in and out, or their session times out), so there shouldn’t be any major infrastructure problems. It’s also really easy to do with <a href="https://github.com/spring-projects/spring-session/">Spring Session</a>. We’ll be using Spring Session in the next section in this series, so there’s no need to go into any detail about how to set it up here, but it is literally a few lines of code and a Redis server, which is super fast.</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-tip" title="Tip"></i> </td>
<td class="content"> Another easy way to set up shared session state is to deploy your application as a WAR file to Cloud Foundry <a href="https://run.pivotal.io">Pivotal Web Services</a> and bind it to a Redis service. </td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_but_what_about_my_custom_token_implementation_its_stateless_look">But, What about My Custom Token Implementation (it’s Stateless, Look)?</h3>
<div class="paragraph">
<p>If that was your response to the last section, then read it again because maybe you didn’t get it the first time. It’s probably not stateless if you stored the token somewhere, but even if you didn’t (e.g. you use JWT encoded tokens), how are you going to provide CSRF protection? It’s important. Here’s a rule of thumb (attributed to Rob Winch): if your application or API is going to be accessed by a browser, you need CSRF protection. It’s not that you can’t do it without sessions, it’s just that you’d have to write all that code yourself, and what would be the point because it’s already implemented and works perfectly well on top of <code>HttpSession</code> (which in turn is part of the container you are using and baked into specs since the very beginning)? Even if you decide you don’t need CSRF, and have a perfectly "stateless" (non-session based) token implementation, you still had to write extra code in the client to consume and use it, where you could have just delegated to the browser and server’s own built-in features: the browser always sends cookies, and the server always has a session (unless you switch it off). That code is not business logic, and it isn’t making you any money, it’s just an overhead, so even worse, it costs you money.</p>
</div>
</div>
<div class="sect2">
<h3 id="_conclusion">Conclusion</h3>
<div class="paragraph">
<p>The application we have now is close to what a user might expect in a "real" application in a live environment, and it probably could be used as a template for building out into a more feature rich application with that architecture (single server with static content and JSON resources). We are using the <code>HttpSession</code> for storing security data, relying on our clients to respect and use the cookies we send them, and we are comfortable with that because it lets us concentrate on our own business domain. In the <a href="#_the_resource_server_angular_js_and_spring_security_part_iii">next section</a> we expand the architecture to a separate authentication and UI server, plus a standalone resource server for the JSON. This is obviously easily generalised to multiple resource servers. We are also going to introduce Spring Session into the stack and show how that can be used to share authentication data.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_resource_server_angular_js_and_spring_security_part_iii">The Resource Server</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this section we continue <a href="#_the_login_page_angular_js_and_spring_security_part_ii">our discussion</a> of how to use <a href="https://projects.spring.io/spring-security">Spring Security</a> with <a href="https://angular.io">Angular</a> in a "single page application". Here we start by breaking out the "greeting" resource that we are using as the dynamic content in our application into a separate server, first as an unprotected resource, and then protected by an opaque token. This is the third in a series of sections, and you can catch up on the basic building blocks of the application or build it from scratch by reading the <a href="#_spring_and_angular_js_a_secure_single_page_application">first section</a>, or you can just go straight to the source code in Github, which is in two parts: one where the <a href="https://github.com/dsyer/spring-security-angular/tree/master/vanilla">resource is unprotected</a>, and one where it is <a href="https://github.com/dsyer/spring-security-angular/tree/master/spring-session">protected by a token</a>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-tip" title="Tip"></i> </td>
<td class="content"> if you are working through this section with the sample application, be sure to clear your browser cache of cookies and HTTP Basic credentials. In Chrome the best way to do that for a single server is to open a new incognito window. </td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_a_separate_resource_server">A Separate Resource Server</h3>
<div class="sect3">
<h4 id="_client_side_changes">Client Side Changes</h4>
<div class="paragraph">
<p>On the client side there isn’t very much to do to move the resource to a different backend. Here’s the "home" component in the <a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/blob/master/single/src/app/home/component.ts">last section</a>:</p>
</div>
<div class="listingblock">
<div class="title">
home.component.ts
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">@Component({
  templateUrl: './home.component.html'
})
export class HomeComponent {

  title = 'Demo';
  greeting = {};

  constructor(private app: AppService, private http: HttpClient) {
    http.get('resource').subscribe(data =&gt; this.greeting = data);
  }

  authenticated() { return this.app.authenticated; }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>All we need to do to this is change the URL. For example, if we are going to run the new resource on localhost, it could look like this:</p>
</div>
<div class="listingblock">
<div class="title">
home.component.ts
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">        http.get('http://localhost:9000').subscribe(data =&gt; this.greeting = data);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_server_side_changes">Server Side Changes</h4>
<div class="paragraph">
<p>The <a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/blob/master/vanilla/ui/src/main/java/demo/UiApplication.java">UI server</a> is trivial to change: we just need to remove the <code>@RequestMapping</code> for the greeting resource (it was "/resource"). Then we need to create a new resource server, which we can do like we did in the <a href="#_spring_and_angular_js_a_secure_single_page_application">first section</a> using the <a href="https://start.spring.io">Spring Boot Initializr</a>. E.g. using curl on a UN*X like system:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ mkdir resource &amp;&amp; cd resource
$ curl https://start.spring.io/starter.tgz -d style=web \
-d name=resource | tar -xzvf -</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can then import that project (it’s a normal Maven Java project by default) into your favourite IDE, or just work with the files and "mvn" on the command line.</p>
</div>
<div class="paragraph">
<p>Just add a <code>@RequestMapping</code> to the <a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/blob/master/vanilla/resource/src/main/java/demo/ResourceApplication.java">main application class</a>, copying the implementation from the <a href="https://github.com/dsyer/spring-security-angular/blob/master/single/src/main/java/demo/UiApplication.java">old UI</a>:</p>
</div>
<div class="listingblock">
<div class="title">
ResourceApplication.java
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@RestController
class ResourceApplication {

  @RequestMapping("/")
  public Message home() {
    return new Message("Hello World");
  }

  public static void main(String[] args) {
    SpringApplication.run(ResourceApplication.class, args);
  }

}

class Message {
  private String id = UUID.randomUUID().toString();
  private String content;
  public Message(String content) {
    this.content = content;
  }
  // ... getters and setters and default constructor
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once that is done your application will be loadable in a browser. On the command line you can do this</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ mvn spring-boot:run -Dserver.port=9000</code></pre>
</div>
</div>
<div class="paragraph">
<p>and go to a browser at <a href="http://localhost:9000">http://localhost:9000</a> and you should see JSON with a greeting. You can bake in the port change in <code>application.properties</code> (in"src/main/resources"):</p>
</div>
<div class="listingblock">
<div class="title">
application.properties
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-properties" data-lang="properties">server.port: 9000</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you try loading that resource from the UI (on port 8080) in a browser, you will find that it doesn’t work because the browser won’t allow the XHR request.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_cors_negotiation">CORS Negotiation</h3>
<div class="paragraph">
<p>The browser tries to negotiate with our resource server to find out if it is allowed to access it according to the <a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing">Cross Origin Resource Sharing</a> protocol. It’s not an Angular responsibility, so just like the cookie contract it will work like this with all JavaScript in the browser. The two servers do not declare that they have a common origin, so the browser declines to send the request and the UI is broken.</p>
</div>
<div class="paragraph">
<p>To fix that we need to support the CORS protocol which involves a "pre-flight" OPTIONS request and some headers to list the allowed behaviour of the caller. Spring 4.2 has some nice <a href="https://jira.spring.io/browse/SPR-9278">fine-grained CORS support</a>, so we can just add an annotation to our controller mapping, for example:</p>
</div>
<div class="listingblock">
<div class="title">
ResourceApplication.java
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@RequestMapping("/")
@CrossOrigin(origins="*", maxAge=3600)
public Message home() {
  return new Message("Hello World");
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="Note"></i> </td>
<td class="content"> Blithely using <code>origins=*</code> is quick and dirty, and it works, but it is not not secure and is not in any way recommended. </td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_securing_the_resource_server">Securing the Resource Server</h3>
<div class="paragraph">
<p>Great! We have a working application with a new architecture. The only problem is that the resource server has no security.</p>
</div>
<div class="sect3">
<h4 id="_adding_spring_security">Adding Spring Security</h4>
<div class="paragraph">
<p>We can also look at how to add security to the resource server as a filter layer, like in the UI server. The first step is really easy: just add Spring Security to the classpath in the Maven POM:</p>
</div>
<div class="listingblock">
<div class="title">
pom.xml
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
  &lt;/dependency&gt;
  ...
&lt;/dependencies&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Re-launch the resource server and, hey presto! It’s secure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ curl -v localhost:9000
&lt; HTTP/1.1 302 Found
&lt; Location: http://localhost:9000/login
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>We are getting a redirect to a (whitelabel) login page because curl is not sending the same headers that our Angular client will. Modifying the command to send more similar headers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ curl -v -H "Accept: application/json" \
    -H "X-Requested-With: XMLHttpRequest" localhost:9000
&lt; HTTP/1.1 401 Unauthorized
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>So all we need to do is teach the client to send credentials with every request.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_token_authentication">Token Authentication</h3>
<div class="paragraph">
<p>The internet, and people’s Spring backend projects, are littered with custom token-based authentication solutions. Spring Security provides a barebones <code>Filter</code> implementation to get you started on your own (see for example <a href="https://github.com/spring-projects/spring-security/blob/master/web/src/main/java/org/springframework/security/web/authentication/preauth/AbstractPreAuthenticatedProcessingFilter.java"><code>AbstractPreAuthenticatedProcessingFilter</code></a> and <a href="https://github.com/spring-projects/spring-security/blob/master/core/src/main/java/org/springframework/security/core/token/TokenService.java"><code>TokenService</code></a>). There is no canonical implementation in Spring Security though, and one of the reasons why is probably that there’s an easier way.</p>
</div>
<div class="paragraph">
<p>Remember from <a href="#_the_login_page_angular_js_and_spring_security_part_ii">Part II</a> of this series that Spring Security uses the <code>HttpSession</code> to store authentication data by default. It doesn’t interact directly with the session though: there’s an abstraction layer (<a href="https://github.com/spring-projects/spring-security/blob/master/web/src/main/java/org/springframework/security/web/context/SecurityContextRepository.java"><code>SecurityContextRepository</code></a>) in between that you can use to change the storage backend. If we can point that repository, in our resource server, to a store with an authentication verified by our UI, then we have a way to share authentication between the two servers. The UI server already has such a store (the <code>HttpSession</code>), so if we can distribute that store and open it up to the resource server, we have most of a solution.</p>
</div>
<div class="sect3">
<h4 id="_spring_session">Spring Session</h4>
<div class="paragraph">
<p>That part of the solution is pretty easy with <a href="https://github.com/spring-projects/spring-session/">Spring Session</a>. All we need is a shared data store (Redis and JDBC are supported out of the box), and a few lines of configuration in the servers to set up a <code>Filter</code>.</p>
</div>
<div class="paragraph">
<p>In the UI application we need to add some dependencies to our <a href="https://github.com/dsyer/spring-security-angular/blob/master/spring-session/ui/pom.xml">POM</a>:</p>
</div>
<div class="listingblock">
<div class="title">
pom.xml
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;
  &lt;artifactId&gt;spring-session&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Boot and Spring Session work together to connect to Redis and store session data centrally.</p>
</div>
<div class="paragraph">
<p>With that 1 line of code in place and a Redis server running on localhost you can run the UI application, login with some valid user credentials, and the session data (the authentication) will be stored in redis.</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-tip" title="Tip"></i> </td>
<td class="content"> if you don’t have a redis server running locally you can easily spin one up with <a href="https://www.docker.com/">Docker</a> (on Windows or MacOS this requires a VM). There is a <a href="https://docs.docker.com/compose/"><code>docker-compose.yml</code></a> file in the <a href="https://github.com/dsyer/spring-security-angular/tree/master/spring-session/docker-compose.yml">source code in Github</a> which you can run really easily on the command line with <code>docker-compose up</code>. If you do this in a VM the Redis server will be running on a different host than localhost, so you either need to tunnel it onto localhost, or configure the app to point at the correct <code>spring.redis.host</code> in your <code>application.properties</code>. </td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sending_a_custom_token_from_the_ui">Sending a Custom Token from the UI</h3>
<div class="paragraph">
<p>The only missing piece is the transport mechanism for the key to the data in the store. The key is the <code>HttpSession</code> ID, so if we can get hold of that key in the UI client, we can send it as a custom header to the resource server. So the "home" controller would need to change so that it sends the header as part of the HTTP request for the greeting resource. For example:</p>
</div>
<div class="listingblock">
<div class="title">
home.component.ts
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">  constructor(private app: AppService, private http: HttpClient) {
    http.get('token').subscribe(data =&gt; {
      const token = data['token'];
      http.get('http://localhost:9000', {headers : new HttpHeaders().set('X-Auth-Token', token)})
        .subscribe(response =&gt; this.greeting = response);
    }, () =&gt; {});
  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>(A more elegant solution might be to grab the token as needed, and use our <code>RequestOptionsService</code> to add the header to every request to the resource server.)</p>
</div>
<div class="paragraph">
<p>Instead of going directly to "http://localhost:9000[<a href="http://localhost:9000" class="bare">http://localhost:9000</a>]" we have wrapped that call in the success callback of a call to a new custom endpoint on the UI server at "/token". The implementation of that is trivial:</p>
</div>
<div class="listingblock">
<div class="title">
UiApplication.java
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@RestController
public class UiApplication {

  public static void main(String[] args) {
    SpringApplication.run(UiApplication.class, args);
  }

  ...

  @RequestMapping("/token")
  public Map&lt;String,String&gt; token(HttpSession session) {
    return Collections.singletonMap("token", session.getId());
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>So the UI application is ready and will include the session ID in a header called "X-Auth-Token" for all calls to the backend.</p>
</div>
</div>
<div class="sect2">
<h3 id="_authentication_in_the_resource_server">Authentication in the Resource Server</h3>
<div class="paragraph">
<p>There is one tiny change to the resource server for it to be able to accept the custom header. The CORS configuration has to nominate that header as an allowed one from remote clients, e.g.</p>
</div>
<div class="listingblock">
<div class="title">
ResourceApplication.java
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@RequestMapping("/")
@CrossOrigin(origins = "*", maxAge = 3600,
    allowedHeaders={"x-auth-token", "x-requested-with", "x-xsrf-token"})
public Message home() {
  return new Message("Hello World");
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The pre-flight check from the browser will now be handled by Spring MVC, but we need to tell Spring Security that it is allowed to let it through:</p>
</div>
<div class="listingblock">
<div class="title">
ResourceApplication.java
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public class ResourceApplication extends WebSecurityConfigurerAdapter {

  @Override
  protected void configure(HttpSecurity http) throws Exception {
    http.cors().and().authorizeRequests()
      .anyRequest().authenticated();
  }

  ...</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="Note"></i> </td>
<td class="content"> There is no need to <code>permitAll()</code> access to all resources, and there might be a handler that inadvertently sends sensitive data because it is not aware that the request is pre-flight. The <code>cors()</code> configuration utility mitigates this by handling all pre-flight requests in the filter layer. </td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>All that remains is to pick up the custom token in the resource server and use it to authenticate our user. This turns out to be pretty straightforward because all we need to do is tell Spring Security where the session repository is, and where to look for the token (session ID) in an incoming request. First we need to add the Spring Session and Redis dependencies, and then we can set up the <code>Filter</code>:</p>
</div>
<div class="listingblock">
<div class="title">
ResourceApplication.java
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@RestController
class ResourceApplication {

  ...

  @Bean
  HeaderHttpSessionStrategy sessionStrategy() {
    return new HeaderHttpSessionStrategy();
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This <code>Filter</code> created is the mirror image of the one in the UI server, so it establishes Redis as the session store. The only difference is that it uses a custom <code>HttpSessionStrategy</code> that looks in the header ("X-Auth-Token" by default) instead of the default (cookie named "JSESSIONID"). We also need to prevent the browser from popping up a dialog in an unauthenticated client - the app is secure but sends a 401 with <code>WWW-Authenticate: Basic</code> by default, so the browser responds with a dialog for username and password. There is more than one way to achieve this, but we already made Angular send an "X-Requested-With" header, so Spring Security handles it for us by default.</p>
</div>
<div class="paragraph">
<p>There is one final change to the resource server to make it work with our new authentication scheme. Spring Boot default security is stateless, and we want this to store authentication in the session, so we need to be explicit in <code>application.yml</code> (or <code>application.properties</code>):</p>
</div>
<div class="listingblock">
<div class="title">
application.yml
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-yaml" data-lang="yaml">security:
  sessions: NEVER</code></pre>
</div>
</div>
<div class="paragraph">
<p>This says to Spring Security "never create a session, but use one if it is there" (it will already be there because of the authentication in the UI).</p>
</div>
<div class="paragraph">
<p>Re-launch the resource server and open the UI up in a new browser window.</p>
</div>
</div>
<div class="sect2">
<h3 id="_why_doesnt_it_all_work_with_cookies">Why Doesn’t it All Work With Cookies?</h3>
<div class="paragraph">
<p>We had to use a custom header and write code in the client to populate the header, which isn’t terribly complicated, but it seems to contradict the advice in <a href="#_the_login_page_angular_js_and_spring_security_part_ii">Part II</a> to use cookies and sessions wherever possible. The argument there was that not to do so introduces additional unecessary complexity, and for sure the implementation we have now is the most complex we have seen so far: the technical part of the solution far outweighs the business logic (which is admittedly tiny). This is definitely a fair criticism (and one we plan to address in the next section in this series), but let’s just briefly look at why it’s not as simple as just using cookies and sessions for everything.</p>
</div>
<div class="paragraph">
<p>At least we are still using the session, which makes sense because Spring Security and the Servlet container know how to do that with no effort on our part. But couldn’t we have continued to use cookies to transport the authentication token? It would have been nice, but there is a reason it wouldn’t work, and that is that the browser wouldn’t let us. You can just go poking around in the browser’s cookie store from a JavaScript client, but there are some restrictions, and for good reason. In particular you don’t have access to the cookies that were sent by the server as "HttpOnly" (which you will see is the case by default for session cookies). You also can’t set cookies in outgoing requests, so we couldn’t set a "SESSION" cookie (which is the Spring Session default cookie name), we had to use a custom "X-Session" header. Both these restrictions are for your own protection so malicious scripts cannot access your resources without proper authorization.</p>
</div>
<div class="paragraph">
<p>TL;DR the UI and resource servers do not have a common origin, so they cannot share cookies (even though we can use Spring Session to force them to share sessions).</p>
</div>
</div>
<div class="sect2">
<h3 id="_conclusion_2">Conclusion</h3>
<div class="paragraph">
<p>We have duplicated the features of the application in <a href="#_the_login_page_angular_js_and_spring_security_part_ii">Part II of this series</a>: a home page with a greeting fetched from a remote backend, with login and logout links in a navigation bar. The difference is that the greeting comes from a resource server that is a standalone, instead of being embedded in the UI server. This added significant complexity to the implementation, but the good news is that we have a mostly configuration-based (and practically 100% declarative) solution. We could even make the solution 100% declarative by extracting all the new code into libraries (Spring configuration and Angular custom directives). We are going to defer that interesting task for after the next couple of installments. In the <a href="#_the_api_gateway_pattern_angular_js_and_spring_security_part_iv">next section</a> we are going to look at a different really great way to reduce all the complexity in the current implementation: the API Gateway Pattern (the client sends all its requests to one place and authentication is handled there).</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="Note"></i> </td>
<td class="content"> We used Spring Session here to share sessions between 2 servers that are not logically the same application. It’s a neat trick, and it isn’t possible with "regular" JEE distributed sessions. </td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_api_gateway_pattern_angular_js_and_spring_security_part_iv">The API Gateway</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this section we continue <a href="#_the_resource_server_angular_js_and_spring_security_part_iii">our discussion</a> of how to use <a href="https://projects.spring.io/spring-security">Spring Security</a> with <a href="https://angular.io">Angular</a> in a "single page application". Here we show how to build an API Gateway to control the authentication and access to the backend resources using <a href="https://projects.spring.io/spring-cloud/">Spring Cloud</a>. This is the fourth in a series of sections, and you can catch up on the basic building blocks of the application or build it from scratch by reading the <a href="#_spring_and_angular_js_a_secure_single_page_application">first section</a>, or you can just go straight to the <a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/tree/master/proxy">source code in Github</a>. In the <a href="#_the_resource_server_angular_js_and_spring_security_part_iii">last section</a> we built a simple distributed application that used <a href="https://github.com/spring-projects/spring-session/">Spring Session</a> to authenticate the backend resources. In this one we make the UI server into a reverse proxy to the backend resource server, fixing the issues with the last implementation (technical complexity introduced by custom token authentication), and giving us a lot of new options for controlling access from the browser client.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Reminder: if you are working through this section with the sample application, be sure to clear your browser cache of cookies and HTTP Basic credentials. In Chrome the best way to do that for a single server is to open a new incognito window.</p>
</div>
</blockquote>
</div>
<div class="sect2">
<h3 id="_creating_an_api_gateway">Creating an API Gateway</h3>
<div class="paragraph">
<p>An API Gateway is a single point of entry (and control) for front end clients, which could be browser based (like the examples in this section) or mobile. The client only has to know the URL of one server, and the backend can be refactored at will with no change, which is a significant advantage. There are other advantages in terms of centralization and control: rate limiting, authentication, auditing and logging. And implementing a simple reverse proxy is really simple with <a href="https://projects.spring.io/spring-cloud/">Spring Cloud</a>.</p>
</div>
<div class="paragraph">
<p>If you were following along in the code, you will know that the application implementation at the end of the <a href="#_the_resource_server_angular_js_and_spring_security_part_iii">last section</a> was a bit complicated, so it’s not a great place to iterate away from. There was, however, a halfway point which we could start from more easily, where the backend resource wasn’t yet secured with Spring Security. The source code for this is a separate project <a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/tree/master/vanilla">in Github</a> so we are going to start from there. It has a UI server and a resource server and they are talking to each other. The resource server doesn’t have Spring Security yet so we can get the system working first and then add that layer.</p>
</div>
<div class="sect3">
<h4 id="_declarative_reverse_proxy_in_one_line">Declarative Reverse Proxy in One Line</h4>
<div class="paragraph">
<p>To turn it into an API Gateway, the UI server needs one small tweak. Somewhere in the Spring configuration we need to add an <code>@EnableZuulProxy</code> annotation, e.g. in the main (only) <a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/blob/master/proxy/ui/src/main/java/demo/UiApplication.java">application class</a>:</p>
</div>
<div class="listingblock">
<div class="title">
UiApplication.java
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@RestController
@EnableZuulProxy
public class UiApplication {
  ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and in an external configuration file we need to map a local resource in the UI server to a remote one in the <a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/blob/master/proxy/ui/src/main/resources/application.yml">external configuration</a> ("application.yml"):</p>
</div>
<div class="listingblock">
<div class="title">
application.yml
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-yaml" data-lang="yaml">security:
  ...
zuul:
  routes:
    resource:
      path: /resource/**
      url: http://localhost:9000</code></pre>
</div>
</div>
<div class="paragraph">
<p>This says "map paths with the pattern /resource/** in this server to the same paths in the remote server at localhost:9000". Simple and yet effective (OK so it’s 6 lines including the YAML, but you don’t always need that)!</p>
</div>
<div class="paragraph">
<p>All we need to make this work is the right stuff on the classpath. For that purpose we have a few new lines in our Maven POM:</p>
</div>
<div class="listingblock">
<div class="title">
pom.xml
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;dependencyManagement&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
      &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
      &lt;version&gt;Dalston.SR4&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
      &lt;scope&gt;import&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;

&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;
  &lt;/dependency&gt;
  ...
&lt;/dependencies&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note the use of the "spring-cloud-starter-zuul" - it’s a starter POM just like the Spring Boot ones, but it governs the dependencies we need for this Zuul proxy. We are also using <code>&lt;dependencyManagement&gt;</code> because we want to be able to depend on all the versions of transitive dependencies being correct.</p>
</div>
</div>
<div class="sect3">
<h4 id="_consuming_the_proxy_in_the_client">Consuming the Proxy in the Client</h4>
<div class="paragraph">
<p>With those changes in place our application still works, but we haven’t actually used the new proxy yet until we modify the client. Fortunately that’s trivial. We just need to revert the change we made going from the "single" to the "vanilla" samples in <a href="#_the_resource_server_angular_js_and_spring_security_part_iii">the last section</a>:</p>
</div>
<div class="listingblock">
<div class="title">
home.component.ts
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">constructor(private app: AppService, private http: HttpClient) {
  http.get('resource').subscribe(data =&gt; this.greeting = data);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now when we fire up the servers everything is working and the requests are being proxied through the UI (API Gateway) to the resource server.</p>
</div>
</div>
<div class="sect3">
<h4 id="_further_simplifications">Further Simplifications</h4>
<div class="paragraph">
<p>Even better: we don’t need the CORS filter any more in the resource server. We threw that one together pretty quickly anyway, and it should have been a red light that we had to do anything as technically focused by hand (especially where it concerns security). Fortunately it is now redundant, so we can just throw it away, and go back to sleeping at night!</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_securing_the_resource_server_2">Securing the Resource Server</h3>
<div class="paragraph">
<p>You might remember in the intermediate state that we started from there is no security in place for the resource server.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Aside: Lack of software security might not even be a problem if your network architecture mirrors the application architecture (you can just make the resource server physically inaccessible to anyone but the UI server). As a simple demonstration of that we can make the resource server only accessible on localhost. Just add this to <code>application.properties</code> in the resource server:</p>
</div>
</blockquote>
</div>
<div class="listingblock">
<div class="title">
application.properties
</div>
<div class="content">
<pre class="prettyprint highlight"><code>server.address: 127.0.0.1</code></pre>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Wow, that was easy! Do that with a network address that’s only visible in your data center and you have a security solution that works for all resource servers and all user desktops.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Suppose that we decide we do need security at the software level (quite likely for a number of reasons). That’s not going to be a problem, because all we need to do is add Spring Security as a dependency (in the <a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/blob/master/proxy/resource/pom.xml">resource server POM</a>):</p>
</div>
<div class="listingblock">
<div class="title">
pom.xml
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>That’s enough to get us a secure resource server, but it won’t get us a working application yet, for the same reason that it didn’t in <a href="#_the_resource_server_angular_js_and_spring_security_part_iii">Part III</a>: there is no shared authentication state between the two servers.</p>
</div>
</div>
<div class="sect2">
<h3 id="_sharing_authentication_state">Sharing Authentication State</h3>
<div class="paragraph">
<p>We can use the same mechanism to share authentication (and CSRF) state as we did in the last, i.e. <a href="https://github.com/spring-projects/spring-session/">Spring Session</a>. We add the dependency to both servers as before:</p>
</div>
<div class="listingblock">
<div class="title">
pom.xml
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;
  &lt;artifactId&gt;spring-session&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>but this time the configuration is much simpler because we can just add the same <code>Filter</code> declaration to both. First the UI server, declaring explicitly that we want all headers to be forwarded (i.e. none are "sensitive"):</p>
</div>
<div class="listingblock">
<div class="title">
application.yml
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-properties" data-lang="properties">zuul:
  routes:
    resource:
      sensitive-headers:</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then we can move on to the resource server. There are two small changes to make: one is to explicitly disable HTTP Basic in the resource server (to prevent the browser from popping up authentication dialogs):</p>
</div>
<div class="listingblock">
<div class="title">
ResourceApplication.java
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@RestController
class ResourceApplication extends WebSecurityConfigurerAdapter {

  ...

  @Override
  protected void configure(HttpSecurity http) throws Exception {
    http.httpBasic().disable();
    http.authorizeRequests().anyRequest().authenticated();
  }

}</code></pre>
</div>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Aside: an alternative, which would also prevent the authentication dialog, would be to keep HTTP Basic but change the 401 challenge to something other than "Basic". You can do that with a one-line implementation of <code>AuthenticationEntryPoint</code> in the <code>HttpSecurity</code> configuration callback.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>and the other is to explicitly ask for a non-stateless session creation policy in <code>application.properties</code>:</p>
</div>
<div class="listingblock">
<div class="title">
application.properties
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-properties" data-lang="properties">security.sessions: NEVER</code></pre>
</div>
</div>
<div class="paragraph">
<p>As long as redis is still running in the background (use the <a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/tree/master/proxy/docker-compose.yml"><code>docker-compose.yml</code></a> if you like to start it) then the system will work. Load the homepage for the UI at <a href="http://localhost:8080">http://localhost:8080</a> and login and you will see the message from the backend rendered on the homepage.</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_does_it_work_2">How Does it Work?</h3>
<div class="paragraph">
<p>What is going on behind the scenes now? First we can look at the HTTP requests in the UI server (and API Gateway):</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Verb</th>
<th class="tableblock halign-left valign-top">Path</th>
<th class="tableblock halign-left valign-top">Status</th>
<th class="tableblock halign-left valign-top">Response</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">index.html</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/*.js</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Assets form angular</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/user</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">401</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Unauthorized (ignored)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/resource</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">401</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Unauthenticated access to resource</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/user</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JSON authenticated user</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/resource</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(Proxied) JSON greeting</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>That’s identical to the sequence at the end of <a href="#_the_login_page_angular_js_and_spring_security_part_ii">Part II</a> except for the fact that the cookie names are slightly different ("SESSION" instead of "JSESSIONID") because we are using Spring Session. But the architecture is different and that last request to "/resource" is special because it was proxied to the resource server.</p>
</div>
<div class="paragraph">
<p>We can see the reverse proxy in action by looking at the "/trace" endpoint in the UI server (from Spring Boot Actuator, which we added with the Spring Cloud dependencies). Go to <a href="http://localhost:8080/trace">http://localhost:8080/trace</a> in a new browser (if you don’t have one already get a JSON plugin for your browser to make it nice and readable). You will need to authenticate with HTTP Basic (browser popup), but the same credentials are valid as for your login form. At or near the start you should see a pair of requests something like this:</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="Note"></i> </td>
<td class="content"> Try to use a different browser so that there is no chance of authentication crossover (e.g. use Firefox if yoused Chrome for testing the UI) - it won’t stop the app from working, but it will make the traces harder to read if they contain a mixture of authentication from the same browser. </td>
</tr>
</tbody>
</table>
</div>
<div class="listingblock">
<div class="title">
/trace
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">{
  "timestamp": 1420558194546,
  "info": {
    "method": "GET",
    "path": "/",
    "query": ""
    "remote": true,
    "proxy": "resource",
    "headers": {
      "request": {
        "accept": "application/json, text/plain, */*",
        "x-xsrf-token": "542c7005-309c-4f50-8a1d-d6c74afe8260",
        "cookie": "SESSION=c18846b5-f805-4679-9820-cd13bd83be67; XSRF-TOKEN=542c7005-309c-4f50-8a1d-d6c74afe8260",
        "x-forwarded-prefix": "/resource",
        "x-forwarded-host": "localhost:8080"
      },
      "response": {
        "Content-Type": "application/json;charset=UTF-8",
        "status": "200"
      }
    },
  }
},
{
  "timestamp": 1420558200232,
  "info": {
    "method": "GET",
    "path": "/resource/",
    "headers": {
      "request": {
        "host": "localhost:8080",
        "accept": "application/json, text/plain, */*",
        "x-xsrf-token": "542c7005-309c-4f50-8a1d-d6c74afe8260",
        "cookie": "SESSION=c18846b5-f805-4679-9820-cd13bd83be67; XSRF-TOKEN=542c7005-309c-4f50-8a1d-d6c74afe8260"
      },
      "response": {
        "Content-Type": "application/json;charset=UTF-8",
        "status": "200"
      }
    }
  }
},</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second entry there is the request from the client to the gateway on "/resource" and you can see the cookies (added by the browser) and the CSRF header (added by Angular as discussed in <a href="second">Part II</a>). The first entry has <code>remote: true</code> and that means it’s tracing the call to the resource server. You can see it went out to a uri path "/" and you can see that (crucially) the cookies and CSRF headers have been sent too. Without Spring Session these headers would be meaningless to the resource server, but the way we have set it up it can now use those headers to re-constitute a session with authentication and CSRF token data. So the request is permitted and we are in business!</p>
</div>
</div>
<div class="sect2">
<h3 id="_conclusion_3">Conclusion</h3>
<div class="paragraph">
<p>We covered quite a lot in this section but we got to a really nice place where there is a minimal amount of boilerplate code in our two servers, they are both nicely secure and the user experience isn’t compromised. That alone would be a reason to use the API Gateway pattern, but really we have only scratched the surface of what that might be used for (Netflix uses it for <a href="https://github.com/Netflix/zuul/wiki/How-We-Use-Zuul-At-Netflix">a lot of things</a>). Read up on <a href="https://projects.spring.io/spring-cloud/">Spring Cloud</a> to find out more on how to make it easy to add more features to the gateway. The <a href="#_sso_with_oauth2_angular_js_and_spring_security_part_v">next section</a> in this series will extend the application architecture a bit by extracting the authentication responsibilities to a separate server (the Single Sign On pattern).</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sso_with_oauth2_angular_js_and_spring_security_part_v">Single Sign On with OAuth2</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this section we continue <a href="#_the_api_gateway_pattern_angular_js_and_spring_security_part_iv">our discussion</a> of how to use <a href="https://projects.spring.io/spring-security">Spring Security</a> with <a href="https://angular.io">Angular</a> in a "single page application". Here we show how to use <a href="https://projects.spring.io/spring-security-oauth/">Spring Security OAuth</a> together with <a href="https://projects.spring.io/spring-cloud/">Spring Cloud</a> to extend our API Gateway to do Single Sign On and OAuth2 token authentication to backend resources. This is the fifth in a series of sections, and you can catch up on the basic building blocks of the application or build it from scratch by reading the <a href="#_spring_and_angular_js_a_secure_single_page_application">first section</a>, or you can just go straight to the <a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/tree/master/oauth2">source code in Github</a>. In the <a href="#_the_api_gateway_pattern_angular_js_and_spring_security_part_iv">last section</a> we built a small distributed application that used <a href="https://github.com/spring-projects/spring-session/">Spring Session</a> to authenticate the backend resources and <a href="https://projects.spring.io/spring-cloud/">Spring Cloud</a> to implement an embedded API Gateway in the UI server. In this section we extract the authentication responsibilities to a separate server to make our UI server the first of potentially many Single Sign On applications to the authorization server. This is a common pattern in many applications these days, both in the enterprise and in social startups. We will use an OAuth2 server as the authenticator, so that we can also use it to grant tokens for the backend resource server. Spring Cloud will automatically relay the access token to our backend, and enable us to further simplify the implementation of both the UI and resource servers.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Reminder: if you are working through this section with the sample application, be sure to clear your browser cache of cookies and HTTP Basic credentials. In Chrome the best way to do that for a single server is to open a new incognito window.</p>
</div>
</blockquote>
</div>
<div class="sect2">
<h3 id="_creating_an_oauth2_authorization_server">Creating an OAuth2 Authorization Server</h3>
<div class="paragraph">
<p>Our first step is to create a new server to handle authentication and token management. Following the steps in <a href="#_spring_and_angular_js_a_secure_single_page_application">Part I</a> we can begin with <a href="https://start.spring.io">Spring Boot Initializr</a>. E.g. using curl on a UN*X like system:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ curl https://start.spring.io/starter.tgz -d style=web \
-d style=security -d name=authserver | tar -xzvf -</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can then import that project (it’s a normal Maven Java project by default) into your favourite IDE, or just work with the files and "mvn" on the command line.</p>
</div>
<div class="sect3">
<h4 id="_adding_the_oauth2_dependencies">Adding the OAuth2 Dependencies</h4>
<div class="paragraph">
<p>We need to add the <a href="https://projects.spring.io/spring-security-oauth">Spring OAuth</a> dependencies, so in our <a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/blob/master/oauth2/authserver/pom.xml">POM</a> we add:</p>
</div>
<div class="listingblock">
<div class="title">
pom.xml
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.security.oauth&lt;/groupId&gt;
  &lt;artifactId&gt;spring-security-oauth2&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The authorization server is pretty easy to implement. A minimal version looks like this:</p>
</div>
<div class="listingblock">
<div class="title">
AuthserverApplication.java
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@EnableAuthorizationServer
public class AuthserverApplication extends WebMvcConfigurerAdapter {

  public static void main(String[] args) {
    SpringApplication.run(AuthserverApplication.class, args);
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We only have to do 1 more thing (after adding <code>@EnableAuthorizationServer</code>):</p>
</div>
<div class="listingblock">
<div class="title">
application.properties
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-properties" data-lang="properties">---
...
security.oauth2.client.clientId: acme
security.oauth2.client.clientSecret: acmesecret
security.oauth2.client.authorized-grant-types: authorization_code,refresh_token,password
security.oauth2.client.scope: openid
---</code></pre>
</div>
</div>
<div class="paragraph">
<p>This registers a client "acme" with a secret and some authorized grant types including "authorization_code".</p>
</div>
<div class="paragraph">
<p>Now let’s get it running on port 9999, with a predictable password for testing:</p>
</div>
<div class="listingblock">
<div class="title">
application.properties
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-properties" data-lang="properties">server.port=9999
security.user.password=password
server.contextPath=/uaa
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>We also set the context path so that it doesn’t use the default ("/") because otherwise you can get cookies for other servers on localhost being sent to the wrong server. So get the server running and we can make sure it is working:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ mvn spring-boot:run</code></pre>
</div>
</div>
<div class="paragraph">
<p>or start the <code>main()</code> method in your IDE.</p>
</div>
</div>
<div class="sect3">
<h4 id="_testing_the_authorization_server">Testing the Authorization Server</h4>
<div class="paragraph">
<p>Our server is using the Spring Boot default security settings, so like the server in <a href="#_spring_and_angular_js_a_secure_single_page_application">Part I</a> it will be protected by HTTP Basic authentication. To initiate an <a href="https://tools.ietf.org/html/rfc6749#section-1.3.1">authorization code token grant</a> you visit the authorization endpoint, e.g. at <a href="http://localhost:9999/uaa/oauth/authorize?response_type=code&amp;client_id=acme&amp;redirect_uri=http://example.com">http://localhost:9999/uaa/oauth/authorize?response_type=code&amp;client_id=acme&amp;redirect_uri=http://example.com</a> once you have authenticated you will get a redirect to example.com with an authorization code attached, e.g. <a href="http://example.com/?code=jYWioI">http://example.com/?code=jYWioI</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="Note"></i> </td>
<td class="content"> for the purposes of this sample application we have created a client "acme" with no registered redirect, which is what enables us to get a redirect the example.com. In a production application you should always register a redirect (and use HTTPS). </td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>The code can be exchanged for an access token using the "acme" client credentials on the token endpoint:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ curl acme:<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="442527292137212736213004282b2725282c2b3730">[email&#160;protected]</a>:9999/uaa/oauth/token  \
-d grant_type=authorization_code -d client_id=acme     \
-d redirect_uri=http://example.com -d code=jYWioI
{"access_token":"2219199c-966e-4466-8b7e-12bb9038c9bb","token_type":"bearer","refresh_token":"d193caf4-5643-4988-9a4a-1c03c9d657aa","expires_in":43199,"scope":"openid"}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The access token is a UUID ("2219199c…"), backed by an in-memory token store in the server. We also got a refresh token that we can use to get a new access token when the current one expires.</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="Note"></i> </td>
<td class="content"> since we allowed "password" grants for the "acme" client we can also get a token directly from the token endpoint using curl and user credentials instead of an authorization code. This is not suitable for a browser based client, but it’s useful for testing. </td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>If you followed the link above you would have seen the whitelabel UI provided by Spring OAuth. To start with we will use this and we can come back later to beef it up like we did in <a href="#_the_login_page_angular_js_and_spring_security_part_ii">Part II</a> for the self-contained server.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="changing-the-resource-server">Changing the Resource Server</h3>
<div class="paragraph">
<p>If we follow on from <a href="#_the_api_gateway_pattern_angular_js_and_spring_security_part_iv">Part IV</a>, our resource server is using <a href="https://github.com/spring-projects/spring-session/">Spring Session</a> for authentication, so we can take that out and replace it with Spring OAuth. We also need to remove the Spring Session and Redis dependencies, so replace this:</p>
</div>
<div class="listingblock">
<div class="title">
pom.xml
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;
  &lt;artifactId&gt;spring-session&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>with this:</p>
</div>
<div class="listingblock">
<div class="title">
pom.xml
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.security.oauth&lt;/groupId&gt;
  &lt;artifactId&gt;spring-security-oauth2&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>and then remove the session <code>Filter</code> from the <a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/blob/master/vanilla-oauth2/resource/src/main/java/demo/ResourceApplication.java">main application class</a>, replacing it with the convenient <code>@EnableResourceServer</code> annotation (from Spring Security OAuth2):</p>
</div>
<div class="listingblock">
<div class="title">
ResourceApplication.java
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@RestController
@EnableResourceServer
class ResourceApplication {

  @RequestMapping("/")
  public Message home() {
    return new Message("Hello World");
  }

  public static void main(String[] args) {
    SpringApplication.run(ResourceApplication.class, args);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>With that one change the app is ready to challenge for an access token instead of HTTP Basic, but we need a config change to actually finish the process. We are going to add a small amount of external configuration (in "application.properties") to allow the resource server to decode the tokens it is given and authenticate a user:</p>
</div>
<div class="listingblock">
<div class="title">
application.properties
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-properties" data-lang="properties">...
security.oauth2.resource.userInfoUri: http://localhost:9999/uaa/user</code></pre>
</div>
</div>
<div class="paragraph">
<p>This tells the server that it can use the token to access a "/user" endpoint and use that to derive authentication information (it’s a bit like the <a href="https://developers.facebook.com/docs/graph-api/reference/v2.2/user/?locale=en_GB">"/me" endpoint</a> in the Facebook API). Effectively it provides a way for the resource server to decode the token, as expressed by the <code>ResourceServerTokenServices</code> interface in Spring OAuth2.</p>
</div>
<div class="paragraph">
<p>Run the application and hit the home page with a command line client:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ curl -v localhost:9000
&gt; GET / HTTP/1.1
&gt; User-Agent: curl/7.35.0
&gt; Host: localhost:9000
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 401 Unauthorized
...
&lt; WWW-Authenticate: Bearer realm="null", error="unauthorized", error_description="An Authentication object was not found in the SecurityContext"
&lt; Content-Type: application/json;charset=UTF-8
{"error":"unauthorized","error_description":"An Authentication object was not found in the SecurityContext"}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and you will see a 401 with a "WWW-Authenticate" header indicating that it wants a bearer token.</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="Note"></i> </td>
<td class="content"> the <code>userInfoUri</code> is by far not the only way of hooking a resource server up with a way to decode tokens. In fact it’s sort of a lowest common denominator (and not part of the spec), but quite often available from OAuth2 providers (like Facebook, Cloud Foundry, Github), and other choices are available. For instance you can encode the user authentication in the token itself (e.g. with <a href="http://jwt.io/">JWT</a>), or use a shared backend store. There is also a <code>/token_info</code> endpoint in CloudFoundry, which provides more detailed information than the user info endpoint, but which requires more thorough authentication. Different options (naturally) provide different benefits and trade-offs, but a full discussion of those is outside the scope of this section. </td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_implementing_the_user_endpoint">Implementing the User Endpoint</h3>
<div class="paragraph">
<p>On the authorization server we can easily add that endpoint</p>
</div>
<div class="listingblock">
<div class="title">
AuthserverApplication.java
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@RestController
@EnableAuthorizationServer
@EnableResourceServer
public class AuthserverApplication {

  @RequestMapping("/user")
  public Principal user(Principal user) {
    return user;
  }

  ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We added a <code>@RequestMapping</code> the same as the UI server in <a href="#_the_login_page_angular_js_and_spring_security_part_ii">Part II</a>, and also the <code>@EnableResourceServer</code> annotation from Spring OAuth, which by default secures everything in an authorization server except the "/oauth/*" endpoints.</p>
</div>
<div class="paragraph">
<p>With that endpoint in place we can test it and the greeting resource, since they both now accept bearer tokens that were created by the authorization server:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ TOKEN=2219199c-966e-4466-8b7e-12bb9038c9bb
$ curl -H "Authorization: Bearer $TOKEN" localhost:9000
{"id":"03af8be3-2fc3-4d75-acf7-c484d9cf32b1","content":"Hello World"}
$ curl -H "Authorization: Bearer $TOKEN" localhost:9999/uaa/user
{"details":...,"principal":{"username":"user",...},"name":"user"}</code></pre>
</div>
</div>
<div class="paragraph">
<p>(substitute the value of the access token that you obtain from your own authorization server to get that working yourself).</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_ui_server">The UI Server</h3>
<div class="paragraph">
<p>The final piece of this application we need to complete is the UI server, extracting the authentication part and delegating to the authorization server. So, as with <a href="#changing-the-resource-server">the resource server</a>, we first need to remove the Spring Session and Redis dependencies and replace them with Spring OAuth2. Because we are using Zuul in the UI layer we actually use <code>spring-cloud-starter-oauth2</code> instead of <code>spring-security-oauth2</code> directly (this sets up some autoconfiguration for relaying tokens through the proxy).</p>
</div>
<div class="paragraph">
<p>Once that is done we can remove the session filter and the "/user" endpoint as well, and set up the application to redirect to the authorization server (using the <code>@EnableOAuth2Sso</code> annotation):</p>
</div>
<div class="listingblock">
<div class="title">
UiApplication.java
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@EnableZuulProxy
@EnableOAuth2Sso
public class UiApplication {

  public static void main(String[] args) {
    SpringApplication.run(UiApplication.class, args);
  }

...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Recall from <a href="#_the_api_gateway_pattern_angular_js_and_spring_security_part_iv">Part IV</a> that the UI server, by virtue of the <code>@EnableZuulProxy</code>, acts an API Gateway and we can declare the route mappings in YAML. So the "/user" endpoint can be proxied to the authorization server:</p>
</div>
<div class="listingblock">
<div class="title">
application.yml
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-yaml" data-lang="yaml">zuul:
  routes:
    resource:
      path: /resource/**
      url: http://localhost:9000
    user:
      path: /user/**
      url: http://localhost:9999/uaa/user</code></pre>
</div>
</div>
<div class="paragraph">
<p>Lastly, we need to change the application to a <code>WebSecurityConfigurerAdapter</code> since now it is going to be used to modify the defaults in the SSO filter chain set up by <code>@EnableOAuth2Sso</code>:</p>
</div>
<div class="listingblock">
<div class="title">
SecurityConfiguration.java
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@EnableZuulProxy
@EnableOAuth2Sso
public class UiApplication extends WebSecurityConfigurerAdapter {
    @Override
    public void configure(HttpSecurity http) throws Exception {
      http
          .logout().logoutSuccessUrl("/").and()
          .authorizeRequests().antMatchers("/index.html", "/app.html", "/")
          .permitAll().anyRequest().authenticated().and()
          .csrf()
            .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse());
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The main changes (apart from the base class name) are that the matchers go into their own method, and there is no need for <code>formLogin()</code> any more. The explicit <code>logout()</code> configuration explicitly adds a success url that is unprotected, so that an XHR request to <code>/logout</code> will return successfully.</p>
</div>
<div class="paragraph">
<p>There are also some mandatory external configuration properties for the <code>@EnableOAuth2Sso</code> annotation to be able to contact and authenticate with the right authorization server. So we need this in <code>application.yml</code>:</p>
</div>
<div class="listingblock">
<div class="title">
application.yml
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-yaml" data-lang="yaml">security:
  ...
  oauth2:
    client:
      accessTokenUri: http://localhost:9999/uaa/oauth/token
      userAuthorizationUri: http://localhost:9999/uaa/oauth/authorize
      clientId: acme
      clientSecret: acmesecret
    resource:
      userInfoUri: http://localhost:9999/uaa/user</code></pre>
</div>
</div>
<div class="paragraph">
<p>The bulk of that is about the OAuth2 client ("acme") and the authorization server locations. There is also a <code>userInfoUri</code> (just like in the resource server) so that the user can be authenticated in the UI app itself.</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="Note"></i> </td>
<td class="content"> If you want the UI application be able to refresh expired access tokens automatically, you have to get an <code>OAuth2RestOperations</code> injected into the Zuul filter that does the relay. You can do this by just creating a bean of that type (check the <code>OAuth2TokenRelayFilter</code> for details): </td>
</tr>
</tbody>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Bean
protected OAuth2RestTemplate OAuth2RestTemplate(
    OAuth2ProtectedResourceDetails resource, OAuth2ClientContext context) {
  return new OAuth2RestTemplate(resource, context);
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_in_the_client">In the Client</h4>
<div class="paragraph">
<p>There are some tweaks to the UI application on the front end that we still need to make to trigger the redirect to the authorization server. In this simple demo we can strip the Angular app down to its bare essentials so you can see what is going on more clearly. So we forgo, for now, the use of forms or routes, and we go back to a single Angular component:</p>
</div>
<div class="listingblock">
<div class="title">
app.component.ts
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">import { Component } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import 'rxjs/add/operator/finally';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {

  title = 'Demo';
  authenticated = false;
  greeting = {};

  constructor(private http: HttpClient) {
    this.authenticate();
  }

  authenticate() {

    this.http.get('user').subscribe(response =&gt; {
        if (response['name']) {
            this.authenticated = true;
            this.http.get('resource').subscribe(data =&gt; this.greeting = data);
        } else {
            this.authenticated = false;
        }
    }, () =&gt; { this.authenticated = false; });

  }
  logout() {
      this.http.post('logout', {}).finally(() =&gt; {
          this.authenticated = false;
      }).subscribe();
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>AppComponent</code> handles everything, fetching the user details and, if successful, the greeting. It also provides the <code>logout</code> function.</p>
</div>
<div class="paragraph">
<p>Now we need to create the template for this new component:</p>
</div>
<div class="paragraph">
<p>app.component.html</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;div class="container"&gt;
  &lt;ul class="nav nav-pills"&gt;
    &lt;li&gt;&lt;a&gt;Home&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href="login"&gt;Login&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a (click)="logout()"&gt;Logout&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;
&lt;div class="container"&gt;
&lt;h1&gt;Greeting&lt;/h1&gt;
&lt;div [hidden]="!authenticated"&gt;
	&lt;p&gt;The ID is {{greeting.id}}&lt;/p&gt;
	&lt;p&gt;The content is {{greeting.content}}&lt;/p&gt;
&lt;/div&gt;
&lt;div [hidden]="authenticated"&gt;
	&lt;p&gt;Login to see your greeting&lt;/p&gt;
&lt;/div&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>and include it in the home page as <code>&lt;app-root/&gt;</code>.</p>
</div>
<div class="paragraph">
<p>Note that the navigation link for "Login" is a regular link with an <code>href</code> (not an Angular route). The "/login" endpoint that this goes to is handled by Spring Security and if the user is not authenticated it will result in a redirect to the authorization server.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_how_does_it_work_3">How Does it Work?</h3>
<div class="paragraph">
<p>Run all the servers together now, and visit the UI in a browser at <a href="http://localhost:8080">http://localhost:8080</a>. Click on the "login" link and you will be redirected to the authorization server to authenticate (HTTP Basic popup) and approve the token grant (whitelabel HTML), before being redirected to the home page in the UI with the greeting fetched from the OAuth2 resource server using the same token as we authenticated the UI with.</p>
</div>
<div class="paragraph">
<p>The interactions between the browser and the backend can be seen in your browser if you use some developer tools (usually F12 opens this up, works in Chrome by default, may require a plugin in Firefox). Here’s a summary:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Verb</th>
<th class="tableblock halign-left valign-top">Path</th>
<th class="tableblock halign-left valign-top">Status</th>
<th class="tableblock halign-left valign-top">Response</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">index.html</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/*.js</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Assets from angular</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/user</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">302</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Redirect to login page</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/login</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">302</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Redirect to auth server</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(uaa)/oauth/authorize</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">401</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(ignored)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/login</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">302</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Redirect to auth server</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(uaa)/oauth/authorize</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HTTP Basic auth happens here</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">POST</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(uaa)/oauth/authorize</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">302</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">User approves grant, redirect to /login</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/login</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">302</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Redirect to home page</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/user</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(Proxied) JSON authenticated user</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/app.html</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HTML partial for home page</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/resource</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(Proxied) JSON greeting</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The requests prefixed with (uaa) are to the authorization server. The responses that are marked "ignored" are responses received by Angular in an XHR call, and since we aren’t processing that data they are dropped on the floor. We do look for an authenticated user in the case of the "/user" resource, but since it isn’t there in the first call, that response is dropped.</p>
</div>
<div class="paragraph">
<p>In the "/trace" endpoint of the UI (scroll down to the bottom) you will see the proxied backend requests to "/user" and "/resource", with <code>remote:true</code> and the bearer token instead of the cookie (as it would have been in <a href="#_the_api_gateway_pattern_angular_js_and_spring_security_part_iv">Part IV</a>) being used for authentication. Spring Cloud Security has taken care of this for us: by recognising that we has <code>@EnableOAuth2Sso</code> and <code>@EnableZuulProxy</code> it has figured out that (by default) we want to relay the token to the proxied backends.</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="Note"></i> </td>
<td class="content"> As in previous sections, try to use a different browser for "/trace" so that there is no chance of authentication crossover (e.g. use Firefox if you used Chrome for testing the UI). </td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_the_logout_experience">The Logout Experience</h3>
<div class="paragraph">
<p>If you click on the "logout" link you will see that the home page changes (the greeting is no longer displayed) so the user is no longer authenticated with the UI server. Click back on "login" though and you actually <em>don’t</em> need to go back through the authentication and approval cycle in the authorization server (because you haven’t logged out of that). Opinions will be divided as to whether that is a desirable user experience, and it’s a notoriously tricky problem (Single Sign Out: <a href="https://www.sciencedirect.com/science/article/pii/S2214212614000179">Science Direct article</a> and <a href="https://wiki.shibboleth.net/confluence/display/SHIB2/SLOIssues">Shibboleth docs</a>). The ideal user experience might not be technically feasible, and you also have to be suspicious sometimes that users really want what they say they want. "I want 'logout' to log me out" sounds simple enough, but the obvious response is, "Logged out of what? Do you want to be logged out of <em>all</em> the systems controlled by this SSO server, or just the one that you clicked the 'logout' link in?" If you are interested then there is <a href="#_oauth2_logout_angular_js_and_spring_security_part_ix">a later section</a> of this tutorial where it is discussed in more depth.</p>
</div>
</div>
<div class="sect2">
<h3 id="_conclusion_4">Conclusion</h3>
<div class="paragraph">
<p>This is almost the end of our shallow tour through the Spring Security and Angular stack. We have a nice architecture now with clear responsibilities in three separate components, UI/API Gateway, resource server and authorization server/token granter. The amount of non-business code in all layers is now minimal, and it’s easy to see where to extend and improve the implementation with more business logic. The next steps will be to tidy up the UI in our authorization server, and probably add some more tests, including tests on the JavaScript client. Another interesting task is to extract all the boiler plate code and put it in a library (e.g. "spring-security-angular") containing Spring Security and Spring Session autoconfiguration and some webjars resources for the navigation controller in the Angular piece. Having read the sections in thir series, anyone who was hoping to learn the inner workings of either Angular or Spring Security will probably be disappointed, but if you wanted to see how they can work well together and how a little bit of configuration can go a long way, then hopefully you will have had a good experience. <a href="https://projects.spring.io/spring-cloud/">Spring Cloud</a> is new and these samples required snapshots when they were written, but there are release candidates available and a GA release coming soon, so check it out and send some feedback <a href="https://github.com/spring-cloud">via Github</a> or <a href="https://gitter.im/spring-cloud/spring-cloud">gitter.im</a>.</p>
</div>
<div class="paragraph">
<p>The <a href="#_multiple_ui_applications_and_a_gateway_single_page_application_with_spring_and_angular_js_part_vi">next section</a> in the series is about access decisions (beyond authentication) and employs multiple UI applications behind the same proxy.</p>
</div>
</div>
<div class="sect2">
<h3 id="_addendum_bootstrap_ui_and_jwt_tokens_for_the_authorization_server">Addendum: Bootstrap UI and JWT Tokens for the Authorization Server</h3>
<div class="paragraph">
<p>You will find another version of this application in the <a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/tree/master/oauth2">source code in Github</a> which has a pretty login page and user approval page implemented similarly to the way we did the login page in <a href="#_the_login_page_angular_js_and_spring_security_part_ii">Part II</a>. It also uses <a href="http://jwt.io/">JWT</a> to encode the tokens, so instead of using the "/user" endpoint, the resource server can pull enough information out of the token itself to do a simple authentication. The browser client still uses it, proxied through the UI server, so that it can determine if a user is authenticated (it doesn’t need to do that very often, compared to the likely number of calls to a resource server in a real application).</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_multiple_ui_applications_and_a_gateway_single_page_application_with_spring_and_angular_js_part_vi">Multiple UI Applications and a Gateway</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this section we continue <a href="#_sso_with_oauth2_angular_js_and_spring_security_part_v">our discussion</a> of how to use <a href="https://projects.spring.io/spring-security">Spring Security</a> with <a href="https://angular.io">Angular</a> in a "single page application". Here we show how to use <a href="https://projects.spring.io/spring-security-oauth/">Spring Session</a> together with <a href="https://projects.spring.io/spring-cloud/">Spring Cloud</a> to combine the features of the systems we built in parts II and IV, and actually end up building 3 single page applications with quite different responsibilities. The aim is to build a Gateway (like in <a href="#_the_api_gateway_pattern_angular_js_and_spring_security_part_iv">part IV</a>) that is used not only for API resources but also to load the UI from a backend server. We simplify the token-wrangling bits of <a href="#_the_login_page_angular_js_and_spring_security_part_ii">part II</a> by using the Gateway to pass through the authentication to the backends. Then we extend the system to show how we can make local, granular access decisions in the backends, while still controlling identity and authentication at the Gateway. This is a very powerful model for building distributed systems in general, and has a number of benefits that we can explore as we introduce the features in the code we build.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Reminder: if you are working through this section with the sample application, be sure to clear your browser cache of cookies and HTTP Basic credentials. In Chrome the best way to do that is to open a new incognito window.</p>
</div>
</blockquote>
</div>
<div class="sect2">
<h3 id="_target_architecture">Target Architecture</h3>
<div class="paragraph">
<p>Here’s a picture of the basic system we are going to build to start with:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://raw.githubusercontent.com/spring-guides/tut-spring-security-and-angular-js/master/double/double-simple.png" alt="Components of the System"></span></p>
</div>
<div class="paragraph">
<p>Like the other sample applications in this series it has a UI (HTML and JavaScript) and a Resource server. Like the sample in <a href="#_the_api_gateway_pattern_angular_js_and_spring_security_part_iv">Section IV</a> it has a Gateway, but here it is separate, not part of the UI. The UI effectively becomes part of the backend, giving us even more choice to re-configure and re-implement features, and also bringing other benefits as we will see.</p>
</div>
<div class="paragraph">
<p>The browser goes to the Gateway for everything and it doesn’t have to know about the architecture of the backend (fundamentally, it has no idea that there is a back end). One of the things the browser does in this Gateway is authentication, e.g. it sends a username and password like in <a href="#_the_login_page_angular_js_and_spring_security_part_ii">Section II</a>, and it gets a cookie in return. On subsequent requests it presents the cookie automatically and the Gateway passes it through to the backends. No code needs to be written on the client to enable the cookie passing. The backends use the cookie to authenticate and because all components share a session they share the same information about the user. Contrast this with <a href="#_sso_with_oauth2_angular_js_and_spring_security_part_v">Section V</a> where the cookie had to be converted to an access token in the Gateway, and the access token then had to be independently decoded by all the backend components.</p>
</div>
<div class="paragraph">
<p>As in <a href="#_the_api_gateway_pattern_angular_js_and_spring_security_part_iv">Section IV</a> the Gateway simplifies the interaction between clients and servers, and it presents a small, well-defined surface on which to deal with security. For example, we don’t need to worry about <a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing">Cross Origin Resource Sharing</a>, which is a welcome relief since it is easy to get wrong.</p>
</div>
<div class="paragraph">
<p>The source code for the complete project we are going to build is in <a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/tree/master/double">Github here</a>, so you can just clone the project and work directly from there if you want. There is an extra component in the end state of this system ("double-admin") so ignore that for now.</p>
</div>
</div>
<div class="sect2">
<h3 id="_building_the_backend">Building the Backend</h3>
<div class="paragraph">
<p>In this architecture the backend is very similar to the <a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/tree/master/spring-session">"spring-session"</a> sample we built in <a href="#_the_resource_server_angular_js_and_spring_security_part_iii">Section III</a>, with the exception that it doesn’t actually need a login page. The easiest way to get to what we want here is probably to copy the "resource" server from Section III and take the UI from the <a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/tree/master/basic">"basic"</a> sample in <a href="#_spring_and_angular_js_a_secure_single_page_application">Section I</a>. To get from the "basic" UI to the one we want here, we need only to add a couple of dependencies (like when we first used <a href="https://github.com/spring-projects/spring-session/">Spring Session</a> in Section III):</p>
</div>
<div class="listingblock">
<div class="title">
pom.xml
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;
  &lt;artifactId&gt;spring-session&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since this is now a UI there is no need for the "/resource" endpoint. When you have done that you will have a very simple Angular application (the same as in the "basic" sample), which simplifies testing and reasoning about its behaviour greatly.</p>
</div>
<div class="paragraph">
<p>Lastly, we want this server to run as a backend, so we’ll give it a non-default port to listen on (in <code>application.properties</code>):</p>
</div>
<div class="listingblock">
<div class="title">
application.properties
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-properties" data-lang="properties">server.port: 8081
security.sessions: NEVER</code></pre>
</div>
</div>
<div class="paragraph">
<p>If that’s the <em>whole</em> content <code>application.properties</code> then the application will be secure and accessible to a user called "user" with a password that is random, but printed on the console (at log level INFO) on startup. The "security.sessions" setting means that Spring Security will accept cookies as authentication tokens but won’t create them unless they already exist.</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_resource_server">The Resource Server</h3>
<div class="paragraph">
<p>The Resource server is easy to generate from one of our existing samples. It is the same as the "spring-session" Resource server in <a href="#_the_resource_server_angular_js_and_spring_security_part_iii">Section III</a>: just a "/resource" endpoint Spring Session to get the distributed session data. We want this server to have a non-default port to listen on, and we want to be able to look up authentication in the session so we need this (in <code>application.properties</code>):</p>
</div>
<div class="listingblock">
<div class="title">
application.properties
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-properties" data-lang="properties">server.port: 9000
security.sessions: NEVER</code></pre>
</div>
</div>
<div class="paragraph">
<p>We are going to be POSTing changes to our message resource, which is a new feature in this tutorial. It means that we are going to need CSRF protection in the backend, and we need to do the usual trick to make Spring Security play nicely with Angular:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Override
protected void configure(HttpSecurity http) throws Exception {
	http.csrf()
			.csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The completed sample is <a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/tree/master/double/resource">here in github</a> if you want to take a peek.</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_gateway">The Gateway</h3>
<div class="paragraph">
<p>For an initial implementation of a Gateway (the simplest thing that could possibly work) we can just take an empty Spring Boot web application and add the <code>@EnableZuulProxy</code> annotation. As we saw in <a href="#_spring_and_angular_js_a_secure_single_page_application">Section I</a> there are several ways to do that, and one is to use the <a href="https://start.spring.io">Spring Initializr</a> to generate a skeleton project. Even easier, is to use the <a href="https://cloud-start.spring.io">Spring Cloud Initializr</a> which is the same thing, but for <a href="https://cloud.spring.io">Spring Cloud</a> applications. Using the same sequence of command line operations as in Section I:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ mkdir gateway &amp;&amp; cd gateway
$ curl https://cloud-start.spring.io/starter.tgz -d style=web \
  -d style=security -d style=cloud-zuul -d name=gateway \
  -d style=redis | tar -xzvf -</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can then import that project (it’s a normal Maven Java project by default) into your favourite IDE, or just work with the files and "mvn" on the command line. There is a version <a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/tree/master/double/gateway">in github</a> if you want to go from there, but it has a few extra features that we don’t need yet.</p>
</div>
<div class="paragraph">
<p>Starting from the blank Initializr application, we add the Spring Session dependency (like in the UI above). The Gateway is ready to run, but it doesn’t yet know about our backend services, so let’s just set that up in its <code>application.yml</code> (renaming from <code>application.properties</code> if you did the curl thing above):</p>
</div>
<div class="listingblock">
<div class="title">
application.yml
</div>
<div class="content">
<pre class="prettyprint highlight"><code>zuul:
  sensitive-headers:
  routes:
    ui:
      url: http://localhost:8081
   resource:
      url: http://localhost:9000
security:
  user:
    password:
      password
  sessions: ALWAYS</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are 2 routes in the proxy, both of which pass cookies downstream using the <code>sensitive-headers</code> property, one each for the UI and resource server, and we have set up a default password and a session persistence strategy (telling Spring Security to always create a session on authentication). This last bit is important because we want authentication and therefore sessions to be managed in the Gateway.</p>
</div>
</div>
<div class="sect2">
<h3 id="_up_and_running">Up and Running</h3>
<div class="paragraph">
<p>We now have three components, running on 3 ports. If you point the browser at <a href="http://localhost:8080/ui/">http://localhost:8080/ui/</a> you should get an HTTP Basic challenge, and you can authenticate as "user/password" (your credentials in the Gateway), and once you do that you should see a greeting in the UI, via a backend call through the proxy to the Resource server.</p>
</div>
<div class="paragraph">
<p>The interactions between the browser and the backend can be seen in your browser if you use some developer tools (usually F12 opens this up, works in Chrome by default, may require a plugin in Firefox). Here’s a summary:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Verb</th>
<th class="tableblock halign-left valign-top">Path</th>
<th class="tableblock halign-left valign-top">Status</th>
<th class="tableblock halign-left valign-top">Response</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/ui/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">401</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Browser prompts for authentication</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/ui/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">index.html</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/ui/*.js</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Angular assets</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/ui/js/hello.js</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Application logic</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/ui/user</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">authentication</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/resource/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JSON greeting</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>You might not see the 401 because the browser treats the home page load as a single interaction. All requests are proxied (there is no content in the Gateway yet, beyond the Actuator endpoints for management).</p>
</div>
<div class="paragraph">
<p>Hurrah, it works! You have two backend servers, one of which is a UI, each with independent capabilities and able to be tested in isolation, and they are connected together with a secure Gateway that you control and for which you have configured the authentication. If the backends are not accessible to the browser it doesn’t matter (in fact it’s probably an advantage because it gives you yet more control over physical security).</p>
</div>
</div>
<div class="sect2">
<h3 id="_adding_a_login_form">Adding a Login Form</h3>
<div class="paragraph">
<p>Just as in the "basic" sample in <a href="#_spring_and_angular_js_a_secure_single_page_application">Section I</a> we can now add a login form to the Gateway, e.g. by copying the code from <a href="#_the_login_page_angular_js_and_spring_security_part_ii">Section II</a>. When we do that we can also add some basic navigation elements in the Gateway, so the user doesn’t have to know the path to the UI backend in the proxy. So let’s first copy the static assets from the "single" UI into the Gateway, delete the message rendering and insert a login form into our home page (in the <code>&lt;app/&gt;</code> somewhere):</p>
</div>
<div class="listingblock">
<div class="title">
app.html
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;div class="container" [hidden]="authenticated"&gt;
	&lt;form role="form" (submit)="login()"&gt;
		&lt;div class="form-group"&gt;
			&lt;label for="username"&gt;Username:&lt;/label&gt; &lt;input type="text"
				class="form-control" id="username" name="username"
				[(ngModel)]="credentials.username" /&gt;
		&lt;/div&gt;
		&lt;div class="form-group"&gt;
			&lt;label for="password"&gt;Password:&lt;/label&gt; &lt;input type="password"
				class="form-control" id="password" name="password"
				[(ngModel)]="credentials.password" /&gt;
		&lt;/div&gt;
		&lt;button type="submit" class="btn btn-primary"&gt;Submit&lt;/button&gt;
	&lt;/form&gt;
&lt;/div&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead of the message rendering we will have a nice big navigation button:</p>
</div>
<div class="listingblock">
<div class="title">
index.html
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;div class="container" [hidden]="!authenticated"&gt;
	&lt;a class="btn btn-primary" href="/ui/"&gt;Go To User Interface&lt;/a&gt;
&lt;/div&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you are looking at the sample in github, it also has a minimal navigation bar with a "Logout" button. Here’s the login form in a screenshot:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://raw.githubusercontent.com/spring-guides/tut-spring-security-and-angular-js/master/double/login.png" alt="Login Page"></span></p>
</div>
<div class="paragraph">
<p>To support the login form we need some TypeScript with a component implementing the <code>login()</code> function we declared in the <code>&lt;form/&gt;</code>, and we need to set the <code>authenticated</code> flag so that the home page will render differently depending on whether or not the user is authenticated. For example:</p>
</div>
<div class="listingblock">
<div class="title">
app.component.ts
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">include::src/app/app.component.ts</code></pre>
</div>
</div>
<div class="paragraph">
<p>where the implementation of the <code>login()</code> function is similar to that in <a href="#_the_login_page_angular_js_and_spring_security_part_ii">Section II</a>.</p>
</div>
<div class="paragraph">
<p>We can use the <code>self</code> to store the <code>authenticated</code> flag because there is only one component in this simple application.</p>
</div>
<div class="paragraph">
<p>If we run this enhanced Gateway, instead of having to remember the URL for the UI we can just load the home page and follow links. Here’s the home page for an authenticated user:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://raw.githubusercontent.com/spring-guides/tut-spring-security-and-angular-js/master/double/home.png" alt="Home Page"></span></p>
</div>
</div>
<div class="sect2">
<h3 id="_granular_access_decisions_in_the_backend">Granular Access Decisions in the Backend</h3>
<div class="paragraph">
<p>Up to now our application is functionally very similar to the one in <a href="#_the_resource_server_angular_js_and_spring_security_part_iii">Section III</a> or <a href="#_the_api_gateway_pattern_angular_js_and_spring_security_part_iv">Section IV</a>, but with an additional dedicated Gateway. The advantage of the extra layer may not be yet apparent, but we can emphasise it by expanding the system a bit. Suppose we want to use that Gateway to expose another backend UI, for users to "administrate" the content in the main UI, and that we want to restrict access to this feature to users with special roles. So we will add an "Admin" application behind the proxy, and the system will look like this:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://raw.githubusercontent.com/spring-guides/tut-spring-security-and-angular-js/master/double/double-components.png" alt="Components of the System"></span></p>
</div>
<div class="paragraph">
<p>There is a new component (Admin) and a new route in the Gateway in <code>application.yml</code>:</p>
</div>
<div class="listingblock">
<div class="title">
application.yml
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-yaml" data-lang="yaml">zuul:
  sensitive-headers:
  routes:
    ui:
      url: http://localhost:8081
    admin:
      url: http://localhost:8082
    resource:
      url: http://localhost:9000</code></pre>
</div>
</div>
<div class="paragraph">
<p>The fact that the existing UI is available to users in the "USER" role is indicated on the block diagram above in the Gateway box (green lettering), as is the fact that the "ADMIN" role is needed to go to the Admin application. The access decision for the "ADMIN" role could be applied in the Gateway, in which case it would appear in a <code>WebSecurityConfigurerAdapter</code>, or it could be applied in the Admin application itself (and we will see how to do that below).</p>
</div>
<div class="paragraph">
<p>So first, create a new Spring Boot application, or copy the UI and edit it. You won’t need to change much in the UI app except the name to start with. The finished app is in <a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/tree/master/double/admin">Github here</a>.</p>
</div>
<div class="paragraph">
<p>Suppose that within the Admin application we want to distinguish between "READER" and "WRITER" roles, so that we can permit (let’s say) users who are auditors to view the changes made by the main admin users. This is a granular access decision, where the rule is only known, and should only be known, in the backend application. In the Gateway we only need to ensure that our user accounts have the roles needed, and this information is available, but the Gateway doesn’t need to know how to interpret it. In the Gateway we create user accounts to keep the sample application self-contained:</p>
</div>
<div class="listingblock">
<div class="title">
SecurityConfiguration.class
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">@Configuration
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {

  @Autowired
  public void globalUserDetails(AuthenticationManagerBuilder auth) throws Exception {
    auth.inMemoryAuthentication()
      .withUser("user").password("password").roles("USER")
    .and()
      .withUser("admin").password("admin").roles("USER", "ADMIN", "READER", "WRITER")
    .and()
      .withUser("audit").password("audit").roles("USER", "ADMIN", "READER");
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>where the "admin" user has been enhanced with 3 new roles ("ADMIN", "READER" and "WRITER") and we have also added an "audit" user with "ADMIN" access, but not "WRITER".</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-tip" title="Tip"></i> </td>
<td class="content"> In a production system the user account data would be managed in a backend database (most likely a directory service), not hard coded in the Spring Configuration. Sample applications connecting to such a database are easy to find on the internet, for example in the <a href="https://github.com/spring-projects/spring-security/tree/master/samples">Spring Security Samples</a>. </td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>The access decisions go in the Admin application. For the "ADMIN" role (which is required globally for this backend) we do it in Spring Security:</p>
</div>
<div class="listingblock">
<div class="title">
SecurityConfiguration.java
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Configuration
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {

@Override
  protected void configure(HttpSecurity http) throws Exception {
    http
    ...
      .authorizeRequests()
        .antMatchers("/index.html", "/").permitAll()
        .antMatchers("/admin/**").hasRole("ADMIN")
        .anyRequest().authenticated()
    ...
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For the "READER" and "WRITER" roles the application itself is split, and since the application is implemented in JavaScript, that is where we need to make the access decision. One way to do this is to have a home page with a computed view embedded in it via the router:</p>
</div>
<div class="listingblock">
<div class="title">
app.component.html
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;div class="container"&gt;
	&lt;h1&gt;Admin&lt;/h1&gt;
	&lt;router-outlet&gt;&lt;/router-outlet&gt;
&lt;/div&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The route is computed when the component loads:</p>
</div>
<div class="listingblock">
<div class="title">
app.component.ts
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {

  user: {};

  constructor(private app: AppService, private http: HttpClient, private router: Router) {
    app.authenticate(response =&gt; {
      this.user = response;
      this.message();
    });
  }

  logout() {
    this.http.post('logout', {}).subscribe(function() {
        this.app.authenticated = false;
        this.router.navigateByUrl('/login');
    });
  }

  message() {
    if (!this.app.authenticated) {
      this.router.navigate(['/unauthenticated']);
    } else {
      if (this.app.writer) {
        this.router.navigate(['/write']);
      } else {
        this.router.navigate(['/read']);
      }
    }
  }
...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>the first thing the application does is look at check if the user is authenticated, and computes the route by looking at the user data. The routes are declared in the main module:</p>
</div>
<div class="listingblock">
<div class="title">
app.module.ts
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">const routes: Routes = [
  { path: '', pathMatch: 'full', redirectTo: 'read'},
  { path: 'read', component: ReadComponent},
  { path: 'write', component: WriteComponent},
  { path: 'unauthenticated', component: UnauthenticatedComponent},
  { path: 'changes', component: ChangesComponent}
];</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each of those components (one for each route) has to be implemented separately. Here’s the <code>ReadComponent</code> as an example:</p>
</div>
<div class="listingblock">
<div class="title">
read.component.ts
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">import { Component } from '@angular/core';
import { HttpClient } from '@angular/common/http';

@Component({
  templateUrl: './read.component.html'
})
export class ReadComponent {

  greeting = {};

  constructor(private http: HttpClient) {
    http.get('/resource').subscribe(data =&gt; this.greeting = data);
  }

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">
read.component.html
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;h1&gt;Greeting&lt;/h1&gt;
&lt;div&gt;
	&lt;p&gt;The ID is {{greeting.id}}&lt;/p&gt;
	&lt;p&gt;The content is {{greeting.content}}&lt;/p&gt;
&lt;/div&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>WriteComponent</code> is similar, but has a form to change the message in the backend:</p>
</div>
<div class="listingblock">
<div class="title">
write.component.ts
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">import { Component } from '@angular/core';
import { HttpClient } from '@angular/common/http';

@Component({
  templateUrl: './write.component.html'
})
export class WriteComponent {

  greeting = {};

  constructor(private http: HttpClient) {
    this.http.get('http://localhost:9000').subscribe(data =&gt; this.greeting = data);
  }

  update() {
    this.http.post('/resource', {content: this.greeting['content']}).subscribe(response =&gt; {
      this.greeting = response;
    });
  }

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">
write.component.html
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;form (submit)="update()"&gt;
	&lt;p&gt;The ID is {{greeting.id}}&lt;/p&gt;
	&lt;div class="form-group"&gt;
		&lt;label for="username"&gt;Content:&lt;/label&gt; &lt;input type="text"
			class="form-control" id="content" name="content" [(ngModel)]="greeting.content"/&gt;
	&lt;/div&gt;
	&lt;button type="submit" class="btn btn-primary"&gt;Submit&lt;/button&gt;
&lt;/form&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>AppService</code> also needs to provide the data to compute the route, so in the <code>authenticate()</code> function we see this:</p>
</div>
<div class="listingblock">
<div class="title">
app.service.ts
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">        http.get('/user').subscribe(function(response) {
            var user = response.json();
            if (user.name) {
                self.authenticated = true;
                self.writer = user.roles &amp;&amp; user.roles.indexOf("ROLE_WRITER")&gt;0;
            } else {
                self.authenticated = false;
                self.writer = false;
            }
            callback &amp;&amp; callback(response);
        })</code></pre>
</div>
</div>
<div class="paragraph">
<p>To support this function on the backend we need the <code>/user</code> endpoint, e.g. in our main application class:</p>
</div>
<div class="listingblock">
<div class="title">
AdminApplication.java
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@RestController
public class AdminApplication {

  @RequestMapping("/user")
  public Map&lt;String, Object&gt; user(Principal user) {
    Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();
    map.put("name", user.getName());
    map.put("roles", AuthorityUtils.authorityListToSet(((Authentication) user)
        .getAuthorities()));
    return map;
  }

  public static void main(String[] args) {
    SpringApplication.run(AdminApplication.class, args);
  }

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="Note"></i> </td>
<td class="content"> the role names come back from the "/user" endpoint with the "ROLE_" prefix so we can distinguish them from other kinds of authorities (it’s a Spring Security thing). Thus the "ROLE_" prefix is needed in the JavaScript, but not in the Spring Security configuration, where it is clear from the method names that "roles" are the focus of the operations. </td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_changes_in_the_gateway_to_support_admin_ui">Changes in the Gateway to Support Admin UI</h3>
<div class="paragraph">
<p>We are going to use the roles to make access decisions in the Gateway as well (so we can conditionally display a link to the admin UI), so we should add the "roles" to the "/user" endpoint in the Gateway as well. Once that is in place we can add some JavaScript to set up a flag to indicate that the current user is an "ADMIN". In the <code>authenticated()</code> function:</p>
</div>
<div class="listingblock">
<div class="title">
app.component.ts
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">this.http.get('user', {headers: headers}).subscribe(data =&gt; {
  this.authenticated = data &amp;&amp; data['name'];
  this.user = this.authenticated ? data['name'] : '';
  this.admin = this.authenticated &amp;&amp; data['roles'] &amp;&amp; data['roles'].indexOf('ROLE_ADMIN') &gt; -1;
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>and we also need to reset the <code>admin</code> flag to <code>false</code> when a user logs out:</p>
 </div>
<div class="listingblock">
<div class="title">
app.component.ts
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">this.logout = function() {
    http.post('logout', {}).subscribe(function() {
        self.authenticated = false;
        self.admin = false;
    });
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and then in the HTML we can conditionally show a new link:</p>
</div>
<div class="listingblock">
<div class="title">
app.component.html
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;div class="container" [hidden]="!authenticated"&gt;
	&lt;a class="btn btn-primary" href="/ui/"&gt;Go To User Interface&lt;/a&gt;
&lt;/div&gt;
&lt;br /&gt;
&lt;div class="container" [hidden]="!authenticated || !admin"&gt;
	&lt;a class="btn btn-primary" href="/admin/"&gt;Go To Admin Interface&lt;/a&gt;
&lt;/div&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Run all the apps and go to <a href="http://localhost:8080" class="bare">http://localhost:8080</a> to see the result. Everything should be working fine, and the UI should change depending on the currently authenticated user.</p>
</div>
</div>
<div class="sect2">
<h3 id="_why_are_we_here">Why are we Here?</h3>
<div class="paragraph">
<p>Now we have a nice little system with 2 independent user interfaces and a backend Resource server, all protected by the same authentication in a Gateway. The fact that the Gateway acts as a micro-proxy makes the implementation of the backend security concerns extremely simple, and they are free to concentrate on their own business concerns. The use of Spring Session has (again) avoided a huge amount of hassle and potential errors.</p>
</div>
<div class="paragraph">
<p>A powerful feature is that the backends can independently have any kind of authentication they like (e.g. you can go directly to the UI if you know its physical address and a set of local credentials). The Gateway imposes a completely unrelated set of constraints, as long as it can authenticate users and assign metadata to them that satisfy the access rules in the backends. This is an excellent design for being able to independently develop and test the backend components. If we wanted to, we could go back to an external OAuth2 server (like in <a href="#_sso_with_oauth2_angular_js_and_spring_security_part_v">Section V</a>, or even something completely different) for the authentication at the Gateway, and the backends would not need to be touched.</p>
</div>
<div class="paragraph">
<p>A bonus feature of this architecture (single Gateway controlling authentication, and shared session token across all components) is that "Single Logout", a feature we identified as difficult to implement in <a href="#_sso_with_oauth2_angular_js_and_spring_security_part_v">Section V</a>, comes for free. To be more precise, one particular approach to the user experience of single logout is automatically available in our finished system: if a user logs out of any of the UIs (Gateway, UI backend or Admin backend), he is logged out of all the others, assuming that each individual UI implemented a "logout" feature the same way (invalidating the session).</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Thanks: I would like to thank again everyone who helped me develop this series, and in particular <a href="https://spring.io/team/rwinch">Rob Winch</a> and <a href="https://twitter.com/thspaeth">Thorsten Späth</a> for their careful reviews of the sections and sources code. Since <a href="#_spring_and_angular_js_a_secure_single_page_application">Section I</a> was published it hasn’t changed much but all the other parts have evolved in response to comments and insights from readers, so thank you also to anyone who read the sections and took the trouble to join in the discussion.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_testing_angular_js_and_spring_security_part_viii">Testing an Angular Application</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this section we continue <a href="#_modular_angular_js_and_spring_security_part_vii">our discussion</a> of how to use <a href="https://projects.spring.io/spring-security">Spring Security</a> with <a href="https://angular.io">Angular</a> in a "single page application". Here we show how to write and run unit tests for the client-side code using the Angular test framework. You can catch up on the basic building blocks of the application or build it from scratch by reading the <a href="#_spring_and_angular_js_a_secure_single_page_application">first section</a>, or you can just go straight to the <a href="https://github.com/dsyer/spring-security-angular/tree/master/basic">source code in Github</a> (the same source code as Part I, but with tests now added). This section actually has very little code using Spring or Spring Security, but it covers the client-side testing in a way that might not be so easy to find in the usual Angular community resources, and one which we feel will be comfortable for the majority of Spring users.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Reminder: if you are working through this section with the sample application, be sure to clear your browser cache of cookies and HTTP Basic credentials. In Chrome the best way to do that for a single server is to open a new incognito window.</p>
</div>
</blockquote>
</div>
<div class="sect2">
<h3 id="_writing_a_specification">Writing a Specification</h3>
<div class="paragraph">
<p>Our "app" component in the "basic" application is very simple, so it won’t take a lot to test it thoroughly. Here’s a reminder of the code:</p>
</div>
<div class="listingblock">
<div class="title">
app.component.ts
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">include::basic/src/app/app.component.ts</code></pre>
</div>
</div>
<div class="paragraph">
<p>The main challenge we face is to provide the <code>http</code> object in the test, so we can make assertions about how they are used in the component. Actually, even before we face that challenge we need to be able to create a component instance, so we can test what happens when it loads. Here’s how you can do that.</p>
</div>
<div class="paragraph">
<p>The Angular build in an app created from <code>ng new</code> already has a spec and some configuration to run it. The generated spec is in "src/app", and it starts like this:</p>
</div>
<div class="listingblock">
<div class="title">
app.component.ts
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">import { TestBed, async } from '@angular/core/testing';
import { AppComponent } from './app.component';
describe('AppComponent', () =&gt; {
  beforeEach(async(() =&gt; {
    TestBed.configureTestingModule({
      imports: [],
      declarations: [
        AppComponent
      ]
    }).compileComponents();
  }));
  it('should create the app', async(() =&gt; {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.debugElement.componentInstance;
    expect(app).toBeTruthy();
  }));
  ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this very basic test suite we have these important elements:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li> <p>We <code>describe()</code> the thing that is being tested (the "AppComponent" in this case) with a function.</p> </li>
<li> <p>Inside that function we provide a <code>beforeEach()</code> callback, which loads the Angular component.</p> </li>
<li> <p>Behaviour is expressed through a call to <code>it()</code>, where we state in words what the expectation is, and then provide a function that makes assertions.</p> </li>
<li> <p>The test environment is initialized before anything else happens. This is boilerplate for most Angular apps.</p> </li>
</ol>
</div>
<div class="paragraph">
<p>The test function here is so trivial it actually only asserts that the component exists, so if that fails then the test will fail.</p>
</div>
</div>
<div class="sect2">
<h3 id="_improving_the_unit_test_mocking_http_backend">Improving the Unit Test: Mocking HTTP Backend</h3>
<div class="paragraph">
<p>To improve the spec to production grade we need to actually assert something about what happens when the controller loads. Since it makes a call to <code>http.get()</code> we need to mock that call to avoid having to run the whole application just for a unit test. To do that we use the Angular <code>HttpClientTestingModule</code>:</p>
</div>
<div class="listingblock">
<div class="title">
app.component.spec
</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">Unresolved directive in testing.adoc - include::basic/src/app/app.component.spec[indent=0]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The new pieces here are:</p>
</div>
<div class="ulist">
<ul>
<li> <p>The declaration of the <code>HttpClientTestingModule</code> as an imports in the <code>TestBed</code> in <code>beforeEach()</code>.</p> </li>
<li> <p>In the test function we set expectations for the backend before we create the component, telling it to expect a call to 'resource/',and what the response should be.</p> </li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_running_the_specs">Running the Specs</h3>
<div class="paragraph">
<p>To run our test" code we can do <code>./ng test</code> (or <code>./ng build</code>) using the convenience script created when the project was set up. It also runs as part of the Maven lifecycle, so <code>./mvnw install</code> is also a good way to run the tests, and this is what will happen in your CI build.</p>
</div>
</div>
<div class="sect2">
<h3 id="_end_to_end_tests">End-to-End Tests</h3>
<div class="paragraph">
<p>Angular also has a standard build set up for "end-to-end tests" using a browser and your generated JavaScript. These are written as "specs" in the top-level <code>e2e</code> directory. All the samples in this tutorial contain a really simple end-to-end test which run in the Maven lifecycle (hence you will see a browser window popup if you run <code>mvn install</code> in any of the "ui" apps).</p>
</div>
</div>
<div class="sect2">
<h3 id="_conclusion_5">Conclusion</h3>
<div class="paragraph">
<p>Being able to run unit tests for Javascript is important in a modern web application and it’s a topic that we’ve ignored (or dodged) up to now in this series. With this installment we have presented the basic ingredients of how to write the tests, how to run them at development time and also, importantly, in a continuous integration setting. The approach we have taken is not going to suit everyone, so please don’t feel bad about doing it in a different way, but make sure you have all those ingredients. The way we did it here will probably feel comfortable to traditional Java enterprise developers, and integrates well with their existing tools and processes, so if you are in that category I hope you will find it useful as a starting point. More examples of testing with Angular and Jasmine can be found in plenty of places on the internet, but the first point of call might be the <a href="https://github.com/dsyer/spring-security-angular/tree/master/single">"single" sample</a> from this series, which now has some up to date test code which is a bit less trivial than the code we needed to write for the "basic" sample in this tutorial.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_oauth2_logout_angular_js_and_spring_security_part_ix">Logout from an OAuth2 Client Application</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this section we continue <a href="#_testing_angular_js_and_spring_security_part_viii">our discussion</a> of how to use <a href="https://projects.spring.io/spring-security">Spring Security</a> with <a href="https://angular.io">Angular</a> in a "single page application". Here we show how to take the OAuth2 samples and add a different logout experience. Many people who implement OAuth2 single sign on find that they have a puzzle to solve of how to logout "cleanly"? The reason it’s a puzzle is that there isn’t a single correct way to do it, and the solution you choose will be determined by the user experience you are looking for, and also the amount of complexity you are willing to take on. The reasons for the complexity stem from the fact that there are potentially multiple browser sessions in the system, all with different backend servers, so when a user logs out from one of them, what should happen to the others? This is the ninth section of a tutorial, and you can catch up on the basic building blocks of the application or build it from scratch by reading the <a href="#_spring_and_angular_js_a_secure_single_page_application">first section</a>, or you can just go straight to the <a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/tree/master/oauth2-logout">source code in Github</a>.</p>
</div>
<div class="sect2">
<h3 id="_logout_patterns">Logout Patterns</h3>
<div class="paragraph">
<p>The user experience with logout of the <code>oauth2</code> sample in this tutorial is that you logout of the UI app, but not from the authserver, so when you log back into the UI app the autheserver does not challenge again for credentials. This is completely expected, normal, and desirable when the autheserver is external - Google and other external authserver providers neither want nor allow you to logout from their servers from an untrusted application - but it isn’t the best user experience if the authserver is really part of the same system as the UI.</p>
</div>
<div class="paragraph">
<p>There are, broadly speaking, three patterns for logout from a UI app that is authenticated as an OAuth2 client:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li> <p>External Authserver (EA, the original sample). The user perceives the authserver as a 3rd party (e.g. using Facebook or Google to authenticate). You don’t want to log out of the authserver when the app session ends. You do want approval for all grants. The <code>oauth2</code> (and <code>oauth2-vanilla</code>) sample from this tutorial implement this pattern.</p> </li>
<li> <p>Gateway and Internal Authserver (GIA). You only need to log out of 2 apps, and they are part of the same system, as perceived by the user. Usually you want to autoapprove all grants.</p> </li>
<li> <p>Single Logout (SL). One authserver and multiple UI apps all with their own authentication, and when the user logs out of one, you want them all to follow suit. Likely to fail with a naive implementation because of network partitions and server failures - you basically need globally consistent storage.</p> </li>
</ol>
</div>
<div class="paragraph">
<p>Sometimes, even if you have an external authserver, you want to control the authentication and add an internal layer of access control (e.g. scopes or roles that the authserver doesn’t support). Then it’s a good idea to use the EA for authentication, but have an internal authserver that can add the additional details you need to the tokens. The <code>auth-server</code> sample from this other <a href="https://github.com/spring-guides/tut-spring-boot-oauth2">OAuth2 Tutorial</a> shows you how to do that in a very simple way. You can then apply the GIA or SL patterns to the system that includes the internal authserver.</p>
</div>
<div class="paragraph">
<p>Here are some options if you don’t want EA:</p>
</div>
<div class="ulist">
<ul>
<li> <p>Log out from authserver as well as UI app in browser client. Simple approach and works with some careful CRSF and CORS configuration. No SL.</p> </li>
<li> <p>Logout from authserver as soon as a token is available. Hard to implement in the UI, where the token is acquired, because you don’t have the session cookie for the authserver there. There is a <a href="https://github.com/spring-projects/spring-security-oauth/issues/140">feature request in Spring OAuth</a> which shows an interesting approach: invalidate the session in the authserver as soon as an auth code is generated. The Github issue contains an aspect that implements the session invalidation, but it’s easier to do as a <code>HandlerInterceptor</code>. No SL.</p> </li>
<li> <p>Proxy authserver through the same gateway as UI and hope that one cookie is enough to manage the state for the whole system. Doesn’t work because unless there is a shared session, which defeats the object to some extent (otherwise there is no session storage for the authserver). SL only if the session is shared between all apps.</p> </li>
<li> <p>Cookie relay in gateway. You are using the gateway as the source of truth for authentication, and the authserver has all the state it needs because the gateway manages the cookie instead of the browser. The browser never has a cookie from more than one server. No SL.</p> </li>
<li> <p>Use the token as global authentication and invalidate it when user logs out of the UI app. Downside: requires tokens to be invalidated by client apps, which isn’t really what they were designed to do. SL possible, but usual constraints apply.</p> </li>
<li> <p>Create and manage a global session token (in addition to the user token) in the authserver. This is the approach taken by <a href="https://openid.net">OpenId Connect</a>, and it does provide some options for SL, at the cost of some extra machinery. None of the options is immune from the usual distributed system limitations: if networks and application nodes are not stable there are no guarantees that a logout signal is shared among all participants when needed. All of the logout specs are still in draft form, and here are some links to the specs: <a href="https://openid.net/specs/openid-connect-session-1_0.html">Session Management</a>, <a href="https://openid.net/specs/openid-connect-frontchannel-1_0.html">Front Channel Logout</a>, and <a href="https://openid.net/specs/openid-connect-backchannel-1_0.html">Back Channel Logout</a>.</p> </li>
</ul>
</div>
<div class="paragraph">
<p>Note that where SL is hard or impossible, it might be better to put all the UIs behind a single gateway anyway. Then you can use GIA, which is easier, to control logout from your whole estate.</p>
</div>
<div class="paragraph">
<p>The easiest two options, which apply nicely in the GIA pattern can be implemented in the tutorial sample as follows (take the <code>oauth2</code> sample and work from there).</p>
</div>
</div>
<div class="sect2">
<h3 id="_logout_of_both_servers_from_browser">Logout of Both Servers from Browser</h3>
<div class="paragraph">
<p>It’s quite easy to add a couple of lines of code to the browser client that logout from the authserver as soon as the UI app is logged out. E.g.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">logout() {
    this.http.post('logout', {}).finally(() =&gt; {
        self.authenticated = false;
        this.http.post('http://localhost:9999/uaa/logout', {}, {withCredentials:true})
            .subscribe(() =&gt; {
                console.log('Logged out');
        });
    }).subscribe();
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this sample we hardcoded the authserver logout endpoint URL into the JavaScript, but it would be easy to externalize that if you needed to. It has to be a POST directly to the authserver because we want the session cookie to go along too. The XHR request will only go out from the browser with a cookie attached if we specifically ask for <code>withCredentials:true</code>.</p>
</div>
<div class="paragraph">
<p>Conversely, on the server we need some CORS configuration because the request is coming from a different domain. E.g. in the <code>WebSecurityConfigurerAdapter</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Override
protected void configure(HttpSecurity http) throws Exception {
  http
	.requestMatchers().antMatchers("/login", "/logout", "/oauth/authorize", "/oauth/confirm_access")
  .and()
    .cors().configurationSource(configurationSource())
    ...
}

private CorsConfigurationSource configurationSource() {
  UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
  CorsConfiguration config = new CorsConfiguration();
  config.addAllowedOrigin("*");
  config.setAllowCredentials(true);
  config.addAllowedHeader("X-Requested-With");
  config.addAllowedHeader("Content-Type");
  config.addAllowedMethod(HttpMethod.POST);
  source.registerCorsConfiguration("/logout", config);
  return source;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The "/logout" endpoint has been given some special treatment. It is allowed to be called from any origin, and explicitly allows credentials (e.g. cookies) to be sent. The allowed headers are just the ones that Angular sends in teh sample app.</p>
</div>
<div class="paragraph">
<p>In addition to the CORS configuration we also need to disable CSRF for the logout endpoint, because Angular will not send the <code>X-XSRF-TOKEN</code> header in a cross-domain request. The authserver didn’t require any CSRF configuration before now, but it’s easy to add an ignore for the logout endpoint:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Override
protected void configure(HttpSecurity http) throws Exception {
  http
    .csrf()
      .ignoringAntMatchers("/logout/**")
    ...
}</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-warning" title="Warning"></i> </td>
<td class="content"> Dropping CSRF protection is not really advisable, but you might be prepared to tolerate it for this restricted use case. </td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>With those two simple changes, one in the UI app client, and one in the authserver, you will find that once you logout of the UI app, when you log back in, you will always be prompted for a password.</p>
</div>
<div class="paragraph">
<p>Another useful change is to set the OAuth2 client to autoapprove, so that the user doesn’t have to approve the token grant. This is common in a internal authserver, where the user doesn’t perceive it as a separate system. In the <code>AuthorizationServerConfigurerAdapter</code> you just need a flag when the client is initialized:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Override
public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
  clients.inMemory().withClient("acme")
    ...
  .autoApprove(true);
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_invalidate_session_in_authserver">Invalidate Session in Authserver</h3>
<div class="paragraph">
<p>If you don’t like to give up the CSRF protection on the logout endpoint, you can try the other easy approach, which is to invalidate the user session in the authserver as soon as a token is granted (actually as soon as an auth code is generated). This is also super easy to implement: starting from the <code>oauth2</code> sample, just add a <code>HandlerInterceptor</code> to the OAuth2 endpoints.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Override
public void configure(AuthorizationServerEndpointsConfigurer endpoints)
    throws Exception {
  ...
  endpoints.addInterceptor(new HandlerInterceptorAdapter() {
    @Override
    public void postHandle(HttpServletRequest request,
        HttpServletResponse response, Object handler,
        ModelAndView modelAndView) throws Exception {
      if (modelAndView != null
          &amp;&amp; modelAndView.getView() instanceof RedirectView) {
        RedirectView redirect = (RedirectView) modelAndView.getView();
        String url = redirect.getUrl();
        if (url.contains("code=") || url.contains("error=")) {
          HttpSession session = request.getSession(false);
          if (session != null) {
            session.invalidate();
          }
        }
      }
    }
  });
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This interceptor looks for a <code>RedirectView</code>, which is a signal that the user is being redirected back to the client app, and checks if the location contains an auth code or an error. You could add "token=" if you were using implicit grants as well.</p>
</div>
<div class="paragraph">
<p>With this simple change, as soon as you authenticate, the session in the authserver is already dead, so there’s no need to try and manage it from the client. When you log out of the UI app, and then log back in, the authserver doesn’t recognize you and prompts for credentials. This pattern is the one implemented by the <code>oauth2-logout</code> sample in the <a href="https://github.com/spring-guides/tut-spring-security-and-angular-js/tree/master/oauth2-logout">source code</a> for this tutorial. The downside of this approach is that you don’t really have true single sign on any more - any other apps that are part of your system will find that the authserver session is dead and they have to prompt for authentication again - it isn’t a great user experience if there are multiple apps.</p>
</div>
</div>
<div class="sect2">
<h3 id="_conclusion_6">Conclusion</h3>
<div class="paragraph">
<p>In this section we have seen how to implement a couple of different patterns for logout from an OAuth2 client application (taking as a starting point the application from <a href="#_sso_with_oauth2_angular_js_and_spring_security_part_v">section five</a> of the tutorial), and some options for other patterns were discussed. These options are not exhaustive, but should give you a good idea of the trade offs involved, and some tools for thinking about the best solution for your use case. There were only couple of lines of JavaScript in this section, and that wasn’t really specific to Angular (it adds a flag to XHR requests), so all the lessons and patterns are applicable beyond the narrow scope of the sample apps in this guide. A recurring theme is that all approaches to single logout (SL) where there are multiple UI apps and a single authserver tend to be flawed in some way: the best you can do is choose the approach that makes your users the least uncomfortable. If you have an internal authserver and a system that is composed of many components, then possibly the only architecture that feels to the user like a single system is a gateway for all user interactions.</p>
</div>
<div class="paragraph">
<p>Want to write a new guide or contribute to an existing one? Check out our <a href="https://github.com/spring-guides/getting-started-guides/wiki">contribution guidelines</a>.</p>
</div>
<div class="admonitionblock important">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-important" title="Important"></i> </td>
<td class="content"> All guides are released with an ASLv2 license for the code, and an <a href="https://creativecommons.org/licenses/by-nd/3.0/">Attribution, NoDerivatives creative commons license</a> for the writing. </td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div>
</article>
</div>
<aside class="span4 content-right-pane--container mobile-left-pane" id="sidebar">
<a class="ci-status desktop-only" href="https://travis-ci.org/spring-guides/tut-spring-security-and-angular-js">
<img src="https://travis-ci.org/spring-guides/tut-spring-security-and-angular-js.svg?branch=master" />
</a>
<div class="right-pane-widget--container desktop-only">
<div class="github-actions https">
<h2>Get the Code</h2>
<div class="btn-group">
<button class="btn" data-protocol="https">HTTPS</button>
<button class="btn" data-protocol="ssh">SSH</button>
</div>
<div class="clone-url https">
<input id="clone-url-https" readonly="readonly" type="text" value="https://github.com/spring-guides/tut-spring-security-and-angular-js.git" />
<button class="copy-button github" data-toggle="tooltip" data-clipboard-text="https://github.com/spring-guides/tut-spring-security-and-angular-js.git"></button>
</div>
<div class="clone-url ssh">
<input id="clone-url-ssh" readonly="readonly" type="text" value="git@github.com:spring-guides/tut-spring-security-and-angular-js.git" />
<button class="copy-button github" data-toggle="tooltip" data-clipboard-text="git@github.com:spring-guides/tut-spring-security-and-angular-js.git"></button>
</div>
<a class="github_download btn btn-black uppercase" href="https://github.com/spring-guides/tut-spring-security-and-angular-js/archive/master.zip">Download ZIP</a>
<a class="gs-guide-import" href="https://github.com/spring-guides/tut-spring-security-and-angular-js.git">Import into STS</a>
<div class="go-to-repo--container">
<a href="https://github.com/spring-guides/tut-spring-security-and-angular-js"><i class="icon-github"></i>Go To Repo</a>
</div>
<div class="go-to-repo--container">
</div>
</div>
</div>
<div class="right-pane-widget--container">
<div>
<h3><a class="anchor" href="#table-of-contents" name="table-of-contents"></a>Table of contents</h3>
<div><ul class="sectlevel1">
<li><a href="#_spring_and_angular_js_a_secure_single_page_application">A Secure Single Page Application</a> </li>
<li><a href="#_the_login_page_angular_js_and_spring_security_part_ii">The Login Page</a> </li>
<li><a href="#_the_resource_server_angular_js_and_spring_security_part_iii">The Resource Server</a> </li>
<li><a href="#_the_api_gateway_pattern_angular_js_and_spring_security_part_iv">The API Gateway</a> </li>
<li><a href="#_sso_with_oauth2_angular_js_and_spring_security_part_v">Single Sign On with OAuth2</a> </li>
<li><a href="#_multiple_ui_applications_and_a_gateway_single_page_application_with_spring_and_angular_js_part_vi">Multiple UI Applications and a Gateway</a> </li>
<li><a href="#_testing_angular_js_and_spring_security_part_viii">Testing an Angular Application</a> </li>
<li><a href="#_oauth2_logout_angular_js_and_spring_security_part_ix">Logout from an OAuth2 Client Application</a> </li>
</ul></div>
</div>
</div>
</aside>
</div>
</main>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
 <div class="container">
 <ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">Tools</a></li>
<li><a href="https://store.pivotal.io/">Store</a></li>
<li><a href="/blog">Newsletter</a></li>
</ul>
</div>
</div>
&copy; <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a>, Inc. All Rights Reserved.
<a href="https://pivotal.io/terms-of-use">Terms of Use</a> &bullet;
<a href="https://pivotal.io/privacy-policy">Privacy</a> &bullet;
<a href="/trademarks">Trademark Guidelines</a>
<div id="teconsent" style="display:inline-block;"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
<script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script></body></html>