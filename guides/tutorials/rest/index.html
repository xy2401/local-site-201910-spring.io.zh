<html  data-clipboard-buttons="" data-code-prettify="" data-code-sidebar="" data-hide-show-guide="" data-sts-import="" data-mobile-support="" data-search=""><head></head><body >﻿
<title>教程·使用Spring构建REST服务</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link rel="stylesheet" type="text/css" href="/css/gsguide-cce08ab7a9f46db88819a14148e45bad.css">

<meta property="og:title" content="Building REST services with Spring">
<meta property="og:image" content="/img/spring-by-pivotal-9066b55828deb3c10e27e609af322c40.png">
<meta property="og:description" content="this tutorial is designed to be completed in 2-3 hours, it provides deeper, in-context explorations of enterprise application development topics, leaving you ready to implement real-world solutions.">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link active">
<a href="/guides">导游</a>
</li>
<li class="navbar-link">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<main class="main-body--wrapper">
<div class="row-fluid">
<div class="span8 mobile-left-pane">
<div class="content--title desktop-only">讲解</div>
<article class="content--container">
<h1 class="title">使用Spring构建REST服务</h1>
<div class="article-body"><div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>REST易于构建和使用，因此已迅速成为在Web上构建Web服务的实际标准。</p>
</div>
<div class="paragraph">
<p>关于REST如何适合微服务世界，还有很多讨论，但是-在本教程中-让我们来看构建RESTful服务。</p>
</div>
<div class="paragraph">
<p>为什么要REST？REST包含Web的戒律，包括其体系结构，优势和其他所有内容。鉴于其作者Roy Fielding参与了十二个规范网络操作的规范，这不足为奇。</p>
</div>
<div class="paragraph">
<p>有什么好处？Web及其核心协议HTTP提供了一系列功能：</p>
</div>
<div class="ulist">
<ul>
<li> <p>适当的动作（ <code>GET</code> ， <code>POST</code> ， <code>PUT</code> ， <code>DELETE</code> ，...）</p> </li>
<li> <p>快取</p> </li>
<li> <p>重定向和转发</p> </li>
<li> <p>安全性（加密和认证）</p> </li>
</ul>
</div>
<div class="paragraph">
<p>这些都是构建弹性服务的关键因素。但这还不是全部。网络是建立在许多微小的规格之上的，因此它能够轻松发展，而不会陷入“标准之战”。</p>
</div>
<div class="paragraph">
<p>开发人员可以利用实现这些不同规格的第三方工具包，立即拥有客户端和服务器技术。</p>
</div>
<div class="paragraph">
<p>因此，基于HTTP的REST API提供了构建灵活的API的方法，这些API可以：</p>
</div>
<div class="ulist">
<ul>
<li> <p>支持向后兼容</p> </li>
<li> <p>可进化的API</p> </li>
<li> <p>可扩展的服务</p> </li>
<li> <p>安全的服务</p> </li>
<li> <p>无状态到有状态服务的范围</p> </li>
</ul>
</div>
<div class="paragraph">
<p>重要的是要认识到，REST <em>本身</em>无处不在，而是一个标准，而是架构上的一种方法，一种样式，一组<em>约束</em> ，可以帮助您构建Web规模的系统。在本教程中，我们将使用Spring产品组合构建RESTful服务，同时利用REST的无堆栈功能。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_getting_started">入门</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在学习本教程时，我们将使用<a href="https://spring.io/projects/spring-boot">Spring Boot</a> 。转到<a href="https://start.spring.io/">Spring Initializr</a>并选择以下内容：</p>
</div>
<div class="ulist">
<ul>
<li> <p>网页</p> </li>
<li> <p>JPA</p> </li>
<li> <p>H2</p> </li>
<li> <p>龙目岛</p> </li>
</ul>
</div>
<div class="paragraph">
<p>然后选择“生成项目”。一种<code>.zip</code>将下载。解压缩。在内部，您将找到一个基于Maven的简单项目，其中包括<code>pom.xml</code>构建文件（注意：您<em>可以</em>使用Gradle。本教程中的示例将基于Maven。）</p>
</div>
<div class="paragraph">
<p>Spring Boot可以与任何IDE一起使用。您可以使用Eclipse，IntelliJ IDEA，Netbeans等。Spring <a href="https://spring.io/tools/">Tool Suite</a>是基于Eclipse的开源IDE发行版，提供Eclipse的Java EE发行版的超集。它包含的功能使使用Spring应用程序更加容易。绝不是必需的。但是，如果您想为按键提供额外的<strong>魅力</strong> ，请考虑一下。这是一个演示如何开始使用STS和Spring Boot的视频。这是使您熟悉这些工具的一般介绍。</p>
</div>
<div class="paragraph">
<p>如果选择IntelliJ IDEA作为本教程的IDE，则必须安装lombok插件。为了了解我们如何在IntelliJ IDEA中安装插件，请看一下<a href="https://www.jetbrains.com/help/idea/managing-plugins.html">manage-plugins</a> 。此后，您必须确保在“首选项”→“编译器”→“注释处理器”下选中“启用注释处理”复选框，如<a href="https://stackoverflow.com/questions/14866765/building-with-lomboks-slf4j-and-intellij-cannot-find-symbol-log" class="bare">https://stackoverflow.com/questions/14866765/building-with-lomboks-slf4j-and- Intellij无法找到符号日志</a></p>
</div>
<div class="videoblock">
<div class="content">
<iframe src="https://www.youtube.com/embed/p8AdyMlpmPk?rel=0" frameborder="0" allowfullscreen></iframe>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_story_so_far">到目前为止的故事...</h2>
<div class="sectionbody">
<div class="paragraph">
<p>让我们从我们可以构造的最简单的东西开始。实际上，为了使其尽可能简单，我们甚至可以省略REST的概念。 （稍后，我们将添加REST以了解它们之间的区别。）</p>
</div>
<div class="paragraph">
<p>我们的示例为管理公司员工的简单工资服务建模。简而言之，您需要将员工对象存储在H2内存数据库中，并通过JPA访问它们。这将被Spring MVC层包装以进行远程访问。</p>
</div>
<div class="listingblock">
<div class="title">nonrest / src / main / java / payroll / Employee.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">package payroll;

import lombok.Data;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;

@Data
@Entity
class Employee {

  private @Id @GeneratedValue Long id;
  private String name;
  private String role;

  Employee() {}

  Employee(String name, String role) {
    this.name = name;
    this.role = role;
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>尽管很小，但此Java类包含许多内容：</p>
</div>
<div class="ulist">
<ul>
<li> <p><code>@Data</code>是Lombok批注，用于创建所有吸气剂，设置器， <code>equals</code> ， <code>hash</code>和<code>toString</code>方法，基于字段。</p> </li>
<li> <p><code>@Entity</code>是一个JPA批注，以使该对象准备好存储在基于JPA的数据存储区中。</p> </li>
<li> <p><code>id</code> ， <code>name</code>和<code>role</code>是我们域对象的属性，第一个被标记了更多的JPA注释以指示它是主键，并由JPA提供程序自动填充。</p> </li>
<li> <p>当我们需要创建一个新实例但还没有ID时，便会创建一个自定义构造函数。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>有了这个领域对象定义，我们现在可以转向<a href="https://spring.io/guides/gs/accessing-data-jpa/">Spring Data JPA</a>来处理繁琐的数据库交互。Spring Data存储库是接口，这些接口具有支持针对后端数据存储读取，更新，删除和创建记录的方法。在适当的情况下，某些存储库还支持数据分页和排序。Spring Data根据在接口中的方法命名中找到的约定来综合实现。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">除了JPA，还有多种存储库实现。您可以使用Spring Data MongoDB，Spring Data GemFire，Spring Data Cassandra等。对于本教程，我们将坚持使用JPA。</td>
</tr>
</tbody>
</table>
</div>
<div class="listingblock">
<div class="title">nonrest / src / main / java / payroll / EmployeeRepository.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">package payroll;

import org.springframework.data.jpa.repository.JpaRepository;

interface EmployeeRepository extends JpaRepository&lt;Employee, Long&gt; {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>该接口扩展了Spring Data JPA的<code>JpaRepository</code> ，将域类型指定为<code>Employee</code>和id类型为<code>Long</code> 。该接口尽管表面上是空的，但只要它支持，它就会打孔：</p>
</div>
<div class="ulist">
<ul>
<li> <p>创建新实例</p> </li>
<li> <p>更新现有的</p> </li>
<li> <p>删除中</p> </li>
<li> <p>查找（一个，全部，通过简单或复杂的属性）</p> </li>
</ul>
</div>
<div class="paragraph">
<p>Spring Data的<a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories">存储库解决方案</a>可以避开数据存储细节，而可以使用特定于域的术语解决大多数问题。</p>
</div>
<div class="paragraph">
<p>信不信由你，这足以启动一个应用程序！Spring Boot应用程序至少是一个<code>public static void main</code>入口点和<code>@SpringBootApplication</code>注解。这告诉Spring Boot尽可能地提供帮助。</p>
</div>
<div class="listingblock">
<div class="title">nonrest / src / main / java / payroll / PayrollApplication.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">package payroll;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class PayrollApplication {

  public static void main(String... args) {
    SpringApplication.run(PayrollApplication.class, args);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@SpringBootApplication</code>是一个元注释，可引入<strong>组件扫描</strong> ， <strong>自动配置</strong>和<strong>属性支持</strong> 。在本教程中，我们不会深入探讨Spring Boot的细节，但从本质上讲，它将启动servlet容器并提供我们的服务。</p>
</div>
<div class="paragraph">
<p>尽管如此，没有数据的应用程序并不是很有趣，所以让我们预加载它。Spring会自动加载follow类：</p>
</div>
<div class="listingblock">
<div class="title">nonrest / src / main / java / payroll / LoadDatabase.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">package payroll;

import lombok.extern.slf4j.Slf4j;

import org.springframework.boot.CommandLineRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@Slf4j
class LoadDatabase {

  @Bean
  CommandLineRunner initDatabase(EmployeeRepository repository) {
    return args -&gt; {
      log.info("Preloading " + repository.save(new Employee("Bilbo Baggins", "burglar")));
      log.info("Preloading " + repository.save(new Employee("Frodo Baggins", "thief")));
    };
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>加载后会发生什么？</p>
</div>
<div class="ulist">
<ul>
<li> <p>Spring Boot将运行所有<code>CommandLineRunner</code>一旦应用程序上下文被加载，beans。</p> </li>
<li> <p>该跑步者将要求提供一份<code>EmployeeRepository</code>您刚刚创建的。</p> </li>
<li> <p>使用它，它将创建两个实体并将其存储。</p> </li>
<li> <p><code>@Slf4j</code>是Lombok批注，用于自动创建基于Slf4j的<code>LoggerFactory</code>如<code>log</code> ，使我们可以记录这些新创建的“员工”。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>右键单击并<strong>运行</strong> <code>PayRollApplication</code> ，这就是您得到的：</p>
</div>
<div class="listingblock">
<div class="title">控制台输出的片段，显示数据的预加载</div>
<div class="content">
<pre>...
2018-08-09 11:36:26.169  INFO 74611 --- [main] payroll.LoadDatabase : Preloading Employee(id=1, name=Bilbo Baggins, role=burglar)
2018-08-09 11:36:26.174  INFO 74611 --- [main] payroll.LoadDatabase : Preloading Employee(id=2, name=Frodo Baggins, role=thief)
...</pre>
</div>
</div>
<div class="paragraph">
<p>这不是<strong>完整的</strong>日志，而只是预加载数据的关键部分。（实际上，请查看整个控制台。真是光荣。）</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_http_is_the_platform">HTTP是平台</h2>
<div class="sectionbody">
<div class="paragraph">
<p>要使用Web层包装存储库，必须使用Spring MVC。多亏了Spring Boot，几乎没有基础代码可以编写。相反，我们可以专注于操作：</p>
</div>
<div class="listingblock">
<div class="title">nonrest / src / main / java / payroll / EmployeeController.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">package payroll;

import java.util.List;

import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

@RestController
class EmployeeController {

  private final EmployeeRepository repository;

  EmployeeController(EmployeeRepository repository) {
    this.repository = repository;
  }

  // Aggregate root

  @GetMapping("/employees")
  List&lt;Employee&gt; all() {
    return repository.findAll();
  }

  @PostMapping("/employees")
  Employee newEmployee(@RequestBody Employee newEmployee) {
    return repository.save(newEmployee);
  }

  // Single item

  @GetMapping("/employees/{id}")
  Employee one(@PathVariable Long id) {

    return repository.findById(id)
      .orElseThrow(() -&gt; new EmployeeNotFoundException(id));
  }

  @PutMapping("/employees/{id}")
  Employee replaceEmployee(@RequestBody Employee newEmployee, @PathVariable Long id) {

    return repository.findById(id)
      .map(employee -&gt; {
        employee.setName(newEmployee.getName());
        employee.setRole(newEmployee.getRole());
        return repository.save(employee);
      })
      .orElseGet(() -&gt; {
        newEmployee.setId(id);
        return repository.save(newEmployee);
      });
  }

  @DeleteMapping("/employees/{id}")
  void deleteEmployee(@PathVariable Long id) {
    repository.deleteById(id);
  }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li> <p><code>@RestController</code>指示每种方法返回的数据将直接写入响应主体中，而不呈现模板。</p> </li>
<li> <p>一个<code>EmployeeRepository</code>由构造函数注入到控制器中。</p> </li>
<li> <p>我们为每个操作提供路线（ <code>@GetMapping</code> ， <code>@PostMapping</code> ， <code>@PutMapping</code>和<code>@DeleteMapping</code> ，对应于HTTP <code>GET</code> ， <code>POST</code> ， <code>PUT</code>和<code>DELETE</code>电话）。（注意：阅读每种方法并了解它们的作用非常有用。）</p> </li>
<li> <p><code>EmployeeNotFoundException</code>是一个例外，用于指示何时查找员工但找不到员工。</p> </li>
</ul>
</div>
<div class="listingblock">
<div class="title">nonrest / src / main / java / payroll / EmployeeNotFoundException.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">package payroll;

class EmployeeNotFoundException extends RuntimeException {

  EmployeeNotFoundException(Long id) {
    super("Could not find employee " + id);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>当一个<code>EmployeeNotFoundException</code>抛出该异常，Spring MVC配置的这个额外花絮用于呈现<strong>HTTP 404</strong> ：</p>
</div>
<div class="listingblock">
<div class="title">nonrest / src / main / java / payroll / EmployeeNotFoundAdvice.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">package payroll;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.ResponseStatus;

@ControllerAdvice
class EmployeeNotFoundAdvice {

  @ResponseBody
  @ExceptionHandler(EmployeeNotFoundException.class)
  @ResponseStatus(HttpStatus.NOT_FOUND)
  String employeeNotFoundHandler(EmployeeNotFoundException ex) {
    return ex.getMessage();
  }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li> <p><code>@ResponseBody</code>表示此建议已直接呈现到响应主体中。</p> </li>
<li> <p><code>@ExceptionHandler</code>将建议配置为仅在以下情况下响应<code>EmployeeNotFoundException</code>被抛出。</p> </li>
<li> <p><code>@ResponseStatus</code>说要发出<code>HttpStatus.NOT_FOUND</code> ，即<strong>HTTP 404</strong> 。</p> </li>
<li> <p>建议的主体生成内容。在这种情况下，它会给出异常消息。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>要启动该应用程序，请右键单击<code>public static void main</code>在<code>PayRollApplication</code>并选择从IDE <strong>运行</strong> ，或者：</p>
</div>
<div class="paragraph">
<p>Spring Initializr使用Maven包装器，因此键入：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./mvnw clean spring-boot:run</pre>
</div>
</div>
<div class="paragraph">
<p>或者，使用安装的maven版本键入以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ mvn clean spring-boot:run</pre>
</div>
</div>
<div class="paragraph">
<p>应用启动后，我们可以立即对其进行查询。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl -v localhost:8080/employees</pre>
</div>
</div>
<div class="paragraph">
<p>这将产生：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>*   Trying ::1...
* TCP_NODELAY set
* Connected to localhost (::1) port 8080 (#0)
&gt; GET /employees HTTP/1.1
&gt; Host: localhost:8080
&gt; User-Agent: curl/7.54.0
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 200
&lt; Content-Type: application/json;charset=UTF-8
&lt; Transfer-Encoding: chunked
&lt; Date: Thu, 09 Aug 2018 17:58:00 GMT
&lt;
* Connection #0 to host localhost left intact
[{"id":1,"name":"Bilbo Baggins","role":"burglar"},{"id":2,"name":"Frodo Baggins","role":"thief"}]</pre>
</div>
</div>
<div class="paragraph">
<p>在这里，您可以查看压缩格式的预加载数据。</p>
</div>
<div class="paragraph">
<p>如果您尝试查询一个不存在的用户...</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl -v localhost:8080/employees/99</pre>
</div>
</div>
<div class="paragraph">
<p>你得到...</p>
</div>
<div class="listingblock">
<div class="content">
<pre>*   Trying ::1...
* TCP_NODELAY set
* Connected to localhost (::1) port 8080 (#0)
&gt; GET /employees/99 HTTP/1.1
&gt; Host: localhost:8080
&gt; User-Agent: curl/7.54.0
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 404
&lt; Content-Type: text/plain;charset=UTF-8
&lt; Content-Length: 26
&lt; Date: Thu, 09 Aug 2018 18:00:56 GMT
&lt;
* Connection #0 to host localhost left intact
Could not find employee 99</pre>
</div>
</div>
<div class="paragraph">
<p>该消息很好地显示了<strong>HTTP 404</strong>错误和自定义消息“ <strong>找不到雇员99”</strong> 。</p>
</div>
<div class="paragraph">
<p>显示当前编码的交互并不难...</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl -X POST localhost:8080/employees -H 'Content-type:application/json' -d '{"name": "Samwise Gamgee", "role": "gardener"}'</pre>
</div>
</div>
<div class="paragraph">
<p>创建一个新的<code>Employee</code>记录，然后将内容发送回给我们：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>{"id":3,"name":"Samwise Gamgee","role":"gardener"}</pre>
</div>
</div>
<div class="paragraph">
<p>您可以更改用户：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl -X PUT localhost:8080/employees/3 -H 'Content-type:application/json' -d '{"name": "Samwise Gamgee", "role": "ring bearer"}'</pre>
</div>
</div>
<div class="paragraph">
<p>更新用户：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>{"id":3,"name":"Samwise Gamgee","role":"ring bearer"}</pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-warning" title="警告"></i> </td>
<td class="content">根据您构建服务的方式，可能会产生重大影响。在这种情况下， <strong>replace</strong>比<strong>update</strong>是更好的描述。例如，如果未提供名称，则将其清空。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>您可以删除...</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl -X DELETE localhost:8080/employees/3
$ curl localhost:8080/employees/3
Could not find employee 3</pre>
</div>
</div>
<div class="paragraph">
<p>这一切都很好，但是我们有RESTful服务吗？（如果您没有收到提示，则答案为否。）</p>
</div>
<div class="paragraph">
<p>少了什么东西？</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_what_makes_something_restful">是什么使RESTful变得有趣？</h2>
<div class="sectionbody">
<div class="paragraph">
<p>到目前为止，您已经有了基于Web的服务，该服务可以处理涉及员工数据的核心操作。但这还不足以使事情变得“ RESTful”。</p>
</div>
<div class="ulist">
<ul>
<li> <p>像/ employees / 3这样的漂亮URL并不是REST。</p> </li>
<li> <p>仅仅使用<code>GET</code> ， <code>POST</code>等不是REST。</p> </li>
<li> <p>安排所有CRUD操作不是REST。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>实际上，到目前为止，我们更好地描述了<strong>RPC</strong> （ <strong>远程过程调用</strong> ）。那是因为没有办法知道如何与该服务进行交互。如果您今天发布了此文档，则还必须编写文档或在其中包含所有详细信息的位置托管开发人员门户。</p>
</div>
<div class="paragraph">
<p>Roy Fielding的这一声明可能进一步为<strong>REST</strong>和<strong>RPC</strong>之间的区别提供了线索：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>I am getting frustrated by the number of people calling any HTTP-based interface a REST API. Today’s example is the SocialSite REST API. That is RPC. It screams RPC. There is so much coupling on display that it should be given an X rating.

What needs to be done to make the REST architectural style clear on the notion that hypertext is a constraint? In other words, if the engine of application state (and hence the API) is not being driven by hypertext, then it cannot be RESTful and cannot be a REST API. Period. Is there some broken manual somewhere that needs to be fixed?</pre>
</div>
</div>
<div class="paragraph">
<p>在我们的表示中不包含超媒体的副作用是客户端必须使用硬编码URI来导航API。这导致了与电子商务在网络上兴起之前一样的脆弱性。这表明我们的JSON输出需要一点帮助。</p>
</div>
<div class="paragraph">
<p>介绍<a href="https://spring.io/projects/spring-hateoas">Spring HATEOAS</a> ，这是一个Spring项目，旨在帮助您编写超媒体驱动的输出。要将服务升级为RESTful，请将其添加到您的构建中：</p>
</div>
<div class="listingblock">
<div class="title">将Spring HATEOAS添加到pom.xml</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
	&lt;artifactId&gt;spring-boot-starter-hateoas&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个小小的库将为我们提供构造以定义RESTful服务，然后将其呈现为可接受的格式以供客户端使用。</p>
</div>
<div class="paragraph">
<p>任何RESTful服务的关键要素是添加到相关操作的<a href="https://tools.ietf.org/html/rfc5988">链接</a> 。为了使您的控制器更加RESTful，请添加以下链接：</p>
</div>
<div class="listingblock">
<div class="title">获取单个项目资源</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@GetMapping("/employees/{id}")
Resource&lt;Employee&gt; one(@PathVariable Long id) {

  Employee employee = repository.findById(id)
    .orElseThrow(() -&gt; new EmployeeNotFoundException(id));

  return new Resource&lt;&gt;(employee,
    linkTo(methodOn(EmployeeController.class).one(id)).withSelfRel(),
    linkTo(methodOn(EmployeeController.class).all()).withRel("employees"));
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">相关进口声明</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">import static org.springframework.hateoas.mvc.ControllerLinkBuilder.*;
import org.springframework.hateoas.Resource;
import org.springframework.hateoas.Resources;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这与我们以前的非常相似，但是有一些变化：</p>
</div>
<div class="ulist">
<ul>
<li> <p>方法的返回类型已从更改为<code>Employee</code>至<code>Resource<Employee></code> 。 <code>Resource<T></code>是Spring HATEOAS的通用容器，不仅包含数据，还包含链接的集合。</p> </li>
<li> <p><code>linkTo(methodOn(EmployeeController.class).one(id)).withSelfRel()</code>要求Spring HATEOAS建立指向<code>EmployeeController</code>的<code>one()</code>方法，并将其标记为<a href="https://www.iana.org/assignments/link-relations/link-relations.xhtml">自我</a>链接。</p> </li>
<li> <p><code>linkTo(methodOn(EmployeeController.class).all()).withRel("employees")</code>要求Spring HATEOAS构建到聚合根的链接， <code>all()</code> ，并将其称为“员工”。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>“建立链接”是什么意思？Spring HATEOAS的核心类型之一是<code>Link</code> 。它包括一个<strong>URI</strong>和一个<strong>rel</strong> （关系）。链接是赋予网络力量的力量。在万维网出现之前，其他文档系统会提供信息或链接，但是文档与数据的链接将网络缝合在一起。</p>
</div>
<div class="paragraph">
<p>Roy Fielding鼓励使用使网络成功的相同技术来构建API，链接就是其中之一。</p>
</div>
<div class="paragraph">
<p>如果重新启动应用程序并查询<strong>Bilbo</strong>的雇员记录，您将得到与之前稍有不同的响应：</p>
</div>
<div class="listingblock">
<div class="title">RESTful代表单个员工</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">{
  "id": 1,
  "name": "Bilbo Baggins",
  "role": "burglar",
  "_links": {
    "self": {
      "href": "http://localhost:8080/employees/1"
    },
    "employees": {
      "href": "http://localhost:8080/employees"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此解压缩后的输出不仅显示您先前看到的数据元素（ <code>id</code> ， <code>name</code>和<code>role</code> ），但也<code>_links</code>包含两个URI的条目。整个文档使用<a href="http://stateless.co/hal_specification.html">HAL</a>格式化。</p>
</div>
<div class="paragraph">
<p>HAL是一个轻量级的<a href="https://tools.ietf.org/html/draft-kelly-json-hal-08">介质类型</a> ，允许编码不只是数据，而且还超媒体管制，提醒消费者，他们可以向浏览API的其他部分。在这种情况下，存在一个“自我”链接（有点像<code>this</code>代码中的语句）以及返回<strong>聚合根</strong>的链接。</p>
</div>
<div class="paragraph">
<p>为了使聚合根ALSO更加RESTful，您希望包括顶级链接，同时还包括以下任何RESTful组件：</p>
</div>
<div class="listingblock">
<div class="title">获取聚合的根资源</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@GetMapping("/employees")
Resources&lt;Resource&lt;Employee&gt;&gt; all() {

  List&lt;Resource&lt;Employee&gt;&gt; employees = repository.findAll().stream()
    .map(employee -&gt; new Resource&lt;&gt;(employee,
      linkTo(methodOn(EmployeeController.class).one(employee.getId())).withSelfRel(),
      linkTo(methodOn(EmployeeController.class).all()).withRel("employees")))
    .collect(Collectors.toList());

  return new Resources&lt;&gt;(employees,
    linkTo(methodOn(EmployeeController.class).all()).withSelfRel());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>哇！该方法曾经只是<code>repository.findAll()</code>变大了！让我们打开包装。</p>
</div>
<div class="paragraph">
<p><code>Resources<></code>是另一个旨在封装集合的Spring HATEOAS容器。它还允许您包含链接。不要让第一个陈述漏掉。“封装集合”何时表示？员工收款？</p>
</div>
<div class="paragraph">
<p>不完全的。</p>
</div>
<div class="paragraph">
<p>由于我们在谈论REST，因此它应该封装<strong>员工资源的</strong>集合。</p>
</div>
<div class="paragraph">
<p>这就是为什么您获取所有员工，然后将其转换为<code>Resource<Employee></code>对象。（感谢Java 8 Stream API！）</p>
</div>
<div class="paragraph">
<p>如果重新启动应用程序并获取聚合根，则可以看到它的外观。</p>
</div>
<div class="listingblock">
<div class="title">RESTful表示员工资源集合</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">{
  "_embedded": {
    "employeeList": [
      {
        "id": 1,
        "name": "Bilbo Baggins",
        "role": "burglar",
        "_links": {
          "self": {
            "href": "http://localhost:8080/employees/1"
          },
          "employees": {
            "href": "http://localhost:8080/employees"
          }
        }
      },
      {
        "id": 2,
        "name": "Frodo Baggins",
        "role": "thief",
        "_links": {
          "self": {
            "href": "http://localhost:8080/employees/2"
          },
          "employees": {
            "href": "http://localhost:8080/employees"
          }
        }
      }
    ]
  },
  "_links": {
    "self": {
      "href": "http://localhost:8080/employees"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于服务于员工资源集合的聚合根，有一个顶层<strong>“自我”</strong>链接。<strong>“集合”</strong>列在<strong>“ _embedded”</strong>部分的下面。这就是HAL表示集合的方式。</p>
</div>
<div class="paragraph">
<p>并且集合中的每个成员都有其信息以及相关链接。</p>
</div>
<div class="paragraph">
<p>添加所有这些链接的意义何在？随着时间的推移，它可以发展REST服务。在将来添加新链接时，可以维护现有链接。较新的客户端可以利用新链接，而旧客户端可以在旧链接上维持自己的位置。如果服务被重新定位和移动，这将特别有用。只要保持链接结构，客户端就可以查找并与事物进行交互。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_simplifying_link_creation">简化链接创建</h2>
<div class="sectionbody">
<div class="paragraph">
<p>您是否注意到在创建单个员工链接时重复进行？两次显示了提供指向员工的单个链接以及指向聚合根的“员工”链接的代码。如果那引起您的关注，那就好！有一个解决方案。</p>
</div>
<div class="paragraph">
<p>简而言之，您需要定义一个函数来转换<code>Employee</code>反对<code>Resource<Employee></code>对象。尽管您可以轻松地自己编写此方法，但在实现Spring HATEOAS的过程中仍有很多好处<code>ResourceAssembler</code>接口。</p>
</div>
<div class="listingblock">
<div class="title">evolution / src / main / java / payroll / EmployeeResourceAssembler.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">package payroll;

import static org.springframework.hateoas.mvc.ControllerLinkBuilder.*;

import org.springframework.hateoas.Resource;
import org.springframework.hateoas.ResourceAssembler;
import org.springframework.stereotype.Component;

@Component
class EmployeeResourceAssembler implements ResourceAssembler&lt;Employee, Resource&lt;Employee&gt;&gt; {

  @Override
  public Resource&lt;Employee&gt; toResource(Employee employee) {

    return new Resource&lt;&gt;(employee,
      linkTo(methodOn(EmployeeController.class).one(employee.getId())).withSelfRel(),
      linkTo(methodOn(EmployeeController.class).all()).withRel("employees"));
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个简单的界面有一种方法： <code>toResource()</code> 。它基于转换非资源对象（ <code>Employee</code> ）转换为基于资源的对象（ <code>Resource<Employee></code> ）。</p>
</div>
<div class="paragraph">
<p>您之前在控制器中看到的所有代码都可以移入此类。并通过应用Spring Framework的<code>@Component</code> ，该组件将在应用启动时自动创建。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">Spring HATEOAS针对所有资源的抽象基类是<code>ResourceSupport</code> 。但为简单起见，我建议使用<code>Resource<T></code>作为将所有POJO轻松包装为资源的机制。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>要利用此汇编器，只需更改<code>EmployeeController</code>通过将汇编程序注入构造函数中。然后</p>
</div>
<div class="listingblock">
<div class="title">将EmployeeResourceAssembler注入控制器</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@RestController
class EmployeeController {

  private final EmployeeRepository repository;

  private final EmployeeResourceAssembler assembler;

  EmployeeController(EmployeeRepository repository,
             EmployeeResourceAssembler assembler) {

    this.repository = repository;
    this.assembler = assembler;
  }

  ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>从这里，您可以在单项员工方法中使用它：</p>
</div>
<div class="listingblock">
<div class="title">使用汇编器获取单项资源</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@GetMapping("/employees/{id}")
Resource&lt;Employee&gt; one(@PathVariable Long id) {

  Employee employee = repository.findById(id)
    .orElseThrow(() -&gt; new EmployeeNotFoundException(id));

  return assembler.toResource(employee);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这段代码几乎相同，除了不是创建<code>Resource<Employee></code>在这里，您将其委托给汇编器。也许看起来不多？</p>
</div>
<div class="paragraph">
<p>在聚合根控制器方法中应用相同的内容会更加令人印象深刻：</p>
</div>
<div class="listingblock">
<div class="title">使用汇编器获取聚合根资源</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@GetMapping("/employees")
Resources&lt;Resource&lt;Employee&gt;&gt; all() {

  List&lt;Resource&lt;Employee&gt;&gt; employees = repository.findAll().stream()
    .map(assembler::toResource)
    .collect(Collectors.toList());

  return new Resources&lt;&gt;(employees,
    linkTo(methodOn(EmployeeController.class).all()).withSelfRel());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>再次，代码几乎相同，但是您必须替换所有代码<code>Resource<Employee></code>与创建逻辑<code>map(assembler::toResource)</code> 。感谢Java 8方法参考，将其插入并简化控制器非常容易。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-important" title="重要"></i> </td>
<td class="content">Spring HATEOAS的主要设计目标是使“正确的事情”变得更容易。在这种情况下，无需对事物进行硬编码即可将超媒体添加到您的服务中。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>在此阶段，您已经创建了一个Spring MVC REST控制器，该控制器实际上可以生成超媒体支持的内容！不使用HAL的客户端在使用纯数据时可以忽略多余的位。会说HAL的客户可以浏览您的授权API。</p>
</div>
<div class="paragraph">
<p>但这不是用Spring构建真正的RESTful服务所需要的唯一东西。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_evolving_rest_apis">不断发展的REST API</h2>
<div class="sectionbody">
<div class="paragraph">
<p>使用一个附加的库和几行附加的代码，您已将超媒体添加到您的应用程序中。但这不是使服务成为RESTful所需的唯一条件。REST的一个重要方面是它既不是技术堆栈也不是单一标准。</p>
</div>
<div class="paragraph">
<p>REST是体系结构约束的集合，采用这些约束可使您的应用程序更具弹性。弹性的关键因素是，当您升级服务时，您的客户不会遭受停机的困扰。</p>
</div>
<div class="paragraph">
<p>在过去，升级是臭名昭著的，因为它破坏了客户。换句话说，对服务器的升级需要对客户端的更新。在当今时代，升级花费的停机时间甚至数小时甚至数分钟可能导致数百万美元的收入损失。</p>
</div>
<div class="paragraph">
<p>一些公司要求您向管理层提出计划，以最大程度地减少停机时间。过去，您可以避免在周日凌晨2:00进行升级，此时负载最小。但是，在当今与国际客户进行的基于Internet的电子商务中，这种策略并不那么有效。</p>
</div>
<div class="paragraph">
<p>基于SOAP的服务和基于CORBA的服务非常脆弱。很难推出可以同时支持新旧客户端的服务器。借助基于REST的实践，它变得容易得多。特别是使用Spring堆栈。</p>
</div>
<div class="paragraph">
<p>想象一下这个设计问题：您已经使用此工具推出了一个系统<code>Employee</code>基于记录。该系统是一个重大打击。您已将系统卖给了无数企业。突然之间，需要将员工姓名拆分为<code>firstName</code>和<code>lastName</code>出现。</p>
</div>
<div class="paragraph">
<p>哦哦没想到。</p>
</div>
<div class="paragraph">
<p>在打开之前<code>Employee</code>类并替换单个字段<code>name</code>与<code>firstName</code>和<code>lastName</code> ，停下来想一想。那会打扰任何客户吗？升级它们需要多长时间。您甚至控制所有访问您服务的客户吗？</p>
</div>
<div class="paragraph">
<p>停机时间=赔钱。管理层为此做好了准备吗？</p>
</div>
<div class="paragraph">
<p>有一种古老的策略要比REST早很多年。</p>
</div>
<div class="quoteblock">
<blockquote>切勿删除数据库中的列。
</blockquote>
<div class="attribution">—未知</div>
</div>
<div class="paragraph">
<p>您始终可以将列（字段）添加到数据库表中。但是不要带走。RESTful服务的原理是相同的。向您的JSON表示中添加新字段，但不要浪费任何精力。像这样：</p>
</div>
<div class="listingblock">
<div class="title">支持多个客户端的JSON</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">{
  "id": 1,
  "firstName": "Bilbo",
  "lastName": "Baggins",
  "role": "burglar",
  "name": "Bilbo Baggins",
  "_links": {
    "self": {
      "href": "http://localhost:8080/employees/1"
    },
    "employees": {
      "href": "http://localhost:8080/employees"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意这种格式的显示方式<code>firstName</code> ， <code>lastName</code>和<code>name</code> ？它具有重复信息的功能，目的是支持新老客户。这意味着您可以升级服务器而无需同时升级客户端。采取适当措施可以减少停机时间。</p>
</div>
<div class="paragraph">
<p>而且，不仅应该以“旧方式”和“新方式”显示此信息，还应该以两种方式处理传入的数据。</p>
</div>
<div class="paragraph">
<p>怎么样？简单。像这样：</p>
</div>
<div class="listingblock">
<div class="title">处理“旧”和“新”客户的员工记录</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">package payroll;

import lombok.Data;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;

@Data
@Entity
class Employee {

  private @Id @GeneratedValue Long id;
  private String firstName;
  private String lastName;
  private String role;

  Employee() {}

  Employee(String firstName, String lastName, String role) {
    this.firstName = firstName;
    this.lastName = lastName;
    this.role = role;
  }

  public String getName() {
    return this.firstName + " " + this.lastName;
  }

  public void setName(String name) {
    String[] parts =name.split(" ");
    this.firstName = parts[0];
    this.lastName = parts[1];
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此类与以前的版本非常相似<code>Employee</code> 。让我们来看一下更改：</p>
</div>
<div class="ulist">
<ul>
<li> <p>领域<code>name</code>已被取代<code>firstName</code>和<code>lastName</code> 。龙目岛将为这些生成getter和setter。</p> </li>
<li> <p>旧的“虚拟”吸气剂<code>name</code>属性， <code>getName()</code>被定义为。它使用<code>firstName</code>和<code>lastName</code>产生价值的字段。</p> </li>
<li> <p>旧的“虚拟”安装员<code>name</code>属性也已定义<code>setName()</code> 。它解析传入的字符串并将其存储到适当的字段中。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>当然，对您的API所做的每一次更改都不像拆分字符串或合并两个字符串那样简单。但是对于大多数情况，肯定要提出一组转换，不是吗？</p>
</div>
<div class="paragraph">
<p>另一个微调是确保您的每个REST方法返回正确的响应。像这样更新POST方法：</p>
</div>
<div class="listingblock">
<div class="title">POST处理“旧”和“新”客户端请求</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@PostMapping("/employees")
ResponseEntity&lt;?&gt; newEmployee(@RequestBody Employee newEmployee) throws URISyntaxException {

  Resource&lt;Employee&gt; resource = assembler.toResource(repository.save(newEmployee));

  return ResponseEntity
    .created(new URI(resource.getId().expand().getHref()))
    .body(resource);
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li> <p>新的<code>Employee</code>对象将像以前一样保存。但是结果对象使用<code>EmployeeResourceAssembler</code> 。</p> </li>
<li> <p> Spring MVC <code>ResponseEntity</code>用于创建<strong>HTTP 201已创建</strong>状态消息。这种类型的响应通常包括<strong>位置</strong>响应标头，我们使用新形成的链接。</p> </li>
<li> <p>此外，返回已保存对象的基于资源的版本。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>进行此调整后，您可以使用同一端点创建新的员工资源，并使用旧版<code>name</code>领域：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl -v -X POST localhost:8080/employees -H 'Content-Type:application/json' -d '{"name": "Samwise Gamgee", "role": "gardener"}'</pre>
</div>
</div>
<div class="paragraph">
<p>输出如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&gt; POST /employees HTTP/1.1
&gt; Host: localhost:8080
&gt; User-Agent: curl/7.54.0
&gt; Accept: */*
&gt; Content-Type:application/json
&gt; Content-Length: 46
&gt;
&lt; Location: http://localhost:8080/employees/3
&lt; Content-Type: application/hal+json;charset=UTF-8
&lt; Transfer-Encoding: chunked
&lt; Date: Fri, 10 Aug 2018 19:44:43 GMT
&lt;
{
  "id": 3,
  "firstName": "Samwise",
  "lastName": "Gamgee",
  "role": "gardener",
  "name": "Samwise Gamgee",
  "_links": {
    "self": {
      "href": "http://localhost:8080/employees/3"
    },
    "employees": {
      "href": "http://localhost:8080/employees"
    }
  }
}</pre>
</div>
</div>
<div class="paragraph">
<p>这不仅使生成的对象在HAL中呈现（两者<code>name</code>以及<code>firstName</code> / <code>lastName</code> ），还填充了<strong>Location</strong>标头<code><a href="http://localhost:8080/employees/3" class="bare">http://localhost:8080/employees/3</a></code> 。具有超媒体功能的客户端可以选择“浏览”该新资源并继续与之交互。</p>
</div>
<div class="paragraph">
<p>PUT控制器方法需要类似的调整：</p>
</div>
<div class="listingblock">
<div class="title">为不同的客户处理PUT</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@PutMapping("/employees/{id}")
ResponseEntity&lt;?&gt; replaceEmployee(@RequestBody Employee newEmployee, @PathVariable Long id) throws URISyntaxException {

  Employee updatedEmployee = repository.findById(id)
    .map(employee -&gt; {
      employee.setName(newEmployee.getName());
      employee.setRole(newEmployee.getRole());
      return repository.save(employee);
    })
    .orElseGet(() -&gt; {
      newEmployee.setId(id);
      return repository.save(newEmployee);
    });

  Resource&lt;Employee&gt; resource = assembler.toResource(updatedEmployee);

  return ResponseEntity
    .created(new URI(resource.getId().expand().getHref()))
    .body(resource);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的<code>Employee</code>从<code>save()</code>然后使用<code>EmployeeResourceAssembler</code>变成一个<code>Resource<Employee></code>宾语。由于我们需要比<strong>200 OK</strong>更详细的HTTP响应代码，因此我们将使用Spring MVC的<code>ResponseEntity</code>包装纸。它有一个方便的静态方法<code>created()</code>我们可以在其中插入资源的URI。</p>
</div>
<div class="paragraph">
<p>通过抓住<code>resource</code>您可以通过获取它的“自我”链接<code>getId()</code>方法调用。此方法产生一个<code>Link</code>您可以将其变成Java <code>URI</code> 。为了更好地捆绑在一起，您可以注入<code>resource</code>本身进入<code>body()</code>方法。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-important" title="重要"></i> </td>
<td class="content">在REST中，资源的<strong>ID</strong>是该资源的URI。因此，Spring HATEOAS不会给您<code>id</code>基础数据类型的字段（没有客户端应具有），而是它的URI。而且不要混淆<code>ResourceSupport.getId()</code>与<code>Employee.getId()</code> 。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>如果<strong>HTTP 201 Created</strong>带有正确的语义，这是有争议的，因为我们不一定要“创建”新资源。但是它预装了<strong>Location</strong>响应标头，因此请运行它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl -v -X PUT localhost:8080/employees/3 -H 'Content-Type:application/json' -d '{"name": "Samwise Gamgee", "role": "ring bearer"}'

* TCP_NODELAY set
* Connected to localhost (::1) port 8080 (#0)
&gt; PUT /employees/3 HTTP/1.1
&gt; Host: localhost:8080
&gt; User-Agent: curl/7.54.0
&gt; Accept: */*
&gt; Content-Type:application/json
&gt; Content-Length: 49
&gt;
&lt; HTTP/1.1 201
&lt; Location: http://localhost:8080/employees/3
&lt; Content-Type: application/hal+json;charset=UTF-8
&lt; Transfer-Encoding: chunked
&lt; Date: Fri, 10 Aug 2018 19:52:56 GMT
{
	"id": 3,
	"firstName": "Samwise",
	"lastName": "Gamgee",
	"role": "ring bearer",
	"name": "Samwise Gamgee",
	"_links": {
		"self": {
			"href": "http://localhost:8080/employees/3"
		},
		"employees": {
			"href": "http://localhost:8080/employees"
		}
	}
}</pre>
</div>
</div>
<div class="paragraph">
<p>该员工资源现已更新，并且位置URI被发送回。最后，适当地更新DELETE操作：</p>
</div>
<div class="listingblock">
<div class="title">处理DELETE请求</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@DeleteMapping("/employees/{id}")
ResponseEntity&lt;?&gt; deleteEmployee(@PathVariable Long id) {

  repository.deleteById(id);

  return ResponseEntity.noContent().build();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将返回<strong>HTTP 204 No Content</strong>响应。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl -v -X DELETE localhost:8080/employees/1

* TCP_NODELAY set
* Connected to localhost (::1) port 8080 (#0)
&gt; DELETE /employees/1 HTTP/1.1
&gt; Host: localhost:8080
&gt; User-Agent: curl/7.54.0
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 204
&lt; Date: Fri, 10 Aug 2018 21:30:26 GMT</pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-important" title="重要"></i> </td>
<td class="content">更改<code>Employee</code>类将需要与您的数据库团队协调，以便他们可以将现有内容正确迁移到新列中。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>现在，您可以进行升级了，它不会打扰现有的客户端，而新的客户端可以利用这些增强功能！</p>
</div>
<div class="paragraph">
<p>顺便说一句，您是否担心通过网络发送太多信息？在某些每个字节都很重要的系统中，API的发展可能需要退居二线。但是在进行测量之前，不要追求这种过早的优化。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_building_links_into_your_rest_api">将链接构建到REST API中</h2>
<div class="sectionbody">
<div class="paragraph">
<p>到目前为止，您已经建立了具有裸露骨骼链接的可演化API。为了增加您的API并更好地为您的客户服务，您需要接受<strong>Hypermedia作为应用程序状态引擎</strong>的概念。</p>
</div>
<div class="paragraph">
<p>这意味着什么？在本节中，您将详细研究它。</p>
</div>
<div class="paragraph">
<p>业务逻辑不可避免地建立涉及流程的规则。此类系统的风险在于，我们经常将此类服务器端逻辑带入客户端并建立牢固的耦合。REST旨在断开此类连接并最小化此类耦合。</p>
</div>
<div class="paragraph">
<p>为了说明如何在不触发客户端变更的情况下应对状态变化，请设想添加一个可以执行订单的系统。</p>
</div>
<div class="paragraph">
<p>第一步，定义一个<code>Order</code>记录：</p>
</div>
<div class="listingblock">
<div class="title">links / src / main / java / payroll / Order.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">package payroll;

import lombok.Data;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity
@Data
@Table(name = "CUSTOMER_ORDER")
class Order {

  private @Id @GeneratedValue Long id;

  private String description;
  private Status status;

  Order() {}

  Order(String description, Status status) {

    this.description = description;
    this.status = status;
  }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li> <p>该课程需要JPA <code>@Table</code>注释将表的名称更改为<code>CUSTOMER_ORDER</code>因为<code>ORDER</code>不是表格的有效名称。</p> </li>
<li> <p>它包括一个<code>description</code>领域以及<code>status</code>领域。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>从客户提交订单到订单已履行或取消，订单必须经历一系列的状态转换。可以将其捕获为Java <code>enum</code> ：</p>
</div>
<div class="listingblock">
<div class="title">链接/src/main/java/payroll/Status.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">package payroll;

enum Status {

  IN_PROGRESS,
  COMPLETED,
  CANCELLED;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个<code>enum</code>捕获各种状态<code>Order</code>可以占领。对于本教程，让我们保持简单。</p>
</div>
<div class="paragraph">
<p>为了支持与数据库中的订单进行交互，您必须定义一个相应的Spring Data存储库：</p>
</div>
<div class="listingblock">
<div class="title">Spring Data JPA的<code>JpaRepository</code>基本介面</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">interface OrderRepository extends JpaRepository&lt;Order, Long&gt; {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有了这个，您现在可以定义一个基本的<code>OrderController</code> ：</p>
</div>
<div class="listingblock">
<div class="title">links / src / main / java / payroll / OrderController.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@RestController
class OrderController {

  private final OrderRepository orderRepository;
  private final OrderResourceAssembler assembler;

  OrderController(OrderRepository orderRepository,
          OrderResourceAssembler assembler) {

    this.orderRepository = orderRepository;
    this.assembler = assembler;
  }

  @GetMapping("/orders")
  Resources&lt;Resource&lt;Order&gt;&gt; all() {

    List&lt;Resource&lt;Order&gt;&gt; orders = orderRepository.findAll().stream()
      .map(assembler::toResource)
      .collect(Collectors.toList());

    return new Resources&lt;&gt;(orders,
      linkTo(methodOn(OrderController.class).all()).withSelfRel());
  }

  @GetMapping("/orders/{id}")
  Resource&lt;Order&gt; one(@PathVariable Long id) {
    return assembler.toResource(
      orderRepository.findById(id)
        .orElseThrow(() -&gt; new OrderNotFoundException(id)));
  }

  @PostMapping("/orders")
  ResponseEntity&lt;Resource&lt;Order&gt;&gt; newOrder(@RequestBody Order order) {

    order.setStatus(Status.IN_PROGRESS);
    Order newOrder = orderRepository.save(order);

    return ResponseEntity
      .created(linkTo(methodOn(OrderController.class).one(newOrder.getId())).toUri())
      .body(assembler.toResource(newOrder));
  }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li> <p>它包含与迄今为止构建的控制器相同的REST控制器设置。</p> </li>
<li> <p>它同时注入<code>OrderRepository</code>以及（尚未构建） <code>OrderResourceAssembler</code> 。</p> </li>
<li> <p>Spring的前两条路由处理聚合根以及单个项<code>Order</code>资源请求。</p> </li>
<li> <p>第三个Spring MVC路线通过在<code>IN_PROGRESS</code>州。</p> </li>
<li> <p>所有的控制器方法都返回Spring HATEOAS之一<code>ResourceSupport</code>子类，以正确呈现超媒体（或围绕此类的包装器）。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>在建立之前<code>OrderResourceAssembler</code> ，让我们讨论一下需要发生的事情。您正在建模之间的状态流<code>Status.IN_PROGRESS</code> ， <code>Status.COMPLETED</code>和<code>Status.CANCELLED</code> 。向客户端提供此类数据时，很自然的事情是让客户端根据此有效负载决定它可以做什么。</p>
</div>
<div class="paragraph">
<p>但这是错误的。</p>
</div>
<div class="paragraph">
<p>在此流程中引入新状态时会发生什么？UI上各种按钮的放置可能是错误的。</p>
</div>
<div class="paragraph">
<p>如果您在更改国际支持并显示每个州的特定于语言环境的文本时更改了每个州的名称怎么办？那很可能会破坏所有客户。</p>
</div>
<div class="paragraph">
<p>输入<strong>HATEOAS</strong>或<strong>Hypermedia作为应用程序状态引擎</strong> 。与其让客户端解析有效负载，不如给他们链接以发出有效动作的信号。将基于状态的操作与数据的有效负载分离。换句话说，当<strong>CANCEL</strong>和<strong>COMPLETE</strong>是有效动作时，将它们动态添加到链接列表中。链接存在时，客户端仅需要向用户显示相应的按钮。</p>
</div>
<div class="paragraph">
<p>这使客户端不必知道何时这些操作有效，从而减少了服务器及其客户端在状态转换逻辑上不同步的风险。</p>
</div>
<div class="paragraph">
<p>已经接受Spring HATEOAS的概念<code>ResourceAssembler</code>组件，将这样的逻辑放在<code>OrderResourceAssembler</code>将是捕获此业务规则的理想场所：</p>
</div>
<div class="listingblock">
<div class="title">links / src / main / java / payroll / OrderResourceAssembler.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">package payroll;

import static org.springframework.hateoas.mvc.ControllerLinkBuilder.*;

import org.springframework.hateoas.Resource;
import org.springframework.hateoas.ResourceAssembler;
import org.springframework.stereotype.Component;

@Component
class OrderResourceAssembler implements ResourceAssembler&lt;Order, Resource&lt;Order&gt;&gt; {

  @Override
  public Resource&lt;Order&gt; toResource(Order order) {

    // Unconditional links to single-item resource and aggregate root

    Resource&lt;Order&gt; orderResource = new Resource&lt;&gt;(order,
      linkTo(methodOn(OrderController.class).one(order.getId())).withSelfRel(),
      linkTo(methodOn(OrderController.class).all()).withRel("orders")
    );

    // Conditional links based on state of the order

    if (order.getStatus() == Status.IN_PROGRESS) {
      orderResource.add(
        linkTo(methodOn(OrderController.class)
          .cancel(order.getId())).withRel("cancel"));
      orderResource.add(
        linkTo(methodOn(OrderController.class)
          .complete(order.getId())).withRel("complete"));
    }

    return orderResource;
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此资源汇编器始终包括指向单项资源的<strong>自身</strong>链接以及指向聚合根的链接。但它也包括两个条件链接<code>OrderController.cancel(id)</code>以及<code>OrderController.complete(id)</code> （尚未定义）。这些链接仅在订单状态为时显示<code>Status.IN_PROGRESS</code> 。</p>
</div>
<div class="paragraph">
<p>如果客户可以采用HAL并具有读取链接的能力，而不是简单地读取普通的旧JSON数据，则可以交易对订单系统领域知识的需求。这自然减少了客户端和服务器之间的耦合。它为调整订单执行流程打开了大门，而不会破坏流程中的客户。</p>
</div>
<div class="paragraph">
<p>要完善订单履行，请将以下内容添加到<code>OrderController</code>为了<code>cancel</code>操作：</p>
</div>
<div class="listingblock">
<div class="title">在OrderController中创建“取消”操作</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@DeleteMapping("/orders/{id}/cancel")
ResponseEntity&lt;ResourceSupport&gt; cancel(@PathVariable Long id) {

  Order order = orderRepository.findById(id).orElseThrow(() -&gt; new OrderNotFoundException(id));

  if (order.getStatus() == Status.IN_PROGRESS) {
    order.setStatus(Status.CANCELLED);
    return ResponseEntity.ok(assembler.toResource(orderRepository.save(order)));
  }

  return ResponseEntity
    .status(HttpStatus.METHOD_NOT_ALLOWED)
    .body(new VndErrors.VndError("Method not allowed", "You can't cancel an order that is in the " + order.getStatus() + " status"));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它检查<code>Order</code>状态，然后才能将其取消。如果状态无效，则返回Spring HATEOAS <code>VndError</code> ，一个支持超媒体的错误容器。如果转换确实有效，则转换<code>Order</code>至<code>CANCELLED</code> 。</p>
</div>
<div class="paragraph">
<p>并将其添加到<code>OrderController</code>以及订单完成：</p>
</div>
<div class="listingblock">
<div class="title">在OrderController中创建“完成”操作</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@PutMapping("/orders/{id}/complete")
ResponseEntity&lt;ResourceSupport&gt; complete(@PathVariable Long id) {

    Order order = orderRepository.findById(id).orElseThrow(() -&gt; new OrderNotFoundException(id));

    if (order.getStatus() == Status.IN_PROGRESS) {
      order.setStatus(Status.COMPLETED);
      return ResponseEntity.ok(assembler.toResource(orderRepository.save(order)));
    }

    return ResponseEntity
      .status(HttpStatus.METHOD_NOT_ALLOWED)
      .body(new VndErrors.VndError("Method not allowed", "You can't complete an order that is in the " + order.getStatus() + " status"));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这实现了类似的逻辑以防止<code>Order</code>除非处于适当状态，否则状态将无法完成。</p>
</div>
<div class="paragraph">
<p>通过向其中添加一些额外的初始化代码<code>LoadDatabase</code> ：</p>
</div>
<div class="listingblock">
<div class="title">更新数据库预加载器</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">orderRepository.save(new Order("MacBook Pro", Status.COMPLETED));
orderRepository.save(new Order("iPhone", Status.IN_PROGRESS));

orderRepository.findAll().forEach(order -&gt; {
  log.info("Preloaded " + order);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>......你可以测试一下！</p>
</div>
<div class="paragraph">
<p>要使用新创建的订单服务，只需执行一些操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl -v http://localhost:8080/orders

{
  "_embedded": {
    "orderList": [
      {
        "id": 3,
        "description": "MacBook Pro",
        "status": "COMPLETED",
        "_links": {
          "self": {
            "href": "http://localhost:8080/orders/3"
          },
          "orders": {
            "href": "http://localhost:8080/orders"
          }
        }
      },
      {
        "id": 4,
        "description": "iPhone",
        "status": "IN_PROGRESS",
        "_links": {
          "self": {
            "href": "http://localhost:8080/orders/4"
          },
          "orders": {
            "href": "http://localhost:8080/orders"
          },
          "cancel": {
            "href": "http://localhost:8080/orders/4/cancel"
          },
          "complete": {
            "href": "http://localhost:8080/orders/4/complete"
          }
        }
      }
    ]
  },
  "_links": {
    "self": {
      "href": "http://localhost:8080/orders"
    }
  }
}</pre>
</div>
</div>
<div class="paragraph">
<p>该HAL文档根据其当前状态立即显示每个订单的不同链接。</p>
</div>
<div class="ulist">
<ul>
<li> <p>第一个命令，而只<strong>完成</strong>了导航链接。状态转换链接未显示。</p> </li>
<li> <p>第二个订单（ <strong>IN_PROGRESS）</strong>另外具有<strong>取消</strong>链接和<strong>完整</strong>链接。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>尝试取消订单：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl -v -X DELETE http://localhost:8080/orders/4/cancel

&gt; DELETE /orders/4/cancel HTTP/1.1
&gt; Host: localhost:8080
&gt; User-Agent: curl/7.54.0
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 200
&lt; Content-Type: application/hal+json;charset=UTF-8
&lt; Transfer-Encoding: chunked
&lt; Date: Mon, 27 Aug 2018 15:02:10 GMT
&lt;
{
  "id": 4,
  "description": "iPhone",
  "status": "CANCELLED",
  "_links": {
    "self": {
      "href": "http://localhost:8080/orders/4"
    },
    "orders": {
      "href": "http://localhost:8080/orders"
    }
  }
}</pre>
</div>
</div>
<div class="paragraph">
<p>此响应显示指示成功的<strong>HTTP 200</strong>状态代码。响应HAL文档显示该订单处于新状态（ <code>CANCELLED</code> ）。改变状态的链接也消失了。</p>
</div>
<div class="paragraph">
<p>如果您再次尝试相同的操作...</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl -v -X DELETE http://localhost:8080/orders/4/cancel

* TCP_NODELAY set
* Connected to localhost (::1) port 8080 (#0)
&gt; DELETE /orders/4/cancel HTTP/1.1
&gt; Host: localhost:8080
&gt; User-Agent: curl/7.54.0
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 405
&lt; Content-Type: application/hal+json;charset=UTF-8
&lt; Transfer-Encoding: chunked
&lt; Date: Mon, 27 Aug 2018 15:03:24 GMT
&lt;
{
  "logref": "Method not allowed",
  "message": "You can't cancel an order that is in the CANCELLED status"
}</pre>
</div>
</div>
<div class="paragraph">
<p>......您会看到<strong>HTTP 405方法不允许</strong>响应。<strong>删除</strong>已成为无效操作。的<code>VndError</code>响应对象清楚地表明不允许您“取消”已经处于“已取消”状态的订单。</p>
</div>
<div class="paragraph">
<p>此外，尝试完成相同的订单也会失败：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl -v -X PUT localhost:8080/orders/4/complete

* TCP_NODELAY set
* Connected to localhost (::1) port 8080 (#0)
&gt; PUT /orders/4/complete HTTP/1.1
&gt; Host: localhost:8080
&gt; User-Agent: curl/7.54.0
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 405
&lt; Content-Type: application/hal+json;charset=UTF-8
&lt; Transfer-Encoding: chunked
&lt; Date: Mon, 27 Aug 2018 15:05:40 GMT
&lt;
{
  "logref": "Method not allowed",
  "message": "You can't complete an order that is in the CANCELLED status"
}</pre>
</div>
</div>
<div class="paragraph">
<p>完成所有这些操作后，您的订单履行服务便可以有条件地显示可用的操作。它还可以防止无效操作。</p>
</div>
<div class="paragraph">
<p>通过利用超媒体和链接协议，可以使客户端更坚固，并且仅因数据更改而导致崩溃的可能性就较小。Spring HATEOAS简化了构建服务于客户所需的超媒体的工作。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_summary">摘要</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在本教程中，您参与了各种构建REST API的策略。事实证明，REST不仅涉及漂亮的URI，而且还返回JSON而不是XML。</p>
</div>
<div class="paragraph">
<p>相反，以下策略有助于使您的服务不太可能破坏您可能控制或可能无法控制的现有客户端：</p>
</div>
<div class="ulist">
<ul>
<li> <p>不要删除旧字段。相反，支持他们。</p> </li>
<li> <p>使用基于rel的链接，这样客户端就不必对URI进行硬编码。</p> </li>
<li> <p>尽可能保留旧的链接。即使必须更改URI，也请保留rel，以便较旧的客户端可以使用较新的功能。</p> </li>
<li> <p>使用链接（而不是有效负载数据）来指示客户端何时可以进行各种状态驱动操作。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>建立起来似乎有些努力<code>ResourceAssembler</code>每种资源类型的实现，并在所有控制器中使用这些组件。但是，服务器端设置的这一额外点（借助Spring HATEOAS可以轻松实现）可以确保您控制的客户端（更重要的是，那些您不需要的客户端）可以在开发API时轻松升级。</p>
</div>
<div class="paragraph">
<p>这结束了我们关于如何使用Spring构建RESTful服务的教程。本教程的每个部分在单个github存储库中作为单独的子项目进行管理：</p>
</div>
<div class="ulist">
<ul>
<li> <p><strong>nonrest</strong> -没有超媒体的简单Spring MVC应用</p> </li>
<li> <p><strong>rest</strong> - Spring MVC的+Spring HATEOAS 应用与每个资源的HAL表示</p> </li>
<li> <p><strong>演进</strong> -REST应用程序，在该应用程序中可扩展字段，但保留旧数据以实现向后兼容性</p> </li>
<li> <p><strong>链接</strong> -REST应用程序，其中使用条件链接向客户端发送有效状态更改信号</p> </li>
</ul>
</div>
<div class="paragraph">
<p>要查看更多使用Spring HATEOAS的示例，请参见<a href="https://github.com/spring-projects/spring-hateoas-examples" class="bare">https://github.com/spring-projects/spring-hateoas-examples</a> 。</p>
</div>
<div class="paragraph">
<p>要进行更多探索，请查看Spring队友Oliver Gierke的以下视频：</p>
</div>
<div class="videoblock">
<div class="content">
<iframe src="https://www.youtube.com/embed/WDBUlu_lYas?rel=0" frameborder="0" allowfullscreen></iframe>
</div>
</div>
<div class="paragraph">
<p>是否要编写新指南或为现有指南做出贡献？查看我们的<a href="https://github.com/spring-guides/getting-started-guides/wiki">贡献准则</a> 。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-important" title="重要"></i> </td>
<td class="content">所有指南均以代码的ASLv2许可证和写作的<a href="https://creativecommons.org/licenses/by-nd/3.0/">Attribution，NoDerivatives创作共用许可证发布</a> 。</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</article>
</div>
<aside class="span4 content-right-pane--container mobile-left-pane" id="sidebar">
<a class="ci-status desktop-only" href="https://travis-ci.org/spring-guides/tut-rest">
<img src="https://travis-ci.org/spring-guides/tut-rest.svg?branch=master">
</a>
<div class="right-pane-widget--container desktop-only">
<div class="github-actions https">
<h2>获取代码</h2>
<div class="btn-group">
<button class="btn" data-protocol="https">HTTPS</button>
<button class="btn" data-protocol="ssh">SSH协议</button>
</div>
<div class="clone-url https">
<input id="clone-url-https" type="text" value="https://github.com/spring-guides/tut-rest.git" readonly>
<button class="copy-button github" data-toggle="tooltip" data-clipboard-text="https://github.com/spring-guides/tut-rest.git"></button>
</div>
<div class="clone-url ssh">
<input id="clone-url-ssh" type="text" value="git@github.com：spring-guides / tut-rest.git" readonly>
<button class="copy-button github" data-toggle="tooltip" data-clipboard-text="git@github.com:spring-guides/tut-rest.git"></button>
</div>
<a class="github_download btn btn-black uppercase" href="https://github.com/spring-guides/tut-rest/archive/master.zip">下载ZIP</a> <a class="gs-guide-import" href="https://github.com/spring-guides/tut-rest.git">导入STS</a>
<div class="go-to-repo--container">
<a href="https://github.com/spring-guides/tut-rest"><i class="icon-github"></i>去回购</a>
</div>
<div class="go-to-repo--container">
</div>
</div>
</div>
<div class="right-pane-widget--container">
<div>
<h3><a class="anchor" href="#table-of-contents" name="table-of-contents"></a>目录</h3>
<div><ul class="sectlevel1">
<li><a href="#_getting_started">入门</a></li>
<li><a href="#_the_story_so_far">到目前为止的故事...</a></li>
<li><a href="#_http_is_the_platform">HTTP是平台</a></li>
<li><a href="#_what_makes_something_restful">是什么使RESTful变得有趣？</a></li>
<li><a href="#_simplifying_link_creation">简化链接创建</a></li>
<li><a href="#_evolving_rest_apis">不断发展的REST API</a></li>
<li><a href="#_building_links_into_your_rest_api">将链接构建到REST API中</a></li>
<li><a href="#_summary">摘要</a></li>
</ul></div>
</div>
</div>
</aside>
</div>
</main>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>