<html  data-clipboard-buttons="" data-code-prettify="" data-code-sidebar="" data-hide-show-guide="" data-sts-import="" data-mobile-support="" data-search="" lang="zh-Hans"><head>
<title>教程·Spring Boot和OAuth2</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>System.config({baseURL: "/b92013b"});</script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>System.import('app/main.js')</script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link rel="stylesheet" type="text/css" href="/css/gsguide-cce08ab7a9f46db88819a14148e45bad.css">

<meta property="og:title" content="Spring Boot and OAuth2">
<meta property="og:image" content="/img/spring-by-pivotal-9066b55828deb3c10e27e609af322c40.png">
<meta property="og:description" content="this tutorial is designed to be completed in 2-3 hours, it provides deeper, in-context explorations of enterprise application development topics, leaving you ready to implement real-world solutions.">
</head>
<body >

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">// Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }</script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link active">
<a href="/guides">导游</a>
</li>
<li class="navbar-link">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<main class="main-body--wrapper">
<div class="row-fluid">
<div class="span8 mobile-left-pane">
<div class="content--title desktop-only">讲解</div>
<article class="content--container">
<h1 class="title">Spring Boot和OAuth2</h1>
<div class="article-body"><div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>本指南将向您展示如何使用<a href="https://tools.ietf.org/html/rfc6749">OAuth2</a>和<a href="https://projects.spring.io/spring-boot/">Spring Boot</a>通过“社交登录”构建一个样例应用程序来执行各种操作。它以简单的单一提供商单点登录开始，并且可以与带有身份验证提供程序（ <a href="https://developers.facebook.com">Facebook</a>或<a href="https://developer.github.com/">Github</a> ）的自托管OAuth2授权服务器一起使用。这些示例都是在后端使用Spring Boot和Spring OAuth的所有单页应用程序。它们都在前端都使用普通的<a href="https://jquery.org/">jQuery</a> ，但是转换为其他JavaScript框架或使用服务器端呈现所需的更改将很小。</p>
</div>
<div class="paragraph">
<p>因为其中一个示例是完整的OAuth2授权服务器，所以我们使用了<a href="https://docs.spring.io/spring-security-oauth2-boot/docs/current/reference/htmlsingle/">填充JAR</a> ，它支持从Spring Boot 2.0到旧的Spring Security OAuth2库的桥接。还可以使用<a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-security-oauth2">Spring Boot</a>安全功能中的本机OAuth2支持来实现更简单的示例。配置非常相似。</p>
</div>
<div class="paragraph">
<p>有几个相互补充的示例，它们增加了新功能：</p>
</div>
<div class="ulist">
<ul>
<li> <p><a href="#_social_login_simple"><strong>简单</strong></a> ：一个非常基本的静态应用，只有一个主页，并通过Spring Boot的<code>@EnableOAuth2Sso</code>无条件登录（如果您访问主页，您将自动重定向到Facebook）。</p> </li>
<li> <p><a href="#_social_login_click"><strong>click</strong></a> ：添加一个显式链接，用户必须单击该链接才能登录。</p> </li>
<li> <p><a href="#_social_login_logout"><strong>注销</strong></a> ：还为经过身份验证的用户添加注销链接。</p> </li>
<li> <p><a href="#_social_login_manual"><strong>manual</strong></a> ：通过取消选中<code>@EnableOAuth2Sso</code>并手动配置其所有部分来显示其工作方式。</p> </li>
<li> <p><a href="#_social_login_github"><strong>github</strong></a> ：在Github中添加了第二个登录提供程序，因此用户可以在主页上选择要使用的登录提供程序。</p> </li>
<li> <p><a href="#_social_login_authserver"><strong>auth-server</strong></a> ：将应用程序转换为成熟的OAuth2授权服务器，可以发布自己的令牌，但仍使用外部OAuth2提供程序进行身份验证。</p> </li>
<li> <p><a href="#_social_login_custom_error"><strong>custom-error</strong></a> ：为未经身份验证的用户添加错误消息，以及基于Github API的自定义身份验证。</p> </li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">可以在源代码中跟踪从功能阶梯中的一个应用迁移到下一个应用所需的更改（源代码<a href="https://github.com/spring-guides/tut-spring-boot-oauth2">在Github中</a> ）。存储库中的前6个更改正在转换一个应用程序，因此您可以轻松地看到它们之间的差异。您可能会在应用程序的早期提交和指南中看到的最终状态之间看到任何进一步的差异，这都是表面上的。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>它们每个都可以导入到IDE中，并且可以在其中运行主类<code>SocialApplication</code>来启动应用程序。他们都提供了一个位于<a href="http://localhost:8080" class="bare">http://localhost:8080</a>的主页（如果要登录并查看内容，都要求您至少拥有一个Facebook帐户）。您还可以使用<code>mvn spring-boot:run</code>命令行运行所有应用程序，或者通过构建jar文件并使用<code>mvn package</code>和<code>java -jar target/*.jar</code>运行它（根据<a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#getting-started-first-application-run">Spring Boot文档</a>和其他<a href="https://spring.io/guides/gs/spring-boot/">可用文档</a> ） 。如果您在顶层使用<a href="https://github.com/takari/maven-wrapper">包装器</a> ，则无需安装Maven，例如</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ cd simple
$ ../mvnw package
$ java -jar target/*.jar</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">这些应用程序均可在<code>localhost:8080</code>因为它们使用在Facebook和Github上注册了该地址的OAuth2客户端。要在不同的主机或端口上运行它们，您需要注册自己的应用程序并将凭据放入配置文件中。如果使用默认值，则没有将您的Facebook或Github凭据泄漏到本地主机之外的危险，但是请注意您在Internet上公开的内容，并且不要将自己的应用程序注册置于公共源代码控制中。</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_social_login_simple">使用Facebook单一登录</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在本节中，我们将创建一个使用Facebook进行身份验证的最小应用程序。如果我们利用Spring Boot中的自动配置功能，这将非常容易。</p>
</div>
<div class="sect2">
<h3 id="_creating_a_new_project">创建一个新项目</h3>
<div class="paragraph">
<p>首先，我们需要创建一个Spring Boot应用程序，可以通过多种方式来完成。最简单的方法是转到<a href="https://start.spring.io" class="bare">https://start.spring.io</a>并生成一个空项目（选择“ Web”依赖项作为起点）。在命令行上等效地执行此操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ mkdir ui && cd ui
$ curl https://start.spring.io/starter.tgz -d style=web -d name=simple | tar -xzvf -</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，您可以将该项目导入您喜欢的IDE（默认情况下是普通的Maven Java项目），或者仅在命令行上使用文件和“ mvn”。</p>
</div>
</div>
<div class="sect2">
<h3 id="_add_a_home_page">添加主页</h3>
<div class="paragraph">
<p>在您的新项目中，在“ src / main / resources / static”文件夹中创建一个<code>index.html</code> 。您应该添加一些样式表和Java脚本链接，以便结果如下所示：</p>
</div>
<div class="listingblock">
<div class="title">index.html</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html"><!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <title>Demo</title>
    <meta name="description" content=""/>
    <meta name="viewport" content="width=device-width"/>
    <base href="/"/>
    <link rel="stylesheet" type="text/css" href="/webjars/bootstrap/css/bootstrap.min.css"/>
    <script type="text/javascript" src="/webjars/jquery/jquery.min.js"></script>
    <script type="text/javascript" src="/webjars/bootstrap/js/bootstrap.min.js"></script>
</head>
<body>
	<h1>Demo</h1>
	<div class="container"></div>
</body>
</html></code></pre>
</div>
</div>
<div class="paragraph">
<p>演示OAuth2登录功能不需要这样做，但是我们希望最终拥有一个漂亮的UI，因此我们不妨从主页中的一些基本内容开始。</p>
</div>
<div class="paragraph">
<p>如果启动应用程序并加载主页，您会注意到尚未加载样式表。因此，我们也需要添加它们，并且可以通过添加一些依赖项来做到这一点：</p>
</div>
<div class="listingblock">
<div class="title">pom.xml</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml"><dependency>
	<groupId>org.webjars</groupId>
	<artifactId>jquery</artifactId>
	<version>2.1.1</version>
</dependency>
<dependency>
	<groupId>org.webjars</groupId>
	<artifactId>bootstrap</artifactId>
	<version>3.2.0</version>
</dependency>
<dependency>
	<groupId>org.webjars</groupId>
	<artifactId>webjars-locator-core</artifactId>
</dependency></code></pre>
</div>
</div>
<div class="paragraph">
<p>我们添加了Twitter引导程序和jQuery（这是我们现在所需要的）。另一个依赖项是webjars“定位器”，由webjars站点作为库提供，并且Spring可以使用它来定位webjars中的静态资产，而无需知道确切的版本（因此，无版本<code>/webjars/**</code>链接在<code>index.html</code> ）。只要您不关闭MVC自动配置，默认情况下就会在Spring Boot应用程序中激活webjar定位器。</p>
</div>
<div class="paragraph">
<p>完成这些更改后，我们应该为我们的应用程序提供一个漂亮的主页。</p>
</div>
</div>
<div class="sect2">
<h3 id="_securing_the_application">保护应用程序</h3>
<div class="paragraph">
<p>为了使应用程序安全，我们只需要添加Spring Security作为依赖项即可。如果这样做的话，默认值将是使用HTTP Basic对其进行保护，因此由于我们要进行“社交”登录（委托给Facebook），因此我们还添加了Spring Security OAuth2依赖项：</p>
</div>
<div class="listingblock">
<div class="title">pom.xml</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml"><dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-security</artifactId>
</dependency>
<dependency>
	<groupId>org.springframework.security.oauth.boot</groupId>
	<artifactId>spring-security-oauth2-autoconfigure</artifactId>
	<version>2.0.0.RELEASE</version>
</dependency></code></pre>
</div>
</div>
<div class="paragraph">
<p>要链接到Facebook，我们需要在主类上添加一个<code>@EnableOAuth2Sso</code>annotation：</p>
</div>
<div class="listingblock">
<div class="title">SocialApplication.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@EnableOAuth2Sso
public class SocialApplication {

  ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>和一些配置（将<code>application.properties</code>转换为YAML以提高可读性）：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-yaml" data-lang="yaml">security:
  oauth2:
    client:
      clientId: 233668646673605
      clientSecret: 33b17e044ee6a4fa383f46ec6e28ea1d
      accessTokenUri: https://graph.facebook.com/oauth/access_token
      userAuthorizationUri: https://www.facebook.com/dialog/oauth
      tokenName: oauth_token
      authenticationScheme: query
      clientAuthenticationScheme: form
    resource:
      userInfoUri: https://graph.facebook.com/me
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>该配置指的是在其<a href="https://developers.facebook.com">开发人员</a>站点中向Facebook注册的客户端应用程序，您必须在其中提供该应用程序的注册重定向（主页）。此地址已注册到“ localhost：8080”，因此仅在在该地址上运行的应用程序中有效。</p>
</div>
<div class="paragraph">
<p>进行此更改后，您可以再次运行该应用程序，并访问位于<a href="http://localhost:8080" class="bare">http://localhost:8080</a>的主页。而不是主页，您应该被重定向到使用Facebook登录。如果这样做，并接受要求您进行的任何授权，您将被重定向回本地应用程序，并且主页将可见。如果您保持登录状态，即使您在没有Cookie和缓存数据的全新浏览器中打开该应用程序，也不必使用该本地应用程序重新进行身份验证。（这就是“单点登录”的意思。）</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-tip" title="小费"></i> </td>
<td class="content">如果您正在使用示例应用程序来完成本节，请确保清除浏览器的cookie和HTTP Basic凭据缓存。在Chrome中，对单个服务器执行此操作的最佳方法是打开一个新的隐身窗口。</td>
</tr>
</tbody>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>授予对此示例访问权限是安全的，因为只有在本地运行的应用程序才能使用令牌，并且它要求的范围是有限的。但是，当您登录这样的应用程序时，请注意您正在批准的内容：他们可能会要求您做比您满意的事情（例如，他们可能会要求您更改您的个人数据，这不太可能出现在您的个人资料中）利益）。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_what_just_happened">刚刚发生了什么？</h3>
<div class="paragraph">
<p>您刚刚以OAuth2术语编写的应用程序是一个客户端应用程序，它使用<a href="https://tools.ietf.org/html/rfc6749#section-4">授权代码授予</a>从Facebook（授权服务器）获取访问令牌。然后，它使用访问令牌向Facebook询问一些个人详细信息（仅包括您允许的操作），包括您的登录ID和名称。在此阶段，facebook充当资源服务器，对您发送的令牌进行解码并检查它是否授予应用程序访问用户详细信息的权限。如果该过程成功，则该应用会将用户详细信息插入到Spring Security上下文中，从而对您进行身份验证。</p>
</div>
<div class="paragraph">
<p>如果您在浏览器工具（Chrome上为F12）中查找并跟踪所有跃点的网络流量，则将看到与Facebook进行来回重定向，最后使用新的<code>Set-Cookie</code>标头返回首页。该cookie（默认为<code>JSESSIONID</code> ）是用于Spring（或任何基于servlet的）应用程序的身份验证详细信息的令牌。</p>
</div>
<div class="paragraph">
<p>因此，我们拥有一个安全的应用程序，即从某种意义上来说，用户必须查看与外部提供商（Facebook）进行身份验证的任何内容。我们不希望将其用于互联网银行网站，而是出于基本标识的目的，并在您网站的不同用户之间隔离内容，这是一个很好的起点，这说明了为什么这种身份验证在当今非常流行。在下一节中，我们将向该应用程序添加一些基本功能，并使用户将初始重定向到Facebook时所发生的情况更加清楚。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_social_login_click">添加欢迎页面</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在本节中，我们通过添加一个显式链接来登录Facebook来修改我们刚刚构建的<a href="#_social_login_simple">简单</a>应用程序。新的链接将在主页上显示，而不是立即重定向，并且用户可以选择登录或不进行身份验证。仅当用户单击链接时，才会向他显示安全内容。</p>
</div>
<div class="sect2">
<h3 id="_conditional_content_in_home_page">主页中的条件内容</h3>
<div class="paragraph">
<p>为了使某些内容取决于用户是否通过身份验证，我们可以使用服务器端渲染（例如，使用Freemarker或Tymeleaf），或者我们可以使用一些JavaScript要求浏览器访问它。为此，我们将使用<a href="https://angularjs.org/">AngularJS</a> ，但是如果您喜欢使用其他框架，则翻译客户端代码应该不会很困难。</p>
</div>
<div class="paragraph">
<p>要开始使用动态内容，我们需要标记HTML的一部分以显示它：</p>
</div>
<div class="listingblock">
<div class="title">index.html</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html"><div class="container unauthenticated">
    With Facebook: <a href="/login">click here</a>
</div>
<div class="container authenticated" style="display:none">
    Logged in as: <span id="user"></span>
</div></code></pre>
</div>
</div>
<div class="paragraph">
<p>此HTML使我们需要一些可操作经过<code>authenticated</code> ， <code>unauthenticated</code> <code>authenticated</code> <code>unauthenticated</code>和<code>user</code>元素的客户端代码。这是这些功能的简单实现（将其放在<code><body></code> ）：</p>
</div>
<div class="listingblock">
<div class="title">index.html</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html"><script type="text/javascript">
    $.get("/user", function(data) {
        $("#user").html(data.userAuthentication.details.name);
        $(".unauthenticated").hide()
        $(".authenticated").show()
    });
</script></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_server_side_changes">服务器端更改</h3>
<div class="paragraph">
<p>为此，我们需要在服务器端进行一些更改。“ home”控制器需要一个位于“ / user”的端点，该端点描述了当前已认证的用户。这很容易做到，例如在我们的主课中：</p>
</div>
<div class="listingblock">
<div class="title">社会应用</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@EnableOAuth2Sso
@RestController
public class SocialApplication {

  @RequestMapping("/user")
  public Principal user(Principal principal) {
    return principal;
  }

  public static void main(String[] args) {
    SpringApplication.run(SocialApplication.class, args);
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意<code>@RestController</code>和<code>@RequestMapping</code>以及<code>java.security.Principal</code>注入到handler方法中。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-warning" title="警告"></i> </td>
<td class="content">这样在<code>/user</code>端点中返回整个<code>Principal</code>并不是一个好主意（它可能包含您不希望向浏览器客户端显示的信息）。我们这样做只是为了使某些东西快速工作。在指南的后面，我们将转换端点以隐藏不需要浏览器的信息。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>该应用程序现在可以像以前一样正常工作并进行身份验证，但是不会给用户提供单击我们刚刚提供的链接的机会。为了使链接可见，我们还需要通过添加<code>WebSecurityConfigurer</code>在主页上关闭安全性：</p>
</div>
<div class="listingblock">
<div class="title">社会应用</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@EnableOAuth2Sso
@RestController
public class SocialApplication extends WebSecurityConfigurerAdapter {

  ...

  @Override
  protected void configure(HttpSecurity http) throws Exception {
    http
      .antMatcher("/**")
      .authorizeRequests()
        .antMatchers("/", "/login**", "/webjars/**", "/error**")
        .permitAll()
      .anyRequest()
        .authenticated();
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Boot对带有<code>@EnableOAuth2Sso</code>annotation的类的<code>WebSecurityConfigurer</code>特殊含义：它使用它来配置带有OAuth2身份验证处理器的安全过滤器链。因此，要使我们的主页可见，我们要做的就是显式<code>authorizeRequests()</code>到主页及其所包含的静态资源的izeizeRequests（）（我们还包括对处理身份验证的登录端点的访问）。所有其他请求（例如对<code>/user</code>端点的请求）都需要身份验证。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content"> <code>/error**</code>是不受保护的路径，因为我们希望Spring Boot能够在应用程序出现问题时呈现错误，即使用户未经身份验证也是如此。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>完成该更改后，应用程序就完成了，如果您运行它并访问主页，您应该会看到一个漂亮的HTML链接，以“使用Facebook登录”。该链接将您直接带到Facebook，而不是直接带到处理身份验证的本地路径（并将重定向发送到Facebook）。通过身份验证后，您将重定向回本地应用程序，该应用程序现在将在其中显示您的姓名（假设您已在Facebook中设置了权限以允许访问该数据）。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_social_login_logout">添加注销按钮</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在本部分中，我们通过添加一个允许用户注销该应用程序的按钮来修改我们构建的<a href="#_social_login_click">click</a>应用程序。这似乎是一个简单的功能，但是需要一点点的实现，因此值得花一些时间讨论确切的操作方法。大多数更改与以下事实有关：我们正在将应用程序从只读资源转换为可读写资源（注销需要状态更改），因此，在任何实际的应用程序中都需要进行相同的更改。不只是静态内容。</p>
</div>
<div class="sect2">
<h3 id="_client_side_changes">客户端更改</h3>
<div class="paragraph">
<p>在客户端上，我们只需要提供一个注销按钮和一些JavaScript即可回调服务器以请求取消身份验证。首先，在用户界面的“已验证”部分中，添加按钮：</p>
</div>
<div class="listingblock">
<div class="title">index.html</div>
<div class="content">
<pre><div class="container authenticated">
  Logged in as: <span id="user"></span>
  <div>
    <button onClick="logout()" class="btn btn-primary">Logout</button>
  </div>
</div></pre>
</div>
</div>
<div class="paragraph">
<p>然后我们提供它在JavaScript中引用的<code>logout()</code>函数：</p>
</div>
<div class="listingblock">
<div class="title">index.html</div>
<div class="content">
<pre>var logout = function() {
    $.post("/logout", function() {
        $("#user").html('');
        $(".unauthenticated").show();
        $(".authenticated").hide();
    })
    return true;
}</pre>
</div>
</div>
<div class="paragraph">
<p><code>logout()</code>函数对<code>/logout</code>执行POST，然后清除动态内容。现在，我们可以切换到服务器端以实现该端点。</p>
</div>
</div>
<div class="sect2">
<h3 id="_adding_a_logout_endpoint">添加注销端点</h3>
<div class="paragraph">
<p>Spring Security内置了对<code>/logout</code>端点的支持，它将为我们做正确的事（清除会话并使cookie无效）。要配置端点，我们只需在<code>WebSecurityConfigurer</code>扩展现有的<code>configure()</code>方法<code>WebSecurityConfigurer</code> ：</p>
</div>
<div class="listingblock">
<div class="title">SocialApplication.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Override
protected void configure(HttpSecurity http) throws Exception {
  http.antMatcher("/**")
    ... // existing code here
    .and().logout().logoutSuccessUrl("/").permitAll();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>/logout</code>端点要求我们对其进行POST，并且为了保护用户免受跨站点请求伪造（CSRF，发音为“海上冲浪”）的影响，它要求在请求中包含令牌。令牌的值链接到提供保护的当前会话，因此我们需要一种方法来将这些数据导入我们的JavaScript应用程序。</p>
</div>
<div class="paragraph">
<p>许多JavaScript框架都内置了对CSRF的支持（例如，在Angular中称其为XSRF），但是通常以与Spring Security的开箱即用行为稍有不同的方式实现。例如，在Angular中，前端希望服务器向其发送一个名为“ XSRF-TOKEN”的cookie，如果看到，它将把值作为名为“ X-XSRF-TOKEN”的标头发送回去。我们可以使用简单的jQuery客户端实现相同的行为，然后服务器端的更改将与其他前端实现一起使用，而无需更改或更改很少。为了向Spring Security教授这一点，我们需要添加一个创建cookie的过滤器，并且还需要告知现有CRSF过滤器有关标头名称的信息。在<code>WebSecurityConfigurer</code> ：</p>
</div>
<div class="listingblock">
<div class="title">SocialApplication.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Override
protected void configure(HttpSecurity http) throws Exception {
  http.antMatcher("/**")
    ... // existing code here
    .and().csrf().csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse());
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_adding_the_csrf_token_in_the_client">在客户端中添加CSRF令牌</h3>
<div class="paragraph">
<p>由于在此示例中我们没有使用更高级别的框架，因此我们需要显式添加CSRF令牌，该令牌可以从后端作为cookie使用。为了使代码更简单，我们包括一个附加的库：</p>
</div>
<div class="listingblock">
<div class="title">pom.xml</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml"><dependency>
    <groupId>org.webjars</groupId>
    <artifactId>js-cookie</artifactId>
    <version>2.1.0</version>
</dependency></code></pre>
</div>
</div>
<div class="paragraph">
<p>将其导入HTML：</p>
</div>
<div class="listingblock">
<div class="title">index.html</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html"><script type="text/javascript" src="/webjars/js-cookie/js.cookie.js"></script></code></pre>
</div>
</div>
<div class="paragraph">
<p>那么我们可以在xhr中使用<code>Cookies</code>便捷方法：</p>
</div>
<div class="listingblock">
<div class="title">index.html</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">$.ajaxSetup({
beforeSend : function(xhr, settings) {
  if (settings.type == 'POST' || settings.type == 'PUT'
      || settings.type == 'DELETE') {
    if (!(/^http:.*/.test(settings.url) || /^https:.*/
        .test(settings.url))) {
      // Only send the token to relative URLs i.e. locally.
      xhr.setRequestHeader("X-XSRF-TOKEN",
          Cookies.get('XSRF-TOKEN'));
    }
  }
}
});</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ready_to_roll">准备推出！</h3>
<div class="paragraph">
<p>完成这些更改后，我们就可以运行该应用程序并尝试新的注销按钮。启动应用程序并将主页加载到新的浏览器窗口中。单击“登录”链接以将您带到Facebook（如果您已经在那登录，则可能不会注意到重定向）。单击“注销”按钮以取消当前会话，并使应用程序返回未经身份验证的状态。如果您感到好奇，则应该能够在浏览器与本地服务器交换的请求中看到新的cookie和标头。</p>
</div>
<div class="paragraph">
<p>请记住，现在注销端点正在与浏览器客户端一起使用，然后所有其他HTTP请求（POST，PUT，DELETE等）也将同样起作用。因此，对于具有更多实际功能的应用程序来说，这应该是一个很好的平台。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_social_login_manual">手动配置OAuth2客户端</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在本部分中，我们通过在<code>@EnableOAuth2Sso</code>annotation中选择“魔术”，并手动配置其中的所有内容使其明确，来修改已经构建的<a href="#_social_login_logout">注销</a>应用程序。</p>
</div>
<div class="sect2">
<h3 id="_clients_and_authentication">客户端和认证</h3>
<div class="paragraph">
<p><code>@EnableOAuth2Sso</code>背后有2个功能：OAuth2客户端和身份验证。客户端是可重用的，因此您也可以使用它与您的授权服务器（在这种情况下为Facebook）提供的OAuth2资源（在这种情况下为<a href="https://developers.facebook.com/docs/graph-api">Graph API</a> ）进行交互。身份验证块使您的应用程序与Spring Security的其余部分保持一致，因此一旦与Facebook发生冲突后，您的应用程序的行为就与其他任何安全的Spring应用程序完全一样。</p>
</div>
<div class="paragraph">
<p>客户<code>@EnableOAuth2Client</code> Spring Security OAuth2提供，并由其他注释<code>@EnableOAuth2Client</code> 。因此，此转换的第一步是删除<code>@EnableOAuth2Sso</code>并将其替换为较低级别的注释：</p>
</div>
<div class="listingblock">
<div class="title">社会应用</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@EnableOAuth2Client
@RestController
public class SocialApplication extends WebSecurityConfigurerAdapter {
  ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦完成，我们就会为我们创建一些有用的东西。首先，我们可以注入<code>OAuth2ClientContext</code>并将其用于构建身份验证过滤器，该过滤器将添加到我们的安全配置中：</p>
</div>
<div class="listingblock">
<div class="title">社会应用</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@EnableOAuth2Client
@RestController
public class SocialApplication extends WebSecurityConfigurerAdapter {

  @Autowired
  OAuth2ClientContext oauth2ClientContext;

  @Override
  protected void configure(HttpSecurity http) throws Exception {
    http.antMatcher("/**")
      ...
      .and().addFilterBefore(ssoFilter(), BasicAuthenticationFilter.class);
  }

  ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此过滤器是在使用<code>OAuth2ClientContext</code>新方法中创建的：</p>
</div>
<div class="listingblock">
<div class="title">社会应用</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">private Filter ssoFilter() {
  OAuth2ClientAuthenticationProcessingFilter facebookFilter = new OAuth2ClientAuthenticationProcessingFilter("/login/facebook");
  OAuth2RestTemplate facebookTemplate = new OAuth2RestTemplate(facebook(), oauth2ClientContext);
  facebookFilter.setRestTemplate(facebookTemplate);
  UserInfoTokenServices tokenServices = new UserInfoTokenServices(facebookResource().getUserInfoUri(), facebook().getClientId());
  tokenServices.setRestTemplate(facebookTemplate);
  facebookFilter.setTokenServices(tokenServices);
  return facebookFilter;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>筛选器还需要了解客户端在Facebook上的注册：</p>
</div>
<div class="listingblock">
<div class="title">社会应用</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">  @Bean
  @ConfigurationProperties("facebook.client")
  public AuthorizationCodeResourceDetails facebook() {
    return new AuthorizationCodeResourceDetails();
  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>并完成身份验证，它需要知道用户信息端点在Facebook中的位置：</p>
</div>
<div class="listingblock">
<div class="title">社会应用</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">  @Bean
  @ConfigurationProperties("facebook.resource")
  public ResourceServerProperties facebookResource() {
    return new ResourceServerProperties();
  }</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，对于这两个“静态”数据对象（ <code>facebook()</code>和<code>facebookResource()</code> ），我们使用了装饰为<code>@ConfigurationProperties</code>的<code>@Bean</code> 。这意味着我们可以将<code>application.yml</code>转换为稍微新的格式，其中配置的前缀为<code>facebook</code>而不是<code>security.oauth2</code> ：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-yaml" data-lang="yaml">facebook:
  client:
    clientId: 233668646673605
    clientSecret: 33b17e044ee6a4fa383f46ec6e28ea1d
    accessTokenUri: https://graph.facebook.com/oauth/access_token
    userAuthorizationUri: https://www.facebook.com/dialog/oauth
    tokenName: oauth_token
    authenticationScheme: query
    clientAuthenticationScheme: form
  resource:
    userInfoUri: https://graph.facebook.com/me</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，我们在上面的<code>Filter</code>声明中将登录路径更改为特定于Facebook，因此我们需要在HTML中进行相同的更改：</p>
</div>
<div class="listingblock">
<div class="title">index.html</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html"><h1>Login</h1>
<div class="container unauthenticated">
	<div>
	With Facebook: <a href="/login/facebook">click here</a>
	</div>
</div></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_handling_the_redirects">处理重定向</h3>
<div class="paragraph">
<p>我们需要做的最后一个更改是显式支持从应用程序到Facebook的重定向。这是在Spring OAuth2中使用Servlet <code>Filter</code> ，并且该过滤器已在应用程序上下文中可用，因为我们使用了<code>@EnableOAuth2Client</code> 。所有需要做的就是连接过滤器，以便在我们的Spring Boot应用程序中以正确的顺序调用它。为此，我们需要一个<code>FilterRegistrationBean</code> ：</p>
</div>
<div class="listingblock">
<div class="title">SocialApplication.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Bean
	public FilterRegistrationBean<OAuth2ClientContextFilter> oauth2ClientFilterRegistration(OAuth2ClientContextFilter filter) {
		FilterRegistrationBean<OAuth2ClientContextFilter> registration = new FilterRegistrationBean<OAuth2ClientContextFilter>();
		registration.setFilter(filter);
		registration.setOrder(-100);
		return registration;
	}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们自动连接已经可用的过滤器，并以足够低的顺序注册它，使其<strong>在</strong>主Spring Security过滤器<strong>之前</strong>出现。通过这种方式，我们可以使用它来处理身份验证请求中异常指示的重定向。</p>
</div>
<div class="paragraph">
<p>有了这些更改，应用程序就可以运行了，在运行时相当于我们在上一节中构建的<a href="#_social_login_logout">注销</a>示例。分解配置并使其明确告诉我们，Spring Boot所做的事情没有什么神奇的（只是配置样板），它还准备了我们的应用程序以自动扩展自动提供的功能，并添加我们自己的意见。和业务需求。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_social_login_github">用Github登录</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在本节中，我们将修改我们已经构建的<a href="#_social_login_manual">应用程序</a> ，添加一个链接，以便用户除了可以链接到Facebook的原始链接之外，还可以选择使用Github进行身份验证。</p>
</div>
<div class="sect2">
<h3 id="_adding_the_github_link">添加Github链接</h3>
<div class="paragraph">
<p>在客户端中，更改是微不足道的，我们只需添加另一个链接：</p>
</div>
<div class="listingblock">
<div class="title">index.html</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html"><div class="container unauthenticated">
  <div>
    With Facebook: <a href="/login/facebook">click here</a>
  </div>
  <div>
    With Github: <a href="/login/github">click here</a>
  </div>
</div></code></pre>
</div>
</div>
<div class="paragraph">
<p>原则上，一旦开始添加身份验证提供程序，我们可能需要更加注意“ / user”端点返回的数据。事实证明，Github和Facebook在他们的用户信息中的相同位置都有一个“名称”字段，因此对我们的简单终结点的实践没有任何改变。</p>
</div>
</div>
<div class="sect2">
<h3 id="_adding_the_github_authentication_filter">添加Github身份验证过滤器</h3>
<div class="paragraph">
<p>服务器上的主要更改是添加了一个附加的安全过滤器，以处理来自我们新链接的“ / login / github”请求。我们已经在<code>ssoFilter()</code>方法中创建了一个针对Facebook的自定义身份验证过滤器，因此我们所需要做的就是将其替换为可以处理多个身份验证路径的复合文件：</p>
</div>
<div class="listingblock">
<div class="title">SocialApplication.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">private Filter ssoFilter() {

  CompositeFilter filter = new CompositeFilter();
  List<Filter> filters = new ArrayList<>();

  OAuth2ClientAuthenticationProcessingFilter facebookFilter = new OAuth2ClientAuthenticationProcessingFilter("/login/facebook");
  OAuth2RestTemplate facebookTemplate = new OAuth2RestTemplate(facebook(), oauth2ClientContext);
  facebookFilter.setRestTemplate(facebookTemplate);
  UserInfoTokenServices tokenServices = new UserInfoTokenServices(facebookResource().getUserInfoUri(), facebook().getClientId());
  tokenServices.setRestTemplate(facebookTemplate);
  facebookFilter.setTokenServices(tokenServices);
  filters.add(facebookFilter);

  OAuth2ClientAuthenticationProcessingFilter githubFilter = new OAuth2ClientAuthenticationProcessingFilter("/login/github");
  OAuth2RestTemplate githubTemplate = new OAuth2RestTemplate(github(), oauth2ClientContext);
  githubFilter.setRestTemplate(githubTemplate);
  tokenServices = new UserInfoTokenServices(githubResource().getUserInfoUri(), github().getClientId());
  tokenServices.setRestTemplate(githubTemplate);
  githubFilter.setTokenServices(tokenServices);
  filters.add(githubFilter);

  filter.setFilters(filters);
  return filter;

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中旧<code>ssoFilter()</code>中的代码已被复制，一次用于Facebook，一次用于Github，两个过滤器合并为一个复合文件。</p>
</div>
<div class="paragraph">
<p>请注意， <code>facebook()</code>和<code>facebookResource()</code>方法已经用类似的方法<code>github()</code>和<code>githubResource()</code>进行了补充：</p>
</div>
<div class="listingblock">
<div class="title">SocialApplication.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Bean
@ConfigurationProperties("github.client")
public AuthorizationCodeResourceDetails github() {
	return new AuthorizationCodeResourceDetails();
}

@Bean
@ConfigurationProperties("github.resource")
public ResourceServerProperties githubResource() {
	return new ResourceServerProperties();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以及相应的配置：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-yaml" data-lang="yaml">github:
  client:
    clientId: bd1c0a783ccdd1c9b9e4
    clientSecret: 1a9030fbca47a5b2c28e92f19050bb77824b5ad1
    accessTokenUri: https://github.com/login/oauth/access_token
    userAuthorizationUri: https://github.com/login/oauth/authorize
    clientAuthenticationScheme: form
  resource:
    userInfoUri: https://api.github.com/user</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的客户端详细信息已在<a href="https://github.com/settings/developers">Github</a>中注册，地址也为<code>localhost:8080</code> （与Facebook相同）。</p>
</div>
<div class="paragraph">
<p>该应用程序现在可以运行了，并为用户提供了使用Facebook或Github进行身份验证的选择。</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_to_add_a_local_user_database">如何添加本地用户数据库</h3>
<div class="paragraph">
<p>即使将身份验证委派给外部提供商，许多应用程序仍需要在本地保存有关其用户的数据。我们这里没有显示代码，但是很容易分两步进行。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li> <p>为数据库选择一个后端，并为自定义的<code>User</code>对象设置一些存储库（例如，使用Spring Data），以满足您的需求，并且可以从外部身份验证中完全或部分填充该对象。</p> </li>
<li> <p>通过检查<code>/user</code>端点中的存储库，为每个登录的唯一用户设置一个<code>User</code>对象。如果已经有一个具有当前<code>Principal</code>身份的用户，则可以对其进行更新，否则可以进行创建。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>提示：在<code>User</code>对象中添加一个字段，以链接到外部提供者中的唯一标识符（不是用户名，而是外部提供者中的帐户唯一的东西）。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_social_login_authserver">托管授权服务器</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在本节中，我们通过将应用程序制作为成熟的OAuth2授权服务器来修改我们构建的<a href="#_social_login_github">github</a>应用程序，该服务器仍使用Facebook和Github进行身份验证，但能够创建自己的访问令牌。然后，这些令牌可用于保护后端资源，或与我们碰巧需要以相同方式保护的其他应用程序进行SSO。</p>
</div>
<div class="sect2">
<h3 id="_tidying_up_the_authentication_configuration">整理身份验证配置</h3>
<div class="paragraph">
<p>在开始使用授权服务器功能之前，我们将整理两个外部提供程序的配置代码。<code>ssoFilter()</code>方法中有一些重复的代码，因此我们将其提取到共享方法中：</p>
</div>
<div class="listingblock">
<div class="title">SocialApplication.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">private Filter ssoFilter() {
  CompositeFilter filter = new CompositeFilter();
  List<Filter> filters = new ArrayList<>();
  filters.add(ssoFilter(facebook(), "/login/facebook"));
  filters.add(ssoFilter(github(), "/login/github"));
  filter.setFilters(filters);
  return filter;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>新的便捷方法具有旧方法中所有重复的代码：</p>
</div>
<div class="listingblock">
<div class="title">SocialApplication.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">private Filter ssoFilter(ClientResources client, String path) {
  OAuth2ClientAuthenticationProcessingFilter filter = new OAuth2ClientAuthenticationProcessingFilter(path);
  OAuth2RestTemplate template = new OAuth2RestTemplate(client.getClient(), oauth2ClientContext);
  filter.setRestTemplate(template);
  UserInfoTokenServices tokenServices = new UserInfoTokenServices(
      client.getResource().getUserInfoUri(), client.getClient().getClientId());
  tokenServices.setRestTemplate(template);
  filter.setTokenServices(tokenServices);
  return filter;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>并使用新的包装器对象<code>ClientResources</code>合并了在应用程序最新版本中声明为单独<code>@Beans</code>的<code>OAuth2ProtectedResourceDetails</code>和<code>ResourceServerProperties</code> ：</p>
</div>
<div class="listingblock">
<div class="title">SocialApplication.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">class ClientResources {

  @NestedConfigurationProperty
  private AuthorizationCodeResourceDetails client = new AuthorizationCodeResourceDetails();

  @NestedConfigurationProperty
  private ResourceServerProperties resource = new ResourceServerProperties();

  public AuthorizationCodeResourceDetails getClient() {
    return client;
  }

  public ResourceServerProperties getResource() {
    return resource;
  }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">包装器使用<code>@NestedConfigurationProperty</code>来指示注释处理器也为元数据爬网该类型，因为它不表示单个值而是完整的嵌套类型。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>有了这个包装器后，我们可以使用与以前相同的YAML配置，但是每个提供程序都可以使用一个方法：</p>
</div>
<div class="listingblock">
<div class="title">SocialApplication.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Bean
@ConfigurationProperties("github")
public ClientResources github() {
  return new ClientResources();
}

@Bean
@ConfigurationProperties("facebook")
public ClientResources facebook() {
  return new ClientResources();
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_enabling_the_authorization_server">启用授权服务器</h3>
<div class="paragraph">
<p>如果我们想将我们的应用程序转换为OAuth2授权服务器，则没有什么大惊小怪的事情，至少不需要从一些基本功能（一个客户端和创建访问令牌的功能）入手。Authorization Server只是一堆端点，它们在Spring OAuth2中作为Spring MVC处理程序实现。我们已经有一个安全的应用程序，因此实际上只需要添加<code>@EnableAuthorizationServer</code>annotation即可：</p>
</div>
<div class="listingblock">
<div class="title">SocialApplication.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@RestController
@EnableOAuth2Client
@EnableAuthorizationServer
public class SocialApplication extends WebSecurityConfigurerAdapter {

   ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有了新的注释，Spring Boot将安装所有必要的端点并为其设置安全性，只要我们提供了我们要支持的OAuth2客户端的一些详细信息：</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-yaml" data-lang="yaml">security:
  oauth2:
    client:
      client-id: acme
      client-secret: acmesecret
      scope: read,write
      auto-approve-scopes: '.*'</code></pre>
</div>
</div>
<div class="paragraph">
<p>该客户端相当于我们进行外部身份验证所需的<code>facebook.client*</code>和<code>github.client*</code> 。与外部提供商一起，我们必须注册并获得客户端ID和在我们的应用程序中使用的秘密。在这种情况下，我们将提供与我们相同的功能，因此我们需要（至少一个）客户端才能运行。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">我们已经将<code>auto-approve-scopes</code>设置为匹配所有范围的正则表达式。这不一定是我们将这个应用程序留在真实系统中的位置，但是它使我们可以快速工作，而不必替换白标签批准页面，否则，当用户想要访问令牌时，Spring OAuth2会为我们的用户弹出。要在令牌授予中添加明确的批准步骤，我们需要提供一个替换whitelabel版本的UI（位于<code>/oauth/confirm_access</code> ）。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>要完成Authorization Server，我们只需要为其UI提供安全性配置。实际上，在这个简单的应用程序中并没有太多的用户界面，但是我们仍然需要保护<code>/oauth/authorize</code>端点，并确保带有“登录”按钮的主页可见。这就是为什么我们有这种方法的原因：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Override
protected void configure(HttpSecurity http) throws Exception {
  http.antMatcher("/**")                                       <i class="conum" data-value="1"></i><b>(1)</b>
    .authorizeRequests()
      .antMatchers("/", "/login**", "/webjars/**").permitAll() <i class="conum" data-value="2"></i><b>(2)</b>
      .anyRequest().authenticated()                            <i class="conum" data-value="3"></i><b>(3)</b>
    .and().exceptionHandling()
      .authenticationEntryPoint(new LoginUrlAuthenticationEntryPoint("/")) <i class="conum" data-value="4"></i><b>(4)</b>
    ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody>
<tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>默认情况下，所有请求均受保护</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>主页和登录端点被明确排除</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>所有其他端点都需要经过身份验证的用户</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>未经身份验证的用户将重定向到主页</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_how_to_get_an_access_token">如何获取访问令牌</h3>
<div class="paragraph">
<p>现在可以从我们的新授权服务器获得访问令牌。到目前为止，获得令牌的最简单方法是将其作为“ acme”客户端。如果您运行应用程序并将其卷曲，则可以看到以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ curl acme:<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a3c2c0cec6d0c6c0d1c6d7e3cfccc0c2cfcbccd0d7">[email protected]</a>:8080/oauth/token -d grant_type=client_credentials
{"access_token":"370592fd-b9f8-452d-816a-4fd5c6b4b8a6","token_type":"bearer","expires_in":43199,"scope":"read write"}</code></pre>
</div>
</div>
<div class="paragraph">
<p>客户凭证令牌在某些情况下很有用（例如测试令牌端点是否正常工作），但是要利用我们服务器的所有功能，我们希望能够为用户创建令牌。为了代表我们应用程序的用户获得令牌，我们需要能够对该用户进行身份验证。如果您在应用程序启动时仔细查看日志，您会发现默认的Spring Boot用户正在记录一个随机密码（根据<a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-security">Spring Boot用户指南</a> ）。您可以使用此密码代表ID为“ user”的用户获取令牌：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ curl acme:<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="3657555b53455355445342765a5955575a5e594542">[email protected]</a>:8080/oauth/token -d grant_type=password -d username=user -d password=...
{"access_token":"aa49e025-c4fe-4892-86af-15af2e6b72a2","token_type":"bearer","refresh_token":"97a9f978-7aad-4af7-9329-78ff2ce9962d","expires_in":43199,"scope":"read write"}</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中“…”应替换为实际密码。这称为“密码”授予，您在其中交换访问令牌的用户名和密码。</p>
</div>
<div class="paragraph">
<p>密码授予也主要用于测试，但是当您具有本地用户数据库来存储和验证凭据时，密码授予可能适用于本机或移动应用程序。对于大多数应用程序或任何具有“社交”登录名的应用程序（例如我们的应用程序），您需要“授权码”授予，这意味着您需要使用浏览器（或行为类似于浏览器的客户端）来处理重定向和Cookie，并进行渲染来自外部提供程序的用户界面。</p>
</div>
</div>
<div class="sect2">
<h3 id="_creating_a_client_application">创建客户端应用程序</h3>
<div class="paragraph">
<p>使用Spring Boot可以轻松创建用于授权服务器的客户端应用程序，该客户端应用程序本身是一个Web应用程序。这是一个例子：</p>
</div>
<div class="listingblock">
<div class="title">ClientApplication.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@EnableAutoConfiguration
@Configuration
@EnableOAuth2Sso
@RestController
public class ClientApplication {

  @RequestMapping("/")
  public String home(Principal user) {
    return "Hello " + user.getName();
  }

  public static void main(String[] args) {
    new SpringApplicationBuilder(ClientApplication.class)
        .properties("spring.config.name=client").run(args);
  }

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">所述<code>ClientApplication</code>类不能在同一包（或子包）来创建<code>SocialApplication</code>类。否则，Spring将在启动<code>SocialApplication</code>服务器时加载一些<code>ClientApplication</code>自动配置，从而导致启动错误。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>客户端的组成部分是一个主页（仅打印用户名），以及配置文件的显式名称（通过<code>spring.config.name=client</code> ）。当我们运行该应用程序时，它将寻找我们提供的配置文件，如下所示：</p>
</div>
<div class="listingblock">
<div class="title">client.yml</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-yaml" data-lang="yaml">server:
  port: 9999
  context-path: /client
security:
  oauth2:
    client:
      client-id: acme
      client-secret: acmesecret
      access-token-uri: http://localhost:8080/oauth/token
      user-authorization-uri: http://localhost:8080/oauth/authorize
    resource:
      user-info-uri: http://localhost:8080/me</code></pre>
</div>
</div>
<div class="paragraph">
<p>配置看起来很像我们在主应用程序中使用的值，但是使用的是“ acme”客户端，而不是Facebook或Github客户端。该应用程序将在端口9999上运行，以避免与主应用程序发生冲突。它指的是我们尚未实现的用户信息终结点“ / me”。</p>
</div>
<div class="paragraph">
<p>请注意， <code>server.context-path</code>是显式设置的，因此，如果运行应用程序进行测试，请记住主页为<a href="http://localhost:9999/client" class="bare">http：// localhost：9999 / client</a> 。单击该链接应将您带到身份验证服务器，并且在您选择的社交服务提供商进行身份验证之后，您将被重定向回客户端应用程序。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">如果您同时在本地主机上运行客户端和身份验证服务器，则上下文路径必须是明确的，否则Cookie路径会冲突，并且两个应用程序无法在会话标识符上达成共识。</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_protecting_the_user_info_endpoint">保护用户信息端点</h3>
<div class="paragraph">
<p>要像使用Facebook和Github一样使用新的Authorization Server进行单点登录，它需要具有受其创建的访问令牌保护的<code>/user</code>端点。到目前为止，我们有一个<code>/user</code>端点，并且通过用户认证时创建的cookie对其进行保护。除了使用本地授予的访问令牌来保护它之外，我们还可以重复使用现有端点，并在新路径上为其创建别名：</p>
</div>
<div class="listingblock">
<div class="title">SocialApplication.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@RequestMapping({ "/user", "/me" })
public Map<String, String> user(Principal principal) {
  Map<String, String> map = new LinkedHashMap<>();
  map.put("name", principal.getName());
  return map;
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">我们已将<code>Principal</code>转换为<code>Map</code> ，以便隐藏不想公开给浏览器的部分，并统一两个外部身份验证提供程序之间端点的行为。原则上，我们可以在此处添加更多详细信息，例如特定于提供商的唯一标识符，或者如果可用，则提供电子邮件地址。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>现在，可以通过声明我们的应用程序是资源服务器（以及授权服务器）来使用访问令牌来保护“ / me”路径。我们创建一个新的配置类（作为主应用程序中的内部类，但也可以拆分为一个单独的独立类）：</p>
</div>
<div class="listingblock">
<div class="title">SocialApplication.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Configuration
@EnableResourceServer
protected static class ResourceServerConfiguration
    extends ResourceServerConfigurerAdapter {
  @Override
  public void configure(HttpSecurity http) throws Exception {
    http
      .antMatcher("/me")
      .authorizeRequests().anyRequest().authenticated();
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，我们需要为主应用程序安全性指定一个<code>@Order</code> ：</p>
</div>
<div class="listingblock">
<div class="title">SocialApplication.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
...
@Order(SecurityProperties.ACCESS_OVERRIDE_ORDER)
public class SocialApplication extends WebSecurityConfigurerAdapter {
  ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@EnableResourceServer</code>annotation使用<code>@Order(SecurityProperties.ACCESS_OVERRIDE_ORDER-1)</code></p><code>@Order(SecurityProperties.ACCESS_OVERRIDE_ORDER-1)</code></div><code>@Order(SecurityProperties.ACCESS_OVERRIDE_ORDER-1)</code></div><code>@Order(SecurityProperties.ACCESS_OVERRIDE_ORDER-1)</code></div><code>@Order(SecurityProperties.ACCESS_OVERRIDE_ORDER-1)</code></div><code>@Order(SecurityProperties.ACCESS_OVERRIDE_ORDER-1)</code></div><code>@Order(SecurityProperties.ACCESS_OVERRIDE_ORDER-1)</code></article><code>@Order(SecurityProperties.ACCESS_OVERRIDE_ORDER-1)</code></div><code>@Order(SecurityProperties.ACCESS_OVERRIDE_ORDER-1)</code></div><code>@Order(SecurityProperties.ACCESS_OVERRIDE_ORDER-1)</code></main><code>@Order(SecurityProperties.ACCESS_OVERRIDE_ORDER-1)</code></div><code>@Order(SecurityProperties.ACCESS_OVERRIDE_ORDER-1)</code></div><code>@Order(SecurityProperties.ACCESS_OVERRIDE_ORDER-1)</code></body></html>