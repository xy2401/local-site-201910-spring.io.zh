<html  data-clipboard-buttons="" data-code-prettify="" data-code-sidebar="" data-hide-show-guide="" data-sts-import="" data-mobile-support="" data-search=""><head></head><body >﻿
<title>教程·React.js和Spring Data REST</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>System.config({baseURL: "/b92013b"});</script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>System.import('app/main.js')</script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link rel="stylesheet" type="text/css" href="/css/gsguide-cce08ab7a9f46db88819a14148e45bad.css">

<meta property="og:title" content="React.js and Spring Data REST">
<meta property="og:image" content="/img/spring-by-pivotal-9066b55828deb3c10e27e609af322c40.png">
<meta property="og:description" content="this tutorial is designed to be completed in 2-3 hours, it provides deeper, in-context explorations of enterprise application development topics, leaving you ready to implement real-world solutions.">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">// Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }</script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link active">
<a href="/guides">导游</a>
</li>
<li class="navbar-link">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<main class="main-body--wrapper">
<div class="row-fluid">
<div class="span8 mobile-left-pane">
<div class="content--title desktop-only">讲解</div>
<article class="content--container">
<h1 class="title">React.js和Spring Data REST</h1>
<div class="article-body"><div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>本教程展示了一系列使用Spring Data REST的应用程序，其强大的后端功能与React的先进功能相结合，以构建易于使用的UI。</p>
</div>
<div class="ulist">
<ul>
<li> <p><a href="https://www.youtube.com/watch?v=TgCr7v9tdKM">Spring Data REST</a>提供了一种构建基于超媒体的存储库的快速方法。</p> </li>
<li> <p><a href="https://facebook.github.io/react/index.html">React</a>是Facebook在JavaScript领域中对高效，快速且易于使用的视图的解决方案。</p> </li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="react-and-spring-data-rest-part-1">第1部分-基本功能</h2>
<div class="sectionbody">
<div class="paragraph">
<p>欢迎春季社区，</p>
</div>
<div class="paragraph">
<p>在本部分中，您将看到如何快速启动并运行Spring Data REST应用程序。然后，您将使用Facebook的React.js工具集在其之上构建一个简单的UI。</p>
</div>
<div class="sect2">
<h3 id="_step_0_setting_up_your_environment">步骤0-设定您的环境</h3>
<div class="paragraph">
<p>随时从该存储库中<a href="https://github.com/spring-guides/tut-react-and-spring-data-rest/tree/master/basic">获取代码</a>并继续。</p>
</div>
<div class="paragraph">
<p>如果您想自己做，请访问<a href="https://start.spring.io" class="bare">https://start.spring.io</a>并选择以下项目：</p>
</div>
<div class="ulist">
<ul>
<li> <p>其余资料库</p> </li>
<li> <p>胸腺</p> </li>
<li> <p>JPA</p> </li>
<li> <p>H2</p> </li>
</ul>
</div>
<div class="paragraph">
<p>该演示使用Java 8，Maven项目和Spring Boot的最新稳定版本。它还使用<a href="http://es6-features.org/">ES6中</a>编码的React.js。这将为您提供一个干净，空的项目。从那里，您可以添加本节中明确显示的各种文件，和/或从上面列出的存储库中借用。</p>
</div>
</div>
<div class="sect2">
<h3 id="_in_the_beginning">一开始...</h3>
<div class="paragraph">
<p>最初有数据。很好。但是后来人们想要通过各种方式访问数据。多年来，人们将许多MVC控制器拼凑在一起，其中许多都使用了Spring强大的REST支持。但是一遍又一遍地花费很多时间。</p>
</div>
<div class="paragraph">
<p>如果做一些假设，Spring Data REST解决了这个问题有多简单：</p>
</div>
<div class="ulist">
<ul>
<li> <p>开发人员使用支持存储库模型的Spring Data项目。</p> </li>
<li> <p>该系统使用公认的行业标准协议，例如HTTP动词，标准化媒体类型和IANA批准的链接名称。</p> </li>
</ul>
</div>
<div class="sect3">
<h4 id="_declaring_your_domain">声明您的域名</h4>
<div class="paragraph">
<p>任何基于Spring Data REST的应用程序的基石都是领域对象。对于此部分，您将构建一个应用程序来跟踪公司的员工。通过创建如下数据类型来开始：</p>
</div>
<div class="listingblock">
<div class="title">src / main / java / com / greglturnquist / payroll / Employee.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity
public class Employee {

	private @Id @GeneratedValue Long id;
	private String firstName;
	private String lastName;
	private String description;

	private Employee() {}

	public Employee(String firstName, String lastName, String description) {
		this.firstName = firstName;
		this.lastName = lastName;
		this.description = description;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;
		Employee employee = (Employee) o;
		return Objects.equals(id, employee.id) &amp;&amp;
			Objects.equals(firstName, employee.firstName) &amp;&amp;
			Objects.equals(lastName, employee.lastName) &amp;&amp;
			Objects.equals(description, employee.description);
	}

	@Override
	public int hashCode() {

		return Objects.hash(id, firstName, lastName, description);
	}

	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public String getFirstName() {
		return firstName;
	}

	public void setFirstName(String firstName) {
		this.firstName = firstName;
	}

	public String getLastName() {
		return lastName;
	}

	public void setLastName(String lastName) {
		this.lastName = lastName;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	@Override
	public String toString() {
		return "Employee{" +
			"id=" + id +
			", firstName='" + firstName + '\'' +
			", lastName='" + lastName + '\'' +
			", description='" + description + '\'' +
			'}';
	}
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li> <p><code>@Entity</code>是一个JPA批注，它表示要存储在关系表中的整个类。</p> </li>
<li> <p><code>@Id</code>和<code>@GeneratedValue</code>是用于注释主键的JPA注释，它在需要时自动生成。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>该实体用于跟踪员工信息。在这种情况下，其名称和职位描述。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">Spring Data REST不仅限于JPA。它支持许多NoSQL数据存储，但是您将不在这里介绍。</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_defining_the_repository">定义存储库</h3>
<div class="paragraph">
<p>Spring Data REST应用程序的另一个关键部分是创建相应的存储库定义。</p>
</div>
<div class="listingblock">
<div class="title">src / main / java / com / greglturnquist / payroll / EmployeeRepository.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public interface EmployeeRepository extends CrudRepository&lt;Employee, Long&gt; {

}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li> <p>该存储库扩展了Spring Data Commons的<code>CrudRepository</code>并插入域对象的类型及其主键</p> </li>
</ul>
</div>
<div class="paragraph">
<p>这就是所需要的！实际上，如果它是顶级且可见的，则您甚至不必注释它。如果您使用IDE并打开<code>CrudRepository</code> ，您将找到一个已经定义好的预先构建方法的拳头。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">您可以根据需要定义<a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.definition">自己的存储库</a> 。Spring Data REST也支持这一点。</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_pre_loading_the_demo">预加载演示</h3>
<div class="paragraph">
<p>要使用此应用程序，您需要预加载一些数据，如下所示：</p>
</div>
<div class="listingblock">
<div class="title">src / main / java / com / greglturnquist / payroll / DatabaseLoader.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Component
public class DatabaseLoader implements CommandLineRunner {

	private final EmployeeRepository repository;

	@Autowired
	public DatabaseLoader(EmployeeRepository repository) {
		this.repository = repository;
	}

	@Override
	public void run(String... strings) throws Exception {
		this.repository.save(new Employee("Frodo", "Baggins", "ring bearer"));
	}
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li> <p>该课程标记为Spring的<code>@Component</code>批注，以便由<code>@SpringBootApplication</code> 。</p> </li>
<li> <p>它实现了Spring Boot的<code>CommandLineRunner</code>以便在创建并注册所有bean之后运行它。</p> </li>
<li> <p>它使用构造函数注入和自动装配来自动创建Spring Data <code>EmployeeRepository</code> 。</p> </li>
<li> <p>的<code>run()</code>用命令行参数调用方法，加载数据。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>Spring Data最大，最强大的功能之一就是它能够为您编写JPA查询。这不仅减少了您的开发时间，而且降低了错误和错误的风险。Spring Data在存储库类中<a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.details">查看方法的名称，</a>并指出所需的操作，包括保存，删除和查找。</p>
</div>
<div class="paragraph">
<p>这就是我们可以编写一个空接口并继承已构建的保存，查找和删除操作的方式。</p>
</div>
</div>
<div class="sect2">
<h3 id="_adjusting_the_root_uri">调整根URI</h3>
<div class="paragraph">
<p>默认情况下，Spring Data REST在以下位置托管链接的根集合： <code>/</code> 。因为您将在同一路径上托管Web UI，所以需要更改根URI。</p>
</div>
<div class="listingblock">
<div class="title">src / main / resources / application.properties</div>
<div class="content">
<pre>spring.data.rest.base-path=/api</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_launching_the_backend">启动后端</h3>
<div class="paragraph">
<p>全面运行REST API的最后一步是编写一个<code>public static void main</code>使用Spring Boot：</p>
</div>
<div class="listingblock">
<div class="title">src / main / java / com / greglturnquist / payroll / ReactAndSpringDataRestApplication.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
public class ReactAndSpringDataRestApplication {

	public static void main(String[] args) {
		SpringApplication.run(ReactAndSpringDataRestApplication.class, args);
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>假设以前的类以及您的Maven构建文件是从<a href="https://start.spring.io" class="bare">https://start.spring.io</a>生成的，则现在可以通过运行它来启动它<code>main()</code> IDE中的方法，或键入<code>./mvnw spring-boot:run</code>在命令行上。 （对于Windows用户，为mvnw.bat）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">如果您不了解最新的Spring Boot及其工作原理，则应考虑观看<a href="https://www.youtube.com/watch?v=sbPSjI4tt10">Josh Long的介绍性演示之一</a> 。做到了？按下！</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_touring_your_rest_service">游览您的REST服务</h3>
<div class="paragraph">
<p>随着应用程序的运行，您可以使用<a href="https://curl.haxx.se/">cURL</a> （或您喜欢的任何其他工具）在命令行中检出内容。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl localhost:8080/api
{
  "_links" : {
    "employees" : {
      "href" : "http://localhost:8080/api/employees"
    },
    "profile" : {
      "href" : "http://localhost:8080/api/profile"
    }
  }
}</pre>
</div>
</div>
<div class="paragraph">
<p>当您对根节点执行ping操作时，您会得到一系列链接，这些链接包装在<a href="http://stateless.co/hal_specification.html">HAL格式的JSON文档中</a> 。</p>
</div>
<div class="ulist">
<ul>
<li> <p><strong>_links</strong>是可用链接的集合。</p> </li>
<li> <p><strong>员工</strong>指向由定义的员工对象的汇总根<code>EmployeeRepository</code>接口。</p> </li>
<li> <p><strong>配置文件</strong>是IANA标准的关系，指向有关整个服务的可发现元数据。我们将在后面的部分中对此进行探讨。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>您可以通过导航<strong>员工</strong>链接来进一步研究该服务。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl localhost:8080/api/employees
{
  "_embedded" : {
    "employees" : [ {
      "firstName" : "Frodo",
      "lastName" : "Baggins",
      "description" : "ring bearer",
      "_links" : {
        "self" : {
          "href" : "http://localhost:8080/api/employees/1"
        }
      }
    } ]
  }
}</pre>
</div>
</div>
<div class="paragraph">
<p>在此阶段，您正在查看整个员工集合。</p>
</div>
<div class="paragraph">
<p>随您先前预加载的数据一起提供的是带有<strong>自我</strong>链接的<strong>_links</strong>属性。这是该特定员工的规范链接。什么是规范的？这意味着没有上下文。例如，可以通过/ api / orders / 1 / processor之类的链接来提取同一用户，在该链接中，员工被分配处理特定的订单。在这里，与其他实体没有关系。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-important" title="重要"></i> </td>
<td class="content">链接是REST的重要方面。它们提供了导航到相关项目的功能。这样，其他各方就可以浏览您的API，而不必每次更改时都进行重写。当客户端硬代码访问资源时，客户端中的更新是一个常见问题。重组资源可能会导致代码发生重大变化。如果使用链接，而是维护导航路线，则进行此类调整变得容易且灵活。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>如果愿意，您可以决定查看一位员工。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl localhost:8080/api/employees/1
{
  "firstName" : "Frodo",
  "lastName" : "Baggins",
  "description" : "ring bearer",
  "_links" : {
    "self" : {
      "href" : "http://localhost:8080/api/employees/1"
    }
  }
}</pre>
</div>
</div>
<div class="paragraph">
<p>这里没有什么变化，只是因为只有域对象，所以不需要<strong>_embedded</strong>包装器。</p>
</div>
<div class="paragraph">
<p>很好，但是您可能很想创建一些新条目。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl -X POST localhost:8080/api/employees -d "{\"firstName\": \"Bilbo\", \"lastName\": \"Baggins\", \"description\": \"burglar\"}" -H "Content-Type:application/json"
{
  "firstName" : "Bilbo",
  "lastName" : "Baggins",
  "description" : "burglar",
  "_links" : {
    "self" : {
      "href" : "http://localhost:8080/api/employees/2"
    }
  }
}</pre>
</div>
</div>
<div class="paragraph">
<p>您还可以如<a href="https://spring.io/guides/gs/accessing-data-rest/">本相关指南中</a>所示进行PUT，PATCH和DELETE。但是，我们不要深入探讨这一点。您已经花费了太多时间手动与该REST服务进行交互。您是否不想构建一个光滑的UI？</p>
</div>
</div>
<div class="sect2">
<h3 id="_setting_up_a_custom_ui_controller">设置自定义UI控制器</h3>
<div class="paragraph">
<p>Spring Boot使站立自定义网页变得非常简单。首先，您需要一个Spring MVC控制器。</p>
</div>
<div class="listingblock">
<div class="title">src / main / java / com / greglturnquist / payroll / HomeController.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Controller
public class HomeController {

	@RequestMapping(value = "/")
	public String index() {
		return "index";
	}

}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li> <p><code>@Controller</code>将此类标记为Spring MVC控制器。</p> </li>
<li> <p><code>@RequestMapping</code>标记<code>index()</code>支持的方法<code>/</code>路线。</p> </li>
<li> <p>它返回<code>index</code>作为模板的名称，Spring Boot的自动配置的视图解析器将映射到该模板<code>src/main/resources/templates/index.html</code> 。</p> </li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_defining_an_html_template">定义HTML模板</h3>
<div class="paragraph">
<p>您正在使用Thymeleaf，尽管您不会真正使用它的许多功能。</p>
</div>
<div class="listingblock">
<div class="title">src / main / resources / templates / index.html</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;!DOCTYPE html&gt;
&lt;html xmlns:th="https://www.thymeleaf.org"&gt;
&lt;head lang="en"&gt;
    &lt;meta charset="UTF-8"/&gt;
    &lt;title&gt;ReactJS + Spring Data REST&lt;/title&gt;
    &lt;link rel="stylesheet" href="/main.css" /&gt;
&lt;/head&gt;
&lt;body&gt;

    &lt;div id="react"&gt;&lt;/div&gt;

    &lt;script src="built/bundle.js"&gt;&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>此模板中的关键部分是<code><div id="react"></div></code>组件在中间。在这里，您将指示React插入渲染的输出。</p>
</div>
<div class="paragraph">
<p>您可能还想知道<code>bundle.js</code>文件来自。下一部分将显示其构建方式。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-important" title="重要"></i> </td>
<td class="content">本教程未显示<code>main.css</code> ，但您可以在上方看到它的链接。说到CSS，Spring Boot会处理在<code>src/main/resources/static</code>自动。放自己的<code>main.css</code>文件在那里。它没有显示在教程中，因为我们的重点是React和Spring Data REST，而不是CSS3。</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_loading_javascript_modules">加载JavaScript模块</h3>
<div class="paragraph">
<p>本部分包含准系统信息，以帮助您摆脱JavaScript障碍。虽然你<em>可以</em>安装所有的JavaScript的命令行工具，你<em>不必</em> 。至少还没有。相反，您只需添加以下内容即可<code>pom.xml</code>构建文件：</p>
</div>
<div class="listingblock">
<div class="title">的<code>frontend-maven-plugin</code>用于构建JavaScript位</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;plugin&gt;
	&lt;groupId&gt;com.github.eirslett&lt;/groupId&gt;
	&lt;artifactId&gt;frontend-maven-plugin&lt;/artifactId&gt;
	&lt;version&gt;1.6&lt;/version&gt;
	&lt;configuration&gt;
		&lt;installDirectory&gt;target&lt;/installDirectory&gt;
	&lt;/configuration&gt;
	&lt;executions&gt;
		&lt;execution&gt;
			&lt;id&gt;install node and npm&lt;/id&gt;
			&lt;goals&gt;
				&lt;goal&gt;install-node-and-npm&lt;/goal&gt;
			&lt;/goals&gt;
			&lt;configuration&gt;
				&lt;nodeVersion&gt;v10.11.0&lt;/nodeVersion&gt;
				&lt;npmVersion&gt;6.4.1&lt;/npmVersion&gt;
			&lt;/configuration&gt;
		&lt;/execution&gt;
		&lt;execution&gt;
			&lt;id&gt;npm install&lt;/id&gt;
			&lt;goals&gt;
				&lt;goal&gt;npm&lt;/goal&gt;
			&lt;/goals&gt;
			&lt;configuration&gt;
				&lt;arguments&gt;install&lt;/arguments&gt;
			&lt;/configuration&gt;
		&lt;/execution&gt;
		&lt;execution&gt;
			&lt;id&gt;webpack build&lt;/id&gt;
			&lt;goals&gt;
				&lt;goal&gt;webpack&lt;/goal&gt;
			&lt;/goals&gt;
		&lt;/execution&gt;
	&lt;/executions&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个小插件执行多个步骤：</p>
</div>
<div class="ulist">
<ul>
<li> <p>的<code>install-node-and-npm</code>该命令将安装node.js及其程序包管理工具， <code>npm</code> ， 进入<code>target</code>夹。（这确保二进制文件不会在源代码控制下被拉出，并且可以使用<code>clean</code> ）。</p> </li>
<li> <p>的<code>npm</code>命令将使用提供的参数执行npm二进制文件（ <code>install</code> ）。这将安装在<code>package.json</code> 。</p> </li>
<li> <p>的<code>webpack</code>命令将执行webpack二进制文件，该文件将根据以下内容编译所有JavaScript代码： <code>webpack.config.js</code> 。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>这些步骤按顺序运行，实际上是安装node.js，下载JavaScript模块并构建JS位。</p>
</div>
<div class="paragraph">
<p>安装了哪些模块？JavaScript开发人员通常使用<code>npm</code>建立一个<code>package.json</code>文件如下所示：</p>
</div>
<div class="listingblock">
<div class="title">package.json</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">{
  "name": "spring-data-rest-and-reactjs",
  "version": "0.1.0",
  "description": "Demo of ReactJS + Spring Data REST",
  "repository": {
    "type": "git",
    "url": "<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="31565845715658455944531f525e5c">[email&#160;protected]</a>:spring-guides/tut-react-and-spring-data-rest.git"
  },
  "keywords": [
    "rest",
    "hateoas",
    "spring",
    "data",
    "react"
  ],
  "author": "Greg L. Turnquist",
  "license": "Apache-2.0",
  "bugs": {
    "url": "https://github.com/spring-guides/tut-react-and-spring-data-rest/issues"
  },
  "homepage": "https://github.com/spring-guides/tut-react-and-spring-data-rest",
  "dependencies": {
    "react": "^16.5.2",
    "react-dom": "^16.5.2",
    "rest": "^1.3.1"
  },
  "scripts": {
    "watch": "webpack --watch -d"
  },
  "devDependencies": {
    "@babel/core": "^7.1.0",
    "@babel/preset-env": "^7.1.0",
    "@babel/preset-react": "^7.0.0",
    "babel-loader": "^8.0.2",
    "webpack": "^4.19.1",
    "webpack-cli": "^3.1.0"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>关键依赖项包括：</p>
</div>
<div class="ulist">
<ul>
<li> <p>react.js-本教程使用的工具包</p> </li>
<li> <p>rest.js-用于进行REST调用的CujoJS工具包</p> </li>
<li> <p>webpack-用于将JavaScript组件编译为单个可加载包的工具包</p> </li>
<li> <p>babel-使用ES6编写JavaScript代码并将其编译为ES5以在浏览器中运行</p> </li>
</ul>
</div>
<div class="paragraph">
<p>为了进一步构建JavaScript代码，您需要为<a href="https://webpack.github.io/">webpack</a>定义一个构建文件。</p>
</div>
<div class="listingblock">
<div class="title">webpack.config.js</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">var path = require('path');

module.exports = {
    entry: './src/main/js/app.js',
    devtool: 'sourcemaps',
    cache: true,
    mode: 'development',
    output: {
        path: __dirname,
        filename: './src/main/resources/static/built/bundle.js'
    },
    module: {
        rules: [
            {
                test: path.join(__dirname, '.'),
                exclude: /(node_modules)/,
                use: [{
                    loader: 'babel-loader',
                    options: {
                        presets: ["@babel/preset-env", "@babel/preset-react"]
                    }
                }]
            }
        ]
    }
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>该webpack配置文件执行以下操作：</p>
</div>
<div class="ulist">
<ul>
<li> <p>将<strong>入口点</strong>定义为<code>./src/main/js/app.js</code> 。在本质上， <code>app.js</code> （我们将很快编写一个模块）是众所周知的<code>public static void main()</code>我们的JavaScript应用程序。 webpack必须知道这一点，以便知道在浏览器加载最终捆绑包时要启动<em>什么</em> 。</p> </li>
<li> <p>创建<strong>源映射，</strong>以便在浏览器中调试JS代码时能够链接回原始源代码。</p> </li>
<li> <p>将所有JavaScript位编译为<code>./src/main/resources/static/built/bundle.js</code> ，它是与Spring Boot uber JAR等效的JavaScript。您所有的自定义代码和拉入模块<code>require()</code>呼叫将填充到此文件中。</p> </li>
<li> <p>两者都挂在babel引擎上<code>es2015</code>和<code>react</code>预设，以便将ES6 React代码编译为可以在任何标准浏览器中运行的格式。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>有关每种JavaScript工具如何工作的更多详细信息，请阅读其相应的参考文档。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">是否想自动查看您的JavaScript更改？跑<code>npm run-script watch</code>使webpack进入监视模式。当您编辑源代码时，它将重新生成bundle.js。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>完成所有操作后，您可以集中精力在加载DOM之后获取的React位。它分为以下部分：</p>
</div>
<div class="paragraph">
<p>由于您正在使用webpack进行组装，因此继续获取所需的模块：</p>
</div>
<div class="listingblock">
<div class="title">src / main / js / app.js</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">const React = require('react');
const ReactDOM = require('react-dom');
const client = require('./client');</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li> <p><code>React</code>和<code>ReactDOM</code>是Facebook用于构建此应用程序的主要库。</p> </li>
<li> <p><code>client</code>是自定义代码，用于配置rest.js以包括对HAL，URI模板等的支持。还将默认的<strong>接受</strong>请求标头设置为<strong>application / hal + json</strong> 。您可以<a href="https://github.com/spring-guides/tut-react-and-spring-data-rest/blob/master/basic/src/main/js/client.js">在此处阅读代码</a> 。</p> </li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-important" title="重要"></i> </td>
<td class="content">的代码<code>client</code>由于您用于进行REST调用的内容并不重要，因此未显示。随时检查源代码，但是重点是，您可以插入Restangular或任何您喜欢的东西，并且概念仍然适用。</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_diving_into_react">潜入React</h3>
<div class="paragraph">
<p>React是基于定义组件的。通常，一个组件可以以父子关系保存另一个组件的多个实例。这个概念很容易扩展几层。</p>
</div>
<div class="paragraph">
<p>首先，为所有组件配备一个顶层容器非常方便。（随着您扩展本系列中的代码，这一点将变得更加明显。）现在，您只有雇员列表。但是稍后您可能需要其他一些相关组件，因此让我们从此开始：</p>
</div>
<div class="listingblock">
<div class="title">src / main / js / app.js-应用程序组件</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">class App extends React.Component {

	constructor(props) {
		super(props);
		this.state = {employees: []};
	}

	componentDidMount() {
		client({method: 'GET', path: '/api/employees'}).done(response =&gt; {
			this.setState({employees: response.entity._embedded.employees});
		});
	}

	render() {
		return (
			&lt;EmployeeList employees={this.state.employees}/&gt;
		)
	}
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li> <p><code>class Foo extends React.Component{…​}</code>是创建React组件的方法。</p> </li>
<li> <p><code>componentDidMount</code>是React在DOM中渲染组件后调用的API。</p> </li>
<li> <p><code>render</code>是用于在屏幕上“绘制”组件的API。</p> </li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">在React中，大写是组件命名的约定。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>在<strong>App</strong>组件中，从Spring Data REST后端获取一组雇员，并将其存储在该组件的<strong>状态</strong>数据中。</p>
</div>
<div id="NOTE" class="exampleblock">
<div class="content">
<div class="paragraph">
<p>React组件具有两种类型的数据： <strong>state</strong>和<strong>properties</strong> 。</p>
</div>
<div class="paragraph">
<p><strong>状态</strong>是组件期望自己处理的数据。也是可能波动和变化的数据。要读取状态，请使用<code>this.state</code> 。要更新它，您可以使用<code>this.setState()</code> 。每次<code>this.setState()</code>调用后，React更新状态，计算先前状态和新状态之间的差异，并向页面上的DOM注入一组更改。这样可以快速有效地更新您的UI。</p>
</div>
<div class="paragraph">
<p>通用约定是使用构造函数中所有属性为空的状态初始化状态。然后您使用以下命令从服务器中查找数据<code>componentDidMount</code>并填充您的属性。从那里开始，更新可以由用户操作或其他事件来驱动。</p>
</div>
<div class="paragraph">
<p><strong>属性</strong>包含传递到组件中的数据。属性不会改变，而是固定值。要设置它们，您将在创建新组件时将它们分配给属性，您将很快看到。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-warning" title="警告"></i> </td>
<td class="content">JavaScript不会像其他语言一样锁定数据结构。您可以尝试通过分配值来颠覆属性，但这不适用于React的差分引擎，应避免使用。</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>在此代码中，该函数通过<code>client</code> ，一个与<a href="https://promisesaplus.com/">Promise兼容</a>的rest.js实例。完成后从中检索<code>/api/employees</code> ，然后调用内部的函数<code>done()</code>并根据其HAL文档设置状态（ <code>response.entity._embedded.employees</code> ）。您可能还记得<code>curl /api/employees</code> <a href="#_touring_your_rest_service">前面的内容</a> ，看看它如何映射到此结构上。</p>
</div>
<div class="paragraph">
<p>状态更新后， <code>render()</code>函数由框架调用。员工状态数据包含在创建<code><EmployeeList /></code>反应组件作为输入参数。</p>
</div>
<div class="paragraph">
<p>以下是<code>EmployeeList</code> 。</p>
</div>
<div class="listingblock">
<div class="title">src / main / js / app.js-EmployeeList组件</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">class EmployeeList extends React.Component{
	render() {
		const employees = this.props.employees.map(employee =&gt;
			&lt;Employee key={employee._links.self.href} employee={employee}/&gt;
		);
		return (
			&lt;table&gt;
				&lt;tbody&gt;
					&lt;tr&gt;
						&lt;th&gt;First Name&lt;/th&gt;
						&lt;th&gt;Last Name&lt;/th&gt;
						&lt;th&gt;Description&lt;/th&gt;
					&lt;/tr&gt;
					{employees}
				&lt;/tbody&gt;
			&lt;/table&gt;
		)
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用JavaScript的地图功能， <code>this.props.employees</code>从一组员工记录转换为一组<code><Element /></code> React组件（您会在后面看到一些内容）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">&lt;Employee key={employee._links.self.href} data={employee} /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这显示了正在创建的新React组件（请注意大写格式）以及两个属性： <strong>key</strong>和<strong>data</strong> 。这些是从提供的值<code>employee._links.self.href</code>和<code>employee</code> 。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-important" title="重要"></i> </td>
<td class="content">每当您使用Spring Data REST时， <strong>自</strong>链接都是给定资源的关键。React需要一个用于子节点的唯一标识符，并且<code>_links.self.href</code>是完美的。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>最后，返回包装在<code>employees</code>使用映射构建。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;First Name&lt;/th&gt;
        &lt;th&gt;Last Name&lt;/th&gt;
        &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
    {employees}
&lt;/table&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>状态，属性和HTML的这种简单布局显示了React如何使您以声明方式创建一个简单易懂的组件。</p>
</div>
<div id="NOTE" class="exampleblock">
<div class="content">
<div class="paragraph">
<p>此代码是否同时包含HTML <em>和</em> JavaScript？是的，这是<a href="https://facebook.github.io/jsx/">JSX</a> 。不需要使用它。React可以使用纯JavaScript编写，但是JSX语法非常简洁。由于对Babel.js的快速工作，翻译器同时提供了JSX和ES6支持</p>
</div>
<div class="paragraph">
<p>JSX还包含一些<a href="http://es6-features.org/#Constants">ES6</a> 。该代码中使用的一个是<a href="http://es6-features.org/#ExpressionBodies">箭头功能</a> 。它避免了创建一个嵌套函数（）有自己的作用域<strong>这一点</strong> ，避免了需要一个<a href="https://stackoverflow.com/a/962040/28214"><strong>自</strong>变量</a> 。</p>
</div>
<div class="paragraph">
<p>担心将逻辑与您的结构混合？React的API鼓励结合状态和属性的漂亮的声明式结构。React鼓励混合一些不相关的JavaScript和HTML，而不是混合使用一些无关的状态和属性，从而构建简单的组件。它使您可以查看单个组件并了解设计。然后它们很容易组合在一起形成更大的结构。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>接下来，您需要实际定义<code><Employee /></code>是。</p>
</div>
<div class="listingblock">
<div class="title">src / main / js / app.js-员工组件</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">class Employee extends React.Component{
	render() {
		return (
			&lt;tr&gt;
				&lt;td&gt;{this.props.employee.firstName}&lt;/td&gt;
				&lt;td&gt;{this.props.employee.lastName}&lt;/td&gt;
				&lt;td&gt;{this.props.employee.description}&lt;/td&gt;
			&lt;/tr&gt;
		)
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个组件非常简单。它有一个围绕员工的三个属性的HTML表行。财产本身是<code>this.props.employee</code> 。请注意，传递JavaScript对象如何使传递从服务器获取的数据变得容易？</p>
</div>
<div class="paragraph">
<p>因为此组件不管理任何状态，也不处理用户输入，所以没有其他事情要做。这可能会诱使您将其塞入<code><EmployeeList /></code>之上。别做！取而代之的是，将您的应用程序分解为各个小组件，每个组件都完成一项工作，这将使将来构建功能变得更加容易。</p>
</div>
<div class="paragraph">
<p>最后一步是渲染整个内容。</p>
</div>
<div class="listingblock">
<div class="title">src / main / js / app.js-呈现代码</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">ReactDOM.render(
	&lt;App /&gt;,
	document.getElementById('react')
)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>React.render()</code>接受两个参数：您定义的React组件以及将其注入的DOM节点。记住你如何看待<code><div id="react"></div></code> HTML页面中较早的项目？这是它被拾起并插入的地方。</p>
</div>
<div class="paragraph">
<p>一切就绪后，重新运行应用程序（ <code>./mvnw spring-boot:run</code> ）并访问<a href="http://localhost:8080" class="bare">http：// localhost：8080</a> 。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://github.com/spring-guides/tut-react-and-spring-data-rest/raw/master/basic/images/basic-1.png" alt="基本1">
</div>
</div>
<div class="paragraph">
<p>您可以看到系统加载了初始员工。</p>
</div>
<div class="paragraph">
<p>还记得使用cURL创建新条目吗？再做一次。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>curl -X POST localhost:8080/api/employees -d "{\"firstName\": \"Bilbo\", \"lastName\": \"Baggins\", \"description\": \"burglar\"}" -H "Content-Type:application/json"</pre>
</div>
</div>
<div class="paragraph">
<p>刷新浏览器，您应该看到新条目：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://github.com/spring-guides/tut-react-and-spring-data-rest/raw/master/basic/images/basic-2.png" alt="基本2">
</div>
</div>
<div class="paragraph">
<p>现在，您可以在网站上看到这两个列表。</p>
</div>
</div>
<div class="sect2">
<h3 id="_review">评论</h3>
<div class="paragraph">
<p>在这个部分：</p>
</div>
<div class="ulist">
<ul>
<li> <p>您定义了一个域对象和一个相应的存储库。</p> </li>
<li> <p>您让Spring Data REST通过功能强大的超媒体控件将其导出。</p> </li>
<li> <p>您在父子关系中创建了两个简单的React组件。</p> </li>
<li> <p>您获取了服务器数据并将其呈现为简单的静态HTML结构。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>有问题吗？</p>
</div>
<div class="ulist">
<ul>
<li> <p>该网页不是动态的。您必须刷新浏览器才能获取新记录。</p> </li>
<li> <p>该网页未使用任何超媒体控件或元数据。相反，它被硬编码为从<code>/api/employees</code> 。</p> </li>
<li> <p>它是只读的。尽管您可以使用cURL更改记录，但网页没有提供任何内容。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>这些是我们在下一节中可以解决的问题。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="react-and-spring-data-rest-part-2">第2部分-超媒体控件</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在上<a href="#react-and-spring-data-rest-part-1">一节中</a> ，您了解了如何使用Spring Data REST站起来使用后端薪资服务来存储员工数据。它缺少的一个关键功能是使用超媒体控件和按链接导航。相反，它对找到数据的路径进行了硬编码。</p>
</div>
<div class="paragraph">
<p>随时从该存储库中<a href="https://github.com/spring-guides/tut-react-and-spring-data-rest/tree/master/hypermedia">获取代码</a>并继续。本节基于上一节的应用程序，并添加了其他内容。</p>
</div>
<div class="sect2">
<h3 id="_in_the_beginning_there_was_dataand_then_there_was_rest">最初有数据...然后有RES​​T</h3>
<div class="quoteblock">
<blockquote>人们对将任何基于HTTP的接口称为REST API的人数感到沮丧。今天的示例是SocialSite REST API。那就是RPC。它尖叫着RPC ....在超文本是一个约束的概念上，需要采取什么措施才能使REST体系结构风格清晰明了？换句话说，如果应用程序状态的引擎（以及API）不是由超文本驱动的，则它不能是RESTful的，也不能是REST API。期。是否有一些需要修复的故障手册？
</blockquote>
<div class="attribution">—罗伊·菲尔丁（Roy T. Fielding）<br>
<cite>https://roy.gbiv.com/untangled/2008/rest-apis-must-be-超文本驱动</cite>
</div>
</div>
<div class="paragraph">
<p>那么，超媒体控件到底是什么，即超文本，又该如何使用它们呢？为了找出答案，让我们退后一步，看看REST的核心任务。</p>
</div>
<div class="paragraph">
<p>REST的概念是借用使网络如此成功的想法并将其应用于API。尽管Web的规模巨大，动态特性以及客户端（即浏览器）的更新速度很低，但是Web取得了惊人的成功。罗伊·菲尔丁（Roy Fielding）试图利用其一些约束和功能，看看是否能够提供类似的API生产和消费量。</p>
</div>
<div class="paragraph">
<p>限制之一是限制动词的数量。对于REST，主要的是GET，POST，PUT，DELETE和PATCH。还有其他人，但我们不会在这里介绍。</p>
</div>
<div class="ulist">
<ul>
<li> <p>GET-在不更改系统的情况下获取资源状态</p> </li>
<li> <p>POST-创建新资源，而不用说</p> </li>
<li> <p>PUT-替换现有资源，覆盖现有资源（如果有的话）</p> </li>
<li> <p>删除-删除现有资源</p> </li>
<li> <p>PATCH-部分更改现有资源</p> </li>
</ul>
</div>
<div class="paragraph">
<p>这些是具有良好规范的标准化HTTP动词。通过选择并使用已经创造的HTTP操作，我们不必发明新的语言并教育行业。</p>
</div>
<div class="paragraph">
<p>REST的另一个限制是使用媒体类型来定义数据格式。与其每个人都写自己的方言来交换信息，不如发展一些媒体类型。最受欢迎的一种是HAL，媒体类型为application / hal + json。这是Spring Data REST的默认媒体类型。敏锐的价值在于，REST没有集中的单一媒体类型。相反，人们可以开发媒体类型并将其插入。试试看。随着不同需求的出现，行业可以灵活地移动。</p>
</div>
<div class="paragraph">
<p>REST的关键功能是包括指向相关资源的链接。例如，如果您正在查看订单，则RESTful API将包括到相关客户的链接，到商品目录的链接，以及到从其下订单的商店的链接。在本节中，您将介绍分页，并了解如何也使用导航分页链接。</p>
</div>
</div>
<div class="sect2">
<h3 id="_turning_on_paging_from_the_backend">从后端开启分页</h3>
<div class="paragraph">
<p>要开始使用前端超媒体控件，您需要打开一些额外的控件。Spring Data REST提供了页面支持。要使用它，只需调整存储库定义：</p>
</div>
<div class="listingblock">
<div class="title">src / main / java / com / greglturnquist / payroll / EmployeeRepository.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public interface EmployeeRepository extends PagingAndSortingRepository&lt;Employee, Long&gt; {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您的界面现已扩展<code>PagingAndSortingRepository</code>它添加了额外的选项来设置页面大小，还添加了导航链接以在页面之间跳转。后端的其余部分是相同的（一些<a href="https://github.com/spring-guides/tut-react-and-spring-data-rest/blob/master/hypermedia/src/main/java/com/greglturnquist/payroll/DatabaseLoader.java">额外的预加载数据</a>使事情变得有趣）。</p>
</div>
<div class="paragraph">
<p>重新启动应用程序（ <code>./mvnw spring-boot:run</code> ），并查看其工作原理。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl "localhost:8080/api/employees?size=2"
{
  "_links" : {
    "first" : {
      "href" : "http://localhost:8080/api/employees?page=0&amp;size=2"
    },
    "self" : {
      "href" : "http://localhost:8080/api/employees"
    },
    "next" : {
      "href" : "http://localhost:8080/api/employees?page=1&amp;size=2"
    },
    "last" : {
      "href" : "http://localhost:8080/api/employees?page=2&amp;size=2"
    }
  },
  "_embedded" : {
    "employees" : [ {
      "firstName" : "Frodo",
      "lastName" : "Baggins",
      "description" : "ring bearer",
      "_links" : {
        "self" : {
          "href" : "http://localhost:8080/api/employees/1"
        }
      }
    }, {
      "firstName" : "Bilbo",
      "lastName" : "Baggins",
      "description" : "burglar",
      "_links" : {
        "self" : {
          "href" : "http://localhost:8080/api/employees/2"
        }
      }
    } ]
  },
  "page" : {
    "size" : 2,
    "totalElements" : 6,
    "totalPages" : 3,
    "number" : 0
  }
}</pre>
</div>
</div>
<div class="paragraph">
<p>默认页面大小为20，因此要查看实际使用情况， <code>?size=2</code>应用。不出所料，只列出了两名员工。此外，还有一个<strong>first</strong> ， <strong>next</strong>和<strong>last</strong>链接。还有一个<strong>自</strong>链接，没有上下文， <em>包括页面参数</em> 。</p>
</div>
<div class="paragraph">
<p>如果您导航到<strong>下一个</strong>环节，你会再看到<strong>上一个</strong>链接，以及：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl "http://localhost:8080/api/employees?page=1&amp;size=2"
{
  "_links" : {
    "first" : {
      "href" : "http://localhost:8080/api/employees?page=0&amp;size=2"
    },
    "prev" : {
      "href" : "http://localhost:8080/api/employees?page=0&amp;size=2"
    },
    "self" : {
      "href" : "http://localhost:8080/api/employees"
    },
    "next" : {
      "href" : "http://localhost:8080/api/employees?page=2&amp;size=2"
    },
    "last" : {
      "href" : "http://localhost:8080/api/employees?page=2&amp;size=2"
    }
  },
...</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">在URL查询参数中使用“＆”时，命令行认为这是换行符。用引号引起来的整个URL绕过它。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>看起来很整洁，但是当您更新前端以利用它时，效果会更好。</p>
</div>
</div>
<div class="sect2">
<h3 id="_navigating_by_relationship">通过关系导航</h3>
<div class="paragraph">
<p>而已！后端不需要任何其他更改即可开始使用Spring Data REST提供的即用型超媒体控件。您可以切换到在前端工作。（这是Spring Data REST的优点所在。没有凌乱的控制器更新！）</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">需要指出的是，该应用程序不是“特定于Spring Data REST的”。而是使用<a href="http://stateless.co/hal_specification.html">HAL</a> ， <a href="https://tools.ietf.org/html/rfc6570">URI模板</a>和其他标准。这样就可以轻松使用rest.js：该库附带HAL支持。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>在上一节中，您将路径硬编码为<code>/api/employees</code> 。相反，您应该硬编码的唯一路径是根。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">...
var root = '/api';
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>方便的一点<a href="https://github.com/spring-guides/tut-react-and-spring-data-rest/blob/master/hypermedia/src/main/js/follow.js"><code>follow()</code>功能</a> ，您现在可以从根目录开始并导航至所需的位置！</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">componentDidMount() {
	this.loadFromServer(this.state.pageSize);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上一节中，加载是直接在内部完成的<code>componentDidMount()</code> 。在本节中，我们将在页面大小更新时重新加载整个员工列表。为此，我们已将事情转移到<code>loadFromServer()</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">loadFromServer(pageSize) {
	follow(client, root, [
		{rel: 'employees', params: {size: pageSize}}]
	).then(employeeCollection =&gt; {
		return client({
			method: 'GET',
			path: employeeCollection.entity._links.profile.href,
			headers: {'Accept': 'application/schema+json'}
		}).then(schema =&gt; {
			this.schema = schema.entity;
			return employeeCollection;
		});
	}).done(employeeCollection =&gt; {
		this.setState({
			employees: employeeCollection.entity._embedded.employees,
			attributes: Object.keys(this.schema.properties),
			pageSize: pageSize,
			links: employeeCollection.entity._links});
	});
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>loadFromServer</code>与上一节非常相似，但是如果使用<code>follow()</code> ：</p>
</div>
<div class="ulist">
<ul>
<li> <p>follow（）函数的第一个参数是<code>client</code>用于进行REST调用的对象。</p> </li>
<li> <p>第二个参数是起始的根URI。</p> </li>
<li> <p>第三个参数是要导航的一系列关系。每个可以是字符串或对象。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>关系数组可以很简单<code>["employees"]</code> ，表示在首次调用时，在<strong>_links中</strong>查找名为<strong>employee</strong>的关系（或<strong>rel</strong> ）。找到它的<strong>href</strong>并导航到它。如果阵列中存在其他关系，请冲洗并重复。</p>
</div>
<div class="paragraph">
<p>有时，仅靠依靠是不够的。在这段代码中，它还会插入查询参数<strong>？。大小= <pagesize></pagesize></strong> 。您还可以看到其他选项。</p>
</div>
</div>
<div class="sect2">
<h3 id="_grabbing_json_schema_metadata">抓取JSON模式元数据</h3>
<div class="paragraph">
<p>导航与基于尺寸的<strong>员工</strong>查询后<strong>，employeeCollection</strong>是在你的指尖。在上一节中，我们将其命名为day并将其显示在内部<code><EmployeeList /></code> 。今天，您正在执行另一个调用以获取在以下位置找到的一些<a href="https://json-schema.org/">JSON Schema元数据</a> <code>/api/profile/employees/</code> 。</p>
</div>
<div class="paragraph">
<p>您可以自己查看数据：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl http://localhost:8080/api/profile/employees -H "Accept:application/schema+json"
{
  "title" : "Employee",
  "properties" : {
    "firstName" : {
      "title" : "First name",
      "readOnly" : false,
      "type" : "string"
    },
    "lastName" : {
      "title" : "Last name",
      "readOnly" : false,
      "type" : "string"
    },
    "description" : {
      "title" : "Description",
      "readOnly" : false,
      "type" : "string"
    }
  },
  "definitions" : { },
  "type" : "object",
  "$schema" : "https://json-schema.org/draft-04/schema#"
}</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">/ profile / employees中元数据的默认格式为ALPS。不过，在这种情况下，您正在使用内容协商来获取JSON模式。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>通过在中捕获此信息<app></app> `组件的状态，稍后在构建输入表单时可以充分利用它。</p>
</div>
</div>
<div class="sect2">
<h3 id="creating-new-records">创建新记录</h3>
<div class="paragraph">
<p>有了此元数据，您现在可以向UI添加一些额外的控件。创建一个新的React组件， <code><CreateDialog /></code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">class CreateDialog extends React.Component {

	constructor(props) {
		super(props);
		this.handleSubmit = this.handleSubmit.bind(this);
	}

	handleSubmit(e) {
		e.preventDefault();
		const newEmployee = {};
		this.props.attributes.forEach(attribute =&gt; {
			newEmployee[attribute] = ReactDOM.findDOMNode(this.refs[attribute]).value.trim();
		});
		this.props.onCreate(newEmployee);

		// clear out the dialog's inputs
		this.props.attributes.forEach(attribute =&gt; {
			ReactDOM.findDOMNode(this.refs[attribute]).value = '';
		});

		// Navigate away from the dialog to hide it.
		window.location = "#";
	}

	render() {
		const inputs = this.props.attributes.map(attribute =&gt;
			&lt;p key={attribute}&gt;
				&lt;input type="text" placeholder={attribute} ref={attribute} className="field"/&gt;
			&lt;/p&gt;
		);

		return (
			&lt;div&gt;
				&lt;a href="#createEmployee"&gt;Create&lt;/a&gt;

				&lt;div id="createEmployee" className="modalDialog"&gt;
					&lt;div&gt;
						&lt;a href="#" title="Close" className="close"&gt;X&lt;/a&gt;

						&lt;h2&gt;Create new employee&lt;/h2&gt;

						&lt;form&gt;
							{inputs}
							&lt;button onClick={this.handleSubmit}&gt;Create&lt;/button&gt;
						&lt;/form&gt;
					&lt;/div&gt;
				&lt;/div&gt;
			&lt;/div&gt;
		)
	}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个新组件既有<code>handleSubmit()</code>功能和预期的一样<code>render()</code>功能。</p>
</div>
<div class="paragraph">
<p>让我们以相反的顺序深入研究这些功能，然后首先看一下<code>render()</code>功能。</p>
</div>
<div class="sect3">
<h4 id="hypermedia-rendering">渲染图</h4>
<div class="paragraph">
<p>您的代码映射到<strong>attribute</strong>属性中找到的JSON Schema数据，并将其转换为<code><p><input></p></code>元素。</p>
</div>
<div class="ulist">
<ul>
<li> <p>React再次需要使用<strong>key</strong>来区分多个子节点。</p> </li>
<li> <p>这是一个简单的基于文本的输入字段。</p> </li>
<li> <p><strong>占位符</strong>是我们可以向用户显示字段的位置。</p> </li>
<li> <p>您可能曾经拥有过<strong>name</strong>属性，但这不是必需的。借助React， <strong>ref</strong>是获取特定DOM节点的机制（您将很快看到）。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>这代表了组件的动态特性，它是通过从服务器加载数据来驱动的。</p>
</div>
<div class="paragraph">
<p>在此组件的顶级内部<code><div></code>是一个锚标签，另一个<code><div></code> 。锚标记是打开对话框的按钮。和嵌套<code><div></code>是隐藏的对话框本身。在此示例中，您使用的是纯HTML5和CSS3。根本没有JavaScript！您可以<a href="https://github.com/spring-guides/tut-react-and-spring-data-rest/blob/master/hypermedia/src/main/resources/static/main.css">看到</a>用于显示/隐藏对话框<a href="https://github.com/spring-guides/tut-react-and-spring-data-rest/blob/master/hypermedia/src/main/resources/static/main.css">的CSS代码</a> 。我们不会在这里深入探讨。</p>
</div>
<div class="paragraph">
<p>坐落在里面<code><div id="createEmployee"></code>是一种表单，在其中注入了输入字段的动态列表，后跟“ <strong>创建”</strong>按钮。该按钮有一个<code>onClick={this.handleSubmit}</code>事件处理程序。这是注册事件处理程序的React方法。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">React不会在每个DOM元素上创建大量事件处理程序。相反，它具有<a href="https://facebook.github.io/react/docs/interactivity-and-dynamic-uis.html#under-the-hood-autobinding-and-event-delegation">性能更高且更复杂的</a>解决方案。关键是您不必管理该基础结构，而可以专注于编写功能代码。</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_handling_user_input">处理用户输入</h4>
<div class="paragraph">
<p>的<code>handleSubmit()</code>函数首先阻止事件在层次结构中冒泡。然后，它使用相同的JSON Schema属性属性来查找每个<code><input></code>使用<code>React.findDOMNode(this.refs[attribute])</code> 。</p>
</div>
<div class="paragraph">
<p><code>this.refs</code>是一种通过名称获取并获取特定React组件的方法。从这种意义上讲，您只能获得虚拟DOM组件。要获取实际的DOM元素，您需要使用<code>React.findDOMNode()</code> 。</p>
</div>
<div class="paragraph">
<p>遍历每个输入并建立<code>newEmployee</code>对象，我们调用一个回调来<code>onCreate()</code>新员工。此功能位于内部顶部<code>App.onCreate</code>并作为另一个属性提供给此React组件。看一下顶层函数的工作方式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">onCreate(newEmployee) {
	follow(client, root, ['employees']).then(employeeCollection =&gt; {
		return client({
			method: 'POST',
			path: employeeCollection.entity._links.self.href,
			entity: newEmployee,
			headers: {'Content-Type': 'application/json'}
		})
	}).then(response =&gt; {
		return follow(client, root, [
			{rel: 'employees', params: {'size': this.state.pageSize}}]);
	}).done(response =&gt; {
		if (typeof response.entity._links.last !== "undefined") {
			this.onNavigate(response.entity._links.last.href);
		} else {
			this.onNavigate(response.entity._links.self.href);
		}
	});
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>再一次使用<code>follow()</code>功能以导航到执行POST操作的<strong>员工</strong>资源。在这种情况下，不需要应用任何参数，因此基于字符串的rels数组很好。在这种情况下，将返回POST调用。这允许下一个<code>then()</code>子句来处理POST的结果。</p>
</div>
<div class="paragraph">
<p>通常将新记录添加到数据集的末尾。由于您正在查看某个页面，因此合乎逻辑的是期望新员工记录不在当前页面上。要处理此问题，您需要获取应用了相同页面大小的一批新数据。该承诺将为其中的final子句返回<code>done()</code> 。</p>
</div>
<div class="paragraph">
<p>由于用户可能希望看到新创建的员工，因此您可以使用超媒体控件并导航到<strong>最后一个</strong>条目。</p>
</div>
<div class="paragraph">
<p>这在我们的UI中引入了分页的概念。让我们接下来解决这个问题！</p>
</div>
<div id="NOTE" class="exampleblock">
<div class="content">
<div class="paragraph">
<p>第一次使用基于承诺的API？<a href="https://promisesaplus.com/">承诺</a>是一种启动异步操作，然后注册一个函数以在任务完成时做出响应的方法。承诺被设计为链接在一起以避免“回调地狱”。请看以下流程：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">when.promise(async_func_call())
	.then(function(results) {
		/* process the outcome of async_func_call */
	})
	.then(function(more_results) {
		/* process the previous then() return value */
	})
	.done(function(yet_more) {
		/* process the previous then() and wrap things up */
	});</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关更多详细信息，请查看<a href="http://know.cujojs.com/tutorials/promises/consuming-promises">有关promise的本教程</a> 。</p>
</div>
<div class="paragraph">
<p>要记住的秘密是<code>then()</code>函数<em>需要</em>返回某些值，无论它是值还是其他承诺。 <code>done()</code>函数不会返回任何内容，并且您之后也不会链接任何内容。如果您还没有注意到， <code>client</code> （这是<code>rest</code>来自rest.js）以及<code>follow</code>函数返回承诺。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_paging_through_data">分页数据</h3>
<div class="paragraph">
<p>您在后端设置分页，并且在创建新员工时已经开始利用它。</p>
</div>
<div class="paragraph">
<p>在<a href="#creating-new-records">上一节中</a> ，您使用了页面控件来跳至<strong>最后</strong>一页。动态地将其应用于UI并让用户根据需要进行导航将非常方便。根据可用的导航链接动态调整控件会很棒。</p>
</div>
<div class="paragraph">
<p>首先，让我们看看<code>onNavigate()</code>您使用的功能。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">onNavigate(navUri) {
	client({method: 'GET', path: navUri}).done(employeeCollection =&gt; {
		this.setState({
			employees: employeeCollection.entity._embedded.employees,
			attributes: this.state.attributes,
			pageSize: this.state.pageSize,
			links: employeeCollection.entity._links
		});
	});
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在顶部，内部定义<code>App.onNavigate</code> 。同样，这是为了允许在顶部组件中管理UI的状态。经过之后<code>onNavigate()</code>下降到<code><EmployeeList /></code> React组件，对以下处理程序进行了编码，以处理某些按钮上的单击：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">handleNavFirst(e){
	e.preventDefault();
	this.props.onNavigate(this.props.links.first.href);
}

handleNavPrev(e) {
	e.preventDefault();
	this.props.onNavigate(this.props.links.prev.href);
}

handleNavNext(e) {
	e.preventDefault();
	this.props.onNavigate(this.props.links.next.href);
}

handleNavLast(e) {
	e.preventDefault();
	this.props.onNavigate(this.props.links.last.href);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些函数中的每一个都会拦截默认事件并阻止其冒泡。然后，它调用<code>onNavigate()</code>通过适当的超媒体链接起作用。</p>
</div>
<div class="paragraph">
<p>现在，根据哪些链接出现在超链接中而有条件地显示控件<code>EmployeeList.render</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">render() {
	const employees = this.props.employees.map(employee =&gt;
		&lt;Employee key={employee._links.self.href} employee={employee} onDelete={this.props.onDelete}/&gt;
	);

	const navLinks = [];
	if ("first" in this.props.links) {
		navLinks.push(&lt;button key="first" onClick={this.handleNavFirst}&gt;&amp;lt;&amp;lt;&lt;/button&gt;);
	}
	if ("prev" in this.props.links) {
		navLinks.push(&lt;button key="prev" onClick={this.handleNavPrev}&gt;&amp;lt;&lt;/button&gt;);
	}
	if ("next" in this.props.links) {
		navLinks.push(&lt;button key="next" onClick={this.handleNavNext}&gt;&amp;gt;&lt;/button&gt;);
	}
	if ("last" in this.props.links) {
		navLinks.push(&lt;button key="last" onClick={this.handleNavLast}&gt;&amp;gt;&amp;gt;&lt;/button&gt;);
	}

	return (
		&lt;div&gt;
			&lt;input ref="pageSize" defaultValue={this.props.pageSize} onInput={this.handleInput}/&gt;
			&lt;table&gt;
				&lt;tbody&gt;
					&lt;tr&gt;
						&lt;th&gt;First Name&lt;/th&gt;
						&lt;th&gt;Last Name&lt;/th&gt;
						&lt;th&gt;Description&lt;/th&gt;
						&lt;th&gt;&lt;/th&gt;
					&lt;/tr&gt;
					{employees}
				&lt;/tbody&gt;
			&lt;/table&gt;
			&lt;div&gt;
				{navLinks}
			&lt;/div&gt;
		&lt;/div&gt;
	)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>与上一节一样，它仍然可以转换<code>this.props.employees</code>变成一个数组<code><Element /></code>组件。然后建立一个数组<code>navLinks</code> ，一组HTML按钮。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">由于React是基于XML的，因此您不能将“ <”放在<code><button></code>元件。您必须改为使用编码版本。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>然后你可以看到<code>{navLinks}</code>插入返回的HTML的底部。</p>
</div>
</div>
<div class="sect2">
<h3 id="_deleting_existing_records">删除现有记录</h3>
<div class="paragraph">
<p>删除条目要容易得多。保留其基于HAL的记录，并将<strong>DELETE</strong>应用于其<strong>自身</strong>链接。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">class Employee extends React.Component {

	constructor(props) {
		super(props);
		this.handleDelete = this.handleDelete.bind(this);
	}

	handleDelete() {
		this.props.onDelete(this.props.employee);
	}

	render() {
		return (
			&lt;tr&gt;
				&lt;td&gt;{this.props.employee.firstName}&lt;/td&gt;
				&lt;td&gt;{this.props.employee.lastName}&lt;/td&gt;
				&lt;td&gt;{this.props.employee.description}&lt;/td&gt;
				&lt;td&gt;
					&lt;button onClick={this.handleDelete}&gt;Delete&lt;/button&gt;
				&lt;/td&gt;
			&lt;/tr&gt;
		)
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Employee组件的此更新版本在行末显示一个额外的条目，即一个删除按钮。注册调用<code>this.handleDelete</code>当点击。的<code>handleDelete()</code>然后，该函数可以调用传递的回调，同时提供上下文相关的重要信息<code>this.props.employee</code>记录。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-important" title="重要"></i> </td>
<td class="content">这再次表明，最容易在一处管理顶部组件中的状态。情况并非<em>总是</em>如此，但是通常情况下，在一个地方管理状态可以更轻松，更简单地保持状态。通过使用特定于组件的详细信息调用回调（ <code>this.props.onDelete(this.props.employee)</code> ），协调组件之间的行为非常容易。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>追踪<code>onDelete()</code>功能回到顶部<code>App.onDelete</code> ，您可以查看其运作方式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">onDelete(employee) {
	client({method: 'DELETE', path: employee._links.self.href}).done(response =&gt; {
		this.loadFromServer(this.state.pageSize);
	});
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用基于页面的UI删除记录后要应用的行为有些棘手。在这种情况下，它将使用相同的页面大小从服务器重新加载整个数据。然后显示第一页。</p>
</div>
<div class="paragraph">
<p>如果要删除最后一页上的最后一条记录，它将跳到第一页。</p>
</div>
</div>
<div class="sect2">
<h3 id="_adjusting_the_page_size">调整页面大小</h3>
<div class="paragraph">
<p>查看超媒体的真正效果的一种方法是更新页面大小。Spring Data REST根据页面大小流畅地更新导航链接。</p>
</div>
<div class="paragraph">
<p>在顶部有一个HTML元素<code>ElementList.render</code> ： <code><input ref="pageSize" defaultValue={this.props.pageSize} onInput={this.handleInput}/></code> 。</p>
</div>
<div class="ulist">
<ul>
<li> <p><code>ref="pageSize"</code>通过this.refs.pageSize可以轻松获取该元素。</p> </li>
<li> <p><code>defaultValue</code>使用状态的<strong>pageSize</strong>对其进行初始化。</p> </li>
<li> <p><code>onInput</code>注册一个处理程序，如下所示。</p> </li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">handleInput(e) {
	e.preventDefault();
	const pageSize = ReactDOM.findDOMNode(this.refs.pageSize).value;
	if (/^[0-9]+$/.test(pageSize)) {
		this.props.updatePageSize(pageSize);
	} else {
		ReactDOM.findDOMNode(this.refs.pageSize).value =
			pageSize.substring(0, pageSize.length - 1);
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它阻止事件冒泡。然后，它使用的<strong>ref</strong>属性<code><input></code>找到DOM节点并提取其值，全部通过React的<code>findDOMNode()</code>辅助功能。它通过检查输入是否为数字字符串来测试输入是否确实是数字。如果是这样，它将调用回调，将新的页面大小发送到<code>App</code>反应组件。如果不是，则将刚刚输入的字符从输入中删除。</p>
</div>
<div class="paragraph">
<p>是什么<code>App</code>当它得到一个<code>updatePageSize()</code> ？看看这个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">updatePageSize(pageSize) {
	if (pageSize !== this.state.pageSize) {
		this.loadFromServer(pageSize);
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于新的页面大小会导致所有导航链接发生更改，因此最好重新获取数据并从头开始。</p>
</div>
</div>
<div class="sect2">
<h3 id="_putting_it_all_together">放在一起</h3>
<div class="paragraph">
<p>有了所有这些不错的添加，您现在已经拥有了一个非常完善的UI。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://github.com/spring-guides/tut-react-and-spring-data-rest/raw/master/hypermedia/images/hypermedia-1.png" alt="超媒体1">
</div>
</div>
<div class="paragraph">
<p>您可以在顶部看到页面大小设置，在每行上看到删除按钮，在底部看到导航按钮。导航按钮说明了超媒体控件的强大功能。</p>
</div>
<div class="paragraph">
<p>在下面，您可以看到<code>CreateDialog</code>并将元数据插入HTML输入占位符。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://github.com/spring-guides/tut-react-and-spring-data-rest/raw/master/hypermedia/images/hypermedia-2.png" alt="超媒体2">
</div>
</div>
<div class="paragraph">
<p>这确实显示了结合使用超媒体和域驱动的元数据（JSON模式）的强大功能。网页不必知道哪个字段是哪个字段。而是，用户可以<em>看到</em>它并知道如何使用它。如果您将另一个字段添加到<code>Employee</code>域对象，此弹出窗口将自动显示它。</p>
</div>
</div>
<div class="sect2">
<h3 id="_review_2">评论</h3>
<div class="paragraph">
<p>在这个部分：</p>
</div>
<div class="ulist">
<ul>
<li> <p>您打开了Spring Data REST的分页功能。</p> </li>
<li> <p>您抛出了硬编码的URI路径，并开始使用结合了关系名称或“ rels”的根URI。</p> </li>
<li> <p>您更新了UI，以动态使用基于页面的超媒体控件。</p> </li>
<li> <p>您添加了创建和删除员工以及根据需要更新UI的功能。</p> </li>
<li> <p>您可以更改页面大小并灵活地响应UI。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>有问题吗？</p>
</div>
<div class="paragraph">
<p>您使网页具有动态性。但是打开另一个浏览器选项卡，然后将其指向同一应用程序。一个标签中的更改不会更新另一个标签中的任何内容。</p>
</div>
<div class="paragraph">
<p>这是我们在下一节中可以解决的问题。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="react-and-spring-data-rest-part-3">第3部分-条件运算</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在上<a href="#react-and-spring-data-rest-part-2">一节中</a> ，您了解了如何打开Spring Data REST的超媒体控件，如何使UI通过分页导航以及根据更改页面大小来动态调整大小。您添加了创建和删除员工以及调整页面的功能。但是，考虑到其他用户对您当前正在编辑的相同数据进行的更新，还没有一个完整的解决方案。</p>
</div>
<div class="paragraph">
<p>随时从该存储库中<a href="https://github.com/spring-guides/tut-react-and-spring-data-rest/tree/master/conditional">获取代码</a>并继续。本节基于上一节的应用程序，并添加了其他内容。</p>
</div>
<div class="sect2">
<h3 id="_to_put_or_not_to_put_that_is_the_question">要PUT还是不PUT，这就是问题</h3>
<div class="paragraph">
<p>当您获取资源时，如果其他人对其进行更新，则可能会过时。为了解决这个问题，Spring Data REST集成了两种技术：资源版本控制和ETag。</p>
</div>
<div class="paragraph">
<p>通过在后端对资源进行版本控制并在前端使用ETag，可以有意地将更改放入PUT。换句话说，您可以检测资源是否已更改，并防止PUT（或PATCH）踩到别人的更新。让我们来看看。</p>
</div>
</div>
<div class="sect2">
<h3 id="_versioning_rest_resources">REST资源版本化</h3>
<div class="paragraph">
<p>要支持资源的版本控制，请为需要这种保护类型的域对象定义一个版本属性。</p>
</div>
<div class="listingblock">
<div class="title">src / main / java / com / greglturnquist / payroll / Employee.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity
public class Employee {

	private @Id @GeneratedValue Long id;
	private String firstName;
	private String lastName;
	private String description;

	private @Version @JsonIgnore Long version;

	private Employee() {}

	public Employee(String firstName, String lastName, String description) {
		this.firstName = firstName;
		this.lastName = lastName;
		this.description = description;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;
		Employee employee = (Employee) o;
		return Objects.equals(id, employee.id) &amp;&amp;
			Objects.equals(firstName, employee.firstName) &amp;&amp;
			Objects.equals(lastName, employee.lastName) &amp;&amp;
			Objects.equals(description, employee.description) &amp;&amp;
			Objects.equals(version, employee.version);
	}

	@Override
	public int hashCode() {

		return Objects.hash(id, firstName, lastName, description, version);
	}

	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public String getFirstName() {
		return firstName;
	}

	public void setFirstName(String firstName) {
		this.firstName = firstName;
	}

	public String getLastName() {
		return lastName;
	}

	public void setLastName(String lastName) {
		this.lastName = lastName;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public Long getVersion() {
		return version;
	}

	public void setVersion(Long version) {
		this.version = version;
	}

	@Override
	public String toString() {
		return "Employee{" +
			"id=" + id +
			", firstName='" + firstName + '\'' +
			", lastName='" + lastName + '\'' +
			", description='" + description + '\'' +
			", version=" + version +
			'}';
	}
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li> <p><strong>版本</strong>字段带有注释<code>javax.persistence.Version</code> 。每次插入和更新行时，它都会自动存储和更新值。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>当获取单个资源（不是集合资源）时，Spring Data REST将自动添加带有该字段值的<a href="https://tools.ietf.org/html/rfc7232#section-2.3">ETag响应标头</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="_fetching_individual_resources_and_their_headers">获取单个资源及其标头</h3>
<div class="paragraph">
<p>在上<a href="#react-and-spring-data-rest-part-2">一节中，</a>您使用了收集资源来收集数据并填充UI的HTML表。使用Spring Data REST， <strong>已将_embedded</strong>数据集视为数据的预览。尽管对于浏览数据很有用，但要获取诸如ETags的标头，您需要单独获取每个资源。</p>
</div>
<div class="paragraph">
<p>在这个版本中<code>loadFromServer</code>更新以获取集合，然后使用URI检索每个单独的资源。</p>
</div>
<div class="listingblock">
<div class="title">src / main / js / app.js-获取每个资源</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">loadFromServer(pageSize) {
	follow(client, root, [
		{rel: 'employees', params: {size: pageSize}}]
	).then(employeeCollection =&gt; {
		return client({
			method: 'GET',
			path: employeeCollection.entity._links.profile.href,
			headers: {'Accept': 'application/schema+json'}
		}).then(schema =&gt; {
			this.schema = schema.entity;
			this.links = employeeCollection.entity._links;
			return employeeCollection;
		});
	}).then(employeeCollection =&gt; {
		return employeeCollection.entity._embedded.employees.map(employee =&gt;
				client({
					method: 'GET',
					path: employee._links.self.href
				})
		);
	}).then(employeePromises =&gt; {
		return when.all(employeePromises);
	}).done(employees =&gt; {
		this.setState({
			employees: employees,
			attributes: Object.keys(this.schema.properties),
			pageSize: pageSize,
			links: this.links
		});
	});
}</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li> <p>的<code>follow()</code>功能转到<strong>员工</strong>收集资源。</p> </li>
<li> <p>的<code>then(employeeCollection ⇒ …​)</code>子句创建调用以获取JSON模式数据。它有一个sub-then子句，用于将元数据和导航链接存储在<code><App/></code>零件。</p>
<div class="ulist">
<ul>
<li> <p>请注意，此嵌入的承诺将返回employeeCollection。这样，可以将集合传递到下一个调用，同时让您沿途获取元数据。</p> </li>
</ul>
</div> </li>
<li> <p>第二<code>then(employeeCollection ⇒ …​)</code>子句将雇员集合转换为GET承诺数组，以获取每个单独的资源。<strong>这是为每个员工获取ETag标头所需的内容。</strong></p> </li>
<li> <p>的<code>then(employeePromises ⇒ …​)</code>子句采用GET诺言数组，并将它们合并为一个诺言<code>when.all()</code> ，在所有GET Promise都解决后解决。</p> </li>
<li> <p><code>loadFromServer</code>结束<code>done(employees ⇒ …​)</code>使用此数据合并来更新UI状态。</p> </li>
</ol>
</div>
<div class="paragraph">
<p>该链也在其他地方实现。例如， <code>onNavigate()</code> ，用于跳转到不同的页面，已更新为获取单个资源。由于与上面显示的内容基本相同，因此将其排除在本节之外。</p>
</div>
</div>
<div class="sect2">
<h3 id="_updating_existing_resources">更新现有资源</h3>
<div class="paragraph">
<p>在本节中，您将添加一个<code>UpdateDialog</code>反应组件以编辑现有员工记录。</p>
</div>
<div class="listingblock">
<div class="title">src / main / js / app.js-UpdateDialog组件</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">class UpdateDialog extends React.Component {

	constructor(props) {
		super(props);
		this.handleSubmit = this.handleSubmit.bind(this);
	}

	handleSubmit(e) {
		e.preventDefault();
		const updatedEmployee = {};
		this.props.attributes.forEach(attribute =&gt; {
			updatedEmployee[attribute] = ReactDOM.findDOMNode(this.refs[attribute]).value.trim();
		});
		this.props.onUpdate(this.props.employee, updatedEmployee);
		window.location = "#";
	}

	render() {
		const inputs = this.props.attributes.map(attribute =&gt;
			&lt;p key={this.props.employee.entity[attribute]}&gt;
				&lt;input type="text" placeholder={attribute}
					   defaultValue={this.props.employee.entity[attribute]}
					   ref={attribute} className="field"/&gt;
			&lt;/p&gt;
		);

		const dialogId = "updateEmployee-" + this.props.employee.entity._links.self.href;

		return (
			&lt;div key={this.props.employee.entity._links.self.href}&gt;
				&lt;a href={"#" + dialogId}&gt;Update&lt;/a&gt;
				&lt;div id={dialogId} className="modalDialog"&gt;
					&lt;div&gt;
						&lt;a href="#" title="Close" className="close"&gt;X&lt;/a&gt;

						&lt;h2&gt;Update an employee&lt;/h2&gt;

						&lt;form&gt;
							{inputs}
							&lt;button onClick={this.handleSubmit}&gt;Update&lt;/button&gt;
						&lt;/form&gt;
					&lt;/div&gt;
				&lt;/div&gt;
			&lt;/div&gt;
		)
	}

};</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个新组件既有<code>handleSubmit()</code>功能和预期的一样<code>render()</code>功能，类似于<code><CreateDialog /></code>零件。</p>
</div>
<div class="paragraph">
<p>让我们以相反的顺序深入研究这些功能，然后先来看一下<code>render()</code>功能。</p>
</div>
<div class="sect3">
<h4 id="_rendering">渲染图</h4>
<div class="paragraph">
<p>该组件使用与CSS / HTML相同的策略来显示和隐藏对话框。 <code><CreateDialog /></code>从上一节开始。</p>
</div>
<div class="paragraph">
<p>它将JSON Schema属性数组转换为HTML输入数组，并包装在段落元素中以进行样式设置。这也和<code><CreateDialog /></code>唯一的区别是：字段已加载<strong>this.props.employee</strong> 。在CreateDialog组件中，这些字段为空。</p>
</div>
<div class="paragraph">
<p><strong>id</strong>字段的构建方式不同。整个UI上只有一个CreateDialog链接，但显示的每一行都有一个单独的UpdateDialog链接。因此， <strong>id</strong>字段基于<strong>自身</strong>链接的URI。这在两个</p><div>元素的React <strong>键</strong>以及HTML锚标记和隐藏的弹出窗口。
</div>
</div>
<div class="sect3">
<h4 id="_handling_user_input_2">处理用户输入</h4>
<div class="paragraph"> 
<p>提交按钮链接到组件的<code>handleSubmit()</code>功能。方便使用<code>React.findDOMNode()</code>使用<a href="https://facebook.github.io/react/docs/more-about-refs.html">React refs</a>提取弹出窗口的详细信息。</p>
</div>
<div class="paragraph">
 <p>提取输入值并将其加载到<code>updatedEmployee</code>对象，顶层<code>onUpdate()</code>方法被调用。这延续了React的单向绑定样式，其中要调用的函数从上层组件推送到下层组件。这样，状态仍在顶部进行管理。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_conditional_put">有条件的PUT</h3>
<div class="paragraph">
<p>因此，您已经花了所有力气将版本控制嵌入到数据模型中。Spring Data REST已将该值用作ETag响应标头。在这里，您可以充分利用它！</p>
</div>
<div class="listingblock">
<div class="title">src / main / js / app.js-onUpdate函数</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">onUpdate(employee, updatedEmployee) {
	client({
		method: 'PUT',
		path: employee.entity._links.self.href,
		entity: updatedEmployee,
		headers: {
			'Content-Type': 'application/json',
			'If-Match': employee.headers.Etag
		}
	}).done(response =&gt; {
		this.loadFromServer(this.state.pageSize);
	}, response =&gt; {
		if (response.status.code === 412) {
			alert('DENIED: Unable to update ' +
				employee.entity._links.self.href + '. Your copy is stale.');
		}
	});
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>带有<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.24">If-Match请求标头的</a> PUT使Spring Data REST根据当前版本检查该值。如果传入的<strong>If-Match</strong>值与数据存储的版本值不匹配，则Spring Data REST将失败，并显示<strong>HTTP 412 Precondition Failed</strong> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content"><a href="https://promisesaplus.com/">Promises / A +</a>的规范实际上将其API定义为<code>then(successFunction, errorFunction)</code> 。到目前为止，您仅看到它与成功功能一起使用。在上面的代码片段中，有两个功能。成功函数调用<code>loadFromServer</code>而错误功能则显示有关过时数据的浏览器警报。</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_putting_it_all_together_2">放在一起</h3>
<div class="paragraph">
<p>和你的<code>UpdateDialog</code>已定义React组件并与顶级组件很好地链接<code>onUpdate</code>功能，最后一步是将其连接到现有的组件布局中。</p>
</div>
<div class="paragraph">
<p>的<code>CreateDialog</code>上一节中创建的内容放在顶部<code>EmployeeList</code>因为只有一个实例。然而， <code>UpdateDialog</code>与特定员工直接相关。这样您就可以看到它已插入下面的<code>Employee</code>反应组件：</p>
</div>
<div class="listingblock">
<div class="title">src / main / js / app.js-具有UpdateDialog的员工</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">class Employee extends React.Component {

	constructor(props) {
		super(props);
		this.handleDelete = this.handleDelete.bind(this);
	}

	handleDelete() {
		this.props.onDelete(this.props.employee);
	}

	render() {
		return (
			&lt;tr&gt;
				&lt;td&gt;{this.props.employee.entity.firstName}&lt;/td&gt;
				&lt;td&gt;{this.props.employee.entity.lastName}&lt;/td&gt;
				&lt;td&gt;{this.props.employee.entity.description}&lt;/td&gt;
				&lt;td&gt;
					&lt;UpdateDialog employee={this.props.employee}
								  attributes={this.props.attributes}
								  onUpdate={this.props.onUpdate}/&gt;
				&lt;/td&gt;
				&lt;td&gt;
					&lt;button onClick={this.handleDelete}&gt;Delete&lt;/button&gt;
				&lt;/td&gt;
			&lt;/tr&gt;
		)
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在本部分中，您将从使用收集资源切换为单个资源。现在可以在以下位置找到员工记录的字段<code>this.props.employee.entity</code> 。它使我们能够访问<code>this.props.employee.headers</code>在这里可以找到ETag。</p>
</div>
<div class="paragraph">
<p>Spring Data REST支持的其他标头（如<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.29">Last-Modified</a> ）也不属于本系列。因此，以这种方式构造数据非常方便。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-important" title="重要"></i> </td>
<td class="content">的结构<code>.entity</code>和<code>.headers</code>仅在将<a href="https://github.com/cujojs/rest">rest.js</a>用作REST库时才有意义。如果使用其他库，则必须根据需要进行调整。</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_seeing_things_in_action">看到实际情况</h3>
<div class="olist arabic">
<ol class="arabic">
<li> <p>启动应用程序（ <code>./mvnw spring-boot:run</code> ）。</p> </li>
<li> <p>打开一个选项卡，然后浏览至<a href="http://localhost:8080" class="bare">http：// localhost：8080</a> 。</p>
<div class="imageblock">
<div class="content">
<img src="https://github.com/spring-guides/tut-react-and-spring-data-rest/raw/master/conditional/images/conditional-1.png" alt="有条件的1">
</div>
</div> </li>
<li> <p>上拉Frodo的编辑对话框。</p> </li>
<li> <p>在浏览器中打开另一个选项卡，并拉出相同的记录。</p> </li>
<li> <p>在第一个选项卡中更改记录。</p> </li>
<li> <p>尝试在第二个选项卡中进行更改。</p>
<div class="imageblock">
<div class="content">
<img src="https://github.com/spring-guides/tut-react-and-spring-data-rest/raw/master/conditional/images/conditional-2.png" alt="有条件的2">
</div>
</div> </li>
</ol>
</div>
<div class="imageblock">
<div class="content">
<img src="https://github.com/spring-guides/tut-react-and-spring-data-rest/raw/master/conditional/images/conditional-3.png" alt="有条件的3">
</div>
</div>
<div class="paragraph">
<p>使用这些mod，可以避免冲突，从而提高了数据完整性。</p>
</div>
</div>
<div class="sect2">
<h3 id="_review_3">评论</h3>
<div class="paragraph">
<p>在这个部分：</p>
</div>
<div class="ulist">
<ul>
<li> <p>您使用<code>@Version</code>基于JPA的乐观锁定的字段。</p> </li>
<li> <p>您调整了前端以获取单个资源。</p> </li>
<li> <p>您将ETag标头从单个资源插入到<strong>If-Match</strong>请求标头中，以使PUT有条件。</p> </li>
<li> <p>您为列表中显示的每个员工编码了一个新的UpdateDialog。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>插入此插件后，很容易避免与其他用户发生冲突，或者只是覆盖他们的编辑内容。</p>
</div>
<div class="paragraph">
<p>有问题吗？</p>
</div>
<div class="paragraph">
<p>很高兴知道何时编辑不良记录。但是，最好等到您单击“提交”才能找到答案吗？</p>
</div>
<div class="paragraph">
<p>两者中获取资源的逻辑非常相似<code>loadFromServer</code>和<code>onNavigate</code> 。您看到避免重复代码的方法了吗？</p>
</div>
<div class="paragraph">
<p>您充分利用了JSON模式元数据来构建<code>CreateDialog</code>和<code>UpdateDialog</code>输入。您是否在其他地方使用元数据使事情变得更通用？假设您想再添加五个字段<code>Employee.java</code> 。更新用户界面需要什么？</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="react-and-spring-data-rest-part-4">第四部分-活动</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在上<a href="#react-and-spring-data-rest-part-3">一节中</a> ，您介绍了条件更新，以避免在编辑相同数据时与其他用户发生冲突。您还学习了如何使用乐观锁定在后端上对数据进行版本控制。如果有人编辑了同一条记录，您会得到提示，以便刷新页面并获取更新。</p>
</div>
<div class="paragraph">
<p>非常好。但是你知道什么更好吗？当其他人更新资源时，让UI动态响应。</p>
</div>
<div class="paragraph">
<p>在本节中，您将学习如何使用Spring Data REST的内置事件系统来检测后端的更改，并通过Spring的WebSocket支持将更新发布给所有用户。然后，您将能够在数据更新时动态调整客户端。</p>
</div>
<div class="paragraph">
<p>随时从该存储库中<a href="https://github.com/spring-guides/tut-react-and-spring-data-rest/tree/master/events">获取代码</a>并继续。本节基于上一节的应用程序，并添加了其他内容。</p>
</div>
<div class="sect2">
<h3 id="_adding_spring_websocket_support_to_the_project">在项目中添加Spring WebSocket支持</h3>
<div class="paragraph">
<p>在进行之前，您需要向项目的pom.xml文件添加一个依赖项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
	&lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这带来了Spring Boot的WebSocket启动器。</p>
</div>
</div>
<div class="sect2">
<h3 id="_configuring_websockets_with_spring">用Spring配置WebSockets</h3>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#websocket">Spring提供了强大的WebSocket支持</a> 。要认识的一件事是WebSocket是一个非常低级的协议。它仅提供了在客户端和服务器之间传输数据的手段。建议使用子协议（本节为STOMP）对数据和路由进行实际编码。</p>
</div>
<div class="paragraph">
<p>以下代码用于在服务器端配置WebSocket支持：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Component
@EnableWebSocketMessageBroker
public class WebSocketConfiguration implements WebSocketMessageBrokerConfigurer {

	static final String MESSAGE_PREFIX = "/topic";

	@Override
	public void registerStompEndpoints(StompEndpointRegistry registry) {
		registry.addEndpoint("/payroll").withSockJS();
	}

	@Override
	public void configureMessageBroker(MessageBrokerRegistry registry) {
		registry.enableSimpleBroker(MESSAGE_PREFIX);
		registry.setApplicationDestinationPrefixes("/app");
	}
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li> <p><code>@EnableWebSocketMessageBroker</code>打开WebSocket支持。</p> </li>
<li> <p><code>AbstractWebSocketMessageBrokerConfigurer</code>提供了一个方便的基类来配置基本功能。</p> </li>
<li> <p><strong>MESSAGE_PREFIX</strong>是您将在每条消息的路由之前添加的前缀。</p> </li>
<li> <p><code>registerStompEndpoints()</code>用于配置后端上的端点，以便客户端和服务器链接（ <code>/payroll</code> ）。</p> </li>
<li> <p><code>configureMessageBroker()</code>用于配置用于在服务器和客户端之间中继消息的代理。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>通过这种配置，现在可以利用Spring Data REST事件并将其发布到WebSocket上。</p>
</div>
</div>
<div class="sect2">
<h3 id="_subscribing_to_spring_data_rest_events">订阅Spring Data REST事件</h3>
<div class="paragraph">
<p>Spring Data REST根据存储库中发生的操作生成多个<a href="https://docs.spring.io/spring-data/rest/docs/current/reference/html/#events">应用程序事件</a> 。以下代码显示了如何订阅其中一些事件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Component
@RepositoryEventHandler(Employee.class)
public class EventHandler {

	private final SimpMessagingTemplate websocket;

	private final EntityLinks entityLinks;

	@Autowired
	public EventHandler(SimpMessagingTemplate websocket, EntityLinks entityLinks) {
		this.websocket = websocket;
		this.entityLinks = entityLinks;
	}

	@HandleAfterCreate
	public void newEmployee(Employee employee) {
		this.websocket.convertAndSend(
				MESSAGE_PREFIX + "/newEmployee", getPath(employee));
	}

	@HandleAfterDelete
	public void deleteEmployee(Employee employee) {
		this.websocket.convertAndSend(
				MESSAGE_PREFIX + "/deleteEmployee", getPath(employee));
	}

	@HandleAfterSave
	public void updateEmployee(Employee employee) {
		this.websocket.convertAndSend(
				MESSAGE_PREFIX + "/updateEmployee", getPath(employee));
	}

	/**
	 * Take an {@link Employee} and get the URI using Spring Data REST's {@link EntityLinks}.
	 *
	 * @param employee
	 */
	private String getPath(Employee employee) {
		return this.entityLinks.linkForSingleResource(employee.getClass(),
				employee.getId()).toUri().getPath();
	}

}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li> <p><code>@RepositoryEventHandler(Employee.class)</code>标记此类以捕获基于<strong>雇员的</strong>事件。</p> </li>
<li> <p><code>SimpMessagingTemplate</code>和<code>EntityLinks</code>从应用程序上下文自动连接。</p> </li>
<li> <p>的<code>@HandleXYZ</code>批注标记需要侦听的方法。这些方法必须是公开的。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>这些处理程序方法均调用<code>SimpMessagingTemplate.convertAndSend()</code>通过WebSocket传输消息。这是一种发布订阅的方法，因此一条消息将转发给每个附加的使用者。</p>
</div>
<div class="paragraph">
<p>每条消息的路由是不同的，从而允许将多个消息发送到客户端上不同的接收者，而只需要一个开放的WebSocket，这是一种节省资源的方法。</p>
</div>
<div class="paragraph">
<p><code>getPath()</code>使用Spring Data REST的<code>EntityLinks</code>查找给定类类型和ID的路径。为了满足客户的需求，这<code>Link</code>对象将转换为Java URI，并提取其路径。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content"> <code>EntityLinks</code>附带了几种实用程序方法，可以以编程方式找到各种资源的路径，无论是单个资源还是集合资源。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>本质上，您正在侦听创建，更新和删除事件，事件完成后，将它们的通知发送给所有客户端。也有可能在此类操作发生之前对其进行拦截，并可能记录它们，出于某种原因阻止它们或用额外的信息修饰域对象。（在下一节中，我们将看到非常方便的用法！）</p>
</div>
</div>
<div class="sect2">
<h3 id="_configuring_a_javascript_websocket">配置JavaScript WebSocket</h3>
<div class="paragraph">
<p>下一步是编写一些客户端代码来使用WebSocket事件。他们主应用程序中的跟随块引入了一个模块。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">var stompClient = require('./websocket-listener')</code></pre>
</div>
</div>
<div class="paragraph">
<p>该模块如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">'use strict';

const SockJS = require('sockjs-client'); <i class="conum" data-value="1"></i><b>(1)</b>
require('stompjs'); <i class="conum" data-value="2"></i><b>(2)</b>

function register(registrations) {
	const socket = SockJS('/payroll'); <i class="conum" data-value="3"></i><b>(3)</b>
	const stompClient = Stomp.over(socket);
	stompClient.connect({}, function(frame) {
		registrations.forEach(function (registration) { <i class="conum" data-value="4"></i><b>(4)</b>
			stompClient.subscribe(registration.route, registration.callback);
		});
	});
}

module.exports.register = register;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody>
<tr>
<td><i class="conum" data-value="1"></i> <b>1个</b></td>
<td>您可以拉入SockJS JavaScript库以通过WebSocket进行通信。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i> <b>2</b></td>
<td>您拉入stomp-websocket JavaScript库以使用STOMP子协议。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i> <b>3</b></td>
<td>这是WebSocket指向应用程序的位置<code>/payroll</code>端点。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i> <b>4</b></td>
<td>遍历数组<code>registrations</code>提供，因此每个人都可以在消息到达时订阅回调。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>每个注册条目都有一个<code>route</code>和一个<code>callback</code> 。在下一节中，您将看到如何注册事件处理程序。</p>
</div>
</div>
<div class="sect2">
<h3 id="_registering_for_websocket_events">注册WebSocket事件</h3>
<div class="paragraph">
<p>在React中，组件的<code>componentDidMount()</code>是在DOM中呈现后被调用的函数。这也是注册WebSocket事件的合适时机，因为该组件现在已联机并且可以投入使用。签出以下代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">componentDidMount() {
	this.loadFromServer(this.state.pageSize);
	stompClient.register([
		{route: '/topic/newEmployee', callback: this.refreshAndGoToLastPage},
		{route: '/topic/updateEmployee', callback: this.refreshCurrentPage},
		{route: '/topic/deleteEmployee', callback: this.refreshCurrentPage}
	]);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一行与之前相同，在此所有员工都是使用页面大小从服务器中提取的。第二行显示了为WebSocket事件注册的JavaScript对象数组，每个对象都有一个<code>route</code>和一个<code>callback</code> 。</p>
</div>
<div class="paragraph">
<p>创建新员工时，其行为是刷新数据集，然后使用分页链接导航到<strong>最后</strong>一页。为什么在浏览到最后之前刷新数据？添加新记录可能会导致创建新页面。尽管可以计算出是否会发生，但它颠覆了超媒体的观点。最好不要使用定制的链接数，而最好是使用现有的链接，并且只有在有提高性能的原因时才使用它。</p>
</div>
<div class="paragraph">
<p>当员工被更新或删除时，其行为是刷新当前页面。更新记录时，它会影响您正在查看的页面。当您删除当前页面上的记录时，下一页的记录将被拉入当前页面，因此也需要刷新当前页面。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">这些WebSocket消息不需要以<code>/topic</code> 。它只是表明pub-sub语义的通用约定。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>在下一节中，您将看到执行这些操作的实际操作。</p>
</div>
</div>
<div class="sect2">
<h3 id="_reacting_to_websocket_events_and_updating_the_ui_state">响应WebSocket事件并更新UI状态</h3>
<div class="paragraph">
<p>以下代码块包含两个回调，这些回调用于在收到WebSocket事件时更新UI状态。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">refreshAndGoToLastPage(message) {
	follow(client, root, [{
		rel: 'employees',
		params: {size: this.state.pageSize}
	}]).done(response =&gt; {
		if (response.entity._links.last !== undefined) {
			this.onNavigate(response.entity._links.last.href);
		} else {
			this.onNavigate(response.entity._links.self.href);
		}
	})
}

refreshCurrentPage(message) {
	follow(client, root, [{
		rel: 'employees',
		params: {
			size: this.state.pageSize,
			page: this.state.page.number
		}
	}]).then(employeeCollection =&gt; {
		this.links = employeeCollection.entity._links;
		this.page = employeeCollection.entity.page;

		return employeeCollection.entity._embedded.employees.map(employee =&gt; {
			return client({
				method: 'GET',
				path: employee._links.self.href
			})
		});
	}).then(employeePromises =&gt; {
		return when.all(employeePromises);
	}).then(employees =&gt; {
		this.setState({
			page: this.page,
			employees: employees,
			attributes: Object.keys(this.schema.properties),
			pageSize: this.state.pageSize,
			links: this.links
		});
	});
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>refreshAndGoToLastPage()</code>使用熟悉的<code>follow()</code>该功能可导航到应用了<strong>size</strong>参数的<strong>员工</strong>链接，并插入<code>this.state.pageSize</code> 。收到响应后，您将调用相同的<code>onNavigate()</code>功能从最后一节开始，然后跳到<strong>最后</strong>一页，即找到新记录的那一页。</p>
</div>
<div class="paragraph">
<p><code>refreshCurrentPage()</code>也使用<code>follow()</code>功能但适用<code>this.state.pageSize</code> <strong>大小</strong>和<code>this.state.page.number</code>到<strong>页面</strong> 。这将获取您当前正在查看的同一页面，并相应地更新状态。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">此行为告诉每个客户端在发送更新或删除消息时刷新其当前页面。他们的当前页面可能与当前事件无关。但是，弄清楚这一点可能很棘手。如果已删除的记录在第二页上，而您正在查看第三页怎么办？每个条目都会改变。但是，这种期望的行为是根本吗？也许吧，也许不是。</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_moving_state_management_out_of_the_local_updates">将状态管理移出本地更新</h3>
<div class="paragraph">
<p>在完成本节之前，您需要识别一些东西。您刚刚为UI中的状态添加了一种新的更新方式：WebSocket消息到达时。但是更新状态的旧方法仍然存在。</p>
</div>
<div class="paragraph">
<p>为了简化代码的状态管理，请删除旧方法。换句话说，提交您的<strong>POST</strong> ， <strong>PUT</strong>和<strong>DELETE</strong>调用，但不要使用它们的结果来更新UI的状态。相反，请等待WebSocket事件返回，然后再进行更新。</p>
</div>
<div class="paragraph">
<p>以下代码块显示相同<code>onCreate()</code>功能与上一节相同，仅进行了简化：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">onCreate(newEmployee) {
	follow(client, root, ['employees']).done(response =&gt; {
		client({
			method: 'POST',
			path: response.entity._links.self.href,
			entity: newEmployee,
			headers: {'Content-Type': 'application/json'}
		})
	})
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里<code>follow()</code>函数用于获取<strong>雇员</strong>链接，然后应用<strong>POST</strong>操作。注意如何<code>client({method: 'GET' …​})</code>没有<code>then()</code>要么<code>done()</code>就像之前一样？现在可以在以下位置找到用于监听更新的事件处理程序： <code>refreshAndGoToLastPage()</code>您刚刚看过的。</p>
</div>
</div>
<div class="sect2">
<h3 id="_putting_it_all_together_3">放在一起</h3>
<div class="paragraph">
<p>放置所有这些模块后，启动应用程序（ <code>./mvnw spring-boot:run</code> ）并随便戳一下。打开两个浏览器选项卡并调整大小，以便您可以同时看到它们。开始在一个选项卡中进行更新，看看它们如何立即更新另一个选项卡。打开您的手机并访问同一页面。找到一个朋友，并要求他或她做同样的事情。您可能会发现这种动态更新更加敏锐。</p>
</div>
<div class="paragraph">
<p>想要挑战吗？尝试上一部分中的练习，在两个不同的浏览器选项卡中打开同一记录。尝试在其中一个更新它，而在另一个中看不到它更新。如果可能的话，条件PUT代码仍应保护您。但是实现这一目标可能会比较棘手！</p>
</div>
</div>
<div class="sect2">
<h3 id="_review_4">评论</h3>
<div class="paragraph">
<p>在这个部分：</p>
</div>
<div class="ulist">
<ul>
<li> <p>您使用SockJS fallback配置了Spring的WebSocket支持。</p> </li>
<li> <p>您订阅了Spring Data REST中的创建，更新和删除事件，以动态更新UI。</p> </li>
<li> <p>您发布了受影响的REST资源的URI以及上下文消息（“ / topic / newEmployee”，“ / topic / updateEmployee”等）。</p> </li>
<li> <p>您已在UI中注册了WebSocket侦听器以侦听这些事件。</p> </li>
<li> <p>您将侦听器连接到处理程序以更新UI状态。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>通过所有这些功能，可以轻松并排运行两个浏览器，并了解如何将一个浏览器更新到另一个浏览器。</p>
</div>
<div class="paragraph">
<p>有问题吗？</p>
</div>
<div class="paragraph">
<p>尽管多个显示器可以很好地更新，但仍可以保证精确的行为。例如，创建一个新用户将导致所有用户跳到最后。关于如何处理有什么想法？</p>
</div>
<div class="paragraph">
<p>分页很有用，但提供了一个棘手的状态来管理。该示例应用程序的成本很低，并且React在更新DOM时非常高效，而不会在UI中引起大量闪烁。但是对于更复杂的应用程序，并非所有这些方法都适用。</p>
</div>
<div class="paragraph">
<p>考虑分页设计时，您必须确定客户端之间的预期行为以及是否需要更新。根据您的需求和系统性能，现有的导航超媒体可能就足够了。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="react-and-spring-data-rest-part-5">第5部分-保护UI和API</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在上<a href="#react-and-spring-data-rest-part-4">一节中</a> ，您通过Spring Data REST的内置事件处理程序和Spring Framework的WebSocket支持使应用程序动态响应其他用户的更新。但是，如果没有完整的应用程序，那么任何应用程序都是不完整的，因此只有适当的用户才能访问UI及其背后的资源。</p>
</div>
<div class="paragraph">
<p>随时从该存储库中<a href="https://github.com/spring-guides/tut-react-and-spring-data-rest/tree/master/security">获取代码</a>并继续。本节基于上一节的应用程序，并添加了其他内容。</p>
</div>
<div class="sect2">
<h3 id="_adding_spring_security_to_the_project">将Spring Security添加到项目</h3>
<div class="paragraph">
<p>在进行之前，您需要向项目的pom.xml文件中添加几个依赖项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
	&lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
	&lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;
	&lt;artifactId&gt;thymeleaf-extras-springsecurity5&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这引入了Spring Boot的Spring Security入门程序以及一些额外的Thymeleaf标签，以在网页中进行安全性查找。</p>
</div>
</div>
<div class="sect2">
<h3 id="_defining_the_security_model">定义安全模型</h3>
<div class="paragraph">
<p>在上一节中，您使用了不错的薪资系统。在后端声明内容并让Spring Data REST承担繁重的工作很方便。下一步是对需要建立安全控制的系统进行建模。</p>
</div>
<div class="paragraph">
<p>如果这是一个薪资系统，那么只有经理才能访问它。因此，通过建模<code>Manager</code>宾语：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity
public class Manager {

	public static final PasswordEncoder PASSWORD_ENCODER = new BCryptPasswordEncoder();

	private @Id @GeneratedValue Long id;

	private String name;

	private @JsonIgnore String password;

	private String[] roles;

	public void setPassword(String password) {
		this.password = PASSWORD_ENCODER.encode(password);
	}

	protected Manager() {}

	public Manager(String name, String password, String... roles) {

		this.name = name;
		this.setPassword(password);
		this.roles = roles;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;
		Manager manager = (Manager) o;
		return Objects.equals(id, manager.id) &amp;&amp;
			Objects.equals(name, manager.name) &amp;&amp;
			Objects.equals(password, manager.password) &amp;&amp;
			Arrays.equals(roles, manager.roles);
	}

	@Override
	public int hashCode() {

		int result = Objects.hash(id, name, password);
		result = 31 * result + Arrays.hashCode(roles);
		return result;
	}

	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getPassword() {
		return password;
	}

	public String[] getRoles() {
		return roles;
	}

	public void setRoles(String[] roles) {
		this.roles = roles;
	}

	@Override
	public String toString() {
		return "Manager{" +
			"id=" + id +
			", name='" + name + '\'' +
			", roles=" + Arrays.toString(roles) +
			'}';
	}
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li> <p><code>PASSWORD_ENCODER</code>是在比较之前对新密码进行加密或获取密码输入并对其进行加密的方法。</p> </li>
<li> <p><code>id</code> ， <code>name</code> ， <code>password</code>和<code>roles</code>定义限制访问所需的参数。</p> </li>
<li> <p>定制的<code>setPassword()</code>确保密码永远不会以明文形式存储。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>设计安全层时，要记住一件事。保护正确的数据位（例如密码），不要让它们被打印到控制台，日志中或通过JSON序列化导出。</p>
</div>
<div class="ulist">
<ul>
<li> <p><code>@JsonIgnore</code>应用于密码字段可防止Jackson对该字段进行序列化。</p> </li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_creating_a_managers_repository">创建经理的资料库</h3>
<div class="paragraph">
<p>Spring Data非常擅长管理实体。为什么不创建一个存储库来处理这些经理？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@RepositoryRestResource(exported = false)
public interface ManagerRepository extends Repository&lt;Manager, Long&gt; {

	Manager save(Manager manager);

	Manager findByName(String name);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>而不是扩展通常的<code>CrudRepository</code> ，则不需要太多方法。相反，您需要保存数据（也用于更新），并且需要查找现有用户。因此，您可以使用Spring Data Common的<code>Repository</code>标记界面。它没有预定义的操作。</p>
</div>
<div class="paragraph">
<p>默认情况下，Spring Data REST将导出其找到的任何存储库。您不希望此存储库公开以进行REST操作！应用<code>@RepositoryRestResource(exported = false)</code>注释以阻止其导出。这样可以防止存储库以及任何元数据被提供。</p>
</div>
</div>
<div class="sect2">
<h3 id="_linking_employees_with_their_managers">将员工与其经理联系起来</h3>
<div class="paragraph">
<p>安全性建模的最后一点是使员工与经理相关联。在此域中，一个雇员可以有一个经理，而一个经理可以有多个雇员：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity
public class Employee {

	private @Id @GeneratedValue Long id;
	private String firstName;
	private String lastName;
	private String description;

	private @Version @JsonIgnore Long version;

	private @ManyToOne Manager manager;

	private Employee() {}

	public Employee(String firstName, String lastName, String description, Manager manager) {
		this.firstName = firstName;
		this.lastName = lastName;
		this.description = description;
		this.manager = manager;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;
		Employee employee = (Employee) o;
		return Objects.equals(id, employee.id) &amp;&amp;
			Objects.equals(firstName, employee.firstName) &amp;&amp;
			Objects.equals(lastName, employee.lastName) &amp;&amp;
			Objects.equals(description, employee.description) &amp;&amp;
			Objects.equals(version, employee.version) &amp;&amp;
			Objects.equals(manager, employee.manager);
	}

	@Override
	public int hashCode() {

		return Objects.hash(id, firstName, lastName, description, version, manager);
	}

	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public String getFirstName() {
		return firstName;
	}

	public void setFirstName(String firstName) {
		this.firstName = firstName;
	}

	public String getLastName() {
		return lastName;
	}

	public void setLastName(String lastName) {
		this.lastName = lastName;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public Long getVersion() {
		return version;
	}

	public void setVersion(Long version) {
		this.version = version;
	}

	public Manager getManager() {
		return manager;
	}

	public void setManager(Manager manager) {
		this.manager = manager;
	}

	@Override
	public String toString() {
		return "Employee{" +
			"id=" + id +
			", firstName='" + firstName + '\'' +
			", lastName='" + lastName + '\'' +
			", description='" + description + '\'' +
			", version=" + version +
			", manager=" + manager +
			'}';
	}
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li> <p>通过JPA链接到manager属性<code>@ManyToOne</code> 。经理不需要<code>@OneToMany</code>因为您还没有定义查找的必要。</p> </li>
<li> <p>实用程序构造函数调用已更新以支持初始化。</p> </li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_securing_employees_to_their_managers">确保员工与经理的关系</h3>
<div class="paragraph">
<p>当定义安全策略时，Spring Security支持多种选择。在本节中，您希望限制某些事情，以便只有经理可以查看员工工资数据，并且保存，更新和删除操作仅限于员工的经理。换句话说，任何经理都可以登录并查看数据，但是只有给定员工的经理才能进行任何更改。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@PreAuthorize("hasRole('ROLE_MANAGER')")
public interface EmployeeRepository extends PagingAndSortingRepository&lt;Employee, Long&gt; {

	@Override
	@PreAuthorize("#employee?.manager == null or #employee?.manager?.name == authentication?.name")
	Employee save(@Param("employee") Employee employee);

	@Override
	@PreAuthorize("@employeeRepository.findById(#id)?.manager?.name == authentication?.name")
	void deleteById(@Param("id") Long id);

	@Override
	@PreAuthorize("#employee?.manager?.name == authentication?.name")
	void delete(@Param("employee") Employee employee);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@PreAuthorize</code>界面顶部的，禁止访问具有<strong>ROLE_MANAGER的人员</strong> 。</p>
</div>
<div class="paragraph">
<p>上<code>save()</code> ，或者员工的经理为空（在未分配经理的情况下初始创建新员工），或者员工的经理名称与当前经过身份验证的用户名匹配。在这里，您使用<a href="https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#el-access">Spring Security的SpEL表达式</a>来定义访问。它带有方便的“？”。属性导航器来处理空检查。注意使用<code>@Param(…​)</code>在参数上链接HTTP操作与方法。</p>
</div>
<div class="paragraph">
<p>上<code>delete()</code> ，则该方法可以访问雇员，或者如果该方法仅具有ID，则它必须在应用程序上下文中找到<strong>employeeRepository</strong> ，然后执行<code>findOne(id)</code> ，然后针对当前经过身份验证的用户检查管理员。</p>
</div>
</div>
<div class="sect2">
<h3 id="_writing_a_userdetails_service">写一个<code>UserDetails</code>服务</h3>
<div class="paragraph">
<p>与安全性集成的一个共同点是定义一个<code>UserDetailsService</code> 。这是将用户的数据存储连接到Spring Security界面的方法。Spring Security需要一种方法来查找用户以进行安全检查，这就是桥梁。幸运的是，对于Spring Data，所做的工作非常少：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Component
public class SpringDataJpaUserDetailsService implements UserDetailsService {

	private final ManagerRepository repository;

	@Autowired
	public SpringDataJpaUserDetailsService(ManagerRepository repository) {
		this.repository = repository;
	}

	@Override
	public UserDetails loadUserByUsername(String name) throws UsernameNotFoundException {
		Manager manager = this.repository.findByName(name);
		return new User(manager.getName(), manager.getPassword(),
				AuthorityUtils.createAuthorityList(manager.getRoles()));
	}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>SpringDataJpaUserDetailsService</code>实现Spring Security的<code>UserDetailsService</code> 。该接口有一种方法： <code>loadUserByUsername()</code> 。此方法旨在返回一个<code>UserDetails</code>对象，以便Spring Security可以询问用户的信息。</p>
</div>
<div class="paragraph">
<p>因为你有一个<code>ManagerRepository</code> ，则无需编写任何SQL或JPA表达式即可获取此所需数据。在此类中，它是通过构造函数注入自动装配的。</p>
</div>
<div class="paragraph">
<p><code>loadUserByUsername()</code>进入您刚才编写的自定义查找器， <code>findByName()</code> 。然后填充Spring Security <code>User</code>实例，它实现了<code>UserDetails</code>接口。您还在使用Spring Securiy的<code>AuthorityUtils</code>从一系列基于字符串的角色过渡到Java <code>List</code>的<code>GrantedAuthority</code> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="_wiring_up_your_security_policy">连接您的安全策略</h3>
<div class="paragraph">
<p>的<code>@PreAuthorize</code>应用于存储库的表达式是<strong>访问规则</strong> 。没有安全策略，这些规则是徒劳的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {

	@Autowired
	private SpringDataJpaUserDetailsService userDetailsService;

	@Override
	protected void configure(AuthenticationManagerBuilder auth) throws Exception {
		auth
			.userDetailsService(this.userDetailsService)
				.passwordEncoder(Manager.PASSWORD_ENCODER);
	}

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.authorizeRequests()
				.antMatchers("/built/**", "/main.css").permitAll()
				.anyRequest().authenticated()
				.and()
			.formLogin()
				.defaultSuccessUrl("/", true)
				.permitAll()
				.and()
			.httpBasic()
				.and()
			.csrf().disable()
			.logout()
				.logoutSuccessUrl("/");
	}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这段代码有很多复杂性，因此让我们逐步了解一下，首先讨论注释和API。然后，我们将讨论它定义的安全策略。</p>
</div>
<div class="ulist">
<ul>
<li> <p><code>@EnableWebSecurity</code>告诉Spring Boot放弃其自动配置的安全策略，而改用该策略。对于快速演示，可以自动配置安全性。但是对于任何真实的事情，您都应该自己编写策略。</p> </li>
<li> <p><code>@EnableGlobalMethodSecurity</code>通过Spring Security复杂的<a href="https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#el-pre-post-annotations">@Pre和@Post注释</a>打开方法级安全性。</p> </li>
<li> <p>它延伸<code>WebSecurityConfigurerAdapter</code> ，方便编写策略的基类。</p> </li>
<li> <p>它自动接线<code>SpringDataJpaUserDetailsService</code>通过现场注入，然后通过<code>configure(AuthenticationManagerBuilder)</code>方法。的<code>PASSWORD_ENCODER</code>从<code>Manager</code>也已设置。</p> </li>
<li> <p>关键的安全策略是用纯Java编写的， <code>configure(HttpSecurity)</code> 。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>安全策略说使用先前定义的访问规则授权所有请求。</p>
</div>
<div class="ulist">
<ul>
<li> <p>列出的路径<code>antMatchers()</code>被授予无条件访问权限，因为没有理由阻止静态Web资源。</p> </li>
<li> <p>任何不匹配的东西都会落入<code>anyRequest().authenticated()</code>表示需要验证。</p> </li>
<li> <p>设置了这些访问规则后，系统将告知Spring Security使用基于表单的身份验证，成功时默认为“ /”，并授予对登录页面的访问权限。</p> </li>
<li> <p>BASIC登录也配置为禁用CSRF。这主要是用于演示，不建议对生产系统进行仔细分析。</p> </li>
<li> <p>注销配置为将用户带到“ /”。</p> </li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-warning" title="警告"></i> </td>
<td class="content">在尝试curl时，BASIC身份验证非常方便。使用curl访问基于表单的系统令人生畏。重要的是要认识到，通过HTTP（不是HTTPS）上的任何机制进行身份验证都会使您面临通过网络嗅探凭据的风险。CSRF是一个完整的好协议。只需禁用它即可使与BASIC的交互和卷曲更加容易。在生产中，最好将其保留。</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_adding_security_details_automatically">自动添加安全详细信息</h3>
<div class="paragraph">
<p>良好的用户体验是应用程序可以自动应用上下文时。在此示例中，如果已登录的经理创建了新员工记录，则该经理拥有该记录是有意义的。使用Spring Data REST的事件处理程序，用户无需显式链接它。它还可以确保用户不会意外记录到错误的管理员。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Component
@RepositoryEventHandler(Employee.class)
public class SpringDataRestEventHandler {

	private final ManagerRepository managerRepository;

	@Autowired
	public SpringDataRestEventHandler(ManagerRepository managerRepository) {
		this.managerRepository = managerRepository;
	}

	@HandleBeforeCreate
	@HandleBeforeSave
	public void applyUserInformationUsingSecurityContext(Employee employee) {

		String name = SecurityContextHolder.getContext().getAuthentication().getName();
		Manager manager = this.managerRepository.findByName(name);
		if (manager == null) {
			Manager newManager = new Manager();
			newManager.setName(name);
			newManager.setRoles(new String[]{"ROLE_MANAGER"});
			manager = this.managerRepository.save(newManager);
		}
		employee.setManager(manager);
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@RepositoryEventHandler(Employee.class)</code>将此事件处理程序标记为仅应用于<code>Employee</code>对象。的<code>@HandleBeforeCreate</code>注释使您有机会更改传入的<code>Employee</code>在将其写入数据库之前进行记录。</p>
</div>
<div class="paragraph">
<p>在此情况下，您将查找当前用户的安全上下文以获取用户名。然后使用<code>findByName()</code>并将其应用于经理。如果系统中尚不存在新的管理员，则可以使用一些额外的胶水代码来创建新的管理员。但这主要是为了支持数据库的初始化。在实际的生产系统中，应删除该代码，而应依赖DBA或Security Ops团队来正确维护用户数据存储。</p>
</div>
</div>
<div class="sect2">
<h3 id="_pre_loading_manager_data">预加载经理数据</h3>
<div class="paragraph">
<p>加载经理并将员工与这些经理联系起来很简单：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Component
public class DatabaseLoader implements CommandLineRunner {

	private final EmployeeRepository employees;
	private final ManagerRepository managers;

	@Autowired
	public DatabaseLoader(EmployeeRepository employeeRepository,
						  ManagerRepository managerRepository) {

		this.employees = employeeRepository;
		this.managers = managerRepository;
	}

	@Override
	public void run(String... strings) throws Exception {

		Manager greg = this.managers.save(new Manager("greg", "turnquist",
							"ROLE_MANAGER"));
		Manager oliver = this.managers.save(new Manager("oliver", "gierke",
							"ROLE_MANAGER"));

		SecurityContextHolder.getContext().setAuthentication(
			new UsernamePasswordAuthenticationToken("greg", "doesn't matter",
				AuthorityUtils.createAuthorityList("ROLE_MANAGER")));

		this.employees.save(new Employee("Frodo", "Baggins", "ring bearer", greg));
		this.employees.save(new Employee("Bilbo", "Baggins", "burglar", greg));
		this.employees.save(new Employee("Gandalf", "the Grey", "wizard", greg));

		SecurityContextHolder.getContext().setAuthentication(
			new UsernamePasswordAuthenticationToken("oliver", "doesn't matter",
				AuthorityUtils.createAuthorityList("ROLE_MANAGER")));

		this.employees.save(new Employee("Samwise", "Gamgee", "gardener", oliver));
		this.employees.save(new Employee("Merry", "Brandybuck", "pony rider", oliver));
		this.employees.save(new Employee("Peregrin", "Took", "pipe smoker", oliver));

		SecurityContextHolder.clearContext();
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个麻烦是，当此加载程序运行时，Spring Security在启用访问规则的情况下将处于活动状态。因此，要保存员工数据，您必须使用Spring Security的<code>setAuthentication()</code>用于使用正确的名称和角色对该加载程序进行身份验证的API。最后，清除安全上下文。</p>
</div>
</div>
<div class="sect2">
<h3 id="_touring_your_secured_rest_service">游览您的安全REST服务</h3>
<div class="paragraph">
<p>放置所有这些模块后，您可以启动应用程序（ <code>./mvnw spring-boot:run</code> ），并使用cURL检出mod。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl -v -u greg:turnquist localhost:8080/api/employees/1
*   Trying ::1...
* Connected to localhost (::1) port 8080 (#0)
* Server auth using Basic with user 'greg'
&gt; GET /api/employees/1 HTTP/1.1
&gt; Host: localhost:8080
&gt; Authorization: Basic Z3JlZzp0dXJucXVpc3Q=
&gt; User-Agent: curl/7.43.0
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 200 OK
&lt; Server: Apache-Coyote/1.1
&lt; X-Content-Type-Options: nosniff
&lt; X-XSS-Protection: 1; mode=block
&lt; Cache-Control: no-cache, no-store, max-age=0, must-revalidate
&lt; Pragma: no-cache
&lt; Expires: 0
&lt; X-Frame-Options: DENY
&lt; Set-Cookie: JSESSIONID=E27F929C1836CC5BABBEAB78A548DF8C; Path=/; HttpOnly
&lt; ETag: "0"
&lt; Content-Type: application/hal+json;charset=UTF-8
&lt; Transfer-Encoding: chunked
&lt; Date: Tue, 25 Aug 2015 15:57:34 GMT
&lt;
{
  "firstName" : "Frodo",
  "lastName" : "Baggins",
  "description" : "ring bearer",
  "manager" : {
    "name" : "greg",
    "roles" : [ "ROLE_MANAGER" ]
  },
  "_links" : {
    "self" : {
      "href" : "http://localhost:8080/api/employees/1"
    }
  }
}</pre>
</div>
</div>
<div class="paragraph">
<p>与第一部分相比，这显示了更多细节。首先，Spring Security启用了几种HTTP协议来防御各种攻击媒介（编译指示，过期，X-Frame-Options等）。您还将通过以下方式发行BASIC凭证： <code>-u greg:turnquist</code>呈现Authorization标头。</p>
</div>
<div class="paragraph">
<p>在所有标题中，您可以从版本化资源中看到<strong>ETag</strong>标题。</p>
</div>
<div class="paragraph">
<p>最后，在数据本身内部，您可以看到一个新属性： <strong>manager</strong> 。您可以看到它包含名称和角色，但不包含密码。那是由于使用<code>@JsonIgnore</code>在那个领域。由于Spring Data REST并未导出该存储库，因此在该资源中内联了它的值。在下一节中更新UI时，将充分利用它。</p>
</div>
</div>
<div class="sect2">
<h3 id="_displaying_manager_info_on_the_ui">在界面上显示经理信息</h3>
<div class="paragraph">
<p>有了所有这些mod的后端，您现在就可以转移到更新前端中的内容。首先，在内部展示一名员工的经理<code><Employee /></code>反应组件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">class Employee extends React.Component {

	constructor(props) {
		super(props);
		this.handleDelete = this.handleDelete.bind(this);
	}

	handleDelete() {
		this.props.onDelete(this.props.employee);
	}

	render() {
		return (
			&lt;tr&gt;
				&lt;td&gt;{this.props.employee.entity.firstName}&lt;/td&gt;
				&lt;td&gt;{this.props.employee.entity.lastName}&lt;/td&gt;
				&lt;td&gt;{this.props.employee.entity.description}&lt;/td&gt;
				&lt;td&gt;{this.props.employee.entity.manager.name}&lt;/td&gt;
				&lt;td&gt;
					&lt;UpdateDialog employee={this.props.employee}
								  attributes={this.props.attributes}
								  onUpdate={this.props.onUpdate}
								  loggedInManager={this.props.loggedInManager}/&gt;
				&lt;/td&gt;
				&lt;td&gt;
					&lt;button onClick={this.handleDelete}&gt;Delete&lt;/button&gt;
				&lt;/td&gt;
			&lt;/tr&gt;
		)
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这只是为<code>this.props.employee.entity.manager.name</code> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="_filtering_out_json_schema_metadata">过滤出JSON模式元数据</h3>
<div class="paragraph">
<p>如果数据输出中显示了一个字段，则可以假定它在JSON模式元数据中有一个条目。您可以在以下摘录中看到它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>{
	...
    "manager" : {
      "readOnly" : false,
      "$ref" : "#/descriptors/manager"
    },
    ...
  },
  ...
  "$schema" : "https://json-schema.org/draft-04/schema#"
}</pre>
</div>
</div>
<div class="paragraph">
<p>管理员字段不是您希望人们直接编辑的内容。由于是内联的，因此应将其视为只读属性。要从中过滤掉内联条目<code>CreateDialog</code>和<code>UpdateDialog</code> ，只需在获取JSON Schema元数据后删除此类条目即可<code>loadFromServer()</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">/**
 * Filter unneeded JSON Schema properties, like uri references and
 * subtypes ($ref).
 */
Object.keys(schema.entity.properties).forEach(function (property) {
	if (schema.entity.properties[property].hasOwnProperty('format') &amp;&amp;
		schema.entity.properties[property].format === 'uri') {
		delete schema.entity.properties[property];
	}
	else if (schema.entity.properties[property].hasOwnProperty('$ref')) {
		delete schema.entity.properties[property];
	}
});

this.schema = schema.entity;
this.links = employeeCollection.entity._links;
return employeeCollection;</code></pre>
</div>
</div>
<div class="paragraph">
<p>此代码修剪掉URI关系以及$ ref条目。</p>
</div>
</div>
<div class="sect2">
<h3 id="_trapping_for_unauthorized_access">诱捕未经授权的访问</h3>
<div class="paragraph">
<p>在后端配置了安全检查之后，添加一个处理程序，以防有人尝试未经授权而更新记录：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">onUpdate(employee, updatedEmployee) {
	if(employee.entity.manager.name === this.state.loggedInManager) {
		updatedEmployee["manager"] = employee.entity.manager;
		client({
			method: 'PUT',
			path: employee.entity._links.self.href,
			entity: updatedEmployee,
			headers: {
				'Content-Type': 'application/json',
				'If-Match': employee.headers.Etag
			}
		}).done(response =&gt; {
			/* Let the websocket handler update the state */
		}, response =&gt; {
			if (response.status.code === 403) {
				alert('ACCESS DENIED: You are not authorized to update ' +
					employee.entity._links.self.href);
			}
			if (response.status.code === 412) {
				alert('DENIED: Unable to update ' + employee.entity._links.self.href +
					'. Your copy is stale.');
			}
		});
	} else {
		alert("You are not authorized to update");
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您有捕获HTTP 412错误的代码。这将捕获HTTP 403状态代码并提供适当的警报。</p>
</div>
<div class="paragraph">
<p>对删除操作执行相同的操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">onDelete(employee) {
	client({method: 'DELETE', path: employee.entity._links.self.href}
	).done(response =&gt; {/* let the websocket handle updating the UI */},
	response =&gt; {
		if (response.status.code === 403) {
			alert('ACCESS DENIED: You are not authorized to delete ' +
				employee.entity._links.self.href);
		}
	});
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这与定制的错误消息类似地编码。</p>
</div>
</div>
<div class="sect2">
<h3 id="_add_some_security_details_to_the_ui">向用户界面添加一些安全细节</h3>
<div class="paragraph">
<p>冠上该版本应用程序的最后一件事是显示登录者以及通过添加此新按钮来提供注销按钮<code><div></code>在index.html文件之前<code>react</code><code><div></code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;div&gt;
    Hello, &lt;span id="managername" th:text="${#authentication.name}"&gt;user&lt;/span&gt;.
    &lt;form th:action="@{/logout}" method="post"&gt;
        &lt;input type="submit" value="Log Out"/&gt;
    &lt;/form&gt;
&lt;/div&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_putting_it_all_together_4">放在一起</h3>
<div class="paragraph">
<p>通过前端中的这些更改，重新启动应用程序并导航到<a href="http://localhost:8080" class="bare">http：// localhost：8080</a> 。</p>
</div>
<div class="paragraph">
<p>您将立即重定向到登录表单。该表格由Spring Security提供，不过您可以根据需要<a href="https://spring.io/guides/gs/securing-web/">创建自己的</a>表格。以greg / turnquist登录。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://github.com/spring-guides/tut-react-and-spring-data-rest/raw/master/security/images/security-1.png" alt="安全1">
</div>
</div>
<div class="paragraph">
<p>您可以看到新添加的管理员列。浏览几页，直到找到由<strong>Oliver</strong>拥有的雇员。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://github.com/spring-guides/tut-react-and-spring-data-rest/raw/master/security/images/security-2.png" alt="安全2">
</div>
</div>
<div class="paragraph">
<p>单击<strong>更新</strong> ，进行一些更改，然后单击<strong>更新</strong> 。它应该失败，并显示以下弹出窗口：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://github.com/spring-guides/tut-react-and-spring-data-rest/raw/master/security/images/security-3.png" alt="安全3">
</div>
</div>
<div class="paragraph">
<p>如果尝试<strong>Delete</strong> ，它将失败并显示类似消息。创建一个新员工，应将其分配给您。</p>
</div>
</div>
<div class="sect2">
<h3 id="_review_5">评论</h3>
<div class="paragraph">
<p>在这个部分：</p>
</div>
<div class="ulist">
<ul>
<li> <p>您定义了经理模型，并通过一对多关系将其链接到员工。</p> </li>
<li> <p>您为经理创建了一个存储库，并告诉Spring Data REST不要导出。</p> </li>
<li> <p>您为empoyee存储库编写了一组访问规则，还编写了安全策略。</p> </li>
<li> <p>您编写了另一个Spring Data REST事件处理程序，以在创建事件发生之前捕获它们，以便可以将当前用户分配为员工的经理。</p> </li>
<li> <p>您更新了UI，以显示员工的经理，并且在采取未经授权的操作时还显示错误弹出窗口。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>有问题吗？</p>
</div>
<div class="paragraph">
<p>该网页已变得非常复杂。但是，如何管理关系和内联数据呢？创建/更新对话框并不十分适合。它可能需要一些自定义的书面形式。</p>
</div>
<div class="paragraph">
<p>经理有权访问员工数据。员工应该有访问权限吗？如果要添加更多详细信息，例如电话号码和地址，您将如何建模？您将如何授予员工访问系统的权限，以便他们可以更新那些特定字段？是否还有其他易于在页面上放置的超媒体控件？</p>
</div>
<div class="paragraph">
<p>是否要编写新指南或为现有指南做出贡献？查看我们的<a href="https://github.com/spring-guides/getting-started-guides/wiki">贡献准则</a> 。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-important" title="重要"></i> </td>
<td class="content">所有指南均以代码的ASLv2许可证和写作的<a href="https://creativecommons.org/licenses/by-nd/3.0/">Attribution，NoDerivatives创作共用许可证发布</a> 。</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div>
</div></article>
</div>
 <aside class="span4 content-right-pane--container mobile-left-pane" id="sidebar">
<a class="ci-status desktop-only" href="https://travis-ci.org/spring-guides/tut-react-and-spring-data-rest">
<img src="https://travis-ci.org/spring-guides/tut-react-and-spring-data-rest.svg?branch=master">
</a>
<div class="right-pane-widget--container desktop-only">
<div class="github-actions https">
<h2>获取代码</h2>
<div class="btn-group">
<button class="btn" data-protocol="https">HTTPS</button>
<button class="btn" data-protocol="ssh">SSH协议</button>
</div>
<div class="clone-url https">
<input id="clone-url-https" type="text" value="https://github.com/spring-guides/tut-react-and-spring-data-rest.git" readonly>
<button class="copy-button github" data-toggle="tooltip" data-clipboard-text="https://github.com/spring-guides/tut-react-and-spring-data-rest.git"></button>
</div>
<div class="clone-url ssh">
<input id="clone-url-ssh" type="text" value="git@github.com：spring-guides / tut-react-and-spring-data-rest.git" readonly>
<button class="copy-button github" data-toggle="tooltip" data-clipboard-text="git@github.com:spring-guides/tut-react-and-spring-data-rest.git"></button>
</div>
<a class="github_download btn btn-black uppercase" href="https://github.com/spring-guides/tut-react-and-spring-data-rest/archive/master.zip">下载ZIP</a> <a class="gs-guide-import" href="https://github.com/spring-guides/tut-react-and-spring-data-rest.git">导入STS</a>
<div class="go-to-repo--container">
<a href="https://github.com/spring-guides/tut-react-and-spring-data-rest"><i class="icon-github"></i>去回购</a>
</div>
<div class="go-to-repo--container">
</div>
</div>
</div>
<div class="right-pane-widget--container">
<div>
<h3><a class="anchor" href="#table-of-contents" name="table-of-contents"></a>目录</h3>
<div><ul class="sectlevel1">
<li><a href="#react-and-spring-data-rest-part-1">第1部分-基本功能</a> </li>
<li><a href="#react-and-spring-data-rest-part-2">第2部分-超媒体控件</a> </li>
<li><a href="#react-and-spring-data-rest-part-3">第3部分-条件运算</a> </li>
<li><a href="#react-and-spring-data-rest-part-4">第四部分-活动</a> </li>
<li><a href="#react-and-spring-data-rest-part-5">第5部分-保护UI和API</a> </li>
</ul></div>
</div>
</div>
</aside>
</div>
</main>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
<script src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js" data-cfasync="false"></script></body></html>