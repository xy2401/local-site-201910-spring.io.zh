<html dir="ltr" data-clipboard-buttons="" data-code-prettify="" data-code-sidebar="" data-hide-show-guide="" data-sts-import="" data-mobile-support="" data-search="" xmlns:th="https://www.thymeleaf.org"><head>
<title>教程·React.js和Spring Data REST</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>System.config({baseURL: "/b92013b"});</script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>System.import('app/main.js')</script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link rel="stylesheet" type="text/css" href="/css/gsguide-cce08ab7a9f46db88819a14148e45bad.css">

<meta property="og:title" content="React.js and Spring Data REST">
<meta property="og:image" content="/img/spring-by-pivotal-9066b55828deb3c10e27e609af322c40.png">
<meta property="og:description" content="this tutorial is designed to be completed in 2-3 hours, it provides deeper, in-context explorations of enterprise application development topics, leaving you ready to implement real-world solutions.">
</head>
<body dir="ltr">

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">// Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }</script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link active">
<a href="/guides">导游</a>
</li>
<li class="navbar-link">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<main class="main-body--wrapper">
<div class="row-fluid">
<div class="span8 mobile-left-pane">
<div class="content--title desktop-only">讲解</div>
<article class="content--container">
<h1 class="title">React.js和Spring Data REST</h1>
<div class="article-body"><div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>本教程展示了一系列使用Spring Data REST的应用程序，其强大的后端功能与React的先进功能相结合，以构建易于使用的UI。</p>
</div>
<div class="ulist">
<ul>
<li> <p><a href="https://www.youtube.com/watch?v=TgCr7v9tdKM">Spring Data REST</a>提供了一种构建基于超媒体的存储库的快速方法。</p> </li>
<li> <p><a href="https://facebook.github.io/react/index.html">React</a>是Facebook在JavaScript领域中对高效，快速且易于使用的视图的解决方案。</p> </li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="react-and-spring-data-rest-part-1">第1部分-基本功能</h2>
<div class="sectionbody">
<div class="paragraph">
<p>欢迎春季社区，</p>
</div>
<div class="paragraph">
<p>在本部分中，您将看到如何快速启动并运行Spring Data REST应用程序。然后，您将使用Facebook的React.js工具集在其之上构建一个简单的UI。</p>
</div>
<div class="sect2">
<h3 id="_step_0_setting_up_your_environment">步骤0-设定您的环境</h3>
<div class="paragraph">
<p>随时从该存储库中<a href="https://github.com/spring-guides/tut-react-and-spring-data-rest/tree/master/basic">获取代码</a>并继续。</p>
</div>
<div class="paragraph">
<p>如果您想自己做，请访问<a href="https://start.spring.io" class="bare">https://start.spring.io</a>并选择以下项目：</p>
</div>
<div class="ulist">
<ul>
<li> <p>其余资料库</p> </li>
<li> <p>胸腺</p> </li>
<li> <p>JPA</p> </li>
<li> <p>H2</p> </li>
</ul>
</div>
<div class="paragraph">
<p>该演示使用Java 8，Maven项目和Spring Boot的最新稳定版本。它还使用<a href="http://es6-features.org/">ES6中</a>编码的React.js。这将为您提供一个干净，空的项目。从那里，您可以添加本节中明确显示的各种文件，和/或从上面列出的存储库中借用。</p>
</div>
</div>
<div class="sect2">
<h3 id="_in_the_beginning">一开始...</h3>
<div class="paragraph">
<p>最初有数据。很好。但是后来人们想要通过各种方式访问数据。多年来，人们将许多MVC控制器拼凑在一起，其中许多都使用了Spring强大的REST支持。但是一遍又一遍地花费很多时间。</p>
</div>
<div class="paragraph">
<p>如果做一些假设，Spring Data REST解决了这个问题有多简单：</p>
</div>
<div class="ulist">
<ul>
<li> <p>开发人员使用支持存储库模型的Spring Data项目。</p> </li>
<li> <p>该系统使用公认的行业标准协议，例如HTTP动词，标准化媒体类型和IANA批准的链接名称。</p> </li>
</ul>
</div>
<div class="sect3">
<h4 id="_declaring_your_domain">声明您的域名</h4>
<div class="paragraph">
<p>任何基于Spring Data REST的应用程序的基石都是领域对象。对于此部分，您将构建一个应用程序来跟踪公司的员工。通过创建如下数据类型来开始：</p>
</div>
<div class="listingblock">
<div class="title">src / main / java / com / greglturnquist / payroll / Employee.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity
public class Employee {

	private @Id @GeneratedValue Long id;
	private String firstName;
	private String lastName;
	private String description;

	private Employee() {}

	public Employee(String firstName, String lastName, String description) {
		this.firstName = firstName;
		this.lastName = lastName;
		this.description = description;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;
		Employee employee = (Employee) o;
		return Objects.equals(id, employee.id) &&
			Objects.equals(firstName, employee.firstName) &&
			Objects.equals(lastName, employee.lastName) &&
			Objects.equals(description, employee.description);
	}

	@Override
	public int hashCode() {

		return Objects.hash(id, firstName, lastName, description);
	}

	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public String getFirstName() {
		return firstName;
	}

	public void setFirstName(String firstName) {
		this.firstName = firstName;
	}

	public String getLastName() {
		return lastName;
	}

	public void setLastName(String lastName) {
		this.lastName = lastName;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	@Override
	public String toString() {
		return "Employee{" +
			"id=" + id +
			", firstName='" + firstName + '\'' +
			", lastName='" + lastName + '\'' +
			", description='" + description + '\'' +
			'}';
	}
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li> <p><code>@Entity</code>是一个JPAannotation，它表示要存储在关系表中的整个类。</p> </li>
<li> <p><code>@Id</code>和<code>@GeneratedValue</code>是JPA注释，用于记录主键，并在需要时自动生成。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>该实体用于跟踪员工信息。在这种情况下，其名称和职位描述。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">Spring Data REST不仅限于JPA。它支持许多NoSQL数据存储，但是您将不在这里介绍。</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_defining_the_repository">定义存储库</h3>
<div class="paragraph">
<p>Spring Data REST应用程序的另一个关键部分是创建相应的存储库定义。</p>
</div>
<div class="listingblock">
<div class="title">src / main / java / com / greglturnquist / payroll / EmployeeRepository.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public interface EmployeeRepository extends CrudRepository<Employee, Long> {

}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li> <p>该存储库扩展了Spring Data Commons的<code>CrudRepository</code>并插入了域对象的类型及其主键</p> </li>
</ul>
</div>
<div class="paragraph">
<p>这就是所需要的！实际上，如果它是顶级且可见的，则您甚至不必注释它。如果您使用自己的IDE并打开<code>CrudRepository</code> ，则会发现一个拳头充满了已定义的预构建方法。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">您可以根据需要定义<a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.definition">自己的存储库</a> 。Spring Data REST也支持这一点。</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_pre_loading_the_demo">预加载演示</h3>
<div class="paragraph">
<p>要使用此应用程序，您需要使用以下数据预先加载它：</p>
</div>
<div class="listingblock">
<div class="title">src / main / java / com / greglturnquist / payroll / DatabaseLoader.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Component
public class DatabaseLoader implements CommandLineRunner {

	private final EmployeeRepository repository;

	@Autowired
	public DatabaseLoader(EmployeeRepository repository) {
		this.repository = repository;
	}

	@Override
	public void run(String... strings) throws Exception {
		this.repository.save(new Employee("Frodo", "Baggins", "ring bearer"));
	}
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li> <p>此类使用Spring的<code>@Component</code>annotation标记，以便由<code>@SpringBootApplication</code>自动拾取。</p> </li>
<li> <p>它实现了Spring启动的<code>CommandLineRunner</code>因此要创建并注册所有的豆子之后，它被运行。</p> </li>
<li> <p>它使用构造函数注入和自动装配来获取Spring Data的自动创建的<code>EmployeeRepository</code> 。</p> </li>
<li> <p>使用命令行参数调用<code>run()</code>方法，以加载数据。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>Spring Data最大，最强大的功能之一就是它能够为您编写JPA查询。这不仅减少了您的开发时间，而且降低了错误和错误的风险。Spring Data在存储库类中<a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.details">查看方法的名称，</a>并指出所需的操作，包括保存，删除和查找。</p>
</div>
<div class="paragraph">
<p>这就是我们可以编写一个空接口并继承已建立的保存，查找和删除操作的方式。</p>
</div>
</div>
<div class="sect2">
<h3 id="_adjusting_the_root_uri">调整根URI</h3>
<div class="paragraph">
<p>默认情况下，Spring Data REST在<code>/</code>处托管链接的根集合。因为您将在同一路径上托管Web UI，所以需要更改根URI。</p>
</div>
<div class="listingblock">
<div class="title">src / main / resources / application.properties</div>
<div class="content">
<pre>spring.data.rest.base-path=/api</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_launching_the_backend">启动后端</h3>
<div class="paragraph">
<p>使完全可操作的REST API可用的最后一步是使用Spring Boot编写一个<code>public static void main</code> ：</p>
</div>
<div class="listingblock">
<div class="title">src / main / java / com / greglturnquist / payroll / ReactAndSpringDataRestApplication.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
public class ReactAndSpringDataRestApplication {

	public static void main(String[] args) {
		SpringApplication.run(ReactAndSpringDataRestApplication.class, args);
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>假设以前的类以及您的Maven构建文件是从<a href="https://start.spring.io" class="bare">https://start.spring.io</a>生成的，那么您现在可以通过在IDE中运行<code>main()</code>方法或键入<code>./mvnw spring-boot:run</code>在命令行上<code>./mvnw spring-boot:run</code> 。 （对于Windows用户，为mvnw.bat）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">如果您不了解最新的Spring Boot及其工作原理，则应考虑观看<a href="https://www.youtube.com/watch?v=sbPSjI4tt10">Josh Long的介绍性演示之一</a> 。做到了？按下！</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_touring_your_rest_service">游览您的REST服务</h3>
<div class="paragraph">
<p>随着应用程序的运行，您可以使用<a href="https://curl.haxx.se/">cURL</a> （或您喜欢的任何其他工具）在命令行中检出内容。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl localhost:8080/api
{
  "_links" : {
    "employees" : {
      "href" : "http://localhost:8080/api/employees"
    },
    "profile" : {
      "href" : "http://localhost:8080/api/profile"
    }
  }
}</pre>
</div>
</div>
<div class="paragraph">
<p>当您对根节点执行ping操作时，您将获得包装在<a href="http://stateless.co/hal_specification.html">HAL格式的JSON文档中</a>的链接集合。</p>
</div>
<div class="ulist">
<ul>
<li> <p><strong>_links</strong>是可用链接的集合。</p> </li>
<li> <p><strong>employee</strong>指向<code>EmployeeRepository</code>接口定义的雇员对象的聚合根。</p> </li>
<li> <p><strong>配置文件</strong>是IANA标准的关系，指向有关整个服务的可发现元数据。我们将在后面的部分中对此进行探讨。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>您可以通过导航<strong>员工</strong>链接来进一步研究该服务。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl localhost:8080/api/employees
{
  "_embedded" : {
    "employees" : [ {
      "firstName" : "Frodo",
      "lastName" : "Baggins",
      "description" : "ring bearer",
      "_links" : {
        "self" : {
          "href" : "http://localhost:8080/api/employees/1"
        }
      }
    } ]
  }
}</pre>
</div>
</div>
<div class="paragraph">
<p>在此阶段，您正在查看整个员工集合。</p>
</div>
<div class="paragraph">
<p>随您先前预加载的数据一起提供的是带有<strong>自我</strong>链接的<strong>_links</strong>属性。这是该特定员工的规范链接。什么是规范的？这意味着没有上下文。例如，可以通过/ api / orders / 1 / processor之类的链接来提取同一用户，在该链接中，员工被分配处理特定的订单。在这里，与其他实体没有关系。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-important" title="重要"></i> </td>
<td class="content">链接是REST的重要方面。它们提供了导航到相关项目的功能。这样，其他各方就可以浏览您的API，而不必每次更改时都进行重写。当客户端硬代码访问资源时，客户端中的更新是一个常见问题。重组资源可能会导致代码发生重大变化。如果使用链接，而是维护导航路线，则进行此类调整变得容易且灵活。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>如果愿意，您可以决定查看一位员工。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl localhost:8080/api/employees/1
{
  "firstName" : "Frodo",
  "lastName" : "Baggins",
  "description" : "ring bearer",
  "_links" : {
    "self" : {
      "href" : "http://localhost:8080/api/employees/1"
    }
  }
}</pre>
</div>
</div>
<div class="paragraph">
<p>这里没有什么变化，只是因为只有域对象，所以不需要<strong>_embedded</strong>包装器。</p>
</div>
<div class="paragraph">
<p>很好，但是您可能很想创建一些新条目。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl -X POST localhost:8080/api/employees -d "{\"firstName\": \"Bilbo\", \"lastName\": \"Baggins\", \"description\": \"burglar\"}" -H "Content-Type:application/json"
{
  "firstName" : "Bilbo",
  "lastName" : "Baggins",
  "description" : "burglar",
  "_links" : {
    "self" : {
      "href" : "http://localhost:8080/api/employees/2"
    }
  }
}</pre>
</div>
</div>
<div class="paragraph">
<p>您还可以如<a href="https://spring.io/guides/gs/accessing-data-rest/">本相关指南中</a>所示进行PUT，PATCH和DELETE。但是，我们不要深入探讨这一点。您已经花费了太多时间手动与该REST服务进行交互。您是否不想构建一个光滑的UI？</p>
</div>
</div>
<div class="sect2">
<h3 id="_setting_up_a_custom_ui_controller">设置自定义UI控制器</h3>
<div class="paragraph">
<p>Spring Boot使站立自定义网页变得非常简单。首先，您需要一个Spring MVC控制器。</p>
</div>
<div class="listingblock">
<div class="title">src / main / java / com / greglturnquist / payroll / HomeController.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Controller
public class HomeController {

	@RequestMapping(value = "/")
	public String index() {
		return "index";
	}

}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li> <p><code>@Controller</code>将该类标记为Spring MVC控制器。</p> </li>
<li> <p><code>@RequestMapping</code>标记<code>index()</code>方法以支持<code>/</code>路由。</p> </li>
<li> <p>它返回<code>index</code>作为模板的名称，Spring Boot的自动配置的视图解析器将映射到<code>src/main/resources/templates/index.html</code> 。</p> </li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_defining_an_html_template">定义HTML模板</h3>
<div class="paragraph">
<p>您正在使用Thymeleaf，尽管您不会真正使用它的许多功能。</p>
</div>
<div class="listingblock">
<div class="title">src / main / resources / templates / index.html</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html"><!DOCTYPE html>
<html xmlns:th="https://www.thymeleaf.org">
<head lang="en">
    <meta charset="UTF-8"/>
    <title>ReactJS + Spring Data REST</title>
    <link rel="stylesheet" href="/main.css" />
</head>
<body>

    <div id="react"></div>

    <script src="built/bundle.js"></script>

</body>
</html></code></pre>
</div>
</div>
<div class="paragraph">
<p>此模板中的关键部分是<code><div id="react"></div></code></p><div id="react"></div>组件在中间。在这里，您将指示React插入渲染的输出。<p></p>
</div>
<div class="paragraph">
<p>您可能还想知道<code>bundle.js</code>文件的来源。下一部分将显示其构建方式。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-important" title="重要"></i> </td>
<td class="content">本教程未显示<code>main.css</code> ，但您可以在上方看到它的链接。说到CSS，Spring Boot会自动处理<code>src/main/resources/static</code>找到的任何内容。将您自己的<code>main.css</code>文件放在此处。它没有显示在教程中，因为我们的重点是React和Spring Data REST，而不是CSS3。</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_loading_javascript_modules">加载JavaScript模块</h3>
<div class="paragraph">
<p>本部分包含准系统信息，以帮助您摆脱JavaScript障碍。虽然你<em>可以</em>安装所有的JavaScript的命令行工具，你<em>不必</em> 。至少还没有。相反，您只需要向<code>pom.xml</code>构建文件添加以下内容：</p>
</div>
<div class="listingblock">
<div class="title">用于构建JavaScript位的<code>frontend-maven-plugin</code></div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml"><plugin>
	<groupId>com.github.eirslett</groupId>
	<artifactId>frontend-maven-plugin</artifactId>
	<version>1.6</version>
	<configuration>
		<installDirectory>target</installDirectory>
	</configuration>
	<executions>
		<execution>
			<id>install node and npm</id>
			<goals>
				<goal>install-node-and-npm</goal>
			</goals>
			<configuration>
				<nodeVersion>v10.11.0</nodeVersion>
				<npmVersion>6.4.1</npmVersion>
			</configuration>
		</execution>
		<execution>
			<id>npm install</id>
			<goals>
				<goal>npm</goal>
			</goals>
			<configuration>
				<arguments>install</arguments>
			</configuration>
		</execution>
		<execution>
			<id>webpack build</id>
			<goals>
				<goal>webpack</goal>
			</goals>
		</execution>
	</executions>
</plugin></code></pre>
</div>
</div>
<div class="paragraph">
<p>这个小插件执行多个步骤：</p>
</div>
<div class="ulist">
<ul>
<li> <p><code>install-node-and-npm</code>命令将把node.js及其程序包管理工具<code>npm</code>安装到<code>target</code>文件夹中。（这确保二进制文件不会在源代码控制下被拉出，并且可以使用<code>clean</code> ）。</p> </li>
<li> <p><code>npm</code>命令将使用提供的参数（ <code>install</code> ）执行npm二进制文件。这将安装<code>package.json</code>定义的模块。</p> </li>
<li> <p><code>webpack</code>命令将执行webpack二进制文件，该二进制文件将基于<code>webpack.config.js</code>编译所有JavaScript代码。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>这些步骤按顺序运行，实际上是安装node.js，下载JavaScript模块并构建JS位。</p>
</div>
<div class="paragraph">
<p>安装了哪些模块？JavaScript开发人员通常使用<code>npm</code>来构建<code>package.json</code>文件，如下所示：</p>
</div>
<div class="listingblock">
<div class="title">package.json</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">{
  "name": "spring-data-rest-and-reactjs",
  "version": "0.1.0",
  "description": "Demo of ReactJS + Spring Data REST",
  "repository": {
    "type": "git",
    "url": "<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="31565845715658455944531f525e5c">[email protected]</a>:spring-guides/tut-react-and-spring-data-rest.git"
  },
  "keywords": [
    "rest",
    "hateoas",
    "spring",
    "data",
    "react"
  ],
  "author": "Greg L. Turnquist",
  "license": "Apache-2.0",
  "bugs": {
    "url": "https://github.com/spring-guides/tut-react-and-spring-data-rest/issues"
  },
  "homepage": "https://github.com/spring-guides/tut-react-and-spring-data-rest",
  "dependencies": {
    "react": "^16.5.2",
    "react-dom": "^16.5.2",
    "rest": "^1.3.1"
  },
  "scripts": {
    "watch": "webpack --watch -d"
  },
  "devDependencies": {
    "@babel/core": "^7.1.0",
    "@babel/preset-env": "^7.1.0",
    "@babel/preset-react": "^7.0.0",
    "babel-loader": "^8.0.2",
    "webpack": "^4.19.1",
    "webpack-cli": "^3.1.0"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>关键依赖项包括：</p>
</div>
<div class="ulist">
<ul>
<li> <p>react.js-本教程使用的工具包</p> </li>
<li> <p>rest.js-用于进行REST调用的CujoJS工具包</p> </li>
<li> <p>webpack-用于将JavaScript组件编译为单个可加载包的工具包</p> </li>
<li> <p>babel-使用ES6编写JavaScript代码并将其编译为ES5以在浏览器中运行</p> </li>
</ul>
</div>
<div class="paragraph">
<p>为了进一步构建JavaScript代码，您需要为<a href="https://webpack.github.io/">webpack</a>定义一个构建文件。</p>
</div>
<div class="listingblock">
<div class="title">webpack.config.js</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">var path = require('path');

module.exports = {
    entry: './src/main/js/app.js',
    devtool: 'sourcemaps',
    cache: true,
    mode: 'development',
    output: {
        path: __dirname,
        filename: './src/main/resources/static/built/bundle.js'
    },
    module: {
        rules: [
            {
                test: path.join(__dirname, '.'),
                exclude: /(node_modules)/,
                use: [{
                    loader: 'babel-loader',
                    options: {
                        presets: ["@babel/preset-env", "@babel/preset-react"]
                    }
                }]
            }
        ]
    }
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>该webpack配置文件执行以下操作：</p>
</div>
<div class="ulist">
<ul>
<li> <p>将<strong>入口点</strong>定义为<code>./src/main/js/app.js</code> 。本质上， <code>app.js</code> （我们将很快编写的模块）是JavaScript应用程序中众所周知的<code>public static void main()</code> 。 webpack必须知道这一点，以便知道在浏览器加载最终捆绑包时要启动<em>什么</em> 。</p> </li>
<li> <p>创建<strong>源映射，</strong>以便在浏览器中调试JS代码时能够链接回原始源代码。</p> </li>
<li> <p>将所有JavaScript位编译为<code>./src/main/resources/static/built/bundle.js</code> ，这是与Spring Boot uber JAR等效的JavaScript。您所有的自定义代码和引入la <code>require()</code>调用的模块都被填充到此文件中。</p> </li>
<li> <p>它使用<code>es2015</code>和<code>react</code>预设连接到babel引擎，以便将ES6 React代码编译为可以在任何标准浏览器中运行的格式。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>有关每种JavaScript工具如何工作的更多详细信息，请阅读其相应的参考文档。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">是否想自动查看JavaScript更改？运行<code>npm run-script watch</code>以将webpack置于监视模式。当您编辑源代码时，它将重新生成bundle.js。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>完成所有操作后，您可以集中精力在加载DOM之后获取的React位。它分为以下部分：</p>
</div>
<div class="paragraph">
<p>由于您正在使用webpack进行组装，因此继续获取所需的模块：</p>
</div>
<div class="listingblock">
<div class="title">src / main / js / app.js</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">const React = require('react');
const ReactDOM = require('react-dom');
const client = require('./client');</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li> <p><code>React</code>和<code>ReactDOM</code>是Facebook用来构建此应用程序的主要库。</p> </li>
<li> <p><code>client</code>是自定义代码，用于配置rest.js以包括对HAL，URI模板等的支持。还将默认的<strong>接受</strong>请求标头设置为<strong>application / hal + json</strong> 。您可以<a href="https://github.com/spring-guides/tut-react-and-spring-data-rest/blob/master/basic/src/main/js/client.js">在此处阅读代码</a> 。</p> </li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-important" title="重要"></i> </td>
<td class="content">未显示<code>client</code>代码，因为您进行REST调用所用的内容并不重要。随时检查源代码，但是重点是，您可以插入Restangular或任何您喜欢的东西，并且概念仍然适用。</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_diving_into_react">潜入React</h3>
<div class="paragraph">
<p>React是基于定义组件的。通常，一个组件可以以父子关系保存另一个组件的多个实例。这个概念很容易扩展几层。</p>
</div>
<div class="paragraph">
<p>首先，为所有组件配备一个顶层容器非常方便。（随着您扩展本系列中的代码，这一点将变得更加明显。）现在，您只有雇员列表。但是稍后您可能需要其他一些相关组件，因此让我们从此开始：</p>
</div>
<div class="listingblock">
<div class="title">src / main / js / app.js-应用程序组件</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">class App extends React.Component {

	constructor(props) {
		super(props);
		this.state = {employees: []};
	}

	componentDidMount() {
		client({method: 'GET', path: '/api/employees'}).done(response => {
			this.setState({employees: response.entity._embedded.employees});
		});
	}

	render() {
		return (
			<EmployeeList employees={this.state.employees}/>
		)
	}
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li> <p><code>class Foo extends React.Component{…​}</code>是创建React组件的方法。</p> </li>
<li> <p><code>componentDidMount</code>是React在DOM中渲染组件后调用的API。</p> </li>
<li> <p><code>render</code>是在屏幕上“绘制”组件的API。</p> </li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">在React中，大写是组件命名的约定。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>在<strong>App</strong>组件中，从Spring Data REST后端获取一组雇员，并将其存储在该组件的<strong>状态</strong>数据中。</p>
</div>
<div id="NOTE" class="exampleblock">
<div class="content">
<div class="paragraph">
<p>React组件具有两种类型的数据： <strong>state</strong>和<strong>properties</strong> 。</p>
</div>
<div class="paragraph">
<p><strong>状态</strong>是组件期望自己处理的数据。也是可能波动和变化的数据。要读取状态，请使用<code>this.state</code> 。要更新它，请使用<code>this.setState()</code> 。每次调用<code>this.setState()</code> ，React都会更新状态，计算先前状态和新状态之间的差异，并在页面上对DOM注入一组更改。这样可以快速有效地更新您的UI。</p>
</div>
<div class="paragraph">
<p>通用约定是使用构造函数中所有属性为空的状态初始化状态。然后，您使用<code>componentDidMount</code>从服务器中查找数据并填充属性。从那里开始，更新可以由用户操作或其他事件来驱动。</p>
</div>
<div class="paragraph">
<p><strong>属性</strong>包含传递到组件中的数据。属性不会改变，而是固定值。要设置它们，您将在创建新组件时将它们分配给属性，您将很快看到。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-warning" title="警告"></i> </td>
<td class="content">JavaScript不会像其他语言一样锁定数据结构。您可以尝试通过分配值来颠覆属性，但这不适用于React的差分引擎，应避免使用。</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>在这段代码中，该函数通过<code>client</code> （一个<a href="https://promisesaplus.com/">Promise兼容</a>的rest.js实例）来加载数据。从<code>/api/employees</code>检索完成后，它会调用<code>done()</code>内部的函数，并根据其HAL文档（ <code>response.entity._embedded.employees</code> ）设置状态。您可能<a href="#_touring_your_rest_service">早些时候</a>记得<code>curl /api/employees</code>的结构，并了解它如何映射到该结构。</p>
</div>
<div class="paragraph">
<p>更新状态时，框架会调用<code>render()</code>函数。员工状态数据包含在创建<code><EmployeeList /></code>反应组件作为输入参数。</p>
</div>
<div class="paragraph">
<p>以下是<code>EmployeeList</code>的定义。</p>
</div>
<div class="listingblock">
<div class="title">src / main / js / app.js-EmployeeList组件</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">class EmployeeList extends React.Component{
	render() {
		const employees = this.props.employees.map(employee =>
			<Employee key={employee._links.self.href} employee={employee}/>
		);
		return (
			<table>
				<tbody>
					<tr>
						<th>First Name</th>
						<th>Last Name</th>
						<th>Description</th>
					</tr>
					{employees}
				</tbody>
			</table>
		)
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用JavaScript的map函数， <code>this.props.employees</code>从一组员工记录转换为一组<code><Element /></code> React组件（您将在后面看到一些内容）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript"><Employee key={employee._links.self.href} data={employee} /></code></pre>
</div>
</div>
<div class="paragraph">
<p>这显示了正在创建的新React组件（请注意大写格式）以及两个属性： <strong>key</strong>和<strong>data</strong> 。这些是从<code>employee._links.self.href</code>和<code>employee</code>中提供的值。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-important" title="重要"></i> </td>
<td class="content">每当您使用Spring Data REST时， <strong>自</strong>链接都是给定资源的关键。React需要一个用于子节点的唯一标识符，而<code>_links.self.href</code>是完美的。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>最后，您返回一个HTML表，该表围绕着使用映射构建的<code>employees</code>数组。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html"><table>
    <tr>
        <th>First Name</th>
        <th>Last Name</th>
        <th>Description</th>
    </tr>
    {employees}
</table></code></pre>
</div>
</div>
<div class="paragraph">
<p>状态，属性和HTML的这种简单布局显示了React如何使您以声明方式创建一个简单易懂的组件。</p>
</div>
<div id="NOTE" class="exampleblock">
<div class="content">
<div class="paragraph">
<p>此代码是否同时包含HTML <em>和</em> JavaScript？是的，这是<a href="https://facebook.github.io/jsx/">JSX</a> 。不需要使用它。React可以使用纯JavaScript编写，但是JSX语法非常简洁。由于对Babel.js的快速工作，翻译器同时提供了JSX和ES6支持</p>
</div>
<div class="paragraph">
<p>JSX还包含一些<a href="http://es6-features.org/#Constants">ES6</a> 。该代码中使用的一个是<a href="http://es6-features.org/#ExpressionBodies">箭头功能</a> 。它避免了创建一个嵌套函数（）有自己的作用域<strong>这一点</strong> ，避免了需要一个<a href="https://stackoverflow.com/a/962040/28214"><strong>自</strong>变量</a> 。</p>
</div>
<div class="paragraph">
<p>担心将逻辑与您的结构混合？React的API鼓励结合状态和属性的漂亮的声明式结构。React鼓励混合一些不相关的JavaScript和HTML，而不是混合使用一些无关的状态和属性，从而构建简单的组件。它使您可以查看单个组件并了解设计。然后它们很容易组合在一起形成更大的结构。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>接下来，您需要实际定义<code><Employee /></code>是。</p>
</div>
<div class="listingblock">
<div class="title">src / main / js / app.js-员工组件</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">class Employee extends React.Component{
	render() {
		return (
			<tr>
				<td>{this.props.employee.firstName}</td>
				<td>{this.props.employee.lastName}</td>
				<td>{this.props.employee.description}</td>
			</tr>
		)
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个组件非常简单。它有一个围绕员工的三个属性的HTML表行。财产本身就是<code>this.props.employee</code> 。请注意，传递JavaScript对象如何使传递从服务器获取的数据变得容易？</p>
</div>
<div class="paragraph">
<p>因为此组件不管理任何状态，也不处理用户输入，所以没有其他事情要做。这可能会诱使您将其塞入<code><EmployeeList /></code>之上。不要做！取而代之的是，将您的应用程序分解为各个小组件，每个组件都完成一项工作，这将使将来构建功能变得更加容易。</p>
</div>
<div class="paragraph">
<p>最后一步是渲染整个内容。</p>
</div>
<div class="listingblock">
<div class="title">src / main / js / app.js-呈现代码</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">ReactDOM.render(
	<App />,
	document.getElementById('react')
)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>React.render()</code>接受两个参数：您定义的React组件以及将其注入的DOM节点。记住你如何看待<code><div id="react"></div></code></p><div id="react"></div> HTML页面中较早的项目？这是它被拾起并插入的地方。<p></p>
</div>
<div class="paragraph">
<p>完成所有这些操作后，重新运行应用程序（ <code>./mvnw spring-boot:run</code> ）并访问<a href="http://localhost:8080" class="bare">http：// localhost：8080</a> 。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://github.com/spring-guides/tut-react-and-spring-data-rest/raw/master/basic/images/basic-1.png" alt="基本1">
</div>
</div>
<div class="paragraph">
<p>您可以看到系统加载的初始员工。</p>
</div>
<div class="paragraph">
<p>还记得使用cURL创建新条目吗？再做一次。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>curl -X POST localhost:8080/api/employees -d "{\"firstName\": \"Bilbo\", \"lastName\": \"Baggins\", \"description\": \"burglar\"}" -H "Content-Type:application/json"</pre>
</div>
</div>
<div class="paragraph">
<p>刷新浏览器，您应该看到新条目：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://github.com/spring-guides/tut-react-and-spring-data-rest/raw/master/basic/images/basic-2.png" alt="基本2">
</div>
</div>
<div class="paragraph">
<p>现在，您可以在网站上看到这两个列表。</p>
</div>
</div>
<div class="sect2">
<h3 id="_review">评论</h3>
<div class="paragraph">
<p>在这个部分：</p>
</div>
<div class="ulist">
<ul>
<li> <p>您定义了一个域对象和一个相应的存储库。</p> </li>
<li> <p>您让Spring Data REST通过功能强大的超媒体控件导出它。</p> </li>
<li> <p>您在父子关系中创建了两个简单的React组件。</p> </li>
<li> <p>您获取了服务器数据并将其呈现为简单的静态HTML结构。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>有问题吗？</p>
</div>
<div class="ulist">
<ul>
<li> <p>该网页不是动态的。您必须刷新浏览器才能获取新记录。</p> </li>
<li> <p>该网页未使用任何超媒体控件或元数据。相反，它被硬编码为从<code>/api/employees</code>获取数据。</p> </li>
<li> <p>它是只读的。尽管您可以使用cURL更改记录，但网页没有提供任何内容。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>这些是我们在下一节中可以解决的问题。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="react-and-spring-data-rest-part-2">第2部分-超媒体控件</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在上<a href="#react-and-spring-data-rest-part-1">一节中</a> ，您了解了如何使用Spring Data REST站起来使用后端薪资服务来存储员工数据。它缺少的一个关键功能是使用超媒体控件和按链接导航。相反，它对找到数据的路径进行了硬编码。</p>
</div>
<div class="paragraph">
<p>随时从该存储库中<a href="https://github.com/spring-guides/tut-react-and-spring-data-rest/tree/master/hypermedia">获取代码</a>并继续。本节基于上一节的应用程序，并添加了其他内容。</p>
</div>
<div class="sect2">
<h3 id="_in_the_beginning_there_was_dataand_then_there_was_rest">最初有数据...然后有RES​​T</h3>
<div class="quoteblock">
<blockquote>人们对将任何基于HTTP的接口称为REST API的人数感到沮丧。今天的示例是SocialSite REST API。那就是RPC。它尖叫着RPC ....在超文本是一个约束的概念上，需要采取什么措施才能使REST体系结构风格清晰明了？换句话说，如果应用程序状态的引擎（以及API）不是由超文本驱动的，则它不能是RESTful的，也不能是REST API。期。是否有一些需要修复的故障手册？
</blockquote>
<div class="attribution">—罗伊·菲尔丁（Roy T. Fielding）<br>
<cite>https://roy.gbiv.com/untangled/2008/rest-apis-must-be-超文本驱动</cite>
</div>
</div>
<div class="paragraph">
<p>那么，超媒体控件到底是什么，即超文本，又该如何使用它们呢？为了找出答案，让我们退后一步，看看REST的核心任务。</p>
</div>
<div class="paragraph">
<p>REST的概念是借用使网络如此成功的想法并将其应用于API。尽管网络规模庞大，动态特性大，而且客户端（即浏览器）的更新率较低，但网络却取得了惊人的成功。罗伊·菲尔丁（Roy Fielding）试图利用其一些约束和功能，看看是否能提供类似的API生产和消费量。</p>
</div>
<div class="paragraph">
<p>限制之一是限制动词的数量。对于REST，主要的是GET，POST，PUT，DELETE和PATCH。还有其他人，但我们不会在这里介绍。</p>
</div>
<div class="ulist">
<ul>
<li> <p>GET-在不更改系统的情况下获取资源状态</p> </li>
<li> <p>POST-创建新资源，而不用说</p> </li>
<li> <p>PUT-替换现有资源，覆盖现有资源（如果有的话）</p> </li>
<li> <p>删除-删除现有资源</p> </li>
<li> <p>PATCH-部分更改现有资源</p> </li>
</ul>
</div>
<div class="paragraph">
<p>这些是具有良好规范的标准化HTTP动词。通过选择并使用已经创造的HTTP操作，我们不必发明新的语言并教育行业。</p>
</div>
<div class="paragraph">
<p>REST的另一个限制是使用媒体类型来定义数据格式。与其每个人都写自己的方言来交换信息，不如发展一些媒体类型。最受欢迎的一种是HAL，媒体类型为application / hal + json。这是Spring Data REST的默认媒体类型。敏锐的价值在于，REST没有集中的单一媒体类型。相反，人们可以开发媒体类型并将其插入。试试看。随着不同需求的出现，行业可以灵活地移动。</p>
</div>
<div class="paragraph">
<p>REST的关键功能是包括指向相关资源的链接。例如，如果您正在查看订单，则RESTful API将包括到相关客户的链接，到商品目录的链接，以及到从其下订单的商店的链接。在本节中，您将介绍分页，并了解如何也使用导航分页链接。</p>
</div>
</div>
<div class="sect2">
<h3 id="_turning_on_paging_from_the_backend">从后端开启分页</h3>
<div class="paragraph">
<p>要开始使用前端超媒体控件，您需要打开一些额外的控件。Spring Data REST提供了页面支持。要使用它，只需调整存储库定义：</p>
</div>
<div class="listingblock">
<div class="title">src / main / java / com / greglturnquist / payroll / EmployeeRepository.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public interface EmployeeRepository extends PagingAndSortingRepository<Employee, Long> {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，您的界面扩展了<code>PagingAndSortingRepository</code> ，它添加了额外的选项来设置页面大小，还添加了导航链接以在页面之间跳转。后端的其余部分是相同的（一些<a href="https://github.com/spring-guides/tut-react-and-spring-data-rest/blob/master/hypermedia/src/main/java/com/greglturnquist/payroll/DatabaseLoader.java">额外的预加载数据</a>使事情变得有趣）。</p>
</div>
<div class="paragraph">
<p>重新启动应用程序（ <code>./mvnw spring-boot:run</code> ），然后查看其工作方式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl "localhost:8080/api/employees?size=2"
{
  "_links" : {
    "first" : {
      "href" : "http://localhost:8080/api/employees?page=0&size=2"
    },
    "self" : {
      "href" : "http://localhost:8080/api/employees"
    },
    "next" : {
      "href" : "http://localhost:8080/api/employees?page=1&size=2"
    },
    "last" : {
      "href" : "http://localhost:8080/api/employees?page=2&size=2"
    }
  },
  "_embedded" : {
    "employees" : [ {
      "firstName" : "Frodo",
      "lastName" : "Baggins",
      "description" : "ring bearer",
      "_links" : {
        "self" : {
          "href" : "http://localhost:8080/api/employees/1"
        }
      }
    }, {
      "firstName" : "Bilbo",
      "lastName" : "Baggins",
      "description" : "burglar",
      "_links" : {
        "self" : {
          "href" : "http://localhost:8080/api/employees/2"
        }
      }
    } ]
  },
  "page" : {
    "size" : 2,
    "totalElements" : 6,
    "totalPages" : 3,
    "number" : 0
  }
}</pre>
</div>
</div>
<div class="paragraph">
<p>默认页面大小是20，因此要查看它的实际效果， <code>?size=2</code>施加。不出所料，只列出了两名员工。此外，还有一个<strong>第一</strong> ， <strong>下一个</strong>和<strong>最后一个</strong>环节。也有<strong>自我</strong>链接，上下文<em>包括页面参数</em> 。</p>
</div>
<div class="paragraph">
<p>如果您导航到<strong>下一个</strong>环节，你会再看到<strong>上一个</strong>链接，以及：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl "http://localhost:8080/api/employees?page=1&size=2"
{
  "_links" : {
    "first" : {
      "href" : "http://localhost:8080/api/employees?page=0&size=2"
    },
    "prev" : {
      "href" : "http://localhost:8080/api/employees?page=0&size=2"
    },
    "self" : {
      "href" : "http://localhost:8080/api/employees"
    },
    "next" : {
      "href" : "http://localhost:8080/api/employees?page=2&size=2"
    },
    "last" : {
      "href" : "http://localhost:8080/api/employees?page=2&size=2"
    }
  },
...</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">在URL查询参数中使用“＆”时，命令行认为这是换行符。用引号引起来的整个URL绕过它。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>看起来很整洁，但是当您更新前端以利用它时，效果会更好。</p>
</div>
</div>
<div class="sect2">
<h3 id="_navigating_by_relationship">通过关系导航</h3>
<div class="paragraph">
<p>而已！后端不需要任何其他更改即可开始使用Spring Data REST提供的即用型超媒体控件。您可以切换到在前端工作。（这是Spring Data REST的优点所在。没有凌乱的控制器更新！）</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">需要指出的是，该应用程序不是“特定于Spring Data REST的”。而是使用<a href="http://stateless.co/hal_specification.html">HAL</a> ， <a href="https://tools.ietf.org/html/rfc6570">URI模板</a>和其他标准。这样就可以轻松使用rest.js：该库附带HAL支持。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>在上一节中，您将路径硬编码为<code>/api/employees</code> 。相反，您应该硬编码的唯一路径是根。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">...
var root = '/api';
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>有了一个方便的little <a href="https://github.com/spring-guides/tut-react-and-spring-data-rest/blob/master/hypermedia/src/main/js/follow.js"><code>follow()</code>函数</a> ，您现在可以从根目录开始并导航到需要的地方！</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">componentDidMount() {
	this.loadFromServer(this.state.pageSize);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上一节中，加载直接在<code>componentDidMount()</code>内部完成。在本节中，我们将在页面大小更新时重新加载整个员工列表。为此，我们已将内容移至<code>loadFromServer()</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">loadFromServer(pageSize) {
	follow(client, root, [
		{rel: 'employees', params: {size: pageSize}}]
	).then(employeeCollection => {
		return client({
			method: 'GET',
			path: employeeCollection.entity._links.profile.href,
			headers: {'Accept': 'application/schema+json'}
		}).then(schema => {
			this.schema = schema.entity;
			return employeeCollection;
		});
	}).done(employeeCollection => {
		this.setState({
			employees: employeeCollection.entity._embedded.employees,
			attributes: Object.keys(this.schema.properties),
			pageSize: pageSize,
			links: employeeCollection.entity._links});
	});
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>loadFromServer</code>与上一节非常相似，但是如果使用<code>follow()</code> ：</p>
</div>
<div class="ulist">
<ul>
<li> <p>follow（）函数的第一个参数是用于进行REST调用的<code>client</code>对象。</p> </li>
<li> <p>第二个参数是起始的根URI。</p> </li>
<li> <p>第三个参数是要导航的一系列关系。每个可以是字符串或对象。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>关系数组可以像<code>["employees"]</code>一样简单，这意味着在进行第一次调用时，请在<strong>_links中</strong>查找名为<strong>employee</strong>的关系（或<strong>rel</strong> ）。找到它的<strong>href</strong>并导航到它。如果阵列中存在其他关系，请冲洗并重复。</p>
</div>
<div class="paragraph">
<p>有时，仅靠依靠是不够的。在这段代码中，它还会插入查询参数<strong>？。大小= <pagesize></pagesize></strong> 。您还可以看到其他选项。</p>
</div>
</div>
<div class="sect2">
<h3 id="_grabbing_json_schema_metadata">抓取JSON模式元数据</h3>
<div class="paragraph">
<p>导航与基于尺寸的<strong>员工</strong>查询后<strong>，employeeCollection</strong>是在你的指尖。在上一节中，我们将其命名为day并将其显示在内部<code><EmployeeList /></code> 。今天，您将执行另一个调用以获取在<code>/api/profile/employees/</code>找到的一些<a href="https://json-schema.org/">JSON Schema元数据</a> 。</p>
</div>
<div class="paragraph">
<p>您可以自己查看数据：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl http://localhost:8080/api/profile/employees -H "Accept:application/schema+json"
{
  "title" : "Employee",
  "properties" : {
    "firstName" : {
      "title" : "First name",
      "readOnly" : false,
      "type" : "string"
    },
    "lastName" : {
      "title" : "Last name",
      "readOnly" : false,
      "type" : "string"
    },
    "description" : {
      "title" : "Description",
      "readOnly" : false,
      "type" : "string"
    }
  },
  "definitions" : { },
  "type" : "object",
  "$schema" : "https://json-schema.org/draft-04/schema#"
}</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">/ profile / employees中元数据的默认格式为ALPS。不过，在这种情况下，您正在使用内容协商来获取JSON模式。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>通过在中捕获此信息<app></app> `组件的状态，以后在构建输入表单时可以充分利用它。</p>
</div>
</div>
<div class="sect2">
<h3 id="creating-new-records">创建新记录</h3>
<div class="paragraph">
<p>有了此元数据，您现在可以向UI添加一些额外的控件。创建一个新的React组件， <code><CreateDialog /></code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">class CreateDialog extends React.Component {

	constructor(props) {
		super(props);
		this.handleSubmit = this.handleSubmit.bind(this);
	}

	handleSubmit(e) {
		e.preventDefault();
		const newEmployee = {};
		this.props.attributes.forEach(attribute => {
			newEmployee[attribute] = ReactDOM.findDOMNode(this.refs[attribute]).value.trim();
		});
		this.props.onCreate(newEmployee);

		// clear out the dialog's inputs
		this.props.attributes.forEach(attribute => {
			ReactDOM.findDOMNode(this.refs[attribute]).value = '';
		});

		// Navigate away from the dialog to hide it.
		window.location = "#";
	}

	render() {
		const inputs = this.props.attributes.map(attribute =>
			<p key={attribute}>
				<input type="text" placeholder={attribute} ref={attribute} className="field"/>
			</p>
		);

		return (
			<div>
				<a href="#createEmployee">Create</a>

				<div id="createEmployee" className="modalDialog">
					<div>
						<a href="#" title="Close" className="close">X</a>

						<h2>Create new employee</h2>

						<form>
							{inputs}
							<button onClick={this.handleSubmit}>Create</button>
						</form>
					</div>
				</div>
			</div>
		)
	}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个新组件同时具有<code>handleSubmit()</code>函数和预期的<code>render()</code>函数。</p>
</div>
<div class="paragraph">
<p>让我们以相反的顺序深入研究这些函数，然后首先看一下<code>render()</code>函数。</p>
</div>
<div class="sect3">
<h4 id="hypermedia-rendering">渲染图</h4>
<div class="paragraph">
<p>您的代码映射到<strong>attribute</strong>属性中找到的JSON Schema数据，并将其转换为<code><p><input></p></code></p><p><code><p><input></p></code></p>元素。<p></p>
</div>
<div class="ulist">
<ul>
<li> <p>React再次需要使用<strong>key</strong>来区分多个子节点。</p> </li>
<li> <p>这是一个简单的基于文本的输入字段。</p> </li>
<li> <p><strong>占位符</strong>是我们可以向用户显示字段的位置。</p> </li>
<li> <p>您可能曾经拥有过<strong>name</strong>属性，但这不是必需的。借助React， <strong>ref</strong>是获取特定DOM节点的机制（您将很快看到）。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>这代表了组件的动态特性，它是通过从服务器加载数据来驱动的。</p>
</div>
<div class="paragraph">
<p>在此组件的顶级内部<code><div></code></p><div></div>是一个锚标签，另一个<code><div></code> 。锚标记是打开对话框的按钮。和嵌套<code><div></code>是隐藏的对话框本身。在此示例中，您使用的是纯HTML5和CSS3。根本没有JavaScript！您可以<a href="https://github.com/spring-guides/tut-react-and-spring-data-rest/blob/master/hypermedia/src/main/resources/static/main.css">看到</a>用于显示/隐藏对话框<a href="https://github.com/spring-guides/tut-react-and-spring-data-rest/blob/master/hypermedia/src/main/resources/static/main.css">的CSS代码</a> 。我们不会在这里深入探讨。<p></p>
</div>
<div class="paragraph">
<p>坐落在里面<code><div id="createEmployee"></code></p><div id="createEmployee"></div>是一种表单，在其中注入了输入字段的动态列表，后跟“ <strong>创建”</strong>按钮。该按钮具有<code>onClick={this.handleSubmit}</code>事件处理程序。这是注册事件处理程序的React方法。<p></p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">React不会在每个DOM元素上创建大量事件处理程序。相反，它具有<a href="https://facebook.github.io/react/docs/interactivity-and-dynamic-uis.html#under-the-hood-autobinding-and-event-delegation">性能更高且更复杂的</a>解决方案。关键是您不必管理该基础结构，而可以专注于编写功能代码。</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_handling_user_input">处理用户输入</h4>
<div class="paragraph">
<p><code>handleSubmit()</code>函数首先停止事件在层次结构中冒泡。然后，它使用相同的JSON Schema属性属性来查找每个<code><input></code>使用<code>React.findDOMNode(this.refs[attribute])</code> 。</p>
</div>
<div class="paragraph">
<p><code>this.refs</code>是一种通过名称获取并获取特定React组件的方法。从这种意义上讲，您只能获得虚拟DOM组件。要获取实际的DOM元素，您需要使用<code>React.findDOMNode()</code> 。</p>
</div>
<div class="paragraph">
<p>每个输入迭代并建造后<code>newEmployee</code>对象，我们调用一个回调<code>onCreate()</code>的新员工。该函数位于<code>App.onCreate</code>内部，并作为另一个属性提供给此React组件。看一下顶层函数的工作方式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">onCreate(newEmployee) {
	follow(client, root, ['employees']).then(employeeCollection => {
		return client({
			method: 'POST',
			path: employeeCollection.entity._links.self.href,
			entity: newEmployee,
			headers: {'Content-Type': 'application/json'}
		})
	}).then(response => {
		return follow(client, root, [
			{rel: 'employees', params: {'size': this.state.pageSize}}]);
	}).done(response => {
		if (typeof response.entity._links.last !== "undefined") {
			this.onNavigate(response.entity._links.last.href);
		} else {
			this.onNavigate(response.entity._links.self.href);
		}
	});
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>再次，使用<code>follow()</code>函数导航到执行POST操作的<strong>员工</strong>资源。在这种情况下，不需要应用任何参数，因此基于字符串的rels数组很好。在这种情况下，将返回POST调用。这允许下一个<code>then()</code>子句处理POST的结果。</p>
</div>
<div class="paragraph">
<p>通常将新记录添加到数据集的末尾。由于您正在查看某个页面，因此合乎逻辑的是期望新员工记录不在当前页面上。要处理此问题，您需要获取应用了相同页面大小的一批新数据。该承诺将返回<code>done()</code>的final子句。</p>
</div>
<div class="paragraph">
<p>由于用户可能希望看到新创建的员工，因此您可以使用超媒体控件并导航到<strong>最后一个</strong>条目。</p>
</div>
<div class="paragraph">
<p>这在我们的UI中引入了分页的概念。让我们接下来解决这个问题！</p>
</div>
<div id="NOTE" class="exampleblock">
<div class="content">
<div class="paragraph">
<p>第一次使用基于承诺的API？<a href="https://promisesaplus.com/">承诺</a>是一种启动异步操作，然后注册一个函数以在任务完成时做出响应的方法。承诺被设计为链接在一起以避免“回调地狱”。请看以下流程：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">when.promise(async_func_call())
	.then(function(results) {
		/* process the outcome of async_func_call */
	})
	.then(function(more_results) {
		/* process the previous then() return value */
	})
	.done(function(yet_more) {
		/* process the previous then() and wrap things up */
	});</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关详细信息，请<a href="http://know.cujojs.com/tutorials/promises/consuming-promises">在承诺本教程</a> 。</p>
</div>
<div class="paragraph">
<p>使用promises要记住的秘密是， <code>then()</code>函数<em>需要</em>返回某个值，无论它是值还是另一个promise。 <code>done()</code>函数不返回任何东西，并且在它之后不链接任何东西。万一您还没有注意到， <code>client</code> （这是rest.js的<code>rest</code>一个实例）以及<code>follow</code>函数将返回promise。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_paging_through_data">分页数据</h3>
<div class="paragraph">
<p>您在后端设置分页，并且在创建新员工时已经开始利用它。</p>
</div>
<div class="paragraph">
<p>在<a href="#creating-new-records">上一节中</a> ，您使用了页面控件来跳至<strong>最后</strong>一页。动态地将其应用于UI并让用户根据需要进行导航将非常方便。根据可用的导航链接动态调整控件会很棒。</p>
</div>
<div class="paragraph">
<p>首先，让我们检查一下您使用的<code>onNavigate()</code>函数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">onNavigate(navUri) {
	client({method: 'GET', path: navUri}).done(employeeCollection => {
		this.setState({
			employees: employeeCollection.entity._embedded.employees,
			attributes: this.state.attributes,
			pageSize: this.state.pageSize,
			links: employeeCollection.entity._links
		});
	});
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是在顶部<code>App.onNavigate</code>内<code>App.onNavigate</code> 。同样，这是为了允许在顶部组件中管理UI的状态。将<code>onNavigate()</code>传递到<code><EmployeeList /></code> React组件，对以下处理程序进行了编码，以处理某些按钮上的单击：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">handleNavFirst(e){
	e.preventDefault();
	this.props.onNavigate(this.props.links.first.href);
}

handleNavPrev(e) {
	e.preventDefault();
	this.props.onNavigate(this.props.links.prev.href);
}

handleNavNext(e) {
	e.preventDefault();
	this.props.onNavigate(this.props.links.next.href);
}

handleNavLast(e) {
	e.preventDefault();
	this.props.onNavigate(this.props.links.last.href);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些函数中的每一个都会拦截默认事件并阻止其冒泡。然后，它使用适当的超媒体链接调用<code>onNavigate()</code>函数。</p>
</div>
<div class="paragraph">
<p>现在，根据哪些链接出现在<code>EmployeeList.render</code>的超媒体链接中，有条件地显示控件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">render() {
	const employees = this.props.employees.map(employee =>
		<Employee key={employee._links.self.href} employee={employee} onDelete={this.props.onDelete}/>
	);

	const navLinks = [];
	if ("first" in this.props.links) {
		navLinks.push(<button key="first" onClick={this.handleNavFirst}>&lt;&lt;</button>);
	}
	if ("prev" in this.props.links) {
		navLinks.push(<button key="prev" onClick={this.handleNavPrev}>&lt;</button>);
	}
	if ("next" in this.props.links) {
		navLinks.push(<button key="next" onClick={this.handleNavNext}>&gt;</button>);
	}
	if ("last" in this.props.links) {
		navLinks.push(<button key="last" onClick={this.handleNavLast}>&gt;&gt;</button>);
	}

	return (
		<div>
			<input ref="pageSize" defaultValue={this.props.pageSize} onInput={this.handleInput}/>
			<table>
				<tbody>
					<tr>
						<th>First Name</th>
						<th>Last Name</th>
						<th>Description</th>
						<th></th>
					</tr>
					{employees}
				</tbody>
			</table>
			<div>
				{navLinks}
			</div>
		</div>
	)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>与上一节一样，它仍将<code>this.props.employees</code>转换为一个数组<code><Element /></code>组件。然后，它构建了一个<code>navLinks</code>数组，一个HTML按钮数组。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">由于React是基于XML的，因此您不能将“ <”放在<code><button></code>元件。您必须改为使用编码版本。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>然后，您可以看到<code>{navLinks}</code>插入了返回的HTML的底部。</p>
</div>
</div>
<div class="sect2">
<h3 id="_deleting_existing_records">删除现有记录</h3>
<div class="paragraph">
<p>删除条目要容易得多。保留其基于HAL的记录，并将<strong>DELETE</strong>应用于其<strong>自身</strong>链接。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">class Employee extends React.Component {

	constructor(props) {
		super(props);
		this.handleDelete = this.handleDelete.bind(this);
	}

	handleDelete() {
		this.props.onDelete(this.props.employee);
	}

	render() {
		return (
			<tr>
				<td>{this.props.employee.firstName}</td>
				<td>{this.props.employee.lastName}</td>
				<td>{this.props.employee.description}</td>
				<td>
					<button onClick={this.handleDelete}>Delete</button>
				</td>
			</tr>
		)
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Employee组件的此更新版本在行末显示一个额外的条目，即一个删除按钮。它被注册以在单击时调用<code>this.handleDelete</code> 。然后， <code>handleDelete()</code>函数可以调用传递的回调，同时提供上下文重要的<code>this.props.employee</code>记录。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-important" title="重要"></i> </td>
<td class="content">这再次表明，最容易在一处管理顶部组件中的状态。情况并非<em>总是</em>如此，但是通常情况下，在一个地方管理状态可以更轻松，更简单地保持状态。通过使用特定于组件的详细信息（ <code>this.props.onDelete(this.props.employee)</code> ）调用回调，可以很轻松地协调组件之间的行为。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>将<code>onDelete()</code>函数追溯到<code>App.onDelete</code>的顶部，您可以看到其工作方式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">onDelete(employee) {
	client({method: 'DELETE', path: employee._links.self.href}).done(response => {
		this.loadFromServer(this.state.pageSize);
	});
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用基于页面的UI删除记录后要应用的行为有些棘手。在这种情况下，它将使用相同的页面大小从服务器重新加载整个数据。然后显示第一页。</p>
</div>
<div class="paragraph">
<p>如果要删除最后一页上的最后一条记录，它将跳到第一页。</p>
</div>
</div>
<div class="sect2">
<h3 id="_adjusting_the_page_size">调整页面大小</h3>
<div class="paragraph">
<p>查看超媒体的真正效果的一种方法是更新页面大小。Spring Data REST根据页面大小流畅地更新导航链接。</p>
</div>
<div class="paragraph">
<p><code>ElementList.render</code>的顶部有一个HTML元素：<code><input ref="pageSize" defaultValue={this.props.pageSize} onInput={this.handleInput}/></code> 。</p>
</div>
<div class="ulist">
<ul>
<li> <p><code>ref="pageSize"</code>使得通过this.refs.pageSize轻松获取该元素。</p> </li>
<li> <p><code>defaultValue</code>使用状态的<strong>pageSize</strong>对其进行初始化。</p> </li>
<li> <p><code>onInput</code>注册一个处理程序，如下所示。</p> </li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">handleInput(e) {
	e.preventDefault();
	const pageSize = ReactDOM.findDOMNode(this.refs.pageSize).value;
	if (/^[0-9]+$/.test(pageSize)) {
		this.props.updatePageSize(pageSize);
	} else {
		ReactDOM.findDOMNode(this.refs.pageSize).value =
			pageSize.substring(0, pageSize.length - 1);
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>它阻止事件冒泡。然后，它使用的<strong>ref</strong>属性<code><input></code>通过React的<code>findDOMNode()</code>帮助函数来查找DOM节点并提取其值。它通过检查输入是否为数字字符串来测试输入是否确实是数字。如果是这样，它将调用回调，将新的页面大小发送到<code>App</code> React组件。如果不是，则将刚刚输入的字符从输入中删除。</p>
</div>
<div class="paragraph">
<p><code>App</code>获取<code>updatePageSize()</code>时会做什么？看看这个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-javascript" data-lang="javascript">updatePageSize(pageSize) {
	if (pageSize !== this.state.pageSize) {
		this.loadFromServer(pageSize);
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于新的页面大小会导致所有导航链接的更改，因此最好重新获取数据并从头开始。</p>
</div>
</div>
<div class="sect2">
<h3 id="_putting_it_all_together">放在一起</h3>
<div class="paragraph">
<p>有了所有这些不错的添加，您现在已经拥有了一个非常完善的UI。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://github.com/spring-guides/tut-react-and-spring-data-rest/raw/master/hypermedia/images/hypermedia-1.png" alt="超媒体1">
</div>
</div>
<div class="paragraph">
<p>您可以在顶部看到页面大小设置，在每行上看到删除按钮，在底部看到导航按钮。导航按钮说明了超媒体控件的强大功能。</p>
</div>
<div class="paragraph">
<p>在下面，您可以看到带有元数据插入HTML输入占位符的<code>CreateDialog</code> 。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://github.com/spring-guides/tut-react-and-spring-data-rest/raw/master/hypermedia/images/hypermedia-2.png" alt="超媒体2">
</div>
</div>
<div class="paragraph">
<p>这确实显示了结合使用超媒体和域驱动的元数据（JSON模式）的强大功能。网页不必知道哪个字段是哪个字段。而是，用户可以<em>看到</em>它并知道如何使用它。如果将另一个字段添加到<code>Employee</code>域对象，此弹出窗口将自动显示它。</p>
</div>
</div>
<div class="sect2">
<h3 id="_review_2">评论</h3>
<div class="paragraph">
<p>在这个部分：</p>
</div>
<div class="ulist">
<ul>
<li> <p>您打开了Spring Data REST的分页功能。</p> </li>
<li> <p>您抛出了硬编码的URI路径，并开始使用结合了关系名称或“ rels”的根URI。</p> </li>
<li> <p>您更新了UI，以动态使用基于页面的超媒体控件。</p> </li>
<li> <p>您添加了创建和删除员工以及根据需要更新UI的功能。</p> </li>
<li> <p>您可以更改页面大小并灵活地响应UI。</p> </li>
</ul>
</div>
<div class="paragraph">
<p>有问题吗？</p>
</div>
<div class="paragraph">
<p>您使网页具有动态性。但是打开另一个浏览器选项卡，然后将其指向同一应用程序。一个标签中的更改不会更新另一个标签中的任何内容。</p>
</div>
<div class="paragraph">
<p>这是我们在下一节中可以解决的问题。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="react-and-spring-data-rest-part-3">第3部分-条件运算</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在上<a href="#react-and-spring-data-rest-part-2">一节中</a> ，您了解了如何打开Spring Data REST的超媒体控件，如何使UI通过分页导航以及根据更改页面大小来动态调整大小。您添加了创建和删除员工以及调整页面的功能。但是，要考虑到其他用户对您当前正在编辑的相同数据进行的更新，还没有一个完整的解决方案。</p>
</div>
<div class="paragraph">
<p>随时从该存储库中<a href="https://github.com/spring-guides/tut-react-and-spring-data-rest/tree/master/conditional">获取代码</a>并继续。本节基于上一节的应用程序，并添加了其他内容。</p>
</div>
<div class="sect2">
<h3 id="_to_put_or_not_to_put_that_is_the_question">要PUT还是不PUT，这就是问题</h3>
<div class="paragraph">
<p>当您获取资源时，如果其他人对其进行更新，则可能会过时。为了解决这个问题，Spring Data REST集成了两种技术：资源版本控制和ETag。</p>
</div>
<div class="paragraph">
<p>通过在后端对资源进行版本控制并在前端使用ETag，可以有意地将更改放入PUT。换句话说，您可以检测资源是否已更改，并防止PUT（或PATCH）踩到别人的更新。让我们来看看。</p>
</div>
</div>
<div class="sect2">
<h3 id="_versioning_rest_resources">REST资源版本控制</h3>
<div class="paragraph">
<p>要支持资源的版本控制，请为需要这种保护类型的域对象定义一个版本属性。</p>
</div>
<div class="listingblock">
<div class="title">src / main / java / com / greglturnquist / payroll / Employee.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Entity
public class Employee {

	private @Id @GeneratedValue Long id;
	private String firstName;
	private String lastName;
	private String description;

	private @Version @JsonIgnore Long version;

	private Employee() {}

	public Employee(String firstName, String lastName, String description) {
		this.firstName = firstName;
		this.lastName = lastName;
		this.description = description;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;
		Employee employee = (Employee) o;
		return Objects.equals(id, employee.id) &&
			Objects.equals(firstName, employee.firstName) &&
			Objects.equals(lastName, employee.lastName) &&
			Objects.equals(description, employee.description) &&
			Objects.equals(version, employee.version);
	}

	@Override
	public int hashCode() {

		return Objects.hash(id, firstName, lastName, description, version);
	}

	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public String getFirstName() {
		return firstName;
	}

	public void setFirstName(String firstName) {
		this.firstName = firstName;
	}

	public String getLastName() {
		return lastName;
	}

	public void setLastName(String lastName) {
		this.lastName = lastName;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public Long getVersion() {
		return version;
	}

	public void setVersion(Long version) {
		this.version = version;
	}

	@Override
	public String toString() {
		return "Employee{" +
			"id=" + id +
			", firstName='" + firstName + '\'' +
			", lastName='" + lastName + '\'' +
			", description='" + description + '\'' +
			", version=" + version +
			'}';
	}
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li> <p><strong>版本</strong>字段用<code>javax.persistence.Version</code></p><code>javax.persistence.Version</code></li><code>javax.persistence.Version</code></ul><code>javax.persistence.Version</code></div><code>javax.persistence.Version</code></div><code>javax.persistence.Version</code></div><code>javax.persistence.Version</code></div><code>javax.persistence.Version</code></div></article><code>javax.persistence.Version</code></div><code>javax.persistence.Version</code></div><code>javax.persistence.Version</code></main><code>javax.persistence.Version</code></div><code>javax.persistence.Version</code></div><code>javax.persistence.Version</code></body></html>