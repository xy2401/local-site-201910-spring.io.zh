<html  data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>Kafka流和Spring Cloud流</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Kafka Streams and Spring Cloud Stream">
<meta name="twitter:description" content="&lt;div class=" paragrap="="> 
 </head><body ><p>在最近宣布的Spring Cloud Stream <a href="https://spring.io/blog/2018/04/10/announcing-general-availability-of-spring-cloud-stream-elmhurst-release-2-0-0-release">Elmhurst之后。发布</a> ，我们很高兴提供另一篇博客文章，专门介绍Spring Cloud Stream与Apache Kafka Streams库的本机集成。让我们回顾一下新的改进。</p> 

<div class="sect2"> 
 <h3 id="messagechannel-binders"><a class="anchor" href="#messagechannel-binders"></a> MessageChannel绑定器</h3> 
 <div class="paragraph"> 
  <p>Spring Cloud Stream框架使应用程序开发人员能够编写事件驱动的应用程序，这些应用程序使用Spring Boot和Spring Integration的强大基础。所有这些的基础是活页夹实现，它负责应用程序和消息代理之间的通信。这些绑定器是基于<code>MessageChannel</code>的实现。</p> 
 </div> 
</div>“&gt; <meta name="twitter:creator" content="@sobychacko"><meta name="twitter:image:src" content="https://gravatar.com/avatar/08e6680212d29999e9fe53f1992470e7?s=200"><meta property="og:title" content="Kafka Streams and Spring Cloud Stream"><meta property="og:image" content="https://gravatar.com/avatar/08e6680212d29999e9fe53f1992470e7?s=200"><meta property="og:description" content="&lt;div class=" paragrap="="> 
 <p>在最近宣布的Spring Cloud Stream <a href="https://spring.io/blog/2018/04/10/announcing-general-availability-of-spring-cloud-stream-elmhurst-release-2-0-0-release">Elmhurst之后。发布</a> ，我们很高兴提供另一篇博客文章，专门介绍Spring Cloud Stream与Apache Kafka Streams库的本机集成。让我们回顾一下新的改进。</p> 

<div class="sect2"> 
 <h3 id="messagechannel-binders"><a class="anchor" href="#messagechannel-binders"></a> MessageChannel绑定器</h3> 
 <div class="paragraph"> 
  <p>Spring Cloud Stream框架使应用程序开发人员能够编写事件驱动的应用程序，这些应用程序使用Spring Boot和Spring Integration的强大基础。所有这些的基础是活页夹实现，它负责应用程序和消息代理之间的通信。这些绑定器是基于<code>MessageChannel</code>的实现。</p> 
 </div> 
</div>“&gt; <meta content="article" property="og:type"><meta property="og:article:published_time" content="2018-04-19 17:54:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Kafka流和Spring Cloud流</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/08e6680212d29999e9fe53f1992470e7?s=20&amp;d=mm"> <a class="author" rel="author" href="/team/sobychacko">索比·查克（Soby Chacko）</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2018-04-19 17:54:00.0">2018年4月19日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2018/04/19/kafka-streams-and-spring-cloud-stream#disqus_thread" data-disqus-identifier="3249">
</a></div>
</div>
</header>
<div class="blog--post"><div class="paragraph">
<p>在最近宣布的Spring Cloud Stream <a href="https://spring.io/blog/2018/04/10/announcing-general-availability-of-spring-cloud-stream-elmhurst-release-2-0-0-release">Elmhurst之后。发布</a> ，我们很高兴提供另一篇博客文章，专门介绍Spring Cloud Stream与Apache Kafka Streams库的本机集成。让我们回顾一下新的改进。</p>
</div>
<div class="sect2">
<h3 id="messagechannel-binders"><a class="anchor" href="#messagechannel-binders"></a> MessageChannel绑定器</h3>
<div class="paragraph">
<p>Spring Cloud Stream框架使应用程序开发人员能够编写事件驱动的应用程序，这些应用程序使用Spring Boot和Spring Integration的强大基础。所有这些的基础是活页夹实现，它负责应用程序和消息代理之间的通信。这些绑定器是基于<code>MessageChannel</code>的实现。</p>
</div>
</div>
<div class="sect2">
<h3 id="enter-kafka-streams-binder"><a class="anchor" href="#enter-kafka-streams-binder"></a>输入Kafka Streams活页夹</h3>
<div class="paragraph">
<p>从编程模型的角度来维护Spring Cloud Stream建立的合同时，Kafka Streams绑定程序不会将<code>MessageChannel</code>用作目标类型。活页夹实现与Kafka Streams“类型” <code>KStream</code>或<code>KTable</code>本地交互。应用程序可以直接使用Kafka Streams原语并充分利用Spring Cloud Stream和Spring生态系统。</p>
</div>
<div class="paragraph">
<p><strong>注意</strong> ：Kafka Streams联编程序不能代替使用库本身。</p>
</div>
</div>
<div class="sect2">
<h3 id="getting-started"><a class="anchor" href="#getting-started"></a>入门</h3>
<div class="paragraph">
<p>通过Spring Initializr快速生成带有Spring Cloud Stream Kafka Streams应用程序所需组件的项目的方法-参见下文。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://raw.githubusercontent.com/spring-cloud/spring-cloud-stream-binder-kafka/master/spring-cloud-stream-binder-kafka-docs/src/main/asciidoc/images/kafka-streams-initializr.png" alt="Kafka Streams Initializr">
</div>
</div>
</div>
<div class="sect2">
<h3 id="simple-example"><a class="anchor" href="#simple-example"></a>简单的例子</h3>
<div class="paragraph">
<p>这是一个用Spring Cloud Stream和Kafka Streams编写的简单单词计数应用程序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@EnableBinding(KafkaStreamsProcessor.class)
public static class WordCountProcessorApplication {

  @StreamListener("input")
  @SendTo("output")
  public KStream&lt;?, WordCount&gt; process(KStream&lt;Object, String&gt; input) {

     return input
           .flatMapValues(
              value -&gt; Arrays.asList(value.toLowerCase().split("\\W+")))
           .map((key, value) -&gt; new KeyValue&lt;&gt;(value, value))
           .groupByKey()
           .windowedBy(TimeWindows.of(5000)
                   .count(Materialized.as("wordcounts"))
           .toStream()
           .map((key, value) -&gt;
             new KeyValue&lt;&gt;(null, new WordCount(key.key(), value));
  }
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@EnableBinding</code>与注释<code>KafkaStreamsProcessor</code>传达给执行卡夫卡流靶标结合的框架。您也可以拥有带有多个“输入”和“输出”绑定的自己的接口。</p>
</li>
<li>
<p><code>@StreamListener</code>指示框架允许应用程序使用绑定到“输入”目标上的主题的事件作为<code>KStream</code> 。</p>
</li>
<li>
<p><code>process()</code> -一个处理程序，它从<code>KStream</code>接收包含文本数据的事件。业务逻辑对每个单词的数量进行计数，并在一个时间窗口（在这种情况下为5秒）内将总计数存储在状态存储中。生成的<code>KStream</code>在该时间窗口中包含单词及其对应的计数。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这是此示例的完整<a href="https://github.com/spring-cloud/spring-cloud-stream-samples/tree/master/kafka-streams-samples/kafka-streams-word-count">版本</a> 。</p>
</div>
<div class="paragraph">
<p><a href="https://spring.io/team/jlong">Josh Long</a> （ <a href="https://twitter.com/starbuxman?lang=en">@starbuxman</a> ）汇总了一个截屏视频，其中详细介绍了Kafka Streams绑定支持的各种功能。</p>
</div>
<div class="videoblock">
<div class="content">
<iframe width="640" height="300" src="https://www.youtube.com/embed/YPDzcmqwCNo?rel=0" frameborder="0" allowfullscreen=""></iframe>
</div>
</div>
</div>
<div class="sect2">
<h3 id="benefits"><a class="anchor" href="#benefits"></a>好处</h3>
<div class="ulist">
<ul>
<li>
<p>熟悉Spring Cloud Stream（例如， <code>@EnableBinding</code>和<code>@StreamListener</code> ）的开发人员可以使用Kafka Streams API将其扩展为构建有状态的应用程序。</p>
</li>
<li>
<p>开发人员可以利用框架的内容类型转换进行入站和出站转换，或者切换到Kafka提供的本机SerDe。</p>
</li>
<li>
<p>将现有的Kafka Streams工作负载移植到一个独立的云原生应用程序中，并能够使用Spring Cloud Data Flow将它们作为一致的数据管道进行编排。</p>
</li>
<li>
<p>应用程序按原样运行-不受任何云平台供应商的限制。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="features"><a class="anchor" href="#features"></a>特征</h3>
<div class="ulist">
<ul>
<li>
<p>Kafka Streams和Kafka活页夹的<code>MessageChannel</code>绑定之间的互操作性</p>
</li>
<li>
<p>多种Kafka Streams类型（例如<code>KStream</code>和<code>KTable</code> ）作为处理程序参数</p>
</li>
<li>
<p>入站和出站流的内容类型转换</p>
</li>
<li>
<p>属性切换以在框架和本机Kafka SerDe之间切换，以进行入站和出站消息转换</p>
</li>
<li>
<p>错误处理支持</p>
</li>
<li>
<p>死信队列（DLQ）支持反序列化错误中的记录</p>
</li>
<li>
<p>分支支持</p>
</li>
<li>
<p>交互式查询支持</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="multiple-output-bindings-aka-branching"><a class="anchor" href="#multiple-output-bindings-aka-branching"></a>多个输出绑定（又名分支）</h3>
<div class="paragraph">
<p>Kafka Streams活页夹可让您发送到多个输出主题（Kafka Streams中的分支API）。</p>
</div>
<div class="paragraph">
<p>这是这种方法的概述。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@StreamListener("input")
@SendTo({"output1","output2","output3"})
public KStream&lt;String, String&gt;[] process(KStream&lt;Object, String&gt; input) {
...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意，该方法的返回类型为<code>KStream[]</code> 。有关此工作原理的更多详细信息，请参见此<a href="https://github.com/spring-cloud/spring-cloud-stream-samples/tree/master/kafka-streams-samples/kafka-streams-branching">示例</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="multiple-input-bindings"><a class="anchor" href="#multiple-input-bindings"></a>多个输入绑定</h3>
<div class="paragraph">
<p>Kafka Streams绑定程序还允许您绑定到<code>KStream</code>和<code>KTable</code>目标类型的多个输入，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">  @StreamListener
  public void process(@Input("input") KStream&lt;String, PlayEvent&gt; playEvents,
                         @Input("inputX") KTable&lt;Long, Song&gt; songTable) {
...
   }</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意在方法参数列表上使用了多个输入。在这里，您可以看到两个<code>@Input</code>注释-一个用于<code>KStream</code> ，另一个用于<code>KTable</code> 。</p>
</div>
<div class="paragraph">
<p>这是此<a href="https://github.com/spring-cloud/spring-cloud-stream-samples/tree/master/kafka-streams-samples/kafka-streams-table-join">示例</a>的工作版本。</p>
</div>
</div>
<div class="sect2">
<h3 id="framework-content-type-vs-native-kafka-serde"><a class="anchor" href="#framework-content-type-vs-native-kafka-serde"></a>框架内容类型与本机Kafka SerDe</h3>
<div class="paragraph">
<p>与基于<code>MessageChannel</code>的活页夹实现类似，Kafka Streams活页夹还支持传入和传出流上的内容类型转换。任何其他类型的数据序列化完全由Kafka Streams本身处理。可以禁用框架提供的边缘内容类型转换。相反，您可以使用Kafka Streams提供的SerDe功能将职责完全委派给Kafka。</p>
</div>
<div class="paragraph">
<p>当依靠Kafka Streams绑定程序进行内容类型转换时，它仅适用于消息中的“值”（即有效负载）。“密钥”始终由Kafka SerDe转换。</p>
</div>
<div class="paragraph">
<p>请参阅<a href="https://docs.spring.io/spring-cloud-stream/docs/Elmhurst.RELEASE/reference/htmlsingle/#_message_conversion">文档</a>以获取有关如何在Kafka Streams绑定程序中解决内容类型协商和序列化的详细信息。</p>
</div>
</div>
<div class="sect2">
<h3 id="error-handling"><a class="anchor" href="#error-handling"></a>错误处理</h3>
<div class="paragraph">
<p>Kafka Streams库具有用于处理反序列化异常<a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-161%3A+streams+deserialization+exception+handlers">（KIP-161）的</a>内置支持。除了本机反序列化错误处理支持之外，Kafka Streams绑定程序还提供了将错误的有效负载路由到DLQ的支持。有关详细信息，请参见本<a href="https://docs.spring.io/spring-cloud-stream/docs/Elmhurst.RELEASE/reference/htmlsingle/#_error_handling">文档</a>部分。</p>
</div>
<div class="paragraph">
<p>这是一个<a href="https://github.com/spring-cloud/spring-cloud-stream-samples/tree/master/kafka-streams-samples/kafka-streams-dlq-sample">示例</a> ，演示了Kafka Streams绑定程序中的DLQ功能。</p>
</div>
</div>
<div class="sect2">
<h3 id="interactive-query"><a class="anchor" href="#interactive-query"></a>互动查询</h3>
<div class="paragraph">
<p>Kafka Streams使您可以从应用程序以交互方式查询状态存储，该状态存储可用于深入了解正在进行的流数据。Kafka Streams绑定程序API公开了一个名为<code>QueryableStoreRegistry</code>的类。您可以通过注入该bean（可能是通过自动装配）在应用程序中将其作为Spring bean进行访问，如以下示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Autowired
QueryableStoreRegistry queryableStoreRegistry;

ReadOnlyKeyValueStore&lt;Object, Object&gt; keyValueStore =
	queryableStoreRegistry.getQueryableStoreType("my-store",
                         QueryableStoreTypes.keyValueStore());</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是<a href="https://github.com/spring-cloud/spring-cloud-stream-samples/tree/master/kafka-streams-samples/kafka-streams-interactive-query-basic">基础</a>和<a href="https://github.com/spring-cloud/spring-cloud-stream-samples/tree/master/kafka-streams-samples/kafka-streams-interactive-query-advanced">高级</a>示例，它们通过活页夹演示了交互式查询功能。</p>
</div>
</div>
<div class="sect2">
<h3 id="mixing-kafka-streams-and-messagechannel-based-binders"><a class="anchor" href="#mixing-kafka-streams-and-messagechannel-based-binders"></a>混合Kafka流和基于MessageChannel的活页夹</h3>
<div class="paragraph">
<p>如果应用程序用例需要同时使用基于<code>MessageChannel</code>的Kafka绑定程序和Kafka Streams绑定程序，则它们都可以在同一应用程序中使用。在这种情况下，您可以具有多个<code>StreamListener</code>方法或源和接收器/处理器类型方法的组合。以下应用程序示例显示了如何使用多种<code>StreamListener</code>方法来定位各种类型的绑定：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@StreamListener("binding2")
@SendTo("output")
public KStream&lt;?, WordCount&gt; process(KStream&lt;Object, String&gt; input) {
}

@StreamListener("binding1")
public void sink(String input) {

}

interface MultipleProcessor {

	String BINDING_1 = "binding1";
	String BINDING_2 = "binding2";
	String OUTPUT = "output";

	@Input(BINDING_1)
	SubscribableChannel binding1();

	@Input(BINDING_2)
	KStream&lt;?, ?&gt; binding2();

	@Output(OUTPUT)
	KStream&lt;?, ?&gt; output();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此示例中，第一种方法是Kafka Streams处理器，第二种方法是基于常规<code>MessageChannel</code>的使用者。尽管您可以使用具有不同目标类型的多种方法（ <code>MessageChannel</code>与Kafka Stream类型），但是无法将两种方法混合在一个方法中。</p>
</div>
</div>
<div class="sect2">
<h3 id="conclusion"><a class="anchor" href="#conclusion"></a>结论</h3>
<div class="paragraph">
<p>在本文中，我们看到了通过Spring Cloud Stream Kafka Streams绑定程序公开的更高级别的构造和使用示例。除了允许使用基于Spring Cloud Stream的基于<code>MessageChannel</code>的绑定程序之外，此绑定程序实现还使我们能够一致地开发，测试和生成有状态的应用程序。</p>
</div>
<div class="paragraph">
<p>查看<a href="https://cloud.spring.io/spring-cloud-stream/">项目</a>页面和<a href="https://docs.spring.io/spring-cloud-stream/docs/Elmhurst.RELEASE/reference/htmlsingle/">文档</a> 。与往常一样，我们欢迎您提供反馈和意见，因此请访问<a href="https://github.com/spring-cloud/spring-cloud-stream-binder-kafka">GitHub</a> ， <a href="https://stackoverflow.com/tags/spring-cloud-stream">Stack Overflow</a>和<a href="https://gitter.im/spring-cloud/spring-cloud-stream">Gitter</a>与我们联系。</p>
</div>
</div></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 3249;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>