<html  data-code-prettify="" data-mobile-support="" data-search=""><head></head><body >﻿
<title>DDD引发的事件风暴和春天</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Event Storming and Spring with a Splash of DDD">
<meta name="twitter:description" content="<p>It is my pleasure to announce that I have just joined the developer advocacy team at Pivotal, focusing on Spring. I feel privileged to have the opportunity to learn and collaborate with great and passionate engineers from all over the world. Hence, I must say I am really excited for the upcoming journey.</p>
<p><em>If you would like to follow me, I tweet under</em> <a href=" https:="" ="" twitter.com="" jakubpilimo="="><em>@JakubPilimon</em> <em>and blog</em> <a href="http://pillopl.github.io"><em>here</em></a>.
<p>Before joining Pivotal, I have had the pleasure of consulting with and learning from software development teams across a variety of domains. Whether the domain is e-commerce, pharma, fintech, or insurance—common to all domains in software are <em>the expectations of users</em>. In this post I'm going to introduce some of my principles for building Spring applications with DDD.</p>
">
<meta name="twitter:creator" content="@JakubPilimon">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/55bc8e570d4038efca3c01daa2bb376c?s=200">

<meta property="og:title" content="Event Storming and Spring with a Splash of DDD">
<meta property="og:image" content="https://gravatar.com/avatar/55bc8e570d4038efca3c01daa2bb376c?s=200">
<meta property="og:description" content="<p>It is my pleasure to announce that I have just joined the developer advocacy team at Pivotal, focusing on Spring. I feel privileged to have the opportunity to learn and collaborate with great and passionate engineers from all over the world. Hence, I must say I am really excited for the upcoming journey.</p>
<p><em>If you would like to follow me, I tweet under</em> <a href=" https:="" ="" twitter.com="" jakubpilimo="="><em>@JakubPilimon</em> <em>and blog</em> <a href="http://pillopl.github.io"><em>here</em></a>.
<p>Before joining Pivotal, I have had the pleasure of consulting with and learning from software development teams across a variety of domains. Whether the domain is e-commerce, pharma, fintech, or insurance—common to all domains in software are <em>the expectations of users</em>. In this post I'm going to introduce some of my principles for building Spring applications with DDD.</p>
">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2018-04-11 21:01:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">DDD引发的事件风暴和春天</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/55bc8e570d4038efca3c01daa2bb376c?s=20&d=mm"> <a class="author" rel="author" href="/team/pilloPl">雅库布·皮利蒙（Jakub Pilimon）</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2018-04-11 21:01:00.0">2018年4月11日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2018/04/11/event-storming-and-spring-with-a-splash-of-ddd#disqus_thread" data-disqus-identifier="3247">
</a></div>
</div>
</header>
<div class="blog--post"><p>我很高兴地宣布，我刚刚加入Pivotal的开发人员倡导团队，专注于Spring。我很荣幸有机会与来自世界各地的优秀工程师一起学习和合作。因此，我必须说，我为即将到来的旅程感到非常兴奋。</p>
<p><em>如果您想关注我，我会在</em> <a href="https://twitter.com/JakubPilimon"><em>@JakubPilimon</em></a> <em>下</em> <a href="https://twitter.com/JakubPilimon"><em>发</em></a> <em>推文，</em> <em>并</em> <a href="https://pillopl.github.io"><em>在此处</em></a> <a href="https://twitter.com/JakubPilimon"><em>发布</em></a> <em>博客</em> 。</p>
<p>在加入Pivotal之前，我很荣幸能与各个领域的软件开发团队进行咨询和学习。<em>用户</em>对软件的所有领域都通用的领域是电子商务，制药，金融科技还是保险领域。在这篇文章中，我将介绍一些使用DDD构建Spring应用程序的原理。</p>
<p><em>在提高可靠性的同时更快地交付软件的原则</em> ：</p>
<ul>
<li><strong>理解</strong> -帮助团队了解并解决复杂的业务问题（所谓的“域”）与代表该问题的代码模型之间的差距。我遇到的最常见的问题是，找到用于生产的领域模型通常与领域专家的想法相去甚远。</li>
<li><strong>DIVIDE-在</strong>功能<strong>上将</strong>软件分解为模块。所谓模块，是指我们企业中任何独立的部门，可以是一个或多个部署单元。至关重要的是，每个模块都应作为独立的产品提供，以便我们可以应用不同的建筑风格。</li>
<li><strong>实施</strong> -通过将思维方式从整体式转变为分布式系统，从而实现向微服务的重构-或在不需要时<em>不鼓励</em>沿着这种方式前进！</li>
<li><strong>部署</strong> -通过增强对诸如<em>测试驱动开发</em> ， <em>持续集成</em>和<em>持续交付</em>等习惯的意识来改善交付过程</li>
<li><strong>创造价值</strong> -使用Spring Boot和Spring Cloud缩短交付业务价值所需的时间。使开发人员可以根据需要花费尽可能多的时间来了解业务领域本身。</li>
</ul>
<p><strong>领域建模</strong></p>
<p>当要了解您要为其构建软件的业务时，没有一种编程框架可以神奇地帮助我们理解和建模复杂的领域。我不希望这样的工具能够实现，因为通常无法预测这样一个领域在未来的发展和变化。但是，有些最常见的抽象业务领域应该最熟悉，例如<em>销售</em> ， <em>库存</em>或<em>产品目录</em> 。从头开始进行领域建模时，无需重新发明轮子。我为复杂的域建模推荐了一个很棒的资源： <a href="https://www.amazon.com/Enterprise-Patterns-MDA-Building-Archetype/dp/032111230X">企业模式和MDA：使用原型模式和UML构建更好的软件</a> 。</p>
<p><strong>了解，划分和持续征服</strong></p>
<p>在快速交付软件时，我们决不能牺牲以后其他人如何理解代码。幸运的是，我们以<em>域驱动设计</em>的形式提供了一系列的原则和实践来为我们提供帮助。就个人而言，我喜欢将DDD视为对未知事物进行迭代学习的过程。应用DDD的副作用是，我们能够使我们的代码对于开发人员和企业而言都更加易于理解，扩展和统一。使用DDD，可以使我们的源代码成为有关域应如何运行的唯一真实来源。软件功能将被更改。但是，当开发人员无法按照他们理解的术语向企业表达源代码时，该功能将成为装饰性的并且难以更改或替换。</p>
<p>甚至最复杂的领域也可以分为……</p>
<ul>
<li>较小但仍然非常复杂的子域（所谓的核心域）-这可能是我们企业最大的竞争优势，因此，我们在此投入了大量精力。</li>
<li>简单的和可理解的子域可能不是我们的企业所独有的（所谓的通用子域）-我们需要它们来使我们的企业运营，但它不会给我们的客户带来竞争优势。考虑<em>库存</em>或<em>发票。</em> 我们的用户不会再被最漂亮的发票所吸引。</li>
</ul>
<p>识别那些较小的产品为我们提供了如何将代码组织到模块中的初稿。每个子域都等于单独的模块。了解核心域和通用域之间的区别有助于我们了解它们可能需要不同的体系结构样式。</p>
<p>幸运的是， <a href="https://start.spring.io">我们可以选择</a>很多<a href="https://start.spring.io">成分</a> ！</p>
<p><strong>这个例子</strong></p>
<p>我很高兴在这个地方宣布，我和朋友<a href="https://twitter.com/michal_michaluk">MichałMichaluk</a>一起创建了一项名为#dddbyexamples的计划。该计划的目的是将Spring生态系统的许多不同部分与DDD爱好者的兴趣联系起来。您可以<a href="https://github.com/ddd-by-examples">在这里</a>检查我们的样品。到目前为止，有两个样本。一个示例关注事件源和命令查询责任隔离，而另一个关注于端到端DDD示例。两者都通过Spring Boot实现。</p>
<p>让我们深入研究端到端的示例。我们将实施简化的信用卡管理系统。我们将把工作分为理解，划分，实施和部署。要求尚不明确，到目前为止，我们知道该系统应该能够：</p>
<ul>
<li>为卡分配初始限制</li>
<li>提款</li>
<li>创建包含要偿还金额的对帐单（在结算周期结束时）</li>
<li>还钱</li>
<li>订购或更改个性化塑料卡</li>
</ul>
<p><strong>了解</strong></p>
<p>要了解业务问题的<strong>实质</strong> ，我们可以利用一种称为<a href="https://en.wikipedia.org/wiki/Event_storming">Event Storming</a>的轻量级技术。我们需要的是在宽阔的墙上无限的空间，便利贴以及业务和技术人员聚集在一个房间中。第一步是用橙色笔记写下我们的领域<strong>可能发生的事情</strong> 。这些是<strong>域事件。</strong> 注意过去时，没有特殊顺序。</p>
<p><img src="https://github.com/pilloPl/eventstorming-with-spring/blob/master/just-events.png?raw=true" alt="大事记"></p>
<p>然后，我们必须确定每个事件的原因。领域专家知道原因，很可能将其归类为：</p>
<ul>
<li>对系统的直接<strong>命令</strong> -事件旁的蓝色提示</li>
<li>另一个事件-在这种情况下，我们将这些事件并排放置</li>
<li>一段时间过去了-小字说<em>时间</em></li>
</ul>
<p><img src="https://github.com/pilloPl/eventstorming-with-spring/blob/master/events-and-causes.png?raw=true" alt="事件和命令"></p>
<p>还有一个绿色注释： <em>塑料卡个性化视图</em> 。它是直接发送给系统的消息，导致<em>塑料卡个性化显示</em>事件。但这是一个<strong>查询</strong> ，而不是命令。对于视图和读取模型，我们将使用绿色注释。</p>
<p>下一步至关重要。我们需要知道原因是否足以使域事件发生。也许还有另一个条件要满足。也许不止一个。这些条件称为<strong>不变式。</strong> 如果是这样，我们将其写下黄色笔记，并放在事件和原因之间。</p>
<p><img src="https://github.com/pilloPl/eventstorming-with-spring/blob/master/invariants.png?raw=true" alt="不变量"></p>
<p>如果将时间顺序应用于事件，我们将很好地了解我们的领域。此外，我们将学习基本的业务流程。与文本文档或UI原型的色调相比，该技术轻巧，快速，有趣且更具描述性。但是它还没有提供一行代码，对吗？</p>
<p><strong>划分</strong></p>
<p>为了找到业务模块之间的界限，我们可以应用内聚规则：一起变化并且一起使用的事物应该保持在一起。例如，在一个模块中。我们如何谈论只有一组五颜六色的音符的凝聚力？让我们来看看。</p>
<p>为了检查不变式（黄色音符），系统必须提出一些问题。例如，要提款，必须已经有分配的限额。系统必须运行查询： <em>“嗨，它是否已分配限制？”</em> 。另一方面，有些命令和事件可能会<strong>更改</strong>该问题的答案。例如，第一个分配限制的命令将永远从<em>否</em>更改为<em>是</em> 。这清楚地表明了<strong>高度凝聚的</strong>行为，这些行为可能会整合到一个模块或类中。</p>
<p>让我们在所有地方都应用这种启发式方法。在绿色的注释上，我们将写下系统在处理每个不变量时需要检查的查询/视图的名称。此外，让我们突出显示该查询/视图的答案何时可能由于事件而改变。这样，可以在不变变量旁边或事件旁边发现绿色音符。</p>
<p><img src="https://i.imgur.com/G9XVk63.png" alt="不变量视图事件视图更改"></p>
<p>让我们搜索以下模式：</p>
<ul>
<li>命令<code>CmdA</code>被解雇并导致<code>EventA</code></li>
<li><code>EventA</code>影响视图<code>SomeView</code> 。</li>
<li><code>SomeView</code>在处理不变量时也需要<code>CmdB</code></li>
<li>那意味着<code>CmdA</code>和<code>CmdB</code>可能是登陆同一模块的不错的选择！</li>
<li>让我们将这些命令（以及不变式和事件）彼此相邻放置。</li>
</ul>
<p>这样做可能会将我们的领域细分为非常紧密的结合点。下面我们可以找到一个建议的模块化。请记住，这只是一种启发，您可能最终会使用不同的设置。提出的技术使我们有很好的机会来识别松散耦合的模块。此方法只是一种启发式方法（不是严格的规则），可以帮助我们找到独立的模块。另外，如果您考虑一下，建议的模块具有语言上的界限。信用卡对会计和营销而言意味着不同的含义，即使它是同一个词。在DDD术语中，这些称为<em>有界上下文</em> 。这些将是我们的部署单位。同样，如果影响是即时的还是最终的，则必须考虑这种概括。如果最终可以保持一致，那么即使存在某种关系，这种启发也不会那么强烈。</p>
<p><img src="https://i.imgur.com/YJBU0WO.png" alt="模组"></p>
<p>DIVIDE部分的最后一步是确定模块之间如何通信。这就是所谓的上下文映射。以下是一些集成策略的列表：</p>
<ul>
<li>一个模块向另一个模块发送查询-语句模块需要询问Card Operations是否有提款。因为如果没有，它不会发出任何声明。</li>
<li>一个模块侦听另一个模块发送的事件<em>-Money Repaid</em>事件的直接结果是<em>Statement Closed</em>事件。这意味着，对帐单应订阅Card Operations引发的事件。在Event Storming会议开始时就错过了这一点。实际上，上下文映射是我们发现大量新信息的时刻</li>
<li>一个模块向另一个模块发送命令-在我们的系统中没有这样的示例。</li>
</ul>
<p><img src="https://i.imgur.com/vBhouxJ.png" alt="上下文图"></p>
<p><strong>实行</strong></p>
<p>具有功能分解的软件在维护过程中有极大帮助。模块化整体式是一个好的开始，但是它是单个部署单元这一事实可能会引起问题。所有模块都必须一起部署。在某些企业中，使用微服务可能是更好的选择。请参考<a href="https://twitter.com/ntschutta">Nate Shutta的</a> <a href="https://content.pivotal.io/blog/should-that-be-a-microservice-keep-these-six-factors-in-mind?utm_campaign=content-social&utm_medium=social-sprout&utm_source=twitter&utm_content=1516394228">这篇文章</a> ，以了解有关此决定何时正确的更多信息。</p>
<p>假设我们的示例适合微服务架构。每个模块可以是一个单独的Spring Boot应用程序。我们知道模块的边界。可以在每种应用不同的建筑风格。包含最多业务逻辑的场所应仔细注意。另一方面，有些模块是简单明了的。如何找到两者？</p>
<ul>
<li>寻找带有很多黄色调（不变式）的斑点。这是我们在命令和最终事件之间有很多逻辑的地方。系统需要在这里处理复杂的命令。这是我们期待突然变化的地方，也可能是我们建立竞争优势的地方。我们在这里要特别注意，例如，应用领域驱动设计技术或六边形体系结构。</li>
<li>寻找含有少量或零黄色笔记的斑点。这些很清楚并且易于实现。命令和事件之间几乎没有任何关系，系统在这里不需要做任何复杂的事情。这里唯一的工作就是与数据库进行交互，因此我们应该小心并尝试避免那里的意外复杂性。</li>
</ul>
<p>这些知识是非常重要的体系结构驱动力，可以使我们决定将<em>命令公开</em> （例如REST资源）与<em>命令处理</em> （具有不变式的域模型）分离。应用于Card Operations的此体系结构驱动程序将我们带入以下技术堆栈：</p>
<p><img src="https://i.imgur.com/LBOtKc5.png" alt="卡片操作"></p>
<p>查看命令和相关的不变量（蓝色和黄色注释）。在墙上，我们有一套完整的测试方案！剩下的唯一事情就是写下来：</p>
<pre><code class="prettyprint java">class CreditCardTest {

    @Test
    public void cannot_withdraw_when_limit_not_assigned() {

    }

    @Test
    public void cannot_withdraw_when_not_enough_money() {

    }

    @Test
    public void cannot_withdraw_when_there_was_withdrawal_within_lastH() {

    }

    @Test
    public void can_withdraw() {

    }

    @Test
    public void cannot_assign_limit_when_it_was_already_assigned() {

    }

    @Test
    public void can_assign_limit() {

    }

    @Test
    public void can_repay() {

    }

}
</code></pre>
<p>遵循TDD原则，我们可以设计代码来满足这些情况。接下来是一个初始设计，我们可以根据蓝色和黄色的粘滞便笺进行构造。</p>
<pre><code class="prettyprint java">@Entity
class CreditCard {

    //..fields will pop-up during TDD!

    void assignLimit(BigDecimal money) {
        if(limitAlreadyAssigned()) {
            // throw
        }
        //...
    }

    void withdraw(BigDecimal money) {
        if(limitNotAssigned()) {
            // throw
        }
        if(notEnoughMoney()) {
            // throw
        }
        if(withdrawalWithinLastHour()) {
            // throw
        }

        //...
    }

    void repay(BigDecimal money) {

    }

}
</code></pre>
<p>因为使用了便签，所以我们在设计阶段进行了思考。我们只是复制了便签上的内容并将其粘贴到代码中。注释和代码中使用相同的语言，这是使事件猛增功能强大的一部分。作为开发人员，此过程使我们能够专注于自己最擅长的工作，即编写可靠的代码。语言和模型只是与业务领域专家一起工作的一部分。</p>
<p>现在让我们实现集成层。实现对要求<em>的提款</em>视图<em>列表</em>的答案<code>Statements</code>模块，我们将创建REST取款资源。而且，这将是自然暴露出<code>withdraw</code>命令。与往常一样，让我们开始测试：</p>
<pre><code class="prettyprint java">@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = RANDOM_PORT)
class WithdrawalControllerTest {

	private static final String ANY_CARD_NO = &quot;no&quot;;

	@Autowired
	TestRestTemplate testRestTemplate;

	@Test
	public void should_show_correct_number_of_withdrawals() {
	    // when
	    testRestTemplate.postForEntity(&quot;/withdrawals/&quot; + ANY_CARD_NO, 
                                        new WithdrawRequest(TEN), 
                                        WithdrawRequest.class);

	    // then
            ResponseEntity res = testRestTemplate.getForEntity(
                                         &quot;/withdrawals/&quot; + ANY_CARD_NO, 
                                         WithdrawRequest.class);
            assertThat(res.getStatusCode().is2xxSuccessful()).isTrue();
            assertThat(res.getBody()).hasSize(1);
	}

}
</code></pre>
<p>并执行：</p>
<pre><code class="prettyprint java">@RestController(&quot;/withdrawals&quot;)
class WithdrawalController {

    @GetMapping(&quot;/{cardNo}&quot;)
    ResponseEntity withdrawalsForCard(@PathVariable String cardNo) {
        //.. stack for query
        // - direct call to DB to Withdrawals
    }

    @PostMapping(&quot;/{cardNo}&quot;)
    ResponseEntity withdraw(@PathVariable String cardNo, @RequestBody WithdrawRequest r) {
        //.. stack for commands
        // - call to CreditCard.withdraw(r.amount)
        // - insert new Withdrawal to DB
    }

}
</code></pre>
<p>根据上下文图<code>Repay</code>命令发出<code>MoneyRepaid</code>事件。消息代理将是异步传输域事件的自然候选者。为了实现消息传递，我们将使用<a href="https://cloud.spring.io/spring-cloud-stream/">Spring Cloud Stream</a>节省一些时间。让我们创建一个端到端测试：</p>
<pre><code class="prettyprint java">@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = RANDOM_PORT)
class RepaymentsTest {

	private static final String ANY_CARD_NO = &quot;no&quot;;

	@Autowired
        TestRestTemplate testRestTemplate;

	@Autowired
	MessageCollector messageCollector;

	@Autowired
	Source source;

	BlockingQueue&lt;Message&lt;?&gt;&gt; outputEvents;

	@BeforeClass
	public void setup() {
		outputEvents = messageCollector.forChannel(source.output());
	}

	@Test
	public void should_show_correct_number_of_withdrawals_after_1st_withdrawal() {
	    // given
	    testRestTemplate.postForEntity(&quot;/withdrawals/&quot; + ANY_CARD_NR, 
                                new WithdrawRequest(TEN), 
                                WithdrawRequest.class);

	    // when
	    testRestTemplate.postForEntity(&quot;/repayments/&quot; + ANY_CARD_NR, 
                                new RepaymentRequest(TEN), 
                                RepaymentRequest.class);

	    // then
	    assertThat(
                   outputEvents.poll()
                        .getPayload() instanceof MoneyRepaid)
                             .isTrue();
	}

}
</code></pre>
<p>并执行：</p>
<pre><code class="prettyprint">@RestController(&quot;/repayments&quot;)
class RepaymentController {

    private final Source source;

    RepaymentController(Source source) {
        this.source = source;
    }

    @PostMapping(&quot;/{cardNr}&quot;)
    ResponseEntity repay(@PathVariable String cardNo, @RequestBody RepaymentRequest r) {
        //.. stack for commands
        // - call to CreditCard.repay(r)
        // - source.output().send(... new MoneyRepaid(...));
    }

}

class RepaymentRequest {

    final BigDecimal amount;

    RepaymentRequest(BigDecimal amount) {
        this.amount = amount;
    }
}
</code></pre>
<p>的<code>PlasticCards</code>模块非常简单。没有<a href="http://www.informit.com/articles/article.aspx?p=2020371&seqNum=2">不变性</a> ，唯一的责任是与数据库和/或消息代理进行对话。让我们不要对此事复杂化，首先请注意它具有四个主要功能： <em>create，update，read和delete</em> 。<a href="https://projects.spring.io/spring-data-rest/">Spring Data REST</a>是一个很棒的项目，可以轻松创建基本的CRUD存储库，而不会造成任何繁重的工作，也不必过多担心管道问题。</p>
<p><img src="https://i.imgur.com/FUTqyMX.png" alt="塑料卡"></p>
<p>Spring Data允许我们仅用几行代码就可以根据上述设计实现一个存储库。可以提出一种简单的测试来检查上下文和实体映射是否合适，这似乎是个好主意。为简便起见，让我们跳过它，直接跳转到实现：</p>
<pre><code class="prettyprint java">@RepositoryRestResource(path = &quot;plastic-cards&quot;,
        collectionResourceRel = &quot;plastic-cards&quot;,
        itemResourceRel = &quot;plastic-cards&quot;)
interface PlasticCardController extends CrudRepository&lt;PlasticCard, Long&gt; {

}

@Entity
class PlasticCard {

    //..
}
</code></pre>
<p>虽然<code>Statements</code>模块包含一个不变式，该模块也非常接近简单的CRUD接口。虽然， <code>Statements</code>有一个不变式为了处理不变式，模块与<code>CardOperations</code>模块。单独测试该行为（没有真实的<code>CardOperations</code>在我们的Spring Boot应用程序中），我们应该看一下<a href="https://cloud.spring.io/spring-cloud-contract/">Spring Cloud Contract，</a>并将其引入到我们提议的堆栈中。 <code>Statements</code>从本质<em>上讲</em>都是简单的文档， <em>Spring Data MongoDB</em>随文档集合提供了开箱即用的功能。的<code>Statements</code>模块未公开任何命令端点，但它订阅了<code>MoneyRepaid</code>命令并利用Spring Cloud Stream的消息传递功能。</p>
<p><img src="https://i.imgur.com/HhawAb9.png" alt="陈述"></p>
<p>有一个有趣的场景：由于收到消息而关闭语句<code>MoneyRepaid</code>事件。该测试可能会使用Spring Cloud Stream测试工具触发假事件：</p>
<pre><code class="prettyprint">@RunWith(SpringRunner.class)
@SpringBootTest
class MoneyRepaidListenerTest {

	private static final String ANY_CARD_NR = &quot;nr&quot;;

	@Autowired Sink sink;
	@Autowired StatementRepository statementRepository;

	@Test
	public void should_close_the_statement_when_money_repaid_event_happens() {
	    // when
	    sink.input()
                .send(new GenericMessage&lt;&gt;(new MoneyRepaid(ANY_CARD_NR, TEN)));

	    // then
	    assertThat(statementRepository
                .findLastByCardNr(ANY_CARD_NR).isClosed()).isTrue();
	}

}
</code></pre>
<p>并执行：</p>
<pre><code class="prettyprint java">@Component
class MoneyRepaidListener {

    @StreamListener(&quot;card-operations&quot;)
    public void handle(MoneyRepaid moneyRepaid) {
        //..close statement
    }
}

class MoneyRepaid {

    final String cardNo;
    final BigDecimal amount;

    MoneyRepaid(String cardNo, BigDecimal amount) {
        this.cardNo = cardNo;
        this.amount = amount;
    }
}
</code></pre>
<p>另一方面，生成语句的过程需要查询<code>CardOperations</code>模块以检查当前提款。如前所述，应该单独进行测试。为此与负责团队的合同<code>CardOperations</code>可以提出模块。因此，可以触发该模块的存根版本以进行测试。合同生成的<a href="http://wiremock.org/">WireMock</a>存根可能如下所示：</p>
<pre><code class="prettyprint json">{
  &quot;request&quot; : {
    &quot;url&quot; : &quot;/withdrawals/123&quot;,
    &quot;method&quot; : &quot;GET&quot;
  },
  &quot;response&quot; : {
    &quot;status&quot; : 200,
    &quot;body&quot; : &quot;{\&quot;withdrawals\&quot;:\&quot;[&quot;first&quot;, &quot;second&quot;, &quot;third&quot;]\&quot;}&quot;
  }
}

{
  &quot;request&quot; : {
    &quot;url&quot; : &quot;/withdrawals/456&quot;,
    &quot;method&quot; : &quot;GET&quot;
  },
  &quot;response&quot; : {
    &quot;status&quot; : 204,
    &quot;body&quot; : &quot;{}&quot;
  }
}
</code></pre>
<p>这是<em>由于合同</em>而可以在没有任何实际实例的情况下进行的测试<code>CardOperations</code> ：</p>
<pre><code class="prettyprint java">@RunWith(SpringRunner.class)
class StatementGeneratorTest {

	private static final String USED_CARD = &quot;123&quot;;
	private static final String NOT_USED_CARD = &quot;456&quot;;

	@Autowired StatementGenerator statementGenerator;
	@Autowired StatementRepository statementRepository;

	@Test
	public void should_create_statement_only_if_there_are_withdrawals() {
	    // when
	    statementGenerator.generateStatements();

	    // then
	    assertThat(statementRepository
                             .findOpenByCardNr(USED_CARD)).hasSize(1);
	    assertThat(statementRepository
                             .findOpenByCardNr(NOT_USED_CARD)).hasSize(0);

	}

}
</code></pre>
<p>最后一件事是实现：</p>
<pre><code class="prettyprint java">@Component
class StatementGenerator {

    @Scheduled
    public void generateStatements() {
        allCardNumbers()
                .forEach(this::generateIfNeeded);
    }

    private void generateIfNeeded(CardNr cardNo) {
        //query to card-operations
        //if 200 OK - generate and statement
    }

    private List&lt;CardNr&gt; allCardNumbers() {
         return callToCardRepository();
    }
}
</code></pre>
<p>使用<a href="https://cloud.spring.io/spring-cloud-pipelines/">Spring Cloud Pipelines，</a>我们可以轻松地引入CI / CD并通过部署部分完成。</p>
<blockquote>
<p>如果您有兴趣，请不要错过<a href="https://content.pivotal.io/springone-platform-2017/continuous-deployment-to-the-cloud-marcin-grzejszczak-cora-iberkleid">Cora Iberkleid和Marcin Grzejszczak</a>关于Spring Cloud Pipelines的<a href="https://content.pivotal.io/springone-platform-2017/continuous-deployment-to-the-cloud-marcin-grzejszczak-cora-iberkleid">演讲</a> 。</p>
</blockquote>
<p><strong>结论</strong></p>
<p>事件风暴可以帮助我们快速了解域的含义。遵循DDD原则，我们可以将企业划分为较小的内聚和松散耦合的问题。了解了每个模块的复杂性以及它们之间如何相互通信，我们可以从Spring生态系统中的一系列工具中进行选择，以非常快速地实施和部署。</p>
<p><strong>特别感谢</strong></p>
<p>我要感谢<a href="https://twitter.com/kennybastani">肯尼·巴斯塔尼</a> （ <a href="https://twitter.com/kennybastani">Kenny Bastani）</a>关于此职位的初稿的许多有用的评论。但是首先，我要感谢他在创建和演练SpringOne <a href="https://content.pivotal.io/springone-platform-2017/state-or-events-which-shall-i-keep-jakub-pilimon-kenny-bastani-2">演讲</a>时提出的许多好主意。</p>
<p>另外，我还要感谢<a href="https://twitter.com/MGrzejszczak">Marcin Grzejszczak</a>关于微服务和测试的无休止的讨论。我可以说，您很少会在一个人中看到如此多的热情和热情。</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 3247;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
 </ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>