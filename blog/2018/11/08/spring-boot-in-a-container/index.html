<!DOCTYPE html>
<html data-code-prettify="" data-mobile-support="" data-search="">
<head>
<title>Spring Boot in a Container</title>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no" id="Viewport" name="viewport" />
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png" />
<link href="https://fonts.googleapis.com/css?family=Varela+Round|Montserrat:400,700" rel="stylesheet" type="text/css" />
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css" />
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M" name="google-site-verification" />

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css" />

<meta content="summary" name="twitter:card" />
<meta content="@springcentral" name="twitter:site" />
<meta name="twitter:title" content="Spring Boot in a Container" />
<meta name="twitter:description" content="&lt;div class=&quot;paragraph&quot;&gt; 
 &lt;p&gt;Many people are using containers to wrap their Spring Boot applications, and building containers is not a simple thing to do. This is an article for developers of Spring Boot applications, and containers are not always a good abstraction for developers - they force you to learn about and think about very low level concerns - but you will on occasion be called on to create or use a container, so it pays to understand the building blocks. Here we aim to show you some of the choices you can make if you are faced with the prospect of needing to create your own container.&lt;/p&gt; 
&lt;/div&gt;
" />
<meta name="twitter:creator" content="@david_syer" />
<meta name="twitter:image:src" content="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=200" />

<meta property="og:title" content="Spring Boot in a Container" />
<meta property="og:image" content="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=200" />
<meta property="og:description" content="&lt;div class=&quot;paragraph&quot;&gt; 
 &lt;p&gt;Many people are using containers to wrap their Spring Boot applications, and building containers is not a simple thing to do. This is an article for developers of Spring Boot applications, and containers are not always a good abstraction for developers - they force you to learn about and think about very low level concerns - but you will on occasion be called on to create or use a container, so it pays to understand the building blocks. Here we aim to show you some of the choices you can make if you are faced with the prospect of needing to create your own container.&lt;/p&gt; 
&lt;/div&gt;
" />
<meta content="article" property="og:type" />
<meta property="og:article:published_time" content="2018-11-08 12:01:00.0" />
</head>
<body>

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" style="display:none;visibility:hidden" width="0"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">Projects</a>
</li>
<li class="navbar-link">
<a href="/guides">Guides</a>
</li>
<li class="navbar-link active">
<a href="/blog">Blog</a>
</li>
<li class="navbar-link">
<a href="/services">Training & Certification</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form action="/search" class="form-inline form-search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search for documentation, guides, and posts..." type="text" value="" />
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form action="/search" class="form-inline form-search" method="get">
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search..." type="text" value="" />
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">
Home
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">
Projects
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">
Guides
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">
Blog
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">
Training & Certification
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>Engineering</div>
</div>
<div class="blog-category content--title">
<div>Releases</div>
</div>
<div class="blog-category content--title">
<div>News and Events</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Spring Boot in a Container</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">Engineering</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=20&amp;d=mm" />
<a class="author" rel="author" href="/team/dsyer">Dave Syer</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2018-11-08 12:01:00.0">November 08, 2018</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" data-disqus-identifier="3468" href="/blog/2018/11/08/spring-boot-in-a-container#disqus_thread">
</a></div>
</div>
</header>
<div class="blog--post"><div class="paragraph">
<p>Many people are using containers to wrap their Spring Boot applications, and building containers is not a simple thing to do. This is an article for developers of Spring Boot applications, and containers are not always a good abstraction for developers - they force you to learn about and think about very low level concerns - but you will on occasion be called on to create or use a container, so it pays to understand the building blocks. Here we aim to show you some of the choices you can make if you are faced with the prospect of needing to create your own container.</p>
</div>
<div class="paragraph">
<p>We will assume that you know how to create and build a basic Spring Boot application. If you don&#8217;t, go to one of the <a href="https://spring.io/guides">Getting Started Guides</a>, for example the one on building a <a href="https://spring.io/guides/gs/rest-service/">REST Service</a>. Copy the code from there and practise with some of the ideas below. There is also a Getting Started Guide on <a href="https://spring.io/guides/gs/spring-boot-docker">Docker</a>, which would also be a good starting point, but it doesn&#8217;t cover the range of choices that we have here, or in as much detail.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This blog is also a "topical" guide on the spring.io website. Visit it here for updates: <a href="https://spring.io/guides/topicals/spring-boot-docker/" class="bare">https://spring.io/guides/topicals/spring-boot-docker/</a>.
</td>
</tr>
</table>
</div>
<div class="sect1">
<h2 id="a-basic-dockerfile"><a class="anchor" href="#a-basic-dockerfile"></a>A Basic Dockerfile</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A Spring Boot application is easy to convert into an executable JAR file. All the <a href="https://spring.io/guides">Getting Started Guides</a> do this, and every app that you download from <a href="https://start.spring.io">Spring Initializr</a> will have a build step to create an executable JAR. With Maven you <code>./mvnw install</code> and with Gradle you <code>./gradlew build</code>. A basic Dockerfile to run that JAR would then look like this, at the top level of your project:</p>
</div>
<div class="paragraph">
<p><code>Dockerfile</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>FROM openjdk:8-jdk-alpine
VOLUME /tmp
ARG JAR_FILE
COPY ${JAR_FILE} app.jar
ENTRYPOINT ["java","-jar","/app.jar"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>JAR_FILE</code> could be passed in as part of the <code>docker</code> command (it will be different for Maven and Gradle). E.g. for Maven:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ docker build --build-args=target/*.jar -t myorg/myapp .</code></pre>
</div>
</div>
<div class="paragraph">
<p>and for Gradle:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ docker build --build-args=build/libs/*.jar -t myorg/myapp .</code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course, once you have chosen a build system, you don&#8217;t need the <code>ARG</code> - you can just hard code the jar location. E.g. for Maven:</p>
</div>
<div class="paragraph">
<p><code>Dockerfile</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>FROM openjdk:8-jdk-alpine
VOLUME /tmp
COPY target/*.jar app.jar
ENTRYPOINT ["java","-jar","/app.jar"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then we can simply build an image with</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ docker build -t myorg/myapp .</code></pre>
</div>
</div>
<div class="paragraph">
<p>and run it like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ docker run -p 8080:8080 myorg/myapp
  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v2.0.2.RELEASE)

Nov 06, 2018 2:45:16 PM org.springframework.boot.StartupInfoLogger logStarting
INFO: Starting Application v0.1.0 on b8469cdc9b87 with PID 1 (/app.jar started by root in /)
Nov 06, 2018 2:45:16 PM org.springframework.boot.SpringApplication logStartupProfileInfo
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that the base image is <code>openjdk:8-jdk-alpine</code>. The <code>alpine</code> images are smaller than the standard <code>openjdk</code> library images from <a href="https://hub.docker.com/_/openjdk/">Dockerhub</a>. There is no official alpine image for Java 11 yet (AdoptOpenJDK had one for a while but it no longer appears on their <a href="https://hub.docker.com/r/adoptopenjdk/openjdk11/">Dockerhub page</a>).</p>
</div>
<div class="paragraph">
<p>If you want to poke around inside the image you can open a shell in it like this (the base image does not have <code>bash</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ docker run -ti --entrypoint /bin/sh myorg/myapp
/ # ls
app.jar  dev      home     media    proc     run      srv      tmp      var
bin      etc      lib      mnt      root     sbin     sys      usr
/ #</code></pre>
</div>
</div>
<div class="paragraph">
<p>The docker configuration is very simple so far, and the generated image is not very efficient. The docker image has a single filesystem layer with the fat jar in it, and every change we make to the application code changes that layer, which might be 10MB or more (even as much as 50MB for some apps). We can improve on that by splitting the JAR up into multiple layers.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="a-better-dockerfile"><a class="anchor" href="#a-better-dockerfile"></a>A Better Dockerfile</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A Spring Boot fat jar naturally has "layers" because of the way that the jar itself is packaged. If we unpack it first it will already be divided into external and internal dependencies. To do this in one step in the docker build, we need to unpack the jar first. For example (sticking with Maven, but the Gradle version is pretty similar):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ mkdir target/dependency
$ (cd target/dependency; tar -zxf ../*.jar)
$ docker build -t myorg/myapp .</code></pre>
</div>
</div>
<div class="paragraph">
<p>with this <code>Dockerfile</code></p>
</div>
<div class="paragraph">
<p><code>Dockerfile</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>FROM openjdk:8-jdk-alpine
VOLUME /tmp
ARG DEPENDENCY=target/dependency
COPY ${DEPENDENCY}/BOOT-INF/lib /app/lib
COPY ${DEPENDENCY}/META-INF /app/META-INF
COPY ${DEPENDENCY}/BOOT-INF/classes /app
ENTRYPOINT ["java","-cp","app:app/lib/*","hello.Application"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are now 3 layers, with all the application resources in the later 2 layers. If the application dependencies don&#8217;t change, then the first layer (from <code>BOOT-INF/lib</code>) will not change, so the build will be faster, and so will the startup of the container at runtime as long as the base layers are already cached.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
We used a hard-coded main application class <code>hello.Application</code>. This will probably be different for your application. You could parameterize it with another <code>ARG</code> if you wanted. You could also copy the Spring Boot fat <code>JarLauncher</code> into the image and use it to run the app - it would work and you wouldn&#8217;t need to specify the main class, but it would be a bit slower on startup.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="tweaks"><a class="anchor" href="#tweaks"></a>Tweaks</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If you want to start your app as quickly as possible (most people do) there are some tweaks you might consider. Here are some ideas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use the <code>spring-context-indexer</code> (<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-scanning-index">link to docs</a>). It&#8217;s not going to add much for small apps, but every little helps.</p>
</li>
<li>
<p>Don&#8217;t use <a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#production-ready">actuators</a> if you can afford not to.</p>
</li>
<li>
<p>Use Spring Boot 2.1 and Spring 5.1.</p>
</li>
<li>
<p>Fix the location of the
<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-external-config-application-property-files">Spring Boot config file(s)</a>
with <code>spring.config.location</code> (command line argument or System property etc.).</p>
</li>
<li>
<p>Switch off JMX - you probably don&#8217;t need it in a container - with <code>spring.jmx.enabled=false</code></p>
</li>
<li>
<p>Run the JVM with <code>-noverify</code>. Also consider <code>-XX:TieredStopAtLevel=1</code>
(that will slow down the JIT later at the expense of the saved startup time).</p>
</li>
<li>
<p>Use the container memory hints for Java 8: <code>-XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap</code>. With Java 11 this is automatic by default.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Your app might not need a full CPU at runtime, but it will need multiple CPUs to start up as quickly as possible (at least 2, 4 are better). If you don&#8217;t mind a slower startup you could throttle the CPUs down below 4.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="multi-stage-build"><a class="anchor" href="#multi-stage-build"></a>Multi-Stage Build</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>Dockerfile</code> above assumed that the fat JAR was already built on the command line. You can also do that step in docker using a multi-stage build, copying the result from one image to another. Example, using Maven:</p>
</div>
<div class="paragraph">
<p><code>Dockerfile</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>FROM openjdk:8-jdk-alpine as build
WORKDIR /workspace/app

COPY mvnw .
COPY .mvn .mvn
COPY pom.xml .
COPY src src

RUN ./mvnw install -DskipTests
RUN mkdir -p target/dependency &amp;&amp; (cd target/dependency; jar -xf ../*.jar)

FROM openjdk:8-jdk-alpine
VOLUME /tmp
ARG DEPENDENCY=/workspace/app/target/dependency
COPY --from=build ${DEPENDENCY}/BOOT-INF/lib /app/lib
COPY --from=build ${DEPENDENCY}/META-INF /app/META-INF
COPY --from=build ${DEPENDENCY}/BOOT-INF/classes /app
ENTRYPOINT ["java","-cp","app:app/lib/*","hello.Application"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first image is labelled "build" and it is used to run Maven and build the fat jar, then unpack it. The unpacking could also be done by Maven or Gradle (this is the approach taken in the Getting Started Guide) - there really isn&#8217;t much difference, except that the build configuration would have to be edited and a plugin added.</p>
</div>
<div class="paragraph">
<p>Notice that the source code has been split into 4 layers. The later layers contain the build configuration and the source code for the app, and the earlier layers contain the build system itself (the Maven wrapper). This is a small optimization, and it also means that we don&#8217;t have to copy the <code>target</code> directory to a docker image, even a temporary one used for the build.</p>
</div>
<div class="paragraph">
<p>Every build where the source code changes will be slow because the Maven cache has to be re-created in the first <code>RUN</code> section. But you have a completely standalone build that anyone can run to get your application running as long as they have docker. That can be quite useful in some environments, e.g. where you need to share your code with people who don&#8217;t know Java.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="build-plugins"><a class="anchor" href="#build-plugins"></a>Build Plugins</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If you don&#8217;t want to call <code>docker</code> directly in your build, there is quite a rich set of plugins for Maven and Gradle that can do that work for you. Here are just a few.</p>
</div>
<div class="sect2">
<h3 id="spotify-maven-plugin"><a class="anchor" href="#spotify-maven-plugin"></a>Spotify Maven Plugin</h3>
<div class="paragraph">
<p>The <a href="https://github.com/spotify/dockerfile-maven">Spotify Maven Plugin</a> is a popular choice. It requires the application developer to write a <code>Dockerfile</code> and then runs <code>docker</code> for you, just as if you were doing it on the command line. There are some configuration options for the docker image tag and other stuff, but it keeps the docker knowledge in your application concentrated in a <code>Dockerfile</code>, which many people like.</p>
</div>
<div class="paragraph">
<p>For really basic usage it will work out of the box with no extra configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ mvn com.spotify:dockerfile-maven-plugin:build
...
[INFO] Building Docker context /home/dsyer/dev/demo/workspace/myapp
[INFO]
[INFO] Image will be built without a name
[INFO]
...
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 7.630 s
[INFO] Finished at: 2018-11-06T16:03:16+00:00
[INFO] Final Memory: 26M/595M
[INFO] ------------------------------------------------------------------------</code></pre>
</div>
</div>
<div class="paragraph">
<p>That builds an anonymous docker image. We can tag it with <code>docker</code> on the command line now, or use Maven configuration to set it as the <code>repository</code>. Example (without changing the <code>pom.xml</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ mvn com.spotify:dockerfile-maven-plugin:build -Ddockerfile.repository=myorg/myapp</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or in the <code>pom.xml</code>:</p>
</div>
<div class="paragraph">
<p><code>pom.xml</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;com.spotify&lt;/groupId&gt;
            &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt;
            &lt;version&gt;1.4.8&lt;/version&gt;
            &lt;configuration&gt;
                &lt;repository&gt;myorg/${project.artifactId}&lt;/repository&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="palantir-gradle-plugin"><a class="anchor" href="#palantir-gradle-plugin"></a>Palantir Gradle Plugin</h3>
<div class="paragraph">
<p>The <a href="https://github.com/palantir/gradle-docker">Palantir Gradle Plugin</a> works with a <code>Dockerfile</code> and it also is able to generate a <code>Dockerfile</code> for you, and then it runs <code>docker</code> as if you were running it on the command line.</p>
</div>
<div class="paragraph">
<p>First you need to import the plugin into your <code>build.gradle</code>:</p>
</div>
<div class="paragraph">
<p><code>build.gradle</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">buildscript {
    ...
    dependencies {
        ...
        classpath('gradle.plugin.com.palantir.gradle.docker:gradle-docker:0.13.0')
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and then finally you apply the plugin and call its task:</p>
</div>
<div class="paragraph">
<p><code>build.gradle</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">apply plugin: 'com.palantir.docker'

group = 'myorg'

bootJar {
    baseName = 'myapp'
    version =  '0.1.0'
}

task unpack(type: Copy) {
    dependsOn bootJar
    from(zipTree(tasks.bootJar.outputs.files.singleFile))
    into("build/dependency")
}
docker {
    name "${project.group}/${bootJar.baseName}"
    copySpec.from(tasks.unpack.outputs).into("dependency")
    buildArgs(['DEPENDENCY': "dependency"])
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example we have chosen to unpack the Spring Boot fat jar in a specific location in the <code>build</code> directory, which is the root for the docker build. Then the multi-layer (not multi-stage) <code>Dockerfile</code> from above will work.</p>
</div>
</div>
<div class="sect2">
<h3 id="jib-maven-and-gradle-plugins"><a class="anchor" href="#jib-maven-and-gradle-plugins"></a>Jib Maven and Gradle Plugins</h3>
<div class="paragraph">
<p>Google has an open source tool called <a href="https://github.com/GoogleContainerTools/jib">Jib</a> that is relatively new, but quite interesting for a number of reasons. Probably the most interesting thing is that you don&#8217;t need docker to run it - it builds the image using the same standard output as you get from <code>docker build</code> but doesn&#8217;t use <code>docker</code> unless you ask it to - so it works in environments where docker is not installed (not uncommon in build servers). You also don&#8217;t need a <code>Dockerfile</code> (it would be ignored anyway), or anything in your <code>pom.xml</code> to get an image built in Maven (Gradle would require you to at least install the plugin in <code>build.gradle</code>).</p>
</div>
<div class="paragraph">
<p>Another interesting feature of Jib is that it is opinionated about layers, and it optimizes them in a slightly different way than the multi-layer <code>Dockerfile</code> created above. Just like in the fat jar, Jib separates local application resources from dependencies, but it goes a step further and also puts snapshot dependencies into a separate layer, since they are more likely to change. There are configuration options for customizing the layout further.</p>
</div>
<div class="paragraph">
<p>Example with Maven (without changing the <code>pom.xml</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ mvn com.google.cloud.tools:jib-maven-plugin:build -Dimage=myorg/myapp</code></pre>
</div>
</div>
<div class="paragraph">
<p>To run the above command you will need to have permission to push to Dockerhub under the <code>myorg</code> repository prefix. If you have authenticated with <code>docker</code> on the command line, that will work from your local <code>~/.docker</code> configuration. You can also set up a Maven "server" authentication in your <code>~/.m2/settings.xml</code> (the <code>id</code> of the repository ios significant):</p>
</div>
<div class="paragraph">
<p><code>settings.xml</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>    &lt;server&gt;
      &lt;id&gt;registry.hub.docker.com&lt;/id&gt;
      &lt;username&gt;myorg&lt;/username&gt;
      &lt;password&gt;...&lt;/password&gt;
    &lt;/server&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are other options, e.g. you can build locally against a docker daemon (like running <code>docker</code> on the command line), using the <code>dockerBuild</code> goal instead of <code>build</code>. Other container registries are also supported and for each one you will need to set up local authentication via docker or Maven settings.</p>
</div>
<div class="paragraph">
<p>The gradle plugin has similar features, once you have it in your <code>build.gradle</code>, e.g.</p>
</div>
<div class="paragraph">
<p><code>build.gradle</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">plugins {
  ...
  id 'com.google.cloud.tools.jib' version '0.9.11'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>or in the older style used in the Getting Started Guides:</p>
</div>
<div class="paragraph">
<p><code>build.gradle</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">buildscript {
    repositories {
      maven {
        url "https://plugins.gradle.org/m2/"
      }
      mavenCentral()
    }
    dependencies {
        classpath('org.springframework.boot:spring-boot-gradle-plugin:2.0.5.RELEASE')
        classpath('com.google.cloud.tools.jib:com.google.cloud.tools.jib.gradle.plugin:0.9.11')
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and then you can build an image with</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ ./gradlew jib --image=myorg/myapp</code></pre>
</div>
</div>
<div class="paragraph">
<p>As with the Maven build, if you have authenticated with <code>docker</code> on the command line, the image push will authenticate from your local <code>~/.docker</code> configuration.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="continuous-integration"><a class="anchor" href="#continuous-integration"></a>Continuous Integration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Automation is part of every application lifecycle these days (or should be). The tools that people use to do the automation tend to be quite good at just invoking the build system from the source code. So if that gets you a docker image, and the environment in the build agents is sufficiently aligned with developer&#8217;s own environment, that might be good enough. Authenticating to the docker registry is likely to be the biggest challenge, but there are features in all the automation tools to help with that.</p>
</div>
<div class="paragraph">
<p>However, sometimes it is better to leave container creation completely to an automation layer, in which case the user&#8217;s code might not need to be polluted. Container creation is tricky, and developers sometimes don&#8217;t really care about it. If the user code is cleaner there is more chance that a different tool can "do the right thing", applying security fixes, optimizing caches etc. There are multiple options for automation and they will all come with some features related to containers these days. We are just going to look at a couple.</p>
</div>
<div class="sect2">
<h3 id="concourse"><a class="anchor" href="#concourse"></a>Concourse</h3>
<div class="paragraph">
<p><a href="https://concourse-ci.org">Concourse</a> is a pipeline-based automation platform that can be used for CI and CD. It is heavily used inside Pivotal and the main authors of the project work there. Everything in Concourse is stateless and everything runs in a container, except the CLI. Since running containers is the main order of business for the automation pipelines, creating containers is well supported. The <a href="https://github.com/concourse/docker-image-resource">Docker Image Resource</a> is responsible for keeping the output state of your build up to date, if it is a container image.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example pipeline that builds a docker image for the sample above, assuming it is in github at <code>myorg/myapp</code> and has a <code>Dockerfile</code> at the root and a build task declaration in <code>src/main/ci/build.yml</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>resources:
- name: myapp
  type: git
  source:
    uri: https://github.com/myorg/myapp.git
- name: myapp-image
  type: docker-image
  source:
    email: {{docker-hub-email}}
    username: {{docker-hub-username}}
    password: {{docker-hub-password}}
    repository: myorg/myapp

jobs:
- name: main
  plan:
  - task: build
    file: myapp/src/main/ci/build.yml
  - put: myapp-image
    params:
      build: myapp</code></pre>
</div>
</div>
<div class="paragraph">
<p>The structure of a pipeline is very declarative: you define "resources" (which are either input or output or both), and "jobs" (which use and apply actions to resources). If any of the input resources changes a new build is triggered. If any of the output resources changes during a job, then it is updated.</p>
</div>
<div class="paragraph">
<p>The pipeline could be defined in a different place than the application source code. And for a generic build setup the task declarations could be centralized or externalized as well. This allows some separation of concerns between development and automation, if that&#8217;s the way you roll.</p>
</div>
</div>
<div class="sect2">
<h3 id="jenkins"><a class="anchor" href="#jenkins"></a>Jenkins</h3>
<div class="paragraph">
<p><a href="https://jenkins.io">Jenkins</a> is another popular automation server. It has a huge range of features, but one that is the closest to the other automation samples here is the <a href="https://jenkins.io/doc/book/pipeline/docker/">pipeline</a> feature. Here&#8217;s a <code>Jenkinsfile</code> that builds a Spring Boot project with Maven and then uses a <code>Dockerfile</code> to build an image and push it to a repository:</p>
</div>
<div class="paragraph">
<p><code>Jenkinsfile</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>node {
    checkout scm
    sh './mvnw -B -DskipTests clean package'
    docker.build("myorg/myapp").push()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For a (realistic) docker repository that needs authentication in the build server, you can add credentials to the <code>docker</code> object above using <code>docker.withCredentials(&#8230;&#8203;)</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="buildpacks"><a class="anchor" href="#buildpacks"></a>Buildpacks</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://www.cloudfoundry.org/">Cloud Foundry</a> has used containers internally for many years now, and part of the technology used to transform user code into containers is Build Packs, an idea originally borrowed from <a href="https://www.heroku.com/">Heroku</a>. The current generation of buildpacks (v2) generates generic binary output that is assembled into a container by the platform. The <a href="https://buildpacks.io/">new generation of buildpacks</a> (v3) is a collaboration between Heroku and other companies including Pivotal, and it builds container images directly and explicitly. This is very interesting for developers and operators. Developers don&#8217;t need to care so much about the details of how to build a container, but they can easily create one if they need to. Buildpacks also have lots of features for caching build results and dependencies, so often a buildpack will run much quicker than a native docker build. Operators can scan the containers to audit their contents and transform them to patch them for security updates. And you can run the buildpacks locally (e.g. on a developer machine, or in a CI service), or in a platform like Cloud Foundry.</p>
</div>
<div class="paragraph">
<p>The output from a buildpack lifecycle is a container image, but you don&#8217;t need docker or a <code>Dockerfile</code>, so it&#8217;s CI and automation friendly. The filesystem layers in the output image are controlled by the buildpack, and typically many optimizations will be made without the developer having to know or care about them. There is also an <a href="https://en.wikipedia.org/wiki/Application_binary_interface">Application Binary Interface</a> between the lower level layers, like the base image containing the operating system, and the upper layers, containing middleware and language specific dependencies. This makes it possible for a platform, like Cloud Foundry, to patch lower layers if there are security updates without affecting the integrity and functionality of the application.</p>
</div>
<div class="paragraph">
<p>To give you an idea of the features of a buildpack here is an example using the <a href="https://github.com/buildpack/pack">Pack CLI</a> from the command line (it would work with the sample app we have been using in thus article, no need for a <code>Dockerfile</code> or any special build configuration):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ pack build myorg/myapp --builder=nebhale/java-build --path=.
2018/11/07 09:54:48 Pulling builder image 'nebhale/java-build' (use --no-pull flag to skip this step)
2018/11/07 09:54:49 Selected run image 'packs/run' from stack 'io.buildpacks.stacks.bionic'
2018/11/07 09:54:49 Pulling run image 'packs/run' (use --no-pull flag to skip this step)
*** DETECTING:
2018/11/07 09:54:52 Group: Cloud Foundry OpenJDK Buildpack: pass | Cloud Foundry Build System Buildpack: pass | Cloud Foundry JVM Application Buildpack: pass
*** ANALYZING: Reading information from previous image for possible re-use
*** BUILDING:
-----&gt; Cloud Foundry OpenJDK Buildpack 1.0.0-BUILD-SNAPSHOT
-----&gt; OpenJDK JDK 1.8.192: Reusing cached dependency
-----&gt; OpenJDK JRE 1.8.192: Reusing cached launch layer

-----&gt; Cloud Foundry Build System Buildpack 1.0.0-BUILD-SNAPSHOT
-----&gt; Using Maven wrapper
       Linking Maven Cache to /home/pack/.m2
-----&gt; Building application
       Running /workspace/app/mvnw -Dmaven.test.skip=true package
...
---&gt; Running in e6c4a94240c2
---&gt; 4f3a96a4f38c
---&gt; 4f3a96a4f38c
Successfully built 4f3a96a4f38c
Successfully tagged myorg/myapp:latest
$ docker run -p 8080:8080 myorg/myapp
  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v2.0.5.RELEASE)

2018-11-07 09:41:06.390  INFO 1 --- [ main] hello.Application: Starting Application on 1989fb9a00a4 with PID 1 (/workspace/app/BOOT-INF/classes started by pack in /workspace/app)
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>--builder</code> is a docker image that runs the buildpack lifecycle - typically it would be a shared resource for all developers, or all developers on a single platform. This one is work in progress from Ben Hale, who maintains the older buildpacks for Cloud Foundry and is now working on the new generation. The output in this case went to the local docker daemon, but in an automation platform it could be a docker registry. Once the <code>pack</code> CLI reaches a stable release the default builder will probably do the same thing.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="knative"><a class="anchor" href="#knative"></a>Knative</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Another new project in the container and platform space is <a href="https://cloud.google.com/knative/">Knative</a>. Knative is a lot of things, but if you are not familiar with it you can think of it as a building block for building a serverless platform. It is built on <a href="https://kubernetes.io">Kubernetes</a> so ultimately it consumes container images, and turns them into applications or "services" on the platform. One of the main features it has, though, is the ability to consume source code and build the container for you, making it more developer and operator friendly. <a href="https://github.com/knative/build">Knative Build</a> is the component that does this and is itself a flexible platform for transforming user code into containers - you can do it in pretty much any way you like. Some templates are provided with common patterns like Maven and Gradle builds, and multi-stage docker builds using <a href="https://github.com/GoogleContainerTools/kaniko">Kaniko</a>. There is also a template that use <a href="https://github.com/knative/build-templates/tree/master/buildpack">Buildpacks</a> which is very interesting for us, since buildpacks have always had good support for Spring Boot. Buildpacks on Knative are also the opinionated choice of <a href="https://projectriff.io">Riff</a> and <a href="https://pivotal.io/platform/pivotal-function-service">Pivotal Function Service</a> for transforming user functions into running serverless apps.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="closing"><a class="anchor" href="#closing"></a>Closing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This article has presented a lot of options for building container images for Spring Boot applications. All of them are completely valid choices, and it is now up to you to decide which one you need. Your first question should be "do I really need to build a container image?" If the answer is "yes" then your choices will likely be driven by efficiency and cacheability, and by separation of concerns. Do you want to insulate developers from needing to know too much about how container images are created? Do you want to make developers responsible for updating images when operating system and middleware vulnerabilities neeed to be patched? Or maybe developers need complete control over the whole process and they have all the tools and knowledge they need.</p>
</div>
</div>
</div></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 3468;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>
Back
</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">All Posts</a>
<a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">Engineering</a>
<a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">Releases</a>
<a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">News and Events</a>
<a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>Get updates from The Spring Team delivered to your inbox</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">Tools</a></li>
<li><a href="https://store.pivotal.io/">Store</a></li>
<li><a href="/blog">Newsletter</a></li>
</ul>
</div>
</div>
&copy; <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a>, Inc. All Rights Reserved.
<a href="https://pivotal.io/terms-of-use">Terms of Use</a> &bullet;
<a href="https://pivotal.io/privacy-policy">Privacy</a> &bullet;
<a href="/trademarks">Trademark Guidelines</a>
<div id="teconsent" style="display:inline-block;"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>