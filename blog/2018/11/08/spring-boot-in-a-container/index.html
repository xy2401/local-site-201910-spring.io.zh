<html dir="ltr" data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>容器中的Spring Boot</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>System.config({baseURL: "/b92013b"});</script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>System.import('app/main.js')</script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Spring Boot in a Container">
<meta name="twitter:description" content="<div class=" paragrap="="> 
 </head><body dir="ltr"><p>Many people are using containers to wrap their Spring Boot applications, and building containers is not a simple thing to do. This is an article for developers of Spring Boot applications, and containers are not always a good abstraction for developers - they force you to learn about and think about very low level concerns - but you will on occasion be called on to create or use a container, so it pays to understand the building blocks. Here we aim to show you some of the choices you can make if you are faced with the prospect of needing to create your own container.</p> 

">
<meta name="twitter:creator" content="@david_syer">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=200">

<meta property="og:title" content="Spring Boot in a Container">
<meta property="og:image" content="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=200">
<meta property="og:description" content="<div class=" paragrap="="> 
 <p>Many people are using containers to wrap their Spring Boot applications, and building containers is not a simple thing to do. This is an article for developers of Spring Boot applications, and containers are not always a good abstraction for developers - they force you to learn about and think about very low level concerns - but you will on occasion be called on to create or use a container, so it pays to understand the building blocks. Here we aim to show you some of the choices you can make if you are faced with the prospect of needing to create your own container.</p> 

">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2018-11-08 12:01:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">// Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }</script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">容器中的Spring Boot</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=20&d=mm"> <a class="author" rel="author" href="/team/dsyer">戴夫·瑟</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2018-11-08 12:01:00.0">十一月08，2018</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2018/11/08/spring-boot-in-a-container#disqus_thread" data-disqus-identifier="3468">
</a></div>
</div>
</header>
<div class="blog--post"><div class="paragraph">
<p>许多人正在使用容器包装他们的Spring Boot应用程序，而构建容器并不是一件容易的事。这是一篇针对Spring Boot应用程序开发人员的文章，容器对于开发人员而言并不总是一个很好的抽象-它们迫使您学习和思考非常低级的问题-但是有时您会被要求创建或使用容器，因此有必要了解这些基本要素。在这里，我们旨在向您展示一些您需要创建自己的容器时可以做出的选择。</p>
</div>
<div class="paragraph">
<p>我们将假定您知道如何创建和构建基本的Spring Boot应用程序。如果你不这样做，去到一个<a href="https://spring.io/guides">入门指南</a> ，例如关于构建一个<a href="https://spring.io/guides/gs/rest-service/">REST服务</a> 。从此处复制代码，并使用以下一些想法进行练习。在<a href="https://spring.io/guides/gs/spring-boot-docker">Docker</a>上也有一个入门指南，这也是一个很好的起点，但是它没有涵盖我们在此所做的选择范围，也没有详细介绍。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">该博客还是spring.io网站上的“主题”指南。在此处访问以获取更新： <a href="https://spring.io/guides/topicals/spring-boot-docker/" class="bare">https</a> : <a href="https://spring.io/guides/topicals/spring-boot-docker/" class="bare">//spring.io/guides/topicals/spring-boot-docker/</a> 。</td>
</tr>
</tbody></table>
</div>
<div class="sect1">
<h2 id="a-basic-dockerfile"><a class="anchor" href="#a-basic-dockerfile"></a>基本的Dockerfile</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot应用程序很容易转换为可执行的JAR文件。所有<a href="https://spring.io/guides">入门指南</a>都这样做，从<a href="https://start.spring.io">Spring Initializr</a>下载的每个应用程序都将具有一个构建步骤来创建可执行的JAR。使用Maven可以<code>./mvnw install</code> ，使用Gradle可以<code>./mvnw install</code> <code>./gradlew build</code> 。然后，在项目的顶层，运行该JAR的基本Dockerfile如下所示：</p>
</div>
<div class="paragraph">
<p><code>Dockerfile</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>FROM openjdk:8-jdk-alpine
VOLUME /tmp
ARG JAR_FILE
COPY ${JAR_FILE} app.jar
ENTRYPOINT ["java","-jar","/app.jar"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>所述<code>JAR_FILE</code>可以在作为的一部分被传递<code>docker</code>命令（这将是Maven和摇篮不同）。例如Maven：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ docker build --build-args=target/*.jar -t myorg/myapp .</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于Gradle：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ docker build --build-args=build/libs/*.jar -t myorg/myapp .</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然，一旦选择了构建系统，就不需要<code>ARG</code>您只需对jar位置进行硬编码即可。例如Maven：</p>
</div>
<div class="paragraph">
<p><code>Dockerfile</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>FROM openjdk:8-jdk-alpine
VOLUME /tmp
COPY target/*.jar app.jar
ENTRYPOINT ["java","-jar","/app.jar"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后我们可以简单地用</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ docker build -t myorg/myapp .</code></pre>
</div>
</div>
<div class="paragraph">
<p>并像这样运行它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ docker run -p 8080:8080 myorg/myapp
  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v2.0.2.RELEASE)

Nov 06, 2018 2:45:16 PM org.springframework.boot.StartupInfoLogger logStarting
INFO: Starting Application v0.1.0 on b8469cdc9b87 with PID 1 (/app.jar started by root in /)
Nov 06, 2018 2:45:16 PM org.springframework.boot.SpringApplication logStartupProfileInfo
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，基本映像为<code>openjdk:8-jdk-alpine</code> 。<code>alpine</code>映像比<a href="https://hub.docker.com/_/openjdk/">Dockerhub</a>的标准<code>openjdk</code>库映像<a href="https://hub.docker.com/_/openjdk/">小</a> 。尚无Java 11的正式高山图像（AdoptOpenJDK已有一段时间，但不再出现在其<a href="https://hub.docker.com/r/adoptopenjdk/openjdk11/">Dockerhub页面上</a> ）。</p>
</div>
<div class="paragraph">
<p>如果要在图像内部四处浏览，可以像这样打开其中的外壳（基本图像没有<code>bash</code> ）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ docker run -ti --entrypoint /bin/sh myorg/myapp
/ # ls
app.jar  dev      home     media    proc     run      srv      tmp      var
bin      etc      lib      mnt      root     sbin     sys      usr
/ #</code></pre>
</div>
</div>
<div class="paragraph">
<p>到目前为止，docker配置非常简单，并且生成的映像不是很有效。docker映像只有一个文件系统层，其中包含胖子罐，我们对应用程序代码进行的每一次更改都会更改该层，该层可能为10MB或更多（对于某些应用程序甚至可能为50MB）。我们可以通过将JAR分为多个层来改善这一点。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="a-better-dockerfile"><a class="anchor" href="#a-better-dockerfile"></a>更好的Dockerfile</h2>
<div class="sectionbody">
<div class="paragraph">
<p>由于罐子本身的包装方式，Spring Boot胖子罐子自然具有“层”。如果我们先拆包，它将已经分为内部和外部依赖关系。为了在Docker构建中一步一步做到这一点，我们需要首先解压jar。例如（坚持使用Maven，但Gradle版本非常相似）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ mkdir target/dependency
$ (cd target/dependency; tar -zxf ../*.jar)
$ docker build -t myorg/myapp .</code></pre>
</div>
</div>
<div class="paragraph">
<p>与此<code>Dockerfile</code></p>
</div>
<div class="paragraph">
<p><code>Dockerfile</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>FROM openjdk:8-jdk-alpine
VOLUME /tmp
ARG DEPENDENCY=target/dependency
COPY ${DEPENDENCY}/BOOT-INF/lib /app/lib
COPY ${DEPENDENCY}/META-INF /app/META-INF
COPY ${DEPENDENCY}/BOOT-INF/classes /app
ENTRYPOINT ["java","-cp","app:app/lib/*","hello.Application"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在有3层，所有应用程序资源都位于后面的2层中。如果应用程序依存关系不变，那么第一层（来自<code>BOOT-INF/lib</code> ）将不会改变，因此构建会更快，因此只要基础层已经存在，容器在运行时的启动也将更快已缓存。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="注意"></i>
</td>
<td class="content">我们使用了硬编码的主应用程序类<code>hello.Application</code> 。对于您的应用程序，这可能会有所不同。如果需要，可以使用另一个<code>ARG</code>对其进行参数化。您还可以将Spring Boot胖子<code>JarLauncher</code>复制到映像中，然后使用它来运行应用程序-它可以工作，并且您不需要指定主类，但是启动时会慢一些。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="tweaks"><a class="anchor" href="#tweaks"></a>调整</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果您想尽快启动应用程序（大多数人都这样做），则可以考虑一些调整。这里有一些想法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用<code>spring-context-indexer</code> （ <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-scanning-index">链接到docs</a> ）。对于小型应用程序而言，它不会增加太多，但对您有所帮助。</p>
</li>
<li>
<p>如果负担不起，请不要使用<a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#production-ready">执行器</a> 。</p>
</li>
<li>
<p>使用Spring Boot 2.1和Spring 5.1。</p>
</li>
<li>
<p>使用<code>spring.config.location</code> （命令行参数或System属性等）修复<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-external-config-application-property-files">Spring Boot配置文件</a>的位置。</p>
</li>
<li>
<p>使用<code>spring.jmx.enabled=false</code>关闭JMX-您可能不需要在容器中使用它</p>
</li>
<li>
<p>使用<code>-noverify</code>运行JVM。还要考虑<code>-XX:TieredStopAtLevel=1</code> （这将在以后降低JIT速度，但会节省启动时间）。</p>
</li>
<li>
<p>使用Java 8的容器内存提示： <code>-XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap</code> 。对于Java 11，默认情况下是自动的。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您的应用程序在运行时可能不需要完整的CPU，但需要多个CPU才能尽快启动（至少2、4个更好）。如果您不介意启动速度较慢，则可以将CPU速度控制在4以下。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="multi-stage-build"><a class="anchor" href="#multi-stage-build"></a>多阶段构建</h2>
<div class="sectionbody">
<div class="paragraph">
<p>上面的<code>Dockerfile</code>假设胖JAR已在命令行上构建。您也可以使用多阶段构建在Docker中执行此步骤，将结果从一个映像复制到另一个映像。使用Maven的示例：</p>
</div>
<div class="paragraph">
<p><code>Dockerfile</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>FROM openjdk:8-jdk-alpine as build
WORKDIR /workspace/app

COPY mvnw .
COPY .mvn .mvn
COPY pom.xml .
COPY src src

RUN ./mvnw install -DskipTests
RUN mkdir -p target/dependency && (cd target/dependency; jar -xf ../*.jar)

FROM openjdk:8-jdk-alpine
VOLUME /tmp
ARG DEPENDENCY=/workspace/app/target/dependency
COPY --from=build ${DEPENDENCY}/BOOT-INF/lib /app/lib
COPY --from=build ${DEPENDENCY}/META-INF /app/META-INF
COPY --from=build ${DEPENDENCY}/BOOT-INF/classes /app
ENTRYPOINT ["java","-cp","app:app/lib/*","hello.Application"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一个图像标记为“ build”，它用于运行Maven并构建胖罐，然后解压缩它。拆包也可以由Maven或Gradle完成（这是《入门指南》中采用的方法）-确实没有太大区别，只是必须编辑构建配置并添加插件。</p>
</div>
<div class="paragraph">
<p>请注意，源代码已分为4层。后面的层包含构建配置和应用程序的源代码，而前面的层包含构建系统本身（Maven包装器）。这是一个很小的优化，这也意味着我们不必将<code>target</code>目录复制到Docker映像，即使是用于构建的临时目录也是如此。</p>
</div>
<div class="paragraph">
<p>因为必须在第一个<code>RUN</code>部分中重新创建Maven缓存，所以每个更改源代码的构建都会很慢。但是您拥有一个完全独立的构建，只要拥有docker，任何人都可以运行它来使您的应用程序运行。在某些环境中，例如在需要与不懂Java的人共享代码的环境中，这很有用。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="build-plugins"><a class="anchor" href="#build-plugins"></a>构建插件</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果您不想直接在构建中调用<code>docker</code> ，则可以使用Maven和Gradle丰富的插件集来为您工作。这里仅仅是少数。</p>
</div>
<div class="sect2">
<h3 id="spotify-maven-plugin"><a class="anchor" href="#spotify-maven-plugin"></a> Spotify Maven插件</h3>
<div class="paragraph">
<p><a href="https://github.com/spotify/dockerfile-maven">Spotify Maven插件</a>是一个受欢迎的选择。它需要应用程序开发人员编写<code>Dockerfile</code> ，然后运行<code>docker</code>为你，就好像你在做它的命令行上。docker image标签和其他内容有一些配置选项，但它使应用程序中的<code>Dockerfile</code>知识集中在<code>Dockerfile</code> ，这是许多人喜欢的。</p>
</div>
<div class="paragraph">
<p>对于真正的基本用法，它无需额外配置即可直接使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ mvn com.spotify:dockerfile-maven-plugin:build
...
[INFO] Building Docker context /home/dsyer/dev/demo/workspace/myapp
[INFO]
[INFO] Image will be built without a name
[INFO]
...
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 7.630 s
[INFO] Finished at: 2018-11-06T16:03:16+00:00
[INFO] Final Memory: 26M/595M
[INFO] ------------------------------------------------------------------------</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将构建一个匿名docker镜像。我们现在可以在命令行上使用<code>docker</code>对其进行标记，或者使用Maven配置将其设置为<code>repository</code> 。示例（不更改<code>pom.xml</code> ）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ mvn com.spotify:dockerfile-maven-plugin:build -Ddockerfile.repository=myorg/myapp</code></pre>
</div>
</div>
<div class="paragraph">
<p>或在<code>pom.xml</code> ：</p>
</div>
<div class="paragraph">
<p><code>pom.xml</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code><build>
    <plugins>
        <plugin>
            <groupId>com.spotify</groupId>
            <artifactId>dockerfile-maven-plugin</artifactId>
            <version>1.4.8</version>
            <configuration>
                <repository>myorg/${project.artifactId}</repository>
            </configuration>
        </plugin>
    </plugins>
</build></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="palantir-gradle-plugin"><a class="anchor" href="#palantir-gradle-plugin"></a> Palantir Gradle插件</h3>
<div class="paragraph">
<p>该<a href="https://github.com/palantir/gradle-docker">真知晶球摇篮插件</a>工作与<code>Dockerfile</code> ，它也能产生<code>Dockerfile</code>你，然后它运行<code>docker</code> ，如果你是在命令行中运行它。</p>
</div>
<div class="paragraph">
<p>首先，您需要将插件导入到<code>build.gradle</code> ：</p>
</div>
<div class="paragraph">
<p><code>build.gradle</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">buildscript {
    ...
    dependencies {
        ...
        classpath('gradle.plugin.com.palantir.gradle.docker:gradle-docker:0.13.0')
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后最后应用插件并调用其任务：</p>
</div>
<div class="paragraph">
<p><code>build.gradle</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">apply plugin: 'com.palantir.docker'

group = 'myorg'

bootJar {
    baseName = 'myapp'
    version =  '0.1.0'
}

task unpack(type: Copy) {
    dependsOn bootJar
    from(zipTree(tasks.bootJar.outputs.files.singleFile))
    into("build/dependency")
}
docker {
    name "${project.group}/${bootJar.baseName}"
    copySpec.from(tasks.unpack.outputs).into("dependency")
    buildArgs(['DEPENDENCY': "dependency"])
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此示例中，我们选择在<code>build</code>目录中的特定位置解压缩Spring Boot胖子罐，该目录是docker构建的根目录。然后，上面的多层（不是多阶段） <code>Dockerfile</code>将起作用。</p>
</div>
</div>
<div class="sect2">
<h3 id="jib-maven-and-gradle-plugins"><a class="anchor" href="#jib-maven-and-gradle-plugins"></a> Jib Maven和Gradle插件</h3>
<div class="paragraph">
<p>Google有一个名为<a href="https://github.com/GoogleContainerTools/jib">Jib的</a>开源工具，它相对较新，但出于多种原因却很有趣。可能最有趣的事情是您不需要docker来运行它-它使用与从<code>docker build</code>获得的相同的标准输出来构建映像，但是除非您要求，否则不使用<code>docker</code>因此它可以在以下环境中工作没有安装docker（在构建服务器中并不罕见）。您也不需要<code>Dockerfile</code> （无论如何都会被忽略）或<code>pom.xml</code>任何内容来获取在Maven中构建的映像（Gradle要求您至少将插件安装在<code>build.gradle</code> ）。</p>
</div>
<div class="paragraph">
<p>Jib的另一个有趣的功能是，它对层有<code>Dockerfile</code> ，并且以与上面创建的多层<code>Dockerfile</code>稍有不同的方式优化了它们。就像在胖子罐中一样，Jib将本地应用程序资源与依赖项分离开来，但它走得更远，而且还将快照依赖项放入一个单独的层中，因为它们更容易发生变化。有一些配置选项可用于进一步自定义布局。</p>
</div>
<div class="paragraph">
<p>Maven的示例（不更改<code>pom.xml</code> ）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ mvn com.google.cloud.tools:jib-maven-plugin:build -Dimage=myorg/myapp</code></pre>
</div>
</div>
<div class="paragraph">
<p>要运行上述命令，您将需要具有在<code>myorg</code>存储库前缀下推送到Dockerhub的权限。如果您有认证<code>docker</code>在命令行上，将从您的本地工作<code>~/.docker</code>配置。您也可以在<code>~/.m2/settings.xml</code> （重要的信息库ios的<code>id</code>中<code>~/.m2/settings.xml</code> Maven“服务器”身份验证：</p>
</div>
<div class="paragraph">
<p><code>settings.xml</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>    <server>
      <id>registry.hub.docker.com</id>
      <username>myorg</username>
      <password>...</password>
    </server></code></pre>
</div>
</div>
<div class="paragraph">
<p>还有其他的选择，比如，你可以对一个码头工人守护本地构建（就像跑<code>docker</code>在命令行），使用<code>dockerBuild</code>目标，而不是<code>build</code> 。还支持其他容器注册表，对于每个容器注册表，您将需要通过docker或Maven设置来设置本地身份验证。</p>
</div>
<div class="paragraph">
<p>该插件的Gradle也有类似的功能，一旦你拥有了它在你<code>build.gradle</code> ，如</p>
</div>
<div class="paragraph">
<p><code>build.gradle</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">plugins {
  ...
  id 'com.google.cloud.tools.jib' version '0.9.11'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或使用入门指南中使用的较旧样式：</p>
</div>
<div class="paragraph">
<p><code>build.gradle</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-groovy" data-lang="groovy">buildscript {
    repositories {
      maven {
        url "https://plugins.gradle.org/m2/"
      }
      mavenCentral()
    }
    dependencies {
        classpath('org.springframework.boot:spring-boot-gradle-plugin:2.0.5.RELEASE')
        classpath('com.google.cloud.tools.jib:com.google.cloud.tools.jib.gradle.plugin:0.9.11')
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后您可以用</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ ./gradlew jib --image=myorg/myapp</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于与Maven构建，如果已经使用认证<code>docker</code>在命令行上，图像推将从本地认证<code>~/.docker</code>配置。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="continuous-integration"><a class="anchor" href="#continuous-integration"></a>持续集成</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如今（或应该如此），自动化已成为每个应用程序生命周期的一部分。人们用来实现自动化的工具往往非常擅长从源代码调用构建系统。因此，如果您得到一个docker映像，并且构建代理中的环境与开发人员自己的环境充分对齐，则可能就足够了。向Docker注册表进行身份验证可能是最大的挑战，但是所有自动化工具中都有一些功能可以帮助实现这一点。</p>
</div>
<div class="paragraph">
<p>但是，有时最好将容器创建完全留给自动化层，在这种情况下，可能不需要污染用户的代码。容器创建非常棘手，开发人员有时并不真正在意它。如果用户代码更干净，则其他工具更有可能“做正确的事”，应用安全修复程序，优化缓存等。有多种自动化选项，并且这些天它们都具有与容器相关的某些功能。我们只看几个。</p>
</div>
<div class="sect2">
<h3 id="concourse"><a class="anchor" href="#concourse"></a>大堂</h3>
<div class="paragraph">
<p><a href="https://concourse-ci.org">Concourse</a>是基于管道的自动化平台，可用于CI和CD。它在Pivotal内部大量使用，该项目的主要作者在那里工作。除CLI外，Concourse中的所有内容都是无状态的，并且所有内容都在容器中运行。由于运行容器是自动化管道的主要业务顺序，因此很好地支持创建容器。如果它是容器映像，则<a href="https://github.com/concourse/docker-image-resource">Docker Image Resource</a>负责使构建的输出状态保持最新。</p>
</div>
<div class="paragraph">
<p>这是一个示例管道，为上面的示例构建一个docker映像，假设它位于<code>myorg/myapp</code> github中，并且在根目录下有一个<code>Dockerfile</code> ，并且在<code>src/main/ci/build.yml</code>具有一个构建任务声明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>resources:
- name: myapp
  type: git
  source:
    uri: https://github.com/myorg/myapp.git
- name: myapp-image
  type: docker-image
  source:
    email: {{docker-hub-email}}
    username: {{docker-hub-username}}
    password: {{docker-hub-password}}
    repository: myorg/myapp

jobs:
- name: main
  plan:
  - task: build
    file: myapp/src/main/ci/build.yml
  - put: myapp-image
    params:
      build: myapp</code></pre>
</div>
</div>
<div class="paragraph">
<p>管道的结构非常具有声明性：您定义“资源”（输入或输出或两者），以及“作业”（使用并向资源应用操作）。如果任何输入资源发生更改，则会触发新的构建。如果作业期间任何输出资源发生更改，则将对其进行更新。</p>
</div>
<div class="paragraph">
<p>可以在与应用程序源代码不同的位置定义管道。对于通用构建设置，任务声明也可以集中或外部化。如果这是滚动的方式，则可以将开发和自动化之间的关注点分离开。</p>
</div>
</div>
<div class="sect2">
<h3 id="jenkins"><a class="anchor" href="#jenkins"></a>詹金斯</h3>
<div class="paragraph">
<p><a href="https://jenkins.io">Jenkins</a>是另一种流行的自动化服务器。它具有广泛的功能，但此处最接近其他自动化示例的功能是<a href="https://jenkins.io/doc/book/pipeline/docker/">管道</a>功能。这是一个<code>Jenkinsfile</code> ，它使用Maven构建Spring Boot项目，然后使用<code>Dockerfile</code>构建映像并将其推送到存储库：</p>
</div>
<div class="paragraph">
<p><code>Jenkinsfile</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>node {
    checkout scm
    sh './mvnw -B -DskipTests clean package'
    docker.build("myorg/myapp").push()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于需要在构建服务器验证的（现实的）泊坞窗库，你可以添加凭据<code>docker</code>使用上述目的<code>docker.withCredentials(…​)</code></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="buildpacks"><a class="anchor" href="#buildpacks"></a>构建包</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://www.cloudfoundry.org/">Cloud Foundry</a>多年来一直在内部使用容器，用于将用户代码转换为容器的技术的一部分是Build Packs，该思想最初是从<a href="https://www.heroku.com/">Heroku</a>借来的。当前的buildpacks（v2）生成通用二进制输出，该输出由平台组装到容器中。<a href="https://buildpacks.io/">新一代的buildpack</a> （v3）是Heroku与其他公司（包括Pivotal）之间的合作，可以直接且显式地构建容器映像。这对于开发人员和运营商来说非常有趣。开发人员不需要太在乎如何构建容器的细节，但是如果需要，他们可以轻松地创建一个容器。Buildpacks还具有许多用于缓存生成结果和依赖项的功能，因此，Buildpack的运行速度要比本地Docker构建快得多。操作员可以扫描容器以审核其内容并进行转换以修补它们以进行安全更新。您可以在本地（例如，在开发人员机器上或在CI服务中）或在Cloud Foundry之类的平台上运行构建包。</p>
</div>
<div class="paragraph">
<p>buildpack生命周期的输出是一个容器映像，但是您不需要<code>Dockerfile</code>或<code>Dockerfile</code> ，因此它是CI和自动化友好的。输出映像中的文件系统层由buildpack控制，通常，将进行许多优化而无需开发人员知道或关心它们。在较低层（如包含操作系统的基础映像）与较高层（如包含中间件和特定于语言的依赖关系）之间还有一个<a href="https://en.wikipedia.org/wiki/Application_binary_interface">应用程序二进制接口</a> 。如果存在安全更新，则Cloud Foundry这样的平台可以修补较低的层，而不会影响应用程序的完整性和功能。</p>
</div>
<div class="paragraph">
<p>为了让您了解buildpack的功能，这里是从命令行使用<a href="https://github.com/buildpack/pack">Pack CLI</a>的示例（它将与本文中使用的示例应用程序一起使用，不需要<code>Dockerfile</code>或任何特殊的构建配置） ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ pack build myorg/myapp --builder=nebhale/java-build --path=.
2018/11/07 09:54:48 Pulling builder image 'nebhale/java-build' (use --no-pull flag to skip this step)
2018/11/07 09:54:49 Selected run image 'packs/run' from stack 'io.buildpacks.stacks.bionic'
2018/11/07 09:54:49 Pulling run image 'packs/run' (use --no-pull flag to skip this step)
*** DETECTING:
2018/11/07 09:54:52 Group: Cloud Foundry OpenJDK Buildpack: pass | Cloud Foundry Build System Buildpack: pass | Cloud Foundry JVM Application Buildpack: pass
*** ANALYZING: Reading information from previous image for possible re-use
*** BUILDING:
-----> Cloud Foundry OpenJDK Buildpack 1.0.0-BUILD-SNAPSHOT
-----> OpenJDK JDK 1.8.192: Reusing cached dependency
-----> OpenJDK JRE 1.8.192: Reusing cached launch layer

-----> Cloud Foundry Build System Buildpack 1.0.0-BUILD-SNAPSHOT
-----> Using Maven wrapper
       Linking Maven Cache to /home/pack/.m2
-----> Building application
       Running /workspace/app/mvnw -Dmaven.test.skip=true package
...
---> Running in e6c4a94240c2
---> 4f3a96a4f38c
---> 4f3a96a4f38c
Successfully built 4f3a96a4f38c
Successfully tagged myorg/myapp:latest
$ docker run -p 8080:8080 myorg/myapp
  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v2.0.5.RELEASE)

2018-11-07 09:41:06.390  INFO 1 --- [ main] hello.Application: Starting Application on 1989fb9a00a4 with PID 1 (/workspace/app/BOOT-INF/classes started by pack in /workspace/app)
...</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>--builder</code>是运行buildpack生命周期的<code>--builder</code>映像-通常，它将是所有开发人员或单个平台上所有开发人员的共享资源。这是Ben Hale的工作，Ben Hale为Cloud Foundry维护了较旧的构建包，现在正在开发新一代产品。在这种情况下，输出将发送到本地docker守护程序，但是在自动化平台中，它可能是docker注册表。<code>pack</code> CLI稳定发布后，默认的构建器可能会做同样的事情。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="knative"><a class="anchor" href="#knative"></a>基尼特语</h2>
<div class="sectionbody">
<div class="paragraph">
<p>容器和平台领域的另一个新项目是<a href="https://cloud.google.com/knative/">Knative</a> 。Knative有很多东西，但是如果您不熟悉Knative，则可以将其视为构建无服务器平台的基础。它基于<a href="https://kubernetes.io">Kubernetes</a>构建，因此最终它会使用容器映像，并在平台上将它们转换为应用程序或“服务”。但是，它的主要功能之一是能够使用源代码并为您构建容器，从而使其对开发人员和操作员更友好。<a href="https://github.com/knative/build">Knative Build</a>是执行此操作的组件，它本身就是一个将用户代码转换为容器的灵活平台-您几乎可以按照自己喜欢的任何方式进行操作。一些模板提供了常见的模式，例如Maven和Gradle构建，以及使用<a href="https://github.com/GoogleContainerTools/kaniko">Kaniko的</a>多阶段<a href="https://github.com/GoogleContainerTools/kaniko">docker</a>构建。还有一个使用<a href="https://github.com/knative/build-templates/tree/master/buildpack">Buildpacks</a>的模板，这对我们来说很有趣，因为buildpacks一直对Spring Boot具有良好的支持。Knative上的Buildpack也是<a href="https://projectriff.io">Riff</a>和<a href="https://pivotal.io/platform/pivotal-function-service">Pivotal Function Service的</a>明智选择，用于将用户功能转换为正在运行的无服务器应用程序。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="closing"><a class="anchor" href="#closing"></a>闭幕</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本文介绍了许多用于为Spring Boot应用程序构建容器映像的选项。所有这些都是完全有效的选择，现在由您决定需要哪一个。您的第一个问题应该是“我真的需要构建容器映像吗？如果答案是“是”，那么您的选择可能会受到效率和可缓存性以及关注点分离的影响。您是否希望使开发人员不必过多地了解如何创建容器映像？当需要修补操作系统和中间件漏洞时，是否要让开发人员负责更新映像？也许开发人员需要对整个过程进行完全控制，并且他们拥有所需的所有工具和知识。</p>
</div>
</div>
</div></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">var disqus_shortname = 'spring-io';
      var disqus_identifier = 3468;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));</script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });</script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>