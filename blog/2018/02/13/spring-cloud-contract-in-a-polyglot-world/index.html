<!DOCTYPE html>
<html data-code-prettify="" data-mobile-support="" data-search="">
<head>
<title>Spring Cloud Contract in a polyglot world</title>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no" id="Viewport" name="viewport" />
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png" />
<link href="https://fonts.googleapis.com/css?family=Varela+Round|Montserrat:400,700" rel="stylesheet" type="text/css" />
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css" />
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M" name="google-site-verification" />

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css" />

<meta content="summary" name="twitter:card" />
<meta content="@springcentral" name="twitter:site" />
<meta name="twitter:title" content="Spring Cloud Contract in a polyglot world" />
<meta name="twitter:description" content="&lt;div class=&quot;paragraph&quot;&gt; 
 &lt;p&gt;This article contains a short reminder of what Contract Testing is, how Spring Cloud Contract implements it, and how Spring Cloud Contract can be used in a polyglot world.&lt;/p&gt; 
&lt;/div&gt;
&lt;h1 id=&quot;what-is-contract-testing&quot; class=&quot;sect0&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#what-is-contract-testing&quot;&gt;&lt;/a&gt;What is Contract Testing&lt;/h1&gt;
&lt;div class=&quot;paragraph&quot;&gt; 
 &lt;p&gt;In order to increase the certainty that our systems behave properly, we write different types of tests. According to the &lt;a href=&quot;https://martinfowler.com/bliki/TestPyramid.html&quot;&gt;test pyramid&lt;/a&gt; the main types of tests are unit, integration, and UI. The more complex the tests, the more time and effort they require and the more brittle they become.&lt;/p&gt; 
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt; 
 &lt;p&gt;In a distributed system, one of the most frequent problems is testing integrations between applications. Let’s assume that your service sends a REST request to another application. When using Spring Boot, you can write a &lt;code&gt;@SpringBootTest&lt;/code&gt; in which you test that behavior. You set up a Spring context, you prepare a request to be sent…​ and where do you send it? You haven’t started the other application, so you get a &lt;code&gt;Connection Refused&lt;/code&gt; exception. You can try mocking the real HTTP call and returning a fake response. However, if you do that, you do not test any real HTTP integration, serialization and deserialization mechanisms, and so on. You could also start a fake HTTP server (for example, &lt;a href=&quot;http://wiremock.org&quot;&gt;WireMock&lt;/a&gt;) and simulate how it should behave. The problem here is that you, as a client of an API, define how the server behaves. In other words, if you tell the fake server to return text &lt;code&gt;testText&lt;/code&gt; when a request is sent to endpoint &lt;code&gt;/myEndpoint&lt;/code&gt;, it does just that, even if the real server does not have such an endpoint. In short, the problem is that the stubs might not be reliable.&lt;/p&gt; 
&lt;/div&gt;
" />
<meta name="twitter:creator" content="@mgrzejszczak" />
<meta name="twitter:image:src" content="https://gravatar.com/avatar/d4b43000c99fccc46455f42a841fa62e?s=200" />

<meta property="og:title" content="Spring Cloud Contract in a polyglot world" />
<meta property="og:image" content="https://gravatar.com/avatar/d4b43000c99fccc46455f42a841fa62e?s=200" />
<meta property="og:description" content="&lt;div class=&quot;paragraph&quot;&gt; 
 &lt;p&gt;This article contains a short reminder of what Contract Testing is, how Spring Cloud Contract implements it, and how Spring Cloud Contract can be used in a polyglot world.&lt;/p&gt; 
&lt;/div&gt;
&lt;h1 id=&quot;what-is-contract-testing&quot; class=&quot;sect0&quot;&gt;&lt;a class=&quot;anchor&quot; href=&quot;#what-is-contract-testing&quot;&gt;&lt;/a&gt;What is Contract Testing&lt;/h1&gt;
&lt;div class=&quot;paragraph&quot;&gt; 
 &lt;p&gt;In order to increase the certainty that our systems behave properly, we write different types of tests. According to the &lt;a href=&quot;https://martinfowler.com/bliki/TestPyramid.html&quot;&gt;test pyramid&lt;/a&gt; the main types of tests are unit, integration, and UI. The more complex the tests, the more time and effort they require and the more brittle they become.&lt;/p&gt; 
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt; 
 &lt;p&gt;In a distributed system, one of the most frequent problems is testing integrations between applications. Let’s assume that your service sends a REST request to another application. When using Spring Boot, you can write a &lt;code&gt;@SpringBootTest&lt;/code&gt; in which you test that behavior. You set up a Spring context, you prepare a request to be sent…​ and where do you send it? You haven’t started the other application, so you get a &lt;code&gt;Connection Refused&lt;/code&gt; exception. You can try mocking the real HTTP call and returning a fake response. However, if you do that, you do not test any real HTTP integration, serialization and deserialization mechanisms, and so on. You could also start a fake HTTP server (for example, &lt;a href=&quot;http://wiremock.org&quot;&gt;WireMock&lt;/a&gt;) and simulate how it should behave. The problem here is that you, as a client of an API, define how the server behaves. In other words, if you tell the fake server to return text &lt;code&gt;testText&lt;/code&gt; when a request is sent to endpoint &lt;code&gt;/myEndpoint&lt;/code&gt;, it does just that, even if the real server does not have such an endpoint. In short, the problem is that the stubs might not be reliable.&lt;/p&gt; 
&lt;/div&gt;
" />
<meta content="article" property="og:type" />
<meta property="og:article:published_time" content="2018-02-13 20:37:00.0" />
</head>
<body>

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" style="display:none;visibility:hidden" width="0"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">Projects</a>
</li>
<li class="navbar-link">
<a href="/guides">Guides</a>
</li>
<li class="navbar-link active">
<a href="/blog">Blog</a>
</li>
<li class="navbar-link">
<a href="/services">Training & Certification</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form action="/search" class="form-inline form-search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search for documentation, guides, and posts..." type="text" value="" />
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form action="/search" class="form-inline form-search" method="get">
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search..." type="text" value="" />
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">
Home
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">
Projects
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">
Guides
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">
Blog
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">
Training & Certification
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>Engineering</div>
</div>
<div class="blog-category content--title">
<div>Releases</div>
</div>
<div class="blog-category content--title">
<div>News and Events</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Spring Cloud Contract in a polyglot world</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">Engineering</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/d4b43000c99fccc46455f42a841fa62e?s=20&amp;d=mm" />
<a class="author" rel="author" href="/team/marcingrzejszczak">Marcin Grzejszczak</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2018-02-13 20:37:00.0">February 13, 2018</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" data-disqus-identifier="3169" href="/blog/2018/02/13/spring-cloud-contract-in-a-polyglot-world#disqus_thread">
</a></div>
</div>
</header>
<div class="blog--post"><div class="paragraph">
<p>This article contains a short reminder of what Contract Testing is, how Spring Cloud Contract implements it, and how Spring Cloud Contract can be used in a polyglot world.</p>
</div>
<h1 id="what-is-contract-testing" class="sect0"><a class="anchor" href="#what-is-contract-testing"></a>What is Contract Testing</h1>
<div class="paragraph">
<p>In order to increase the certainty that our systems behave properly, we write different types of tests. According to the <a href="https://martinfowler.com/bliki/TestPyramid.html">test pyramid</a> the main types of tests are unit, integration, and UI. The more complex the tests, the more time and effort they require and the more brittle they become.</p>
</div>
<div class="paragraph">
<p>In a distributed system, one of the most frequent problems is testing integrations between applications. Let&#8217;s assume that your service sends a REST request to another application. When using Spring Boot, you can write a <code>@SpringBootTest</code> in which you test that behavior. You set up a Spring context, you prepare a request to be sent&#8230;&#8203; and where do you send it? You haven&#8217;t started the other application, so you get a <code>Connection Refused</code> exception. You can try mocking the real HTTP call and returning a fake response. However, if you do that, you do not test any real HTTP integration, serialization and deserialization mechanisms, and so on. You could also start a fake HTTP server (for example, <a href="http://wiremock.org">WireMock</a>) and simulate how it should behave. The problem here is that you, as a client of an API, define how the server behaves. In other words, if you tell the fake server to return text <code>testText</code> when a request is sent to endpoint <code>/myEndpoint</code>, it does just that, even if the real server does not have such an endpoint. In short, the problem is that the stubs might not be reliable.</p>
</div>
<div class="paragraph">
<p>Another problem is integration with third-party systems. There may be a shared instance that breaks down every 5 minutes due to high load. In that situation we would like to stub that system out so that it doesn&#8217;t influence our integration tests, but we need those stubs to be reliable.</p>
</div>
<div class="paragraph">
<p>It&#8217;s always tempting to set up an environment for end-to-end tests, spawn all applications, and perform tests by running though the whole system. Often, that&#8217;s a good solution that increases the confidence that your business features are still working fine. However, the problem with end-to-end tests is that they often fail for no apparent reason and are very slow. There is nothing more frustrating than seeing that, after running for ten hours, the end-to-end tests have failed due to a typo in the API call.</p>
</div>
<div class="paragraph">
<p>A potential solution to this problem are Contract Tests. Before we go into details of what those are, let&#8217;s define some terms:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>producer</strong>: The server-side owner (for example, the owner of a HTTP API) or a producer of a message sent through a queue, such as RabbitMQ.</p>
</li>
<li>
<p><strong>consumer</strong>: The application that consumes the HTTP API or listens to messages received through (for example) RabbitMQ.</p>
</li>
<li>
<p><strong>contract</strong>: An agreement between the producer and the consumer on what the communication should look like. <strong>It is not a schema</strong>. It is more of a scenario of usage. For example, for this particular scenario, I expect a specified input and then I reply with a specified output.</p>
</li>
<li>
<p><strong>contract test</strong>: A test that verifies that the producer and the consumer can integrate with each other. <strong>It does not mean that the functionality works</strong>. This distinction is important, because you would not want to duplicate your work by writing a contract for each feature. Contract tests assert that the integration between the producer and the consumer meets the requirements defined in the contract. Their main advantage is that they are fast and reliable.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example shows a contract written in YAML:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-yml" data-lang="yml">request: # (1)
  method: PUT # (2)
  url: /fraudcheck # (3)
  body: # (4)
    "client.id": 1234567890
    loanAmount: 99999
  headers: # (5)
    Content-Type: application/json
  matchers:
    body:
      - path: $.['client.id'] # (6)
        type: by_regex
        value: "[0-9]{10}"
response: # (7)
  status: 200 # (8)
  body:  # (9)
    fraudCheckStatus: "FRAUD"
    "rejection.reason": "Amount too high"
  headers: # (10)
    Content-Type: application/json;charset=UTF-8


#From the Consumer perspective, when running a request in the integration test, we can interpret that test as follows:
#
#(1) - If the consumer sends a request
#(2) - With the "PUT" method
#(3) - to the URL "/fraudcheck"
#(4) - with the JSON body that
# * has a `client.id` field
# * has a `loanAmount` field that is equal to `99999`
#(5) - with `Content-Type` header equal to `application/json`
#(6) - and a `client.id` json entry matches a regular expression of `[0-9]{10}`
#(7) - then the response is sent with
#(8) - status equal to `200`
#(9) - and JSON body equal to
# { "fraudCheckStatus": "FRAUD", "rejection.reason": "Amount too high" }
#(10) - with header `Content-Type` equal to `application/json`
#
#From the Producer perspective, in the autogenerated producer-side test, we can interpret that test as follows:
#
#(1) - A request is sent to the producer
#(2) - With the "PUT" method
#(3) - to the URL "/fraudcheck"
#(4) - with the JSON body that
# * has a `client.id` field with a value of `1234567890`
# * has a `loanAmount` field with a value of `99999`
#(5) - with a `Content-Type` header equal to `application/json`
#(7) - then the test asserts if the response has been sent with
#(8) - status equal `200`
#(9) - and a JSON body equal to
# { "fraudCheckStatus": "FRAUD", "rejection.reason": "Amount too high" }
#(10) - with a `Content-Type` header equal to `application/json;charset=UTF-8`</code></pre>
</div>
</div>
<div class="paragraph">
<p>This article focuses on two main types of contract tests: Producer Contract testing and Consumer-Driven Contract testing. The main difference between them is the cooperation style of the producer and the consumer.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In the <strong>Producer Contract</strong> testing approach, the producer defines the contracts and writes the contract tests, describes the API, and publishes the stubs without any cooperation with its clients. Often, this happens when the API is public and the owners of the API don&#8217;t even know who exactly is using it. An example is <a href="https://start.spring.io">Spring Initializr</a>, which publishes its stubs with <a href="https://cloud.spring.io/spring-cloud-static/Edgware.SR2/multi/multi__spring_cloud_contract_wiremock.html#_generating_stubs_using_rest_docs">Spring Rest Docs</a> tests. The stubs for version <code>0.5.0.BUILD-SNAPSHOT</code> are available <a href="https://repo.spring.io/libs-snapshot/io/spring/initializr/initializr-web/0.5.0.BUILD-SNAPSHOT/">here with the <code>stubs</code> classifier</a>.</p>
</li>
<li>
<p>In the <strong>Consumer-Driven Contract</strong> testing approach, the contracts are suggested by the consumers, in strong cooperation with the producer. The producer knows exactly which consumer defined which contract and which one gets broken when the contract compatibility gets broken. This approach is more common when working with an internal API.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In both cases, the contracts can be defined in the repository of the producer (either defined with a DSL or by writing contract tests) or an external repo where all the contracts are stored.</p>
</div>
<h1 id="introduction-to-maven-nomenclature" class="sect0"><a class="anchor" href="#introduction-to-maven-nomenclature"></a>Introduction to Maven Nomenclature</h1>
<div class="paragraph">
<p>Since it&#8217;s much easier now to use Spring Cloud Contract for non-JVM projects, it&#8217;s good to explain the basic terms behind the packaging defaults and introduce the <a href="https://maven.apache.org/">Maven</a> nomenclature.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
Apache Maven is a software project management and comprehension tool. Based on the concept of a project object model (POM), Maven can manage a project&#8217;s build, reporting, and documentation from a central piece of information. (See <a href="https://maven.apache.org/" class="bare">https://maven.apache.org/</a>)
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>(Part of the following definitions were taken from the <a href="https://maven.apache.org/glossary.html">Maven Glossary</a>.)</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Project</code>: Maven thinks in terms of projects. Everything that you build are projects. Those projects follow a well defined
"Project Object Model". Projects can depend on other projects, in which case the latter are called "dependencies". A project may
consistent of several subprojects. However, these subprojects are still treated as projects.</p>
</li>
<li>
<p><code>Artifact</code>: An artifact is something that is either produced or used by a project. Examples of artifacts produced by Maven for a project
include JARs and source and binary distributions. Each artifact is uniquely identified by a group ID and an artifact ID, which is
unique within a group.</p>
</li>
<li>
<p><code>JAR</code>: JAR stands for Java ARchive. It&#8217;s a format based on the ZIP file format. Spring Cloud Contract packages the contracts and generated stubs in a JAR file.</p>
</li>
<li>
<p><code>GroupId</code>: A group ID is a universally unique identifier for a project. While this is often the project name (for example, <code>commons-collections</code>), it is helpful to use a fully-qualified package name to distinguish it from other projects with a similar name (for example, <code>org.apache.maven</code>). Typically, when published to the Artifact Manager, the <code>GroupId</code> gets slash separated and forms part of the URL. For example, for a group ID of <code>com.example</code>, an artifact ID for <code>application</code> would be <code>/com/example/application/</code>.</p>
</li>
<li>
<p><code>Classifier</code>: The Maven dependency notation looks as follows: <code>groupId:artifactId:version:classifier</code>. The classifier is an additional suffix passed to the dependency (for example <code>stubs</code> or <code>sources</code>). The same dependency (for example,<code>com.example:application</code>) can produce multiple artifacts that differ from each other by the classifier.</p>
</li>
<li>
<p><code>Artifact manager</code>: When you generate binaries, sources, or packages, you would like them to be available for others to download, reference, or reuse. In the JVM world, those artifacts would be JARs. For Ruby, these would be gems. For Docker, they would be Docker images. You can store those artifacts in a manager. Examples of such managers include <a href="https://jfrog.com/artifactory/">Artifactory</a>
and <a href="http://www.sonatype.org/nexus/">Nexus</a>.</p>
</li>
</ul>
</div>
<h1 id="what-is-spring-cloud-contract" class="sect0"><a class="anchor" href="#what-is-spring-cloud-contract"></a>What is Spring Cloud Contract</h1>
<div class="paragraph">
<p><a href="https://cloud.spring.io/spring-cloud-contract/">Spring Cloud Contract</a> is an umbrella project holding solutions that help users to implement different sorts of contract tests. It comes with two main modules: <code>Spring Cloud Contract Verifier</code>, which is used mainly by the producer side, and <code>Spring Cloud Contract Stub Runner</code>, which is used by the consumer side.</p>
</div>
<div class="paragraph">
<p>The project lets you define contracts using:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://www.groovy-lang.org/">Groovy DSL</a></p>
</li>
<li>
<p><a href="http://yaml.org/">YAML</a></p>
</li>
<li>
<p><a href="https://docs.pact.io/">Pact JSON</a></p>
</li>
<li>
<p><a href="https://cloud.spring.io/spring-cloud-static/Edgware.SR2/multi/multi__spring_cloud_contract_wiremock.html#_generating_stubs_using_rest_docs">Spring Rest Docs</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s assume that we&#8217;ve decided to write the contracts using YAML. On the producer side, from the contracts:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Tests are generated with a Maven or <a href="https://gradle.org/">Gradle</a> plugin to assert that the contract is met.</p>
</li>
<li>
<p>Stubs are generated for other projects to reuse.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The simplified flow of the producer contract approach, for a JVM application using Spring Cloud Contract with YAML contracts goes as follows.</p>
</div>
<div class="paragraph">
<p>The producer:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Applies a Maven or Gradle Spring Cloud Contract plugin.</p>
</li>
<li>
<p>Defines YAML contracts under <code>src/test/resources/contracts/</code>.</p>
</li>
<li>
<p>Generates tests and stubs from the contract.</p>
</li>
<li>
<p>Creates a base class that extends the generated tests and sets up the test context.</p>
</li>
<li>
<p>Once the tests pass, creates a JAR with <code>stubs</code> classifier where contracts and stubs are stored.</p>
</li>
<li>
<p>Uploads the JAR with a <code>stubs</code> classifier to binary storage.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The consumer:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Uses Stub Runner to fetch the stubs of the producer. Stub Runner starts in memory HTTP servers (by default, those are <a href="https://wiremock.org">WireMock servers</a>) fed with the stubs.</p>
</li>
<li>
<p>Runs tests against the stubs.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Consequently, using Spring Cloud Contract and Contract Testing gives you:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>stubs reliability: They were generated only after the tests have passed.</p>
</li>
<li>
<p>stubs reusability: They can be downloaded and reused by multiple consumers.</p>
</li>
</ul>
</div>
<h1 id="what-is-the-current-problem-with-spring-cloud-contract" class="sect0"><a class="anchor" href="#what-is-the-current-problem-with-spring-cloud-contract"></a>What is the Current "Problem" with Spring Cloud Contract</h1>
<div class="paragraph">
<p>Distibuted systems are set up from applications written in different languages and frameworks. One of the "problems" with Spring Cloud Contract was that the DSL had to be written in Groovy. Even though the contract didn&#8217;t require any special knowledge of the language, it became a problem for non-JVM users.</p>
</div>
<div class="paragraph">
<p>On the producer side, Spring Cloud Contract generates tests in Java or Groovy. Of course, it became a problem to use those tests in a non-JVM environment. Not only do you need to have Java installed, but the tests are generated with a Maven or Gradle plugin, which requires using those build tools.</p>
</div>
<h1 id="spring-cloud-contract-and-polyglot-support" class="sect0"><a class="anchor" href="#spring-cloud-contract-and-polyglot-support"></a>Spring Cloud Contract and Polyglot Support</h1>
<div class="paragraph">
<p>Starting with the <code>Edgware.SR2</code> release train and <code>1.2.3.RELEASE</code> of Spring Cloud Contract, we decided to add features that allow much wider adoption of Spring Cloud Contract in the non-JVM world.</p>
</div>
<div class="paragraph">
<p>We added support for writing contracts with YAML. YAML is a (yet another) markup language that is not bound to any specific language and is already widely used. That should tackle the "problem" of defining contracts using a DSL that is related to any specific language.</p>
</div>
<div class="paragraph">
<p>In order to hide the implementation details (such as generation of java tests, plugin setup, or Java installation), we needed to introduce a layer of abstraction. We decided to hide those by using <a href="https://www.docker.com/">Docker</a> images. We encapsulated all the project setup, required packages, and folder structures inside a docker image in such a way that no knowledge, other than required environment variables, is required from the user.</p>
</div>
<div class="paragraph">
<p>We introduced Docker images for both the <a href="https://cloud.spring.io/spring-cloud-static/Edgware.SR2/single/spring-cloud.html#docker-project">producer</a> and the <a href="https://cloud.spring.io/spring-cloud-static/Edgware.SR2/single/spring-cloud.html#stubrunner-docker">consumer</a>. All the JVM-related logic gets wrapped in a Docker container, which means that you don&#8217;t have to have Java installed to generate tests and run the stubs with Stub Runner.</p>
</div>
<div class="paragraph">
<p>The following sections go through an example of a NodeJS application being tested by using Spring Cloud Contract. The code was forked from <a href="https://github.com/bradtraversy/bookstore" class="bare">https://github.com/bradtraversy/bookstore</a> and is available under <a href="https://github.com/spring-cloud-samples/spring-cloud-contract-nodejs" class="bare">https://github.com/spring-cloud-samples/spring-cloud-contract-nodejs</a>. Our aim is to start generating tests and stubs for an existing application as quickly as possible with the least effort.</p>
</div>
<h1 id="spring-cloud-contract-on-the-producer-side" class="sect0"><a class="anchor" href="#spring-cloud-contract-on-the-producer-side"></a>Spring Cloud Contract on the Producer Side</h1>
<div class="paragraph">
<p>Let&#8217;s clone the simple NodeJS MVC application, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-bash" data-lang="bash">$ git clone https://github.com/spring-cloud-samples/spring-cloud-contract-nodejs
$ cd spring-cloud-contract-nodejs</code></pre>
</div>
</div>
<div class="paragraph">
<p>It connects to a Mongo DB database to store data about books.</p>
</div>
<div class="paragraph">
<p>The YAML contracts are available under the <code>/contracts</code> folder, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-bash" data-lang="bash">$ ls contracts
1_shouldAddABook.yml          2_shouldReturnListOfBooks.yml</code></pre>
</div>
</div>
<div class="paragraph">
<p>The numerical suffixes tell Spring Cloud Contract that the tests generated from these contracts need to be executed sequentially. The stubs are stateful, meaning that, only after performing a request matched by <code>1_shouldAddABook</code> is the <code>2_shouldReturnListOfBooks.yml</code> be available from the stubbed HTTP server.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
In a real-life example, we would run our NodeJS application in a contract testing mode where calls to the database would be stubbed out and there would be no need for stateful stubs. In this example, we want to show how we can benefit from Spring Cloud Contract in no time.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let&#8217;s take a look at one of the stubs:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-yml" data-lang="yml">description: |
  Should add a book
request:
  method: POST
  url: /api/books
  headers:
    Content-Type: application/json
  body: '{
    "title" : "Title",
    "genre" : "Genre",
    "description" : "Description",
    "author" : "Author",
    "publisher" : "Publisher",
    "pages" : 100,
    "image_url" : "https://d213dhlpdb53mu.cloudfront.net/assets/pivotal-square-logo-41418bd391196c3022f3cd9f3959b3f6d7764c47873d858583384e759c7db435.svg",
    "buy_url" : "https://pivotal.io"
  }'
response:
  status: 200</code></pre>
</div>
</div>
<div class="paragraph">
<p>The contract states that, if a <code>POST</code> request is sent to <code>/api/books</code> with a header of <code>Content-Type: application/json</code> and the aforementioned body, then the response should be <code>200</code>. Now, before running the contract tests, let&#8217;s analyze the Spring Cloud Contract docker image requirements.</p>
</div>
<div class="sect1">
<h2 id="spring-cloud-contract-docker-image"><a class="anchor" href="#spring-cloud-contract-docker-image"></a>Spring Cloud Contract Docker Image</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The image is available on <a href="https://hub.docker.com/r/springcloud/spring-cloud-contract/">DockerHub under SpringCloud org</a>.</p>
</div>
<div class="paragraph">
<p>Once you mount your contracts and pass the environment variables, the image:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Generates the contract tests.</p>
</li>
<li>
<p>Executes the tests against the provided URL.</p>
</li>
<li>
<p>Generates the <a href="http://wiremock.org">WireMock</a> stubs.</p>
</li>
<li>
<p>Publishes the stubs to the Artifact Manager. (This step is optional but turned on by default.)</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
The generated tests assume that your application is running and ready to listen to requests on the specified port. That means you have to run it before running the contract tests.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-cloud-contract-docker-image-setup"><a class="anchor" href="#spring-cloud-contract-docker-image-setup"></a>Spring Cloud Contract Docker Image setup</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Docker image searches for contracts under the <code>/contracts</code> folder. The output from running the tests is available under the <code>/spring-cloud-contract/build</code> folder (it&#8217;s useful for debugging purposes). You need to mount those volumes when running the build.</p>
</div>
<div class="paragraph">
<p>The Docker image also requires some environment variables that point to your running application, to the Artifact Manager instance, and others, as described in the following list:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>PROJECT_GROUP</code>: Your project&#8217;s group ID. Defaults to <code>com.example</code>.</p>
</li>
<li>
<p><code>PROJECT_VERSION</code>: Your project&#8217;s version. Defaults to <code>0.0.1-SNAPSHOT</code>.</p>
</li>
<li>
<p><code>PROJECT_NAME</code>. The artifact ID. Defaults to <code>example</code>.</p>
</li>
<li>
<p><code>REPO_WITH_BINARIES_URL</code> - The URL of your Artifact Manager. Defaults to <code><a href="http://localhost:8081/artifactory/libs-release-local" class="bare">http://localhost:8081/artifactory/libs-release-local</a></code>,
which is the default URL of <a href="https://jfrog.com/artifactory/">Artifactory</a> when running locally.</p>
</li>
<li>
<p><code>REPO_WITH_BINARIES_USERNAME</code>: (optional) username when the Artifact Manager is secured.</p>
</li>
<li>
<p><code>REPO_WITH_BINARIES_PASSWORD</code>: (optional) password when the Artifact Manager is secured.</p>
</li>
<li>
<p><code>PUBLISH_ARTIFACTS</code>: If set to <code>true</code>, publish the artifact to binary storage. Defaults to <code>true</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following environment variables are used when tests run:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>APPLICATION_BASE_URL</code>: URL against which tests should be executed.
Remember that it has to be accessible from the Docker container (<code>localhost</code> does not work).</p>
</li>
<li>
<p><code>APPLICATION_USERNAME</code>: (optional) username for basic authentication to your application.</p>
</li>
<li>
<p><code>APPLICATION_PASSWORD</code>: (optional) password for basic authentication to your application.</p>
</li>
</ul>
</div>
</div>
</div>
<h1 id="running-spring-cloud-contract-tests-on-the-producer-side" class="sect0"><a class="anchor" href="#running-spring-cloud-contract-tests-on-the-producer-side"></a>Running Spring Cloud Contract tests on the Producer Side</h1>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
To run this sample you need to have <a href="https://www.docker.com">Docker</a>, <a href="https://docs.docker.com/compose/">Docker Compose</a> and <a href="https://docs.npmjs.com/cli/install">npm</a> installed.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Since we want to run tests, we could use:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-bash" data-lang="bash">$ npm install
$ npm test</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, for learning purposes, let&#8217;s split it into pieces, as follows (we&#8217;re going to analyze each line of a bash script):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-bash" data-lang="bash"># Install the required npm packages
$ npm install

# Stop docker infra (mongodb, artifactory)
$ ./stop_infra.sh
# Start docker infra (mongodb, artifactory)
$ ./setup_infra.sh

# Kill &amp; Run app
$ pkill -f "node app"
$ nohup node app &amp;

# Prepare environment variables
$ export SC_CONTRACT_DOCKER_VERSION="1.2.3.RELEASE"
$ export APP_IP="192.168.0.100" # This has to be the IP that is available outside of Docker container
$ export APP_PORT="3000"
$ export ARTIFACTORY_PORT="8081"
$ export APPLICATION_BASE_URL="http://${APP_IP}:${APP_PORT}"
$ export ARTIFACTORY_URL="http://${APP_IP}:${ARTIFACTORY_PORT}/artifactory/libs-release-local"
$ export CURRENT_DIR="$( pwd )"
$ export PROJECT_NAME="bookstore"
$ export PROJECT_GROUP="com.example"
$ export PROJECT_VERSION="0.0.1.RELEASE"

# Execute contract tests
$ docker run  --rm -e "APPLICATION_BASE_URL=${APPLICATION_BASE_URL}" \
-e "PUBLISH_ARTIFACTS=true" -e "PROJECT_NAME=${PROJECT_NAME}" \
-e "PROJECT_GROUP=${PROJECT_GROUP}" -e "REPO_WITH_BINARIES_URL=${ARTIFACTORY_URL}" \
-e "PROJECT_VERSION=${PROJECT_VERSION}" -v "${CURRENT_DIR}/contracts/:/contracts:ro" \
-v "${CURRENT_DIR}/node_modules/spring-cloud-contract/output:/spring-cloud-contract-output/" \
springcloud/spring-cloud-contract:"${SC_CONTRACT_DOCKER_VERSION}"

# Kill app
$ pkill -f "node app"</code></pre>
</div>
</div>
<div class="paragraph">
<p>What will happen is that, through the bash scripts:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Infrastructure (MongoDb, Artifactory) gets set up.</p>
</li>
<li>
<p>Due to the constraint that we don&#8217;t have the database mocked in the NodeJS application, the contracts also represent the stateful situation</p>
<div class="ulist">
<ul>
<li>
<p>The first request is a <code>POST</code> that causes data to get inserted to the database.</p>
</li>
<li>
<p>The second request is a <code>GET</code> that returns a list of data with one previously inserted element.</p>
</li>
</ul>
</div>
</li>
<li>
<p>The NodeJS application is started (on port <code>3000</code>) and is available at <code>192.168.0.100</code>.</p>
</li>
<li>
<p>Contract tests are generated by Docker and tests are executed against the running application.</p>
<div class="ulist">
<ul>
<li>
<p>The contracts are taken from the <code>/contracts</code> folder.</p>
</li>
<li>
<p>The output of the test execution is available at <code>node_modules/spring-cloud-contract/output</code>.</p>
</li>
</ul>
</div>
</li>
<li>
<p>The stubs are uploaded to Artifactory. You can check them out
at <a href="http://localhost:8081/artifactory/libs-release-local/com/example/bookstore/0.0.1.RELEASE/" class="bare">http://localhost:8081/artifactory/libs-release-local/com/example/bookstore/0.0.1.RELEASE/</a> .
The stubs are at <a href="http://localhost:8081/artifactory/libs-release-local/com/example/bookstore/0.0.1.RELEASE/bookstore-0.0.1.RELEASE-stubs.jar" class="bare">http://localhost:8081/artifactory/libs-release-local/com/example/bookstore/0.0.1.RELEASE/bookstore-0.0.1.RELEASE-stubs.jar</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To sum up, we defined the YAML contracts, ran the NodeJS application, and ran the Docker image to generate contract tests and stubs and upload them to Artifactory.</p>
</div>
<h1 id="using-spring-cloud-contract-stubs-on-the-consumer-side" class="sect0"><a class="anchor" href="#using-spring-cloud-contract-stubs-on-the-consumer-side"></a>Using Spring Cloud Contract Stubs on the Consumer Side</h1>
<div class="paragraph">
<p>In this example, We publish a <a href="https://hub.docker.com/r/springcloud/spring-cloud-contract-stub-runner/">spring-cloud/spring-cloud-contract-stub-runner</a> Docker image that starts the standalone version of Stub Runner.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
If you&#8217;re comfortable with running a <code>java -jar</code> command instead of running Docker, you can download a standalone JAR from Maven (for example, for version 1.2.3.RELEASE), as follows: <code>wget -O stub-runner.jar 'https://search.maven.org/remote_content?g=org.springframework.cloud&amp;a=spring-cloud-contract-stub-runner-boot&amp;v=1.2.3.RELEASE'</code>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can pass any of the <a href="https://cloud.spring.io/spring-cloud-static/Edgware.SR2/single/spring-cloud.html#common-properties-junit-spring">properties</a> as environment variables. The convention is that all the letters should be upper case and that the word delimiters and the dots (<code>.</code>) should be replaced with underscores (<code>_</code>). For example, the <code>stubrunner.repositoryRoot</code> property should be represented as a <code>STUBRUNNER_REPOSITORY_ROOT</code> environment variable.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s assume that we want to run the stubs of the bookstore application on port <code>9876</code>. To do so, let&#8217;s run the Stub Runner Boot application with the stubs, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-bash" data-lang="bash"># Provide the Spring Cloud Contract Docker version
$ export SC_CONTRACT_DOCKER_VERSION="1.2.3.RELEASE"
# The IP at which the app is running and the Docker container can reach it
$ export APP_IP="192.168.0.100"
# Spring Cloud Contract Stub Runner properties
$ export STUBRUNNER_PORT="8083"
# Stub coordinates 'groupId:artifactId:version:classifier:port'
$ export STUBRUNNER_IDS="com.example:bookstore:0.0.1.RELEASE:stubs:9876"
$ export STUBRUNNER_REPOSITORY_ROOT="http://${APP_IP}:8081/artifactory/libs-release-local"
# Run the docker with Stub Runner Boot
$ docker run  --rm -e "STUBRUNNER_IDS=${STUBRUNNER_IDS}" \
-e "STUBRUNNER_REPOSITORY_ROOT=${STUBRUNNER_REPOSITORY_ROOT}" \
-p "${STUBRUNNER_PORT}:${STUBRUNNER_PORT}" -p "9876:9876" \
springcloud/spring-cloud-contract-stub-runner:"${SC_CONTRACT_DOCKER_VERSION}"</code></pre>
</div>
</div>
<div class="paragraph">
<p>That script:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Starts a standalone Spring Cloud Contract Stub Runner application.</p>
</li>
<li>
<p>Causes Stub Runner to download the stubs with the following coordinates: <code>com.example:bookstore:0.0.1.RELEASE:stubs</code>.</p>
</li>
<li>
<p>Downloads the stubs from Artifactory at <code><a href="http://192.168.0.100:8081/artifactory/libs-release-local" class="bare">http://192.168.0.100:8081/artifactory/libs-release-local</a></code>.</p>
</li>
<li>
<p>Starts (after a delay) Stub Runner on port <code>8083</code>.</p>
</li>
<li>
<p>Runs the stubs at port <code>9876</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>On the server side, we built a stateful stub. Let&#8217;s use curl to assert that the stubs are setup properly, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-bash" data-lang="bash"># let's execute the first request (no response is returned)
$ curl -H "Content-Type:application/json" -X POST \
--data '{ "title" : "Title", "genre" : "Genre", "description" : "Description", "author" : "Author", "publisher" : "Publisher", "pages" : 100, "image_url" : "https://d213dhlpdb53mu.cloudfront.net/assets/pivotal-square-logo-41418bd391196c3022f3cd9f3959b3f6d7764c47873d858583384e759c7db435.svg", "buy_url" : "https://pivotal.io" }' http://localhost:9876/api/books
# Now it's time for the second request
$ curl -X GET http://localhost:9876/api/books
# You should receive the contents of the JSON</code></pre>
</div>
</div>
<div class="paragraph">
<p>To sum up, once the stubs got uploaded, you can run a Docker image with a couple of environment variables and reuse them in your integration tests, regardless of the programming language used.</p>
</div>
<h1 id="summary" class="sect0"><a class="anchor" href="#summary"></a>Summary</h1>
<div class="paragraph">
<p>In this blog post, we explained what Contract Tests are and why they are important. We presented how Spring Cloud Contract can be used to generate and execute contract tests. Finally, we went through an example of how you can use Spring Cloud Contract Docker images for the producer and the consumer for a non-JVM application.</p>
</div>
<h1 id="additional-resources" class="sect0"><a class="anchor" href="#additional-resources"></a>Additional Resources</h1>
<div class="ulist">
<ul>
<li>
<p>Read the documentation of <a href="https://cloud.spring.io/spring-cloud-static/Edgware.SR2/single/spring-cloud.html#docker-project">Spring Cloud Contract</a>.</p>
</li>
<li>
<p>Read the documentation of <a href="https://cloud.spring.io/spring-cloud-static/Edgware.SR2/single/spring-cloud.html#stubrunner-docker">Spring Cloud Contract Stub Runner</a>.</p>
</li>
<li>
<p>Check out the <a href="https://github.com/spring-cloud-samples/spring-cloud-contract-nodejs">Bookstore sample</a>.</p>
</li>
<li>
<p>Ask questions on <a href="https://gitter.im/spring-cloud/spring-cloud-contract">Spring Cloud Contract Gitter channel</a>.</p>
</li>
</ul>
</div></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 3169;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>
Back
</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">All Posts</a>
<a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">Engineering</a>
<a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">Releases</a>
<a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">News and Events</a>
<a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>Get updates from The Spring Team delivered to your inbox</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">Tools</a></li>
<li><a href="https://store.pivotal.io/">Store</a></li>
<li><a href="/blog">Newsletter</a></li>
</ul>
</div>
</div>
&copy; <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a>, Inc. All Rights Reserved.
<a href="https://pivotal.io/terms-of-use">Terms of Use</a> &bullet;
<a href="https://pivotal.io/privacy-policy">Privacy</a> &bullet;
<a href="/trademarks">Trademark Guidelines</a>
<div id="teconsent" style="display:inline-block;"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>