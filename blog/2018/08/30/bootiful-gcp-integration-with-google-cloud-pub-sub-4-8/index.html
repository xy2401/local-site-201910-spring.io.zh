<html  data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>Bootiful GCP：与Google Cloud Pub / Sub（4/8）集成</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Bootiful GCP: Integration with Google Cloud Pub/Sub (4/8)">
<meta name="twitter:description" >
<meta name="twitter:creator" content="@starbuxman"><meta name="twitter:image:src" content="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=200"><meta property="og:title" content="Bootiful GCP: Integration with Google Cloud Pub/Sub (4/8)"><meta property="og:image" content="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=200"><meta property="og:description" >
<meta content="article" property="og:type"><meta property="og:article:published_time" content="2018-08-30 00:00:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Bootiful GCP：与Google Cloud Pub / Sub（4/8）集成</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=20&amp;d=mm"> <a class="author" rel="author" href="/team/jlong">乔什·朗（Josh Long）</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2018-08-30 00:00:00.0">八月30，2018</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2018/08/30/bootiful-gcp-integration-with-google-cloud-pub-sub-4-8#disqus_thread" data-disqus-identifier="3366">
</a></div>
</div>
</header>
<div class="blog--post"><blockquote>
<p>嗨， Spring 粉丝！在这个简短的8部分系列文章中，我们将研究Google Cloud Platform的Spring Cloud集成，称为Spring Cloud GCP。 <a href="https://cloud.spring.io/spring-cloud-gcp/">Spring Cloud GCP</a>代表了Google与Pivotal的共同努力，致力于在使用Google Cloud Platform时为Spring Cloud开发人员提供一流的体验。Pivotal Cloud Foundry用户将可以更<a href="https://docs.pivotal.io/partners/gcp-sb/index.html">轻松地与GCP服务代理集成</a> 。我用Google Cloud Developer Advocate和我的好友<a href="https://twitter.com/saturnism">Ray Tsang的</a>投入编写了这些文章。您还可以在我们的Google Next 2018会话<a href="https://www.youtube.com/watch?v=2Jo3vy7iQf8">Bootiful Google Cloud Platform中观看</a> Spring Cloud GCP的演练。谢谢哥们儿！与往常一样， <a href="https://twitter.com/starbuxman">如果您有任何反馈意见</a> ， <a href="https://twitter.com/starbuxman">我希望能收到您的来信</a> 。</p>
</blockquote>
<p>该系列有八个职位。这些都是：</p>
<ul>
<li><a href="https://spring.io/blog/2018/08/20/bootiful-gcp-getting-started-with-spring-cloud-for-google-cloud-platform-1-8">Bootiful GCP：针对Google Cloud Platform的Spring Cloud入门（1/8）</a></li>
<li><a href="https://spring.io/blog/2018/08/23/bootiful-gcp-relational-data-access-with-spring-cloud-gcp-2-8">Bootiful GCP：使用Spring Cloud GCP进行关系数据访问（2/8）</a></li>
<li><a href="https://spring.io/blog/2018/08/27/bootiful-gcp-globally-consistent-data-access-with-spanner-3-8">Bootiful GCP：使用Spanner（3/8）实现全球一致的数据访问</a></li>
<li><a href="https://spring.io/blog/2018/08/30/bootiful-gcp-integration-with-google-cloud-pub-sub-4-8">Bootiful GCP：与Google Cloud Pub / Sub（4/8）集成</a></li>
<li><a href="https://spring.io/blog/2018/09/03/bootiful-gcp-runtime-configuration-with-spring-cloud-gcp-runtime-config-5-8">Bootiful GCP：使用Spring Cloud GCP Runtime Config（5/8）进行运行时配置</a></li>
<li><a href="https://spring.io/blog/2018/09/06/bootiful-gcp-supporting-observability-with-spring-cloud-gcp-stackdriver-trace-6-8">引导性GCP：通过Spring Cloud GCP Stackdriver Trace（6/8）支持可观察性<br></a></li>
<li><a href="https://spring.io/blog/2018/09/10/bootiful-gcp-use-spring-cloud-gcp-to-connect-to-other-gcp-services-7-8">引导性GCP：使用Spring Cloud GCP连接到其他GCP服务（7/8）<br> </a></li>
<li><a href="https://spring.io/blog/2018/09/13/bootiful-gcp-to-production-8-8">可怜的GCP：量产！（8/8）</a></li>
</ul>
<p>让我们看一下应用程序与Google Cloud Pub / Sub的集成。Google Cloud Pub / Sub支持许多Google规模的经典企业应用程序集成用例。<a href="https://cloud.google.com/pubsub/docs/overview">用于发布/订阅</a>的<a href="https://cloud.google.com/pubsub/docs/overview">Google Cloud网站</a>列出了一些内容：</p>
<ul>
<li>
<p><strong>平衡网络群集中的工作负载</strong> 。例如，可以在多个工作人员（例如Google Compute Engine实例）之间高效地分配大量任务。</p></li>
<li>
<p><strong>实施异步工作流</strong> 。例如，订单处理应用程序可以在某个主题上下订单，一个或多个工作人员可以根据该主题进行处理。</p></li>
<li>
<p><strong>分发事件通知</strong> 。例如，接受用户注册的服务可以在新用户注册时发送通知，而下游服务可以订阅以接收事件通知。</p></li>
<li>
<p><strong>刷新分布式缓存</strong> 。例如，应用程序可以发布无效事件以更新已更改的对象的ID。</p></li>
<li>
<p><strong>登录到多个系统</strong> 。例如，Google Compute Engine实例可以将日志写入监视系统，数据库中以供以后查询等等。</p></li>
<li>
<p><strong>来自各种进程或设备的数据流</strong> 。例如，住宅传感器可以将数据流传输到云中托管的后端服务器。</p></li>
<li>
<p><strong>可靠性改善</strong> 。例如，单区域Compute Engine服务可以通过订阅一个公共主题在其他区域中运行，以从区域或区域中的故障中恢复。</p></li>
</ul>
<p>使用Google Cloud Pub / Sub时的流程完全符合您的期望：将消息发送到Pub / Sub代理中的某个主题（由GCP托管在云中），然后为您保留该主题。订阅者可以（通过Webhook）向其推送消息，也可以轮询来自代理的消息。订户从代理接收消息并确认每个消息。当订户确认消息时，该消息将从订户的订阅队列中删除。任何会说HTTPS的客户端都可以使用此服务。不需要其他API。</p>
<p>如果您曾经使用过任何其他消息传递系统（JMS，AMQP，Apache Kafka，Kestrel），则域模型非常简单：主题就是消息发布的对象。订阅表示要从特定主题传递到特定客户端应用程序的消息流。一个主题可以有多个订阅。一个订阅可以有许多订阅者。如果要向不同的订阅者分发不同的消息，则所有订阅者都必须订阅相同的订阅。如果要向所有订阅者发布相同的消息，则每个订阅者都需要订阅自己的订阅。</p>
<p>发布/订阅传递至少一次。因此，如果您不能多次处理同一条消息，则必须处理幂等和/或删除重复消息。</p>
<p>一条消息存储了数据和（可选）属性的组合，这些数据和属性是由Google Cloud Pub / Sub从发布者到订阅者进行的。消息属性（您最好将其理解为<em>标头</em> ）是消息中的键值对。您可能有一个标头，描述了有效负载的语言。您可能有一个描述内容类型的标头。</p>
<p>让我们将Google Cloud Pub / Sub添加到应用程序中并将它们绑定在一起。</p>
<p>和以前一样，我们需要启用Google Cloud Pub / Sub API才能使用。</p>
<pre><code class="prettyprint shell">gcloud services enable pubsub.googleapis.com
</code></pre>
<p>然后，您需要创建一个新主题： <code>reservations</code> 。</p>
<pre><code class="prettyprint shell">gcloud pubsub topics create reservations
</code></pre>
<p>该主题表示我们将在何处发送消息。我们仍然需要创建一个订阅，以使用来自该主题的消息。以下命令创建一个预订<code>reservations-subscription</code> ，以连接到<code>reservations</code>主题。</p>
<pre><code class="prettyprint shell">gcloud pubsub subscriptions create reservations-subscription --topic=reservations
</code></pre>
<p>这些部分就位，我们可以从应用程序中使用它们。添加Spring CloudGCP的Pub / Sub启动， <code>org.springframework.cloud</code> ： <code>spring-cloud-gcp-starter-pubsub</code> ，你的身材。这介绍了Google Cloud <code>PubSubTemplate</code>自动配置。如果您曾经使用过<code>JmsTemplate</code>或<code>KafkaTemplate</code>则应该对<code>PubSubTemplate</code>感到熟悉。这是一个易于使用的客户端，用于通过Google Cloud Pub / Sub生成和使用消息。如果您只是刚开始使用GCP发布/订阅和消息传递，那么Spring Universe中的<code>*Template</code>对象是一个不错的起点。</p>
<p>让我们看一个简单的示例，该示例在您向在Spring Boot应用程序中运行的HTTP端点发出HTTP <code>POST</code>调用时发布一条消息。然后，我们将设置一个订户以使用发送的消息。</p>
<pre><code class="prettyprint java">package com.example.gcp.pubsub.template;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.gcp.pubsub.core.PubSubTemplate;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RestController;

@Configuration
@RestController
class PublisherConfig {

        private final PubSubTemplate template;
        private final String topic;

        PublisherConfig(PubSubTemplate template, @Value(&quot;${reservations.topic:reservations}&quot;) String t) {
                this.template = template;
                this.topic = t;
        }

        
        @PostMapping(&quot;/publish/{name}&quot;)
        void publish(@PathVariable String name) {
                this.template.publish(this.topic, &quot;Hello &quot; + name + &quot;!&quot;);
        }
}
</code></pre>
<ul>
<li>我们使用注入的<code>PubSubTemplate</code>向配置的主题发送消息-字符串。</li>
</ul>
<p>现在，让我们看一个简单的应用程序，它很容易在另一个节点中运行，该节点使用与该主题链接的订阅中的消息。</p>
<pre><code class="prettyprint java">package com.example.gcp.pubsub.template;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.cloud.gcp.pubsub.core.PubSubTemplate;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.event.EventListener;

@Slf4j
@Configuration
class SubscriberConfig {

        private final PubSubTemplate template;
        private final String subscription;

        SubscriberConfig(PubSubTemplate template, @Value(&quot;${reservations.subscription:reservations-subscription}&quot;) String s) {
                this.template = template;
                this.subscription = s;
        }

        @EventListener(ApplicationReadyEvent.class)
        public void start() {
                
                this.template.subscribe(this.subscription, (pubsubMessage, ackReply ) -&gt; {
                        log.info(&quot;consumed new message: [&quot; + pubsubMessage.getData().toStringUtf8() + &quot;]&quot;);
                        ackReply.ack();
                });
        }
}
</code></pre>
<ul>
<li>一旦应用程序启动并运行，我们将明确订阅，将客户端连接到正确的端点。</li>
</ul>
<p>本示例使用<code>PubSubTemplate</code> （效果很好）。简单，简短，可爱。但是，随着集成变得越来越复杂，将消息流中涉及的组件从一个系统分离到另一个系统变得很有用。我们介绍了阶段-组件链中的链接-消息必须经过这些阶段才能到达下游组件。此阶段使我们能够编写可交换的处理代码，而与给定消息的来源或目的地无关。这促进了测试，因为只需要按照组件的前后条件编写组件即可：组件可以说它只接受Spring Framework <code>Message <file></file></code>类型，仅此而已。这种接口间接性<em>非常</em>方便，尤其是当我们开始将可以处理不同节奏的工作的现实世界联系在一起时。在代理到达下游组件之前可能会造成瓶颈，因此引入代理来缓冲工作变得微不足道。这种方法-隔离消息流中涉及的组件并引入缓冲区以保护下游组件-被称为<em>分段事件驱动架构</em> （SEDA），随着当今世界向微服务和高度分布式系统的迁移，这种方法现在更具价值。</p>
<p>Spring Integration是一个旨在促进这种间接性的框架。它的核心是<code>MessageChannel</code>的概念，您可以将其<code>MessageChannel</code>内存<code>Queue</code> 。消息流经的管道。坐席组件位于<code>MessageChannel</code>每一侧。您可以想象一个组件输出某种类型的消息，然后将其发送到此<code>MessageChannel</code> ，而不管它会去哪里。另一方面，另一个组件使用某种类型的消息，而完全不理会任何给定消息的来源。今天，消息的产生可能涉及一种服务。明天可能有十个！上游和下游组件无需更改。这种间接为我们提供了很多可能性。我们更改给定消息的路由，将其通过不同的服务进行字符串处理，拆分，汇总等。我们可以转换其他数据源，并使它们适应上游的消息流（称为入站适配器）。我们可以引入新的数据接收器，以适应Spring Framework <code>Message <t></t></code>转换为正确的类型（称为<em>出站适配器</em> ）。</p>
<p>让我们看一下Spring Integration和Google Cloud Pub / Sub入站和出站适配器。我们将保持与以前相同的方法：HTTP端点将发布消息，然后将消息传递到Google Cloud Pub / Sub。该代码可以在不同的节点中运行。您还需要在类路径上使用Spring Integration类型，此示例才能正常工作。将<code>org.springframework.boot</code> ： <code>spring-boot-starter-integration</code>到构建中。</p>
<p>让我们看一下一个在进行HTTP POST时就发布消息的发布者。在这种情况下，发布者将请求发送到<code>MessageChannel</code> ，然后将其传递到<code>PubSubMessageHandler</code> 。今天，它直接进入Pub / Sub，但是明天它可以进入数据库，FTP服务器，XMPP，Salesforce或其他任何东西， <em>然后再</em>进入Pub / Sub。</p>
<pre><code class="prettyprint java">package com.example.gcp.pubsub.integration;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.gcp.pubsub.core.PubSubTemplate;
import org.springframework.cloud.gcp.pubsub.integration.outbound.PubSubMessageHandler;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.integration.dsl.IntegrationFlow;
import org.springframework.integration.dsl.IntegrationFlows;
import org.springframework.integration.dsl.channel.MessageChannels;
import org.springframework.messaging.SubscribableChannel;
import org.springframework.messaging.support.MessageBuilder;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RestController;

@Slf4j
@RestController
@Configuration
class PublisherConfig {

        private final String topic;
        private final PubSubTemplate template;

        public PublisherConfig(
            @Value(&quot;${reservations.topic:reservations}&quot;) String t,
            PubSubTemplate template) {
                this.topic = t;
                this.template = template;
        }

        @Bean
        IntegrationFlow publisherFlow() {
                return IntegrationFlows
                    .from(this.outgoing()) 
                    .handle(this.pubSubMessageHandler()) 
                    .get();
        }

        @PostMapping(&quot;/publish/{name}&quot;)
        void publish(@PathVariable String name) {
                
                outgoing().send(MessageBuilder.withPayload(name).build());
        }

        @Bean
        SubscribableChannel outgoing() {
                return MessageChannels.direct().get();
        }

        @Bean
        PubSubMessageHandler pubSubMessageHandler() {
                return new PubSubMessageHandler(template, this.topic);
        }
}
</code></pre>
<ul>
<li>
<p><code>IntegrationFlow</code>很好地描述了<code>IntegrationFlow</code>中的消息<em>流</em> 。发送到<code>outgoing</code> <code>MessageChannel</code>将传递到<code>PubSubMessageHandler</code> ，然后使用指定<code>topic</code>将其写入Google Cloud Pub / Sub</p></li>
<li>
<p>在Spring MVC HTTP endpint中，我们获得对<code>MessageChannel</code>的引用，并将一条消息（使用<code>MessageBuilder</code>构建）发布到其中。注意：像我在此示例中一样，调用outing <code>outgoing()</code>很好，因为Spring会记住方法调用的结果。我将始终获得与<code>MessageChannel</code> bean相同的预先实例化的单例。</p></li>
</ul>
<p>在消费者方面，我们相反地做同样的事情，调整传入的消息，然后将它们记录在<code>IntegrationFlow</code> 。</p>
<pre><code class="prettyprint java">package com.example.gcp.pubsub.integration;

import com.google.cloud.pubsub.v1.AckReplyConsumer;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.gcp.pubsub.core.PubSubTemplate;
import org.springframework.cloud.gcp.pubsub.integration.AckMode;
import org.springframework.cloud.gcp.pubsub.integration.inbound.PubSubInboundChannelAdapter;
import org.springframework.cloud.gcp.pubsub.support.GcpPubSubHeaders;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.integration.dsl.IntegrationFlow;
import org.springframework.integration.dsl.IntegrationFlows;
import org.springframework.integration.dsl.channel.MessageChannels;
import org.springframework.messaging.MessageChannel;

@Slf4j
@Configuration
class SubscriberConfig {

        private final String subscription;
        private final PubSubTemplate template;

        SubscriberConfig(
            @Value(&quot;${reservations.subscription:reservations-subscription}&quot;) String s,
            PubSubTemplate t) {
                this.subscription = s;
                this.template = t;
        }

        @Bean 
        public PubSubInboundChannelAdapter messageChannelAdapter() {
                PubSubInboundChannelAdapter adapter = new PubSubInboundChannelAdapter(
                    template, this.subscription);
                adapter.setOutputChannel(this.incoming());
                adapter.setAckMode(AckMode.MANUAL);
                return adapter;
        }

        @Bean
        MessageChannel incoming() {
                return MessageChannels.publishSubscribe().get();
        }

        @Bean
        IntegrationFlow subscriberFlow() {
                return IntegrationFlows
                    .from(this.incoming()) 
                    .handle(message -&gt; { 
                            log.info(&quot;consumed new message: [&quot; + message.getPayload() + &quot;]&quot;);
                            AckReplyConsumer consumer = message.getHeaders()
                                .get(GcpPubSubHeaders.ACKNOWLEDGEMENT, AckReplyConsumer.class);
                            consumer.ack();
                    })
                    .get();
        }
}
</code></pre>
<ul>
<li>
<p><code>PubSubInboundChannelAdapter</code>适配来自订阅的消息，并将其发送到<code>incoming</code> <code>MessageChannel</code> 。</p></li>
<li>
<p><code>IntegrationFlow</code>接收传入消息并将其路由到<code>MessageHandler</code> （我们使用lambda语法进行了贡献），其中a）记录传入消息，b）手动确认消息的接收。</p></li>
</ul>
<p>在两个示例中，关于<code>IntegrationFlow</code>的好处是您可以将调用链接在一起。在这里，我们仅指定消息的来源（ <code>.from()</code> ）和消息的处理源（ <code>.handle()</code> ），但在<code>.handle()</code>调用之后，还可以轻松路由，拆分，转换等操作，消息。作为一个组件（适配器，消息处理程序，转换器等）的输出发送的消息成为任何下游组件的输入。</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 3366;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>