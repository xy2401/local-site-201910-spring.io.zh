<!DOCTYPE html>
<html data-code-prettify="" data-mobile-support="" data-search="">
<head>
<title>How Fast is Spring?</title>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no" id="Viewport" name="viewport" />
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png" />
<link href="https://fonts.googleapis.com/css?family=Varela+Round|Montserrat:400,700" rel="stylesheet" type="text/css" />
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css" />
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M" name="google-site-verification" />

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css" />

<meta content="summary" name="twitter:card" />
<meta content="@springcentral" name="twitter:site" />
<meta name="twitter:title" content="How Fast is Spring?" />
<meta name="twitter:description" content="&lt;div class=&quot;paragraph&quot;&gt; 
 &lt;p&gt;Performance has always been one of the top priorities of the Spring Engineering team, and we are continually monitoring and responding to changes and to feedback. Some fairly intense and precise work has been done recently (in the last 2-3 years) and this article is here to help you to find the results of that work and to learn how to measure and improve performance in your own applications. The headline is that Spring Boot 2.1 and Spring 5.1 have some quite nice optimizations for startup time and heap usage. Here’s a graph made by measuring startup time for heap constrained apps:&lt;/p&gt; 
&lt;/div&gt;
" />
<meta name="twitter:creator" content="@david_syer" />
<meta name="twitter:image:src" content="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=200" />

<meta property="og:title" content="How Fast is Spring?" />
<meta property="og:image" content="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=200" />
<meta property="og:description" content="&lt;div class=&quot;paragraph&quot;&gt; 
 &lt;p&gt;Performance has always been one of the top priorities of the Spring Engineering team, and we are continually monitoring and responding to changes and to feedback. Some fairly intense and precise work has been done recently (in the last 2-3 years) and this article is here to help you to find the results of that work and to learn how to measure and improve performance in your own applications. The headline is that Spring Boot 2.1 and Spring 5.1 have some quite nice optimizations for startup time and heap usage. Here’s a graph made by measuring startup time for heap constrained apps:&lt;/p&gt; 
&lt;/div&gt;
" />
<meta content="article" property="og:type" />
<meta property="og:article:published_time" content="2018-12-12 14:09:00.0" />
</head>
<body>

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" style="display:none;visibility:hidden" width="0"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">Projects</a>
</li>
<li class="navbar-link">
<a href="/guides">Guides</a>
</li>
<li class="navbar-link active">
<a href="/blog">Blog</a>
</li>
<li class="navbar-link">
<a href="/services">Training & Certification</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form action="/search" class="form-inline form-search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search for documentation, guides, and posts..." type="text" value="" />
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form action="/search" class="form-inline form-search" method="get">
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search..." type="text" value="" />
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">
Home
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">
Projects
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">
Guides
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">
Blog
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">
Training & Certification
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>Engineering</div>
</div>
<div class="blog-category content--title">
<div>Releases</div>
</div>
<div class="blog-category content--title">
<div>News and Events</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">How Fast is Spring?</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">Engineering</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=20&amp;d=mm" />
<a class="author" rel="author" href="/team/dsyer">Dave Syer</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2018-12-12 14:09:00.0">December 12, 2018</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" data-disqus-identifier="3497" href="/blog/2018/12/12/how-fast-is-spring#disqus_thread">
</a></div>
</div>
</header>
<div class="blog--post"><div class="paragraph">
<p>Performance has always been one of the top priorities of the Spring Engineering team, and we are continually monitoring and responding to changes and to feedback. Some fairly intense and precise work has been done recently (in the last 2-3 years) and this article is here to help you to find the results of that work and to learn how to measure and improve performance in your own applications. The headline is that Spring Boot 2.1 and Spring 5.1 have some quite nice optimizations for startup time and heap usage. Here&#8217;s a graph made by measuring startup time for heap constrained apps:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQpSEfx0Y1W9aD3XVyn91-S0jtUp2DRCQSy_W_LMGyMR91YLAQ1mL7MiR1BRd8VzshvtuxzL6WAnlxf/pubchart?oid=336485057&format=image" alt="heap-size-2.1.x" width="75%">
</div>
</div>
<div class="paragraph">
<p>As you squeeze the available heap, and application generally isn&#8217;t affected on startup, until it reaches a critical point. The characteristic "hockey stick" shape of the graphs shows the point at which garbage collection loses the fight and the app no longer starts up at all. We see from the graphs that it is quite possible to run a simple Netty app in 10MB heap with Spring Boot 2.1 (but not with 2.0). It is also a bit faster in 2.1 compared to 2.0.</p>
</div>
<div class="paragraph">
<p>Most of the detail here refers specifically to measurements and optimizations for startup time, but heap memory consumption is also something that is very relevant because constraints on heap size generally lead to slower startup (see the graph above). There are other aspects of performance that we could (and will) focus on, particularly where annotations are being used for HTTP request mapping, for example; but those concerns will have to wait for another, separate write up.</p>
</div>
<div class="paragraph">
<p>When all things are considered, remember that Spring was designed <em>ab initio</em> to be lightweight, and actually does very little work unless you ask it to. There are many <strong>optional</strong> features, so you don&#8217;t have to use them. Here are some quick summary points:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Packaging: an exploded jar with the application&#8217;s own main is always faster</p>
</li>
<li>
<p>Server: there is no measureable difference between Tomcat, Jetty and Undertow</p>
</li>
<li>
<p>Netty is a <em>bit</em> faster on startup - you won&#8217;t notice in a large app</p>
</li>
<li>
<p>The more features you use, the more classes are loaded</p>
</li>
<li>
<p>Functional bean definitions provide an incremental improvement</p>
</li>
<li>
<p>A minimal Spring Boot app with an HTTP endpoint starts in &lt;1sec and uses &lt;10MB heap</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Some links:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/dsyer/spring-boot-startup-bench" class="bare">https://github.com/dsyer/spring-boot-startup-bench</a> - older benchmarks (back to Spring Boot 1.3), fat jar data</p>
</li>
<li>
<p><a href="https://github.com/dsyer/spring-boot-startup-bench/blob/master/static/README.adoc">/static</a> benchmarks in the same repo - newer, explores classes loaded correlation</p>
</li>
<li>
<p><a href="https://github.com/dsyer/spring-boot-startup-bench/blob/master/flux/README.adoc">/flux</a> benchmarks in the same repo - WebFlux</p>
</li>
<li>
<p><a href="https://spring.io/blog/2018/10/22/functional-bean-registrations-in-spring-cloud-function" class="bare">https://spring.io/blog/2018/10/22/functional-bean-registrations-in-spring-cloud-function</a> - blog on functional beans in Spring Cloud Function</p>
</li>
<li>
<p>Spring Fu: <a href="https://github.com/spring-projects/spring-fu" class="bare">https://github.com/spring-projects/spring-fu</a></p>
</li>
<li>
<p><a href="https://github.com/dsyer/spring-boot-allocations" class="bare">https://github.com/dsyer/spring-boot-allocations</a> - benchmarks for functional beans and GC pressure</p>
</li>
<li>
<p><a href="https://github.com/dsyer/spring-boot-micro-apps" class="bare">https://github.com/dsyer/spring-boot-micro-apps</a> - functional beans and AOT (same code as the "allocations" project but sample apps not benchmarks)</p>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="tldr-how-do-i-make-my-app-go-faster"><a class="anchor" href="#tldr-how-do-i-make-my-app-go-faster"></a>TL;DR How do I make my app go faster?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(Copied from <a href="https://github.com/dsyer/spring-boot-allocations">here</a>.) You are mostly going to have to drop features, so not all of these suggestions will be possible for all apps. Some are not so painful, and actually pretty natural in a container, e.g. if you are building a docker image it&#8217;s better to unpack the jar and put application classes in a different filesystem layer anyway.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Classpath exclusions from Spring Boot web starters:</p>
<div class="ulist">
<ul>
<li>
<p>Hibernate Validator</p>
</li>
<li>
<p>Jackson (but Spring Boot actuators depend on it). Use
Gson if you need JSON rendering (only works with MVC out of the box).</p>
</li>
<li>
<p>Logback: use <code>slf4j-jdk14</code> instead</p>
</li>
</ul>
</div>
</li>
<li>
<p>Use the <code>spring-context-indexer</code>. It&#8217;s not going to add much, but every little helps.</p>
</li>
<li>
<p>Don&#8217;t use actuators if you can afford not to.</p>
</li>
<li>
<p>Use Spring Boot 2.1 and Spring 5.1. Switch to 2.2 and 5.2 when they are available.</p>
</li>
<li>
<p>Fix the location of the
<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-external-config-application-property-files">Spring Boot config file(s)</a>
with <code>spring.config.location</code> (command line argument or System property etc.).
Example for testing in IDE:
<code>spring.config.location=file://./src/main/resources/application.properties</code>.</p>
</li>
<li>
<p>Switch off JMX if you don&#8217;t need it with <code>spring.jmx.enabled=false</code> (this is the default in Spring Boot 2.2)</p>
</li>
<li>
<p>Make bean definitions lazy by default. There&#8217;s a new flag <code>spring.main.lazy-initialization=true</code> in Spring
Boot 2.2 (and there&#8217;s a <code>LazyInitBeanFactoryPostProcessor</code>
in <a href="https://github.com/dsyer/spring-boot-allocations">this project</a> you can copy).</p>
</li>
<li>
<p>Unpack the fat jar and run with an explicit classpath.</p>
</li>
<li>
<p>Run the JVM with <code>-noverify</code>. Also consider <code>-XX:TieredStopAtLevel=1</code>
(that will slow down the JIT later at the expense of the saved startup time).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A more extreme choice is to re-write all your application configuration using functional bean definitions. This includes all the Spring Boot autoconfiguration you are using, most of which can be re-used, but it&#8217;s stll manual work to identify which classes to use and register all the bean definitions. If you try this approach you might see a 2x improvement in startup time, but not all of that will be because of the functional bean definitions (estimates usually end up in the range of 10% startup time premium for functional beans, but there may be other benefits). Look at the <code>BuncApplication</code> in the <a href="https://github.com/dsyer/spring-boot-micro-apps">micro apps</a> to see how to start Spring Boot without the <code>@Configuration</code> class processor.</p>
</div>
<div class="paragraph">
<p>Excluding <code>netty-transport-native-epoll</code> also boosts the startup time by 30ms or so (Linux only). This is a regression since Spring Boot 2.0, so once we understand it a bit better we can probably eliminate it.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="some-basic-benchmarks"><a class="anchor" href="#some-basic-benchmarks"></a>Some Basic Benchmarks</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Here is a subset of the <a href="https://github.com/dsyer/spring-boot-startup-bench/blob/master/static/README.adoc">static benchmarks</a> from <a href="https://github.com/dsyer/spring-boot-startup-bench" class="bare">https://github.com/dsyer/spring-boot-startup-bench</a>. Each app is started with a new JVM (separate process) per application startup, and has an explicit classpath (not fat jar). The app is always the same, but with different levels of automatic (and in some cases manual) configuration. The "Score" is startup time in seconds, measured as the time from starting the JVM to seeing a marker in the logger output (at this point the app is up and accepting HTTP connections).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>Benchmark   (sample) Mode  Cnt  Score   Error  Units Beans Classes
MainBenchmark  actr  avgt   10  1.316 ± 0.060   s/op 186   5666
MainBenchmark  jdbc  avgt   10  1.237 ± 0.050   s/op 147   5625
MainBenchmark  demo  avgt   10  1.056 ± 0.040   s/op 111   5266
MainBenchmark  slim  avgt   10  1.003 ± 0.011   s/op 105   5208
MainBenchmark  thin  avgt   10  0.855 ± 0.028   s/op 60    4892
MainBenchmark  lite  avgt   10  0.694 ± 0.015   s/op 30    4580
MainBenchmark  func  avgt   10  0.652 ± 0.017   s/op 25    4378</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The host machine is "tower", i7, 3.4GHz, 32G RAM, SSD.
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>Actr: same as "demo" sample plus Actuator</p>
</li>
<li>
<p>Jdbc: same as "demo" sample plus JDBC</p>
</li>
<li>
<p>Demo: vanilla Spring Boot MVC app with one endpoint (no Actuator)</p>
</li>
<li>
<p>Slim: same thing but explicitly <code>@Imports</code> all configuration</p>
</li>
<li>
<p>Thin: reduce the <code>@Imports</code> down to a set of 4 that are needed for the endpoint</p>
</li>
<li>
<p>Lite: copy the imports from "thin" and make them into hard-coded, unconditional configuration</p>
</li>
<li>
<p>Func: extract the configuration methods from "lite" and register bits of it using the function bean API</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Generally speaking, the more features are used, the more classes that are loaded, and also the more beans are created in the <code>ApplicationContext</code>. The correlation is actually very tight between startup time and number of classes loaded (much tighter than versus number of beans). Here&#8217;s a graph compiled from that data and extended with a range of other things, like JPA, bits of Spring Cloud, all the way up to the "kitchen sink" with everything on the classpath including Zuul and Sleuth:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://docs.google.com/spreadsheets/d/e/2PACX-1vR8B4l5WkWf-9gZWmIYTkmBWM7YWf5bRg852OakrV0G2-vtfM_UkVNRC3cTVk1079HagnMVHYZnvbib/pubchart?oid=976086548&format=image" alt="pubchart?oid=976086548&amp;format=image" width="75%">
</div>
</div>
<div class="paragraph">
<p>The data for the graph can be scraped from the benchmark report if you run the "MainBenchmark" and the "StripBenchmark" in the static benchmarks (the table above is old data from a time when they were both in the same class). There are instructions about how to do that in the README.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="garbage-collection-pressure"><a class="anchor" href="#garbage-collection-pressure"></a>Garbage Collection Pressure</h2>
<div class="sectionbody">
<div class="paragraph">
<p>While it is true, and measureable, that more classes loaded (i.e. more features) is directly correlated with slower startup time, there are some subtleties, and one of the most important and also the slipperiest to analyse is garbage collection (GC). Garbage collection can be a really big deal for long running applications, and we have all heard stories of long GC pauses in large applications (the bigger your heap the longer you are likely to wait). Custom GC strategies are big business and an important tool for tweaking long-running, especially large applications. On startup there are some other things happening, but those can be related to garbage collection as well, and many of the optimizations in Spring 5.1 and Spring Boot 2.1 were obtained by analysing those.</p>
</div>
<div class="paragraph">
<p>The main thing to look out for is tight loops with temporary objects being created and discarded. Some code in that pattern is unavoidable, and some is out of our control (e.g. it&#8217;s in the JDK itself), and all we can do in that case is try not to call it. But these hordes of temporary objects create pressure on garbage collection and swell the heap, even if they never actually make it onto the heap per se. You can often see the effect of the extra GC pressure as a spike in heap size, if you can catch it happening. Flame graphs from <a href="https://github.com/jvm-profiling-tools/async-profiler">async-profiler</a> are a better tool because they are allow more fine-grained sampling than most profiling tools, and because they are visually very striking.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example flame graph from the HTTP sample app we have been benchmarking, with Spring Boot 2.0 and with Spring Boot 2.1:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 52%;">
<col style="width: 48%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="https://github.com/dsyer/spring-boot-allocations/raw/master/images/flame_20.svg?sanitize=true" alt="flame_20">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="https://github.com/dsyer/spring-boot-allocations/raw/master/images/flame_21.svg?sanitize=true" alt="flame_21">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Spring Boot 2.0</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Spring Boot 2.1</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The red/brown GC flame on the right is noticeably smaller in Spring Boot 2.1. This is a
sign of less GC pressure as a result of a <a href="https://github.com/spring-projects/spring-framework/commit/81cb740e">change</a> in the bean factory internals. The Spring Framework issue behind one of the main changes is <a href="https://jira.spring.io/browse/SPR-16918">here</a> if you want to look at the details.</p>
</div>
<div class="paragraph">
<p>Recognizing that GC pressure is an issue is one thing (and async-profiler is the best tool we have found), but locating its source is something of an art. The best tool we have found for that is Flight Recorder (or Java Mission Control) which is part of the OpenJDK release, although it used to be only in the Oracle distribution. The problem with Flight Recorder is that the sampling rate is not really high enough to capture enough data on startup, so you have to try and build tight loops that do something you are interested in, or suspect might be contributing to the problem, and analyse those over a longer period (a few seconds or more). This leads to additional insight, but no real data on whether a "real" application will benefit from changing the hotspot. Much of the code in the <a href="https://github.com/dsyer/spring-boot-allocations">spring-boot-allocations</a> project is this kind of code: main methods that run tight loops focusing on suspected hotspots that can then be analyzed with Flight Controller.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux-and-micro-apps"><a class="anchor" href="#webflux-and-micro-apps"></a>WebFlux and Micro Apps</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We might expect some variations between apps using a Servlet container and those using the newer reactive runtime from Netty introduced in Spring 5.0. The benchmark figures above are using Tomcat. There are some similar measurements in a different subdirectory of the same repo. Here are the results from the <a href="https://github.com/dsyer/spring-boot-startup-bench/blob/master/flux/README.adoc">flux benchmarks</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>Benchmark            (sample)  Mode  Cnt  Score   Error  Units Classes
MainBenchmark.main       demo    ss   10  1.081 ± 0.075   s/op 5779
MainBenchmark.main       jlog    ss   10  0.933 ± 0.065   s/op 4367
MiniBenchmark.boot       demo    ss   10  0.579 ± 0.041   s/op 4138
MiniBenchmark.boot       jlog    ss   10  0.486 ± 0.020   s/op 2974
MiniBenchmark.mini       demo    ss   10  0.538 ± 0.009   s/op 3138
MiniBenchmark.mini       jlog    ss   10  0.420 ± 0.011   s/op 2351
MiniBenchmark.micro      demo    ss   10  0.288 ± 0.006   s/op 2112
MiniBenchmark.micro      jlog    ss   10  0.186 ± 0.006   s/op 1371</code></pre>
</div>
</div>
<div class="paragraph">
<p>All the apps have a single HTTP endpoint, just like the apps in the static benchmarks (Tomcat, Servlet). All are a bit faster than Tomcat, but not much (maybe 10%). Note that the fastest one ("micro jlog") is up and running in less than 200ms. Spring is really not doing very much there, and all the cost is basically getting the classes loaded for the features needed by the app (an HTTP server).</p>
</div>
<div class="paragraph">
<p>Notes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>MainBenchmark.main(demo)</code> is full Boot + Webflux + autoconfiguration.</p>
</li>
<li>
<p>The <code>boot</code> samples use Spring Boot but no autoconfiguration.</p>
</li>
<li>
<p>The <code>jlog</code> samples exclude logback as well as Hibernate Validator and Jackson.</p>
</li>
<li>
<p>The <code>mini</code> samples do not use Spring Boot (just <code>@EnableWebFlux</code>).</p>
</li>
<li>
<p>The <code>micro</code> samples do not use <code>@EnableWebflux</code> either, just a manual route registration.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The mini jlog sample runs in about 46MB memory (10 heap, 36 non-heap). The micro jlog sample runs in 38MB (8 heap, 30 non-heap). Non-heap is really what matters for these smaller apps. They are all included on the scatter plot above, so they are consistent with the general correlation between startup time and classes loaded.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="classpath-exclusions"><a class="anchor" href="#classpath-exclusions"></a>Classpath Exclusions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Your mileage my vary, but consider excluding:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Jackson (<code>spring-boot-starter-json</code>): it&#8217;s not super expensive (maybe 50ms on startup), but Gson is faster, and also has a smaller footprint.</p>
</li>
<li>
<p>Logback (<code>spring-boot-starter-logging</code>): still the best, most flexible logging library, but all that flexibility comes with a cost.</p>
</li>
<li>
<p>Hibernate Validator (<code>org.hibernate.validator:hibernate-validator</code>): does a lot of work on startup, so if you are not using it, exclude it.</p>
</li>
<li>
<p>Actuators (<code>spring-boot-starter-actuator</code>): a really useful feature set, so hard to recommend removing it completely, but if you aren&#8217;t using it, don&#8217;t put it on the classpath.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-tweaks"><a class="anchor" href="#spring-tweaks"></a>Spring Tweaks</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Use the <code>spring-context-indexer</code>. It&#8217;s a drop in on the classpath, so very easy to install. It only works on your application&#8217;s own <code>@Component</code> classes, and really only likely to be a very small boost to startup time for all but the largest (1000s beans) applications. But it is measureable.</p>
</li>
<li>
<p>Don&#8217;t use actuators if you can afford not to.</p>
</li>
<li>
<p>Use Spring Boot 2.1 and Spring 5.1. Both have small, but important optimizations, especially regarding garbage collection pressure on startup. This is what enables newer apps to start up with less heap.</p>
</li>
<li>
<p>Use explicit <code>spring.config.location</code>. Spring Boot looks in quite a lot of locations for <code>application.properties</code> (or <code>.yml</code>), so if you know exactly where it is, or might be at runtime, you can shave off a few percent.</p>
</li>
<li>
<p>Switch off JMX: <code>spring.jmx.enabled=false</code>. If you aren&#8217;t using it you don&#8217;t need to pay the cost of creating and registering the MBeans.</p>
</li>
<li>
<p>Make bean definitions lazy by default. There&#8217;s nothing in Spring Boot that does this, but there&#8217;s a <code>LazyInitBeanFactoryPostProcessor</code> in <a href="https://github.com/dsyer/spring-boot-allocations">this project</a> you can copy. It is just a <code>BeanFactoryPostProcessor</code> that switches all beans to <code>lazy=true</code>.</p>
</li>
<li>
<p>Spring Data has some lazy initialization features now (in Lovelace, or Spring Boot 2.1). In Spring Boot you can just set <code>spring.data.jpa.repositories.bootstrap-mode=lazy</code> - for large apps with 100s of entities improves startup time by more than a factor of 10.</p>
</li>
<li>
<p>Use functional bean definitions instead of <code>@Configuration</code>. More detail later on this.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jvm-tweaks"><a class="anchor" href="#jvm-tweaks"></a>JVM Tweaks</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Useful command line tweaks for startup time:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>-noverify</code> - pretty much harmless, has a big impact. Might not be permitted in a low trust environment.</p>
</li>
<li>
<p><code>-XX:TieredStopAtLevel=1</code> - potentially degrades performance later, after startup, since it restricts the JVM ability to optimize itself at runtime. Your mileage my vary but it will have a measureable impact on startup time.</p>
</li>
<li>
<p><code>-Djava.security.egd=file:/dev/./urandom</code> - not really a thing any more, but older versions of Tomcat used to really need it. Might have a small effect on modern apps with or without Tomcat if anyone is using random numbers.</p>
</li>
<li>
<p><code>-XX:+AlwaysPreTouch</code> - small but possibly measurable effect on startup.</p>
</li>
<li>
<p>Use an explicit classpath - i.e. explode the fat jar and use <code>java -cp &#8230;&#8203;</code>. Use the application&#8217;s native main class. More detail on this later.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="class-data-sharing"><a class="anchor" href="#class-data-sharing"></a>Class Data Sharing</h3>
<div class="paragraph">
<p>Class Data Sharing (CDS) was a commercial only feature of the Oracle JDK since version 7, but it has also available in <a href="https://www.eclipse.org/openj9/">OpenJ9</a> (the open source version of the IBM JVM) and now in OpenJDK since version 10. OpenJ9 has had CDS for a long time, and it is super easy to use in that platform. It was designed for optimizing memory usage, not startup time, but those two concerns are not unrelated.</p>
</div>
<div class="paragraph">
<p>You can run OpenJ9 in the same way as a regular OpenJDK JVM, but the CDS is switched on with different command line flags. It&#8217;s super convenient with OpenJ9 because all you need is <code>-Xshareclasses</code>. It&#8217;s probably also a good idea to increase the size of the cache, e.g. <code>-Xscmx128m</code>, and to hint that you want a fast startup with <code>-Xquickstart</code>. These flags are always on in the benchmarks if they detect the OpenJ9 or IBM JVM.</p>
</div>
<div class="paragraph">
<p>Benchmark results with OpenJ9 and CDS:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>Benchmark            (sample)  Mode  Cnt  Score   Error  Units Classes
MainBenchmark.main       demo    ss   10  0.939 ± 0.027   s/op 5954
MainBenchmark.main       jlog    ss   10  0.709 ± 0.034   s/op 4536
MiniBenchmark.boot       demo    ss   10  0.505 ± 0.035   s/op 4314
MiniBenchmark.boot       jlog    ss   10  0.406 ± 0.085   s/op 3090
MiniBenchmark.mini       demo    ss   10  0.432 ± 0.019   s/op 3256
MiniBenchmark.mini       jlog    ss   10  0.340 ± 0.018   s/op 2427
MiniBenchmark.micro      demo    ss   10  0.204 ± 0.019   s/op 2238
MiniBenchmark.micro      jlog    ss   10  0.152 ± 0.045   s/op 1436</code></pre>
</div>
</div>
<div class="paragraph">
<p>That is quite impressive in some cases (25% faster than without CDS for the fastest apps). Similar results can be achieved with OpenJDK: includes CDS (with a less convenient command line interface) since Java 10. Here&#8217;s a scatter plot of the smaller end of the classes loaded versus startup time relationship, with regular OpenJDK (no CDS) in red and OpenJ9 (with CDS) in blue:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQpSEfx0Y1W9aD3XVyn91-S0jtUp2DRCQSy_W_LMGyMR91YLAQ1mL7MiR1BRd8VzshvtuxzL6WAnlxf/pubchart?oid=1689271723&format=image" alt="pubchart?oid=1689271723&amp;format=image" width="75%">
</div>
</div>
<div class="paragraph">
<p>Java 10 and 11 also have an experimental feature called Ahead of Time compilation (AOT) that lets you build a native image from a Java application. Potentially this is super fast on startup, and most apps that can successfully be converted are indeed very fast to start up (by a factor of 10 for the small apps in the benchmarks here). Many "real life" applications cannot yet be converted. AOT is implemented using <a href="https://github.com/oracle/graal">Graal VM</a>, which we will come back to later.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="lazy-subsystems"><a class="anchor" href="#lazy-subsystems"></a>Lazy Subsystems</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We mentioned lazy bean definitions and the idea of a <code>LazyInitBeanFactoryPostProcessor</code> being generally of interest above. The benefits are clear, especially for a Spring Boot application with lots of autoconfigured beasn that you never uese, but also limited because even if you don&#8217;t use them sometimes they needto be created to satisfy a dependency. Those limitations could possibly be addressed by another idea that is more of a research topic, and that is to break down application into modules and initialize each one separately on demand.</p>
</div>
<div class="paragraph">
<p>To do this you would need to be able to precisely identify a subsystem in your source code and mark it somehow. An example of such a subsystem would be the actuators in Spring Boot, which we can identify mainly by the package names of the auto configuration classes. There is a prototype in this project: <a href="https://github.com/dsyer/spring-boot-lazy-actuator">Lazy Actuator</a>. You can just add it to an existing project and it converts all the actuator endpoints into lazy beans which will only be instantiated when they are used, saving about 40% of the startup time in a micro application like the canonical one-endpoint HTTP sample app in the benchmarks above. E.g. (for Maven):</p>
</div>
<div class="listingblock">
<div class="title">pom.xml</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.boot.experimental&lt;/groupId&gt;
	&lt;artifactId&gt;spring-boot-lazy-actuator&lt;/artifactId&gt;
	&lt;version&gt;1.0.0.BUILD-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>To make this kind of pattern more mainstream would probably take some changes in the core Spring programming model, to allow the subsystems to be identified and dealt with in special ways at runtime. It also increases the complexity of an application, which might not really be worth it in a lot of cases - one of the best features of Spring Boot is the simplicity of the application context (all beans are created equal). So this remains an area of active research.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="functional-bean-definitions"><a class="anchor" href="#functional-bean-definitions"></a>Functional Bean Definitions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Functional bean registration is a feature added to Spring 5.0, in the form of a few new methods in <code>BeanDefinitionBuilder</code> and some convenience methods in <code>GenericApplicationContext</code>. It allows for completely non-reflective creation of components by Spring, by attaching a <code>Supplier</code> to a <code>BeanDefinition</code>, instead of a <code>Class</code>.</p>
</div>
<div class="paragraph">
<p>The programming model is a little bit different than the most popular <code>@Configuration</code> style, but it still has the same goal: to extract configuration logic into separate resources, and allow the logic to be implemented in Java. If you had a configuration class like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Configuration
public class SampleConfiguration {

    @Bean
    public Foo foo() {
        return new Foo();
    }

    @Bean
    public Bar bar(Foo foo) {
        return new Bar(foo);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You could convert it to functional style like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public class SampleConfiguration
        implements ApplicationContextInitializer&lt;GenericApplicationContext&gt; {

    public Foo foo() {
        return new Foo();
    }

    public Bar bar(Foo foo) {
        return new Bar(foo);
    }

    @Override
    public void initialize(GenericApplicationContext context) {
        context.registerBean(SampleConfiguration.class, () -&gt; this);
        context.registerBean(Foo.class,
                () -&gt; context.getBean(SampleConfiguration.class).foo());
        context.registerBean(Bar.class, () -&gt; context.getBean(SampleConfiguration.class)
                .bar(context.getBean(Foo.class)));
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are multiple options for where to make these <code>registerBean()</code> method calls, but here we have chosen to show them wrapped in an <code>ApplicationContextInitializer</code>. The <code>ApplicationContextInitializer</code> is a core framework interface, but it has a special place in Spring Boot because a <code>SpringApplication</code> can be loaded up with initializers through its public API, or by declaring them in <code>META-INF/spring.factories</code>. The <code>spring.factories</code> approach is one that easily allows the application and its integration tests (using <code>@SpringBootTest</code>) to share the same configuration.</p>
</div>
<div class="paragraph">
<p>This programming model is not yet mainstream in Spring Boot applications, but it has been implemented in <a href="https://spring.io/blog/2018/10/22/functional-bean-registrations-in-spring-cloud-function">Spring Cloud Function</a> and is also a basic building block in <a href="https://spring.io/blog/2018/10/02/the-evolution-of-spring-fu">Spring Fu</a>. Also the fastest full Spring Boot benchmark apps above ("bunc") are implemented this way. The main reason for this is that functional bean registration is the fastest way for Spring to create bean instances - it requires virtually no computation beyond instantiating a class and calling its constructors natively.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The other, non-functional types of <code>BeanDefinition</code> will always be slower, but that will not stop us from optimizing further and the gap will almost certainly narrow as Spring evolves.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The existing functional bean implementations in libraries and apps had to manually copy quite a bit of code from Spring Boot, and convert it to the functional style. For small applications this might be practical, but the more features from Spring Boot you use, the less convenient it will be. Recognizing this we have started work on various tools that could be used to automatically convert <code>@Configuration</code> to <code>ApplicationContextInitializer</code> code. You can do it at runtime with reflection, and this turns out to be <a href="https://github.com/dsyer/spring-boot-auto-reflect">surprisingly fast</a> (proving that not all reflection is bad), or you could do it at compile time, which promises to be optimal in turns of start up time but is technically a little bit harder to implement.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="the-future"><a class="anchor" href="#the-future"></a>The Future</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Whatever the future brings, I think we can be certain that Spring will stay as lightweight as possible, and continue to improve performance, in terms of startup time, memory usage and also runtime CPU usage. The most promising lines of attack at present are the functional bean registrations, and probably some automated way to generate those from <code>@Configuration</code>, plus the work we are doing with the Graal team at Oracle to make GraalVM more generally usable for Spring Boot applications. There are still optimizations to be made in the core framework, as well as in Spring Boot probably. Keep an eye out on the <a href="https://spring.io/blog">Spring Blog</a> for more new research and new releases, and more topical analysis of performance hotspots and tweaks you can make to avoid them.</p>
</div>
</div>
</div>
</div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 3497;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>
Back
</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">All Posts</a>
<a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">Engineering</a>
<a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">Releases</a>
<a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">News and Events</a>
<a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>Get updates from The Spring Team delivered to your inbox</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">Tools</a></li>
<li><a href="https://store.pivotal.io/">Store</a></li>
<li><a href="/blog">Newsletter</a></li>
</ul>
</div>
</div>
&copy; <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a>, Inc. All Rights Reserved.
<a href="https://pivotal.io/terms-of-use">Terms of Use</a> &bullet;
<a href="https://pivotal.io/privacy-policy">Privacy</a> &bullet;
<a href="/trademarks">Trademark Guidelines</a>
<div id="teconsent" style="display:inline-block;"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>