<html  data-code-prettify="" data-mobile-support="" data-search=""><head></head><body >﻿
<title> Spring 有多快？</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="How Fast is Spring?">
<meta name="twitter:description" >
<meta name="twitter:creator" content="@david_syer">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=200">

<meta property="og:title" content="How Fast is Spring?">
<meta property="og:image" content="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=200">
<meta property="og:description" >
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2018-12-12 14:09:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title"> Spring 有多快？</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=20&d=mm"> <a class="author" rel="author" href="/team/dsyer">戴夫·瑟</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2018-12-12 14:09:00.0">十二月12，2018</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2018/12/12/how-fast-is-spring#disqus_thread" data-disqus-identifier="3497">
</a></div>
</div>
</header>
<div class="blog--post"><div class="paragraph">
<p>性能一直是Spring Engineering团队的头等要务之一，我们一直在监视和响应更改以及反馈。最近（过去2-3年）已经完成了一些相当紧张而精确的工作，本文在这里可以帮助您找到工作的结果，并学习如何衡量和改进自己的应用程序中的性能。标题是Spring Boot 2.1和Spring 5.1对启动时间和堆使用进行了一些相当不错的优化。这是通过测量受堆限制的应用程序的启动时间制成的图形：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQpSEfx0Y1W9aD3XVyn91-S0jtUp2DRCQSy_W_LMGyMR91YLAQ1mL7MiR1BRd8VzshvtuxzL6WAnlxf/pubchart?oid=336485057&format=image" alt="堆大小2.1.x" width="75%">
</div>
</div>
<div class="paragraph">
<p>当您挤压可用堆时，应用程序通常不会在启动时受到影响，直到达到临界点为止。图表的特征是“曲棍球棒”形状，显示了垃圾回收失败的时刻，该应用程序不再启动。从图中可以看出，使用Spring Boot 2.1（而不是2.0）可以在10MB的堆中运行一个简单的Netty应用程序。与2.0相比，它在2.1中也更快。</p>
</div>
<div class="paragraph">
<p>这里的大多数细节都专门针对启动时间的度量和优化，但是堆内存消耗也是非常相关的，因为对堆大小的限制通常会导致启动速度变慢（请参见上图）。我们可以（并且将）关注性能的其他方面，例如，特别是在将注释用于HTTP请求映射的情况下；但是这些顾虑将不得不等待另一个单独的记录。</p>
</div>
<div class="paragraph">
<p>考虑到所有因素后，请记住，Spring <em>从头开始</em>就是设计为轻量级的，除非您要求，否则实际上所做的工作很少。有许多<strong>可选</strong>功能，因此您不必使用它们。以下是一些简要总结：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>包装：带有应用程序自己的主容器的爆炸罐子总是更快</p>
</li>
<li>
<p>服务器：Tomcat，Jetty和Undertow之间没有可测量的差异</p>
</li>
<li>
<p>网状是启动快<em>一点</em> -你不会在一个大的应用程序通知</p>
</li>
<li>
<p>您使用的功能越多，加载的类就越多</p>
</li>
<li>
<p>功能Bean定义提供了增量改进</p>
</li>
<li>
<p>一个带有HTTP终结点的最小Spring Boot应用程序在<1秒内启动，并使用<10MB堆</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>一些链接：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/dsyer/spring-boot-startup-bench" class="bare">https://github.com/dsyer/spring-boot-startup-bench-</a>较旧的基准测试（回到Spring Boot 1.3），胖罐数据</p>
</li>
<li>
<p>同一仓库中的<a href="https://github.com/dsyer/spring-boot-startup-bench/blob/master/static/README.adoc">/ static</a>基准测试-较新，探讨加载了相关性的类</p>
</li>
<li>
<p>同一存储库中的<a href="https://github.com/dsyer/spring-boot-startup-bench/blob/master/flux/README.adoc">/ flux</a>基准测试-WebFlux</p>
</li>
<li>
<p><a href="https://spring.io/blog/2018/10/22/functional-bean-registrations-in-spring-cloud-function" class="bare">https://spring.io/blog/2018/10/22/functional-bean-registrations-in-spring-cloud-function-</a>有关Spring Cloud Function中的功能bean的博客</p>
</li>
<li>
<p>春福： <a href="https://github.com/spring-projects/spring-fu" class="bare">https</a> : <a href="https://github.com/spring-projects/spring-fu" class="bare">//github.com/spring-projects/spring-fu</a></p>
</li>
<li>
<p><a href="https://github.com/dsyer/spring-boot-allocations" class="bare">https://github.com/dsyer/spring-boot-allocations-</a>功能bean和GC压力的基准</p>
</li>
<li>
<p><a href="https://github.com/dsyer/spring-boot-micro-apps" class="bare">https://github.com/dsyer/spring-boot-micro-apps-</a>功能Bean和AOT（与“分配”项目相同的代码，但示例应用不是基准）</p>
</li>
</ul>
</div>
<div class="sect1">
<h2 id="tldr-how-do-i-make-my-app-go-faster"><a class="anchor" href="#tldr-how-do-i-make-my-app-go-faster"></a> TL; DR如何使我的应用运行更快？</h2>
<div class="sectionbody">
<div class="paragraph">
<p>（从<a href="https://github.com/dsyer/spring-boot-allocations">这里</a>复制。）大多数情况下，您将不得不放弃功能，因此并非所有应用程序都可以使用所有这些建议。有些容器并没有那么痛苦，并且实际上在容器中很自然，例如，如果要构建docker映像，最好解压缩jar并将应用程序类放置在其他文件系统层中。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Spring Boot Web入门中的类路径排除项：</p>
<div class="ulist">
<ul>
<li>
<p>休眠验证器</p>
</li>
<li>
<p>杰克逊（但Spring Boot执行器取决于它）。如果您需要JSON呈现，请使用Gson（开箱即用仅适用于MVC）。</p>
</li>
<li>
<p>登录：使用<code>slf4j-jdk14</code>代替</p>
</li>
</ul>
</div>
</li>
<li>
<p>使用<code>spring-context-indexer</code> 。它不会增加太多，但是一点点帮助。</p>
</li>
<li>
<p>如果负担不起，请不要使用执行器。</p>
</li>
<li>
<p>使用Spring Boot 2.1和Spring 5.1。可用时切换到2.2和5.2。</p>
</li>
<li>
<p>使用以下命令修复<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-external-config-application-property-files">Spring Boot配置文件</a>的位置<code>spring.config.location</code> （命令行参数或系统属性等）。在IDE中进行测试的示例： <code>spring.config.location=file://./src/main/resources/application.properties</code> 。</p>
</li>
<li>
<p>如果不需要，请关闭JMX <code>spring.jmx.enabled=false</code> （这是Spring Boot 2.2中的默认设置）</p>
</li>
<li>
<p>默认情况下，使bean定义变得懒惰。有一个新的标志<code>spring.main.lazy-initialization=true</code>在Spring Boot 2.2中（还有一个<code>LazyInitBeanFactoryPostProcessor</code>在<a href="https://github.com/dsyer/spring-boot-allocations">此项目中，</a>您可以复制）。</p>
</li>
<li>
<p>解开胖子jar并使用显式类路径运行。</p>
</li>
<li>
<p>使用以下命令运行JVM <code>-noverify</code> 。还考虑<code>-XX:TieredStopAtLevel=1</code> （这将在以后减慢JIT速度，但会节省启动时间）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>一个更极端的选择是使用功能Bean定义重新编写所有应用程序配置。这包括您正在使用的所有Spring Boot自动配置，其中大部分都可以重复使用，但这是手动识别要使用的类并注册所有Bean定义的手动工作。如果尝试这种方法，则启动时间可能会缩短2倍，但并不是所有的改进都是由于功能Bean的定义（估计通常对于功能Bean而言，启动时间会增加10％，但可能会有其他福利）。看着那（这<code>BuncApplication</code>在<a href="https://github.com/dsyer/spring-boot-micro-apps">微型应用程序</a>中查看如何在不启动Spring Boot的情况下启动<code>@Configuration</code>类处理器。</p>
</div>
<div class="paragraph">
<p>不包括<code>netty-transport-native-epoll</code>还将启动时间增加了30ms左右（仅Linux）。这是自Spring Boot 2.0以来的回归，因此，一旦我们对它有所了解，就可以消除它。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="some-basic-benchmarks"><a class="anchor" href="#some-basic-benchmarks"></a>一些基本基准</h2>
<div class="sectionbody">
<div class="paragraph">
<p>这是来自<a href="https://github.com/dsyer/spring-boot-startup-bench" class="bare">https://github.com/dsyer/spring-boot-startup-bench</a>的<a href="https://github.com/dsyer/spring-boot-startup-bench/blob/master/static/README.adoc">静态基准测试</a>的子集。每个应用程序每次启动时都使用一个新的JVM（独立进程）启动每个应用程序，并具有显式的类路径（而不是胖子）。该应用程序始终是相同的，但是具有不同级别的自动（在某些情况下是手动）配置。“分数”是启动时间，以秒为单位，表示从启动JVM到在记录器输出中看到标记的时间（此时应用程序已启动并接受HTTP连接）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>Benchmark   (sample) Mode  Cnt  Score   Error  Units Beans Classes
MainBenchmark  actr  avgt   10  1.316 ± 0.060   s/op 186   5666
MainBenchmark  jdbc  avgt   10  1.237 ± 0.050   s/op 147   5625
MainBenchmark  demo  avgt   10  1.056 ± 0.040   s/op 111   5266
MainBenchmark  slim  avgt   10  1.003 ± 0.011   s/op 105   5208
MainBenchmark  thin  avgt   10  0.855 ± 0.028   s/op 60    4892
MainBenchmark  lite  avgt   10  0.694 ± 0.015   s/op 30    4580
MainBenchmark  func  avgt   10  0.652 ± 0.017   s/op 25    4378</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">主机是“塔式”，i7、3.4GHz，32G RAM，SSD。</td>
</tr>
</tbody></table>
</div>
<div class="ulist">
<ul>
<li>
<p>演员：与“演示”样本加执行器相同</p>
</li>
<li>
<p>Jdbc：与“ demo”示例相同，外加JDBC</p>
</li>
<li>
<p>演示：带有一个端点的香草Spring Boot MVC应用程序（无执行器）</p>
</li>
<li>
<p>苗条：一样但明确<code>@Imports</code>所有配置</p>
</li>
<li>
<p>薄：减少<code>@Imports</code>减少到端点所需的4个一组</p>
</li>
<li>
<p>精简版：从“ thin”复制导入，并使其成为硬编码的无条件配置</p>
</li>
<li>
<p>Func：从“精简版”中提取配置方法并使用功能bean API对其进行注册</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>一般而言，使用的功能越多，加载的类就越多，并且在<code>ApplicationContext</code> 。实际上，启动时间和装入的类数量之间的关系非常紧密（比与bean数量紧密得多）。这是一个从该数据编译的图，并扩展了一系列其他内容，例如JPA，Spring Cloud的一些位，一直到类路径上所有东西（包括Zuul和Sleuth）的“厨房水槽”：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://docs.google.com/spreadsheets/d/e/2PACX-1vR8B4l5WkWf-9gZWmIYTkmBWM7YWf5bRg852OakrV0G2-vtfM_UkVNRC3cTVk1079HagnMVHYZnvbib/pubchart?oid=976086548&format=image" alt="pubchart？oid = 976086548＆format = image" width="75%">
</div>
</div>
<div class="paragraph">
<p>如果您在静态基准测试中运行“ MainBenchmark”和“ StripBenchmark”，则可以从基准测试报告中删除图形的数据（上表是来自同一类的旧数据）。自述文件中有关于如何执行此操作的说明。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="garbage-collection-pressure"><a class="anchor" href="#garbage-collection-pressure"></a>垃圾收集压力</h2>
<div class="sectionbody">
<div class="paragraph">
<p>尽管确实是可以衡量的，但是加载的更多类（即更多功能）与启动时间较慢直接相关，但存在一些微妙之处，其中最重要也是最易分析的是垃圾收集（GC）。对于长时间运行的应用程序而言，垃圾回收可能是非常重要的事情，而且我们都听说过大型应用程序中GC长时间停顿的故事（堆越大，等待时间越长）。自定义GC策略是一项大生意，并且是调整长期运行（尤其是大型应用程序）的重要工具。在启动时，还会发生其他事情，但是这些事情也可能与垃圾回收有关，Spring 5.1和Spring Boot 2.1中的许多优化都是通过分析这些优化获得的。</p>
</div>
<div class="paragraph">
<p>要注意的主要事情是紧密的循环，其中临时对象被创建和丢弃。这种模式中的某些代码是不可避免的，而有些则超出了我们的控制范围（例如，在JDK本身中），在这种情况下，我们所能做的就是尽量不要调用它。但是，这些成群的临时对象给垃圾回收带来压力，并使堆膨胀，即使它们本身从未真正进入堆中也是如此。如果可以捕获额外的GC压力，那么通常可以将其视为堆大小的峰值。来自<a href="https://github.com/jvm-profiling-tools/async-profiler">async-profiler的</a>火焰图是一个更好的工具，因为与大多数分析工具相比，它们可以进行更细粒度的采样，并且在视觉上非常醒目。</p>
</div>
<div class="paragraph">
<p>这是我们一直在使用Spring Boot 2.0和Spring Boot 2.1进行基准测试的HTTP示例应用程序中的示例火焰图：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width:52%">
<col style="width:48%">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="https://github.com/dsyer/spring-boot-allocations/raw/master/images/flame_20.svg?sanitize=true" alt="flame_20">
</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="https://github.com/dsyer/spring-boot-allocations/raw/master/images/flame_21.svg?sanitize=true" alt="flame_21">
</div>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Spring Boot 2.0</p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Spring Boot 2.1</p>
</div></div></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>在Spring Boot 2.1中，右侧的红色/棕色GC火焰明显较小。这是由于bean工厂内部的<a href="https://github.com/spring-projects/spring-framework/commit/81cb740e">变化</a>而导致GC压力降低的迹象。如果要查看详细信息， <a href="https://jira.spring.io/browse/SPR-16918">此处</a>是主要更改之一背后的Spring Framework问题。</p>
</div>
<div class="paragraph">
<p>认识到GC压力是一个问题是一回事（异步分析器是我们发现的最好的工具），但是找到它的来源是一门艺术。我们找到的最好的工具是Flight Recorder（或Java Mission Control），它是OpenJDK版本的一部分，尽管它过去仅在Oracle发行版中。Flight Recorder的问题在于采样率实际上还不够高，无法在启动时捕获足够的数据，因此您必须尝试建立紧密的循环来执行您感兴趣的事情，或者怀疑可能是造成问题的原因，然后进行分析较长时间（几秒钟或更长时间）的广告。这可以带来更多的见解，但是没有关于“真实”应用程序是否将从更改热点中受益的真实数据。<a href="https://github.com/dsyer/spring-boot-allocations">spring-boot-allocations</a>项目中的许多代码都是这种代码：运行紧密循环的主要方法侧重于可疑热点，然后可以使用Flight Controller对其进行分析。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux-and-micro-apps"><a class="anchor" href="#webflux-and-micro-apps"></a> WebFlux和Micro Apps</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我们可能期望使用Servlet容器的应用程序与使用Spring 5.0中引入的来自Netty的较新的反应式运行时的应用程序之间有所不同。上面的基准数字使用的是Tomcat。在同一存储库的不同子目录中，有一些类似的度量。以下是<a href="https://github.com/dsyer/spring-boot-startup-bench/blob/master/flux/README.adoc">通量基准测试</a>的结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>Benchmark            (sample)  Mode  Cnt  Score   Error  Units Classes
MainBenchmark.main       demo    ss   10  1.081 ± 0.075   s/op 5779
MainBenchmark.main       jlog    ss   10  0.933 ± 0.065   s/op 4367
MiniBenchmark.boot       demo    ss   10  0.579 ± 0.041   s/op 4138
MiniBenchmark.boot       jlog    ss   10  0.486 ± 0.020   s/op 2974
MiniBenchmark.mini       demo    ss   10  0.538 ± 0.009   s/op 3138
MiniBenchmark.mini       jlog    ss   10  0.420 ± 0.011   s/op 2351
MiniBenchmark.micro      demo    ss   10  0.288 ± 0.006   s/op 2112
MiniBenchmark.micro      jlog    ss   10  0.186 ± 0.006   s/op 1371</code></pre>
</div>
</div>
<div class="paragraph">
<p>所有应用程序都有一个HTTP端点，就像静态基准测试（Tomcat，Servlet）中的应用程序一样。所有这些都比Tomcat快一点，但幅度不大（也许10％）。请注意，最快的一个（“微型日志”）在不到200毫秒的时间内启动并运行。Spring实际上并没有做太多事情，而所有的花费基本上就是为应用程序（HTTP服务器）所需的功能加载类。</p>
</div>
<div class="paragraph">
<p>笔记：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>的<code>MainBenchmark.main(demo)</code>是完整的Boot + Webflux +自动配置。</p>
</li>
<li>
<p>的<code>boot</code>示例使用Spring Boot，但没有自动配置。</p>
</li>
<li>
<p>的<code>jlog</code>示例不包括logback以及Hibernate Validator和Jackson。</p>
</li>
<li>
<p>的<code>mini</code>样本不使用Spring Boot（只是<code>@EnableWebFlux</code> ）。</p>
</li>
<li>
<p>的<code>micro</code>样品不使用<code>@EnableWebflux</code>要么只是手动路线注册。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>迷你jlog示例运行在约46MB内存（10堆，36块非堆）中。微型jlog示例运行在38MB（8个堆，30个非堆）中。对于这些较小的应用程序，非堆确实很重要。它们都包含在上面的散点图中，因此它们与启动时间和加载的类之间的一般相关性一致。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="classpath-exclusions"><a class="anchor" href="#classpath-exclusions"></a>类路径排除</h2>
<div class="sectionbody">
<div class="paragraph">
<p>您的里程可能会有所不同，但请考虑排除以下因素：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>杰克逊（ <code>spring-boot-starter-json</code> ）：它并不昂贵（启动时可能需要50毫秒），但Gson更快，并且占用空间更小。</p>
</li>
<li>
<p>登入（ <code>spring-boot-starter-logging</code> ）：仍然是最好，最灵活的日志记录库，但是所有这些灵活性都需要付出一定的代价。</p>
</li>
<li>
<p>休眠验证器（ <code>org.hibernate.validator:hibernate-validator</code> ）：启动时需要做很多工作，因此，如果您不使用它，请将其排除在外。</p>
</li>
<li>
<p>执行器（ <code>spring-boot-starter-actuator</code> ）：非常有用的功能集，因此很难建议完全将其删除，但是如果您不使用它，请不要将其放在类路径中。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-tweaks"><a class="anchor" href="#spring-tweaks"></a> Spring 调整</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>使用<code>spring-context-indexer</code> 。这是对classpath的介绍，因此非常容易安装。它仅适用于您自己的应用程序<code>@Component</code>类，除了最大（1000个bean）的应用程序之外，对于所有其他应用程序而言，实际上只会极大地缩短启动时间。但这是可以衡量的。</p>
</li>
<li>
<p>如果负担不起，请不要使用执行器。</p>
</li>
<li>
<p>使用Spring Boot 2.1和Spring 5.1。两者都有很小但重要的优化，特别是在启动时垃圾回收压力方面。这就是使较新的应用程序以较少的堆启动的原因。</p>
</li>
<li>
<p>使用显式<code>spring.config.location</code> 。Spring Boot在很多地方都可以找到<code>application.properties</code> （要么<code>.yml</code> ），因此如果您确切知道它的位置或可能在运行时，则可以节省几个百分点。</p>
</li>
<li>
<p>关闭JMX： <code>spring.jmx.enabled=false</code> 。如果您不使用它，则无需支付创建和注册MBean的费用。</p>
</li>
<li>
<p>默认情况下，使bean定义变得懒惰。Spring Boot并没有做到这一点，但是有一个<code>LazyInitBeanFactoryPostProcessor</code>在<a href="https://github.com/dsyer/spring-boot-allocations">此项目中，</a>您可以复制。只是一个<code>BeanFactoryPostProcessor</code>将所有bean切换到<code>lazy=true</code> 。</p>
</li>
<li>
<p>Spring Data现在具有一些懒惰的初始化功能（在Lovelace或Spring Boot 2.1中）。在Spring Boot中，您可以设置<code>spring.data.jpa.repositories.bootstrap-mode=lazy</code> -对于拥有数百个实体的大型应用程序，启动时间缩短了10倍以上。</p>
</li>
<li>
<p>使用功能Bean定义而不是<code>@Configuration</code> 。稍后会对此进行详细说明。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jvm-tweaks"><a class="anchor" href="#jvm-tweaks"></a> JVM调整</h2>
<div class="sectionbody">
<div class="paragraph">
<p>有用的命令行调整启动时间：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>-noverify</code> -几乎无害，影响很大。在低信任度的环境中可能不允许。</p>
</li>
<li>
<p><code>-XX:TieredStopAtLevel=1</code> -启动后可能会降低性能，因为它限制了JVM在运行时优化自身的能力。您的行驶里程可能会有所不同，但这会对启动时间产生可观的影响。</p>
</li>
<li>
<p><code>-Djava.security.egd=file:/dev/./urandom</code> -不再是什么了，但是以前确实需要使用旧版本的Tomcat。如果有人使用随机数，则对具有或不具有Tomcat的现代应用程序都可能会产生很小的影响。</p>
</li>
<li>
<p><code>-XX:+AlwaysPreTouch</code> -对启动的影响很小但可能可测量。</p>
</li>
<li>
<p>使用一个明确的类路径-即爆炸胖子罐并使用<code>java -cp …​</code> 。使用应用程序的本机主类。稍后对此有更多详细信息。</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="class-data-sharing"><a class="anchor" href="#class-data-sharing"></a>类数据共享</h3>
<div class="paragraph">
<p>从版本7开始，类数据共享（CDS）是Oracle JDK的唯一商业功能，但在<a href="https://www.eclipse.org/openj9/">OpenJ9</a> （IBM JVM的开源版本）中也已提供，现在从版本10开始也已在OpenJDK中提供。OpenJ9拥有CDS已有很长时间了，并且在该平台上非常易于使用。它是为优化内存使用量而不是启动时间而设计的，但是这两个问题并非无关紧要。</p>
</div>
<div class="paragraph">
<p>您可以以与常规OpenJDK JVM相同的方式运行OpenJ9，但是CDS的打开使用不同的命令行标志。使用OpenJ9超级方便，因为您需要的只是<code>-Xshareclasses</code> 。增大缓存的大小可能也是一个好主意，例如<code>-Xscmx128m</code> ，并暗示您希望通过以下方式快速启动<code>-Xquickstart</code> 。如果这些标志检测到OpenJ9或IBM JVM，则它们始终在基准测试中处于启用状态。</p>
</div>
<div class="paragraph">
<p>OpenJ9和CDS的基准测试结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>Benchmark            (sample)  Mode  Cnt  Score   Error  Units Classes
MainBenchmark.main       demo    ss   10  0.939 ± 0.027   s/op 5954
MainBenchmark.main       jlog    ss   10  0.709 ± 0.034   s/op 4536
MiniBenchmark.boot       demo    ss   10  0.505 ± 0.035   s/op 4314
MiniBenchmark.boot       jlog    ss   10  0.406 ± 0.085   s/op 3090
MiniBenchmark.mini       demo    ss   10  0.432 ± 0.019   s/op 3256
MiniBenchmark.mini       jlog    ss   10  0.340 ± 0.018   s/op 2427
MiniBenchmark.micro      demo    ss   10  0.204 ± 0.019   s/op 2238
MiniBenchmark.micro      jlog    ss   10  0.152 ± 0.045   s/op 1436</code></pre>
</div>
</div>
<div class="paragraph">
<p>在某些情况下，这是非常令人印象深刻的（对于最快的应用程序，此速度比不使用CDS的速度快25％）。使用OpenJDK可以获得类似的结果：自Java 10起，包含CDS（具有不太方便的命令行界面）。这是加载的类的较小端与启动时间关系的散点图，常规的OpenJDK（无CDS）为红色，而OpenJ9（有CDS）为蓝色：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQpSEfx0Y1W9aD3XVyn91-S0jtUp2DRCQSy_W_LMGyMR91YLAQ1mL7MiR1BRd8VzshvtuxzL6WAnlxf/pubchart?oid=1689271723&format=image" alt="pubchart？oid = 1689271723＆format = image" width="75%">
</div>
</div>
<div class="paragraph">
<p>Java 10和11还具有一项称为“时间提前编译”（AOT）的实验性功能，可让您从Java应用程序构建本机映像。潜在的是，这在启动时非常快，而且大多数可以成功转换的应用程序的启动确实非常快（此处基准测试中的小型应用程序的启动速度是原来的10倍）。许多“现实生活”应用程序尚未转换。AOT是使用<a href="https://github.com/oracle/graal">Graal VM</a>实现的，我们将在稍后介绍。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="lazy-subsystems"><a class="anchor" href="#lazy-subsystems"></a>惰性子系统</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我们提到了懒 bean 定义和<code>LazyInitBeanFactoryPostProcessor</code>通常是上面感兴趣的好处是显而易见的，特别是对于具有许多您从未使用过的自动配置beasn的Spring Boot应用程序，但它也受到限制，因为即使您不使用它们，有时也需要创建它们来满足依赖性。这些局限性可以通过另一种想法来解决，该想法更多地是研究主题，那就是将应用程序分解为模块，并根据需要分别初始化每个模块。</p>
</div>
<div class="paragraph">
<p>为此，您将需要能够在源代码中精确识别一个子系统并以某种方式对其进行标记。这样的子系统的一个例子是Spring Boot中的执行器，我们可以主要通过自动配置类的包名来识别它们。该项目中有一个原型： <a href="https://github.com/dsyer/spring-boot-lazy-actuator">Lazy Actuator</a> 。您可以将其添加到现有项目中，并将所有执行器端点转换为惰性bean，仅在使用它们时才实例化它们，从而在微型应用程序（如规范的单端点HTTP示例应用程序）中节省了大约40％的启动时间。在上述基准中。例如（对于Maven）：</p>
</div>
<div class="listingblock">
<div class="title">pom.xml</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
	&lt;groupId&gt;org.springframework.boot.experimental&lt;/groupId&gt;
	&lt;artifactId&gt;spring-boot-lazy-actuator&lt;/artifactId&gt;
	&lt;version&gt;1.0.0.BUILD-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了使这种模式更加主流，可能会在核心Spring编程模型中进行一些更改，以允许在运行时以特殊方式识别和处理子系统。它还增加了应用程序的复杂性，在很多情况下可能并不值得这样做-Spring Boot的最佳功能之一就是应用程序上下文的简单性（所有bean都是平等创建的）。因此，这仍然是一个活跃的研究领域。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="functional-bean-definitions"><a class="anchor" href="#functional-bean-definitions"></a>功能Bean定义</h2>
<div class="sectionbody">
<div class="paragraph">
<p>功能性bean注册是Spring 5.0中新增的功能，其形式为： <code>BeanDefinitionBuilder</code>和一些方便的方法<code>GenericApplicationContext</code> 。通过附加一个，Spring可以完全无反射地创建组件。 <code>Supplier</code>到<code>BeanDefinition</code> ， 代替<code>Class</code> 。</p>
</div>
<div class="paragraph">
<p>编程模型与最受欢迎的模型有所不同<code>@Configuration</code>样式，但它仍然具有相同的目标：将配置逻辑提取到单独的资源中，并允许用Java实现该逻辑。如果您有这样的配置类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Configuration
public class SampleConfiguration {

    @Bean
    public Foo foo() {
        return new Foo();
    }

    @Bean
    public Bar bar(Foo foo) {
        return new Bar(foo);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以将其转换为以下功能样式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public class SampleConfiguration
        implements ApplicationContextInitializer&lt;GenericApplicationContext&gt; {

    public Foo foo() {
        return new Foo();
    }

    public Bar bar(Foo foo) {
        return new Bar(foo);
    }

    @Override
    public void initialize(GenericApplicationContext context) {
        context.registerBean(SampleConfiguration.class, () -&gt; this);
        context.registerBean(Foo.class,
                () -&gt; context.getBean(SampleConfiguration.class).foo());
        context.registerBean(Bar.class, () -&gt; context.getBean(SampleConfiguration.class)
                .bar(context.getBean(Foo.class)));
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在何处制作这些有多种选择<code>registerBean()</code>方法调用，但在这里我们选择将它们包装在一个<code>ApplicationContextInitializer</code> 。的<code>ApplicationContextInitializer</code>是核心框架接口，但在Spring Boot中占有特殊位置，因为<code>SpringApplication</code>可以通过其公共API或通过在以下位置声明它们来加载初始化程序： <code>META-INF/spring.factories</code> 。的<code>spring.factories</code>这种方法很容易允许应用程序及其集成测试（使用<code>@SpringBootTest</code> ）共享相同的配置。</p>
</div>
<div class="paragraph">
<p>该编程模型尚未在Spring Boot应用程序中成为主流，但已在<a href="https://spring.io/blog/2018/10/22/functional-bean-registrations-in-spring-cloud-function">Spring Cloud Function中</a>实现，并且是<a href="https://spring.io/blog/2018/10/02/the-evolution-of-spring-fu">Spring Fu中</a>的基本构建块。上面最快的完整Spring Boot基准测试应用程序（“ bunc”）也以这种方式实现。这样做的主要原因是，功能性bean注册是Spring创建bean实例的最快方法-除了实例化类和本地调用其构造函数外，它实际上不需要任何计算。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">其他非功能类型<code>BeanDefinition</code>速度总是会变慢，但这不会阻止我们进一步优化，随着Spring的发展，差距几乎肯定会缩小。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>库和应用程序中现有的功能Bean实现必须手动从Spring Boot复制大量代码，并将其转换为功能样式。对于小型应用程序，这可能很实用，但是使用的Spring Boot功能越多，使用起来就越不方便。认识到这一点，我们开始着手开发各种可用于自动转换的工具<code>@Configuration</code>至<code>ApplicationContextInitializer</code>码。您可以在运行时使用反射来完成它，结果<a href="https://github.com/dsyer/spring-boot-auto-reflect">出乎意料的快</a> （证明并非所有反射都不好），或者您可以在编译时进行，这保证了启动时的最佳时间，但从技术上讲实施起来有点困难。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="the-future"><a class="anchor" href="#the-future"></a>未来</h2>
<div class="sectionbody">
<div class="paragraph">
<p>无论未来如何发展，我认为我们可以肯定的是，Spring将在启动时间，内存使用率以及运行时CPU使用率方面保持尽可能轻巧，并继续提高性能。当前最有希望的攻击路线是功能性bean注册，并且可能是一些自动方法来从<code>@Configuration</code> ，以及我们与Oracle Graal团队所做的工作，以使GraalVM更广泛地用于Spring Boot应用程序。核心框架以及Spring Boot中可能仍需要进行优化。请密切关注<a href="https://spring.io/blog">Spring Blog，</a>以获取更多新研究和新发行版，以及对性能热点和调节的更多主题分析，您可以针对这些热点和调节进行避免。</p>
</div>
</div>
</div>
</div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 3497;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>