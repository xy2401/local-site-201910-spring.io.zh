<!DOCTYPE html>
<html data-code-prettify="" data-mobile-support="" data-search="">
<head>
<title>Method Injection</title>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no" id="Viewport" name="viewport" />
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png" />
<link href="https://fonts.googleapis.com/css?family=Varela+Round|Montserrat:400,700" rel="stylesheet" type="text/css" />
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css" />
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M" name="google-site-verification" />

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css" />

<meta content="summary" name="twitter:card" />
<meta content="@springcentral" name="twitter:site" />
<meta name="twitter:title" content="Method Injection" />
<meta name="twitter:description" content="&lt;p&gt;A couple of months ago, in the days before I had a blog, there was a discussion by &lt;a href=&quot;http://www.beust.com/weblog/archives/000132.html&quot;&gt;Cedric &lt;/a&gt;and &lt;a href=&quot;http://today.java.net/cs/user/print/au/152?x-t=full.view&quot;&gt;Bob &lt;/a&gt;about “Getter Injection.”&lt;/p&gt;
&lt;p&gt;The basic concept is that the IoC container can override abstract or concrete methods on managed objects on deployment. The container is injecting a method, such as a getter method, rather than a reference or primitive as in Setter Injection. As it happened, I was already working on a container method override mechanism for Spring 1.1, which has since been released in Spring 1.1 RC1. It’s an interesting concept, and definitely part of a complete IoC container. However, I believe that the concept is more general and needs a more general name. Also, that it should only be used in a fairly narrow range of scenarios.&lt;/p&gt;
" />

<meta property="og:title" content="Method Injection" />
<meta property="og:description" content="&lt;p&gt;A couple of months ago, in the days before I had a blog, there was a discussion by &lt;a href=&quot;http://www.beust.com/weblog/archives/000132.html&quot;&gt;Cedric &lt;/a&gt;and &lt;a href=&quot;http://today.java.net/cs/user/print/au/152?x-t=full.view&quot;&gt;Bob &lt;/a&gt;about “Getter Injection.”&lt;/p&gt;
&lt;p&gt;The basic concept is that the IoC container can override abstract or concrete methods on managed objects on deployment. The container is injecting a method, such as a getter method, rather than a reference or primitive as in Setter Injection. As it happened, I was already working on a container method override mechanism for Spring 1.1, which has since been released in Spring 1.1 RC1. It’s an interesting concept, and definitely part of a complete IoC container. However, I believe that the concept is more general and needs a more general name. Also, that it should only be used in a fairly narrow range of scenarios.&lt;/p&gt;
" />
<meta content="article" property="og:type" />
<meta property="og:article:published_time" content="2004-08-06 18:39:00.0" />
</head>
<body>

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" style="display:none;visibility:hidden" width="0"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">Projects</a>
</li>
<li class="navbar-link">
<a href="/guides">Guides</a>
</li>
<li class="navbar-link active">
<a href="/blog">Blog</a>
</li>
<li class="navbar-link">
<a href="/services">Training & Certification</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form action="/search" class="form-inline form-search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search for documentation, guides, and posts..." type="text" value="" />
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form action="/search" class="form-inline form-search" method="get">
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search..." type="text" value="" />
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">
Home
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">
Projects
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">
Guides
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">
Blog
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">
Training & Certification
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>Engineering</div>
</div>
<div class="blog-category content--title">
<div>Releases</div>
</div>
<div class="blog-category content--title">
<div>News and Events</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Method Injection</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">Engineering</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="null?s=20&amp;d=mm" />
<span class="author">Rod Johnson</span>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2004-08-06 18:39:00.0">August 06, 2004</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" data-disqus-identifier="11" href="/blog/2004/08/06/method-injection#disqus_thread">
</a></div>
</div>
</header>
<div class="blog--post"><p>A couple of months ago, in the days before I had a blog, there was a discussion by <a href="http://www.beust.com/weblog/archives/000132.html">Cedric </a>and <a href="http://today.java.net/cs/user/print/au/152?x-t=full.view">Bob </a>about &ldquo;Getter Injection.&rdquo;</p><p>The basic concept is that the IoC container can override abstract or concrete methods on managed objects on deployment. The container is injecting a method, such as a getter method, rather than a reference or primitive as in Setter Injection. As it happened, I was already working on a container method override mechanism for Spring 1.1, which has since been released in Spring 1.1 RC1. It&rsquo;s an interesting concept, and definitely part of a complete IoC container. However, I believe that the concept is more general and needs a more general name. Also, that it should only be used in a fairly narrow range of scenarios.</p><p>Why would you want to do this? Cedric&rsquo;s motivation was that setter methods are &ldquo;useless&rdquo; and that &ldquo;having methods in a Java object that you will never invoke is a Design Smell.&rdquo; In his view, the most important methods in the objects are really the <em>getters</em>, which usually return object references saved in the setters. Thus he proposes having the container implement the getter methods, and doing away with the setters. In practice this will mean that the container will actually override getter methods defined as part of application code, as otherwise it&rsquo;s impossible to use them. Thus the container will end up implementing it using a similar mechanism to CMP 2.x (although hopefully any similarity will end there).</p><p>I don&rsquo;t really buy the &ldquo;useless method&rdquo; argument, because setters <em>will </em>be invoked by an IoC container using Dependency Injection, and <em>will </em>be invoked in unit tests, without any container at all. They&rsquo;ll be invoked by application code if the object is used outside a container. Furthermore, a getter/setter combination is a nice way of establishing defaults, in case you don&rsquo;t choose to configure one or more setters to be invoked: the setter is there if you need it. While I can see Cedric&rsquo;s motivation, there&rsquo;s a tradeoff here: if we get rid of the supposedly useless setters we&rsquo;re left with incomplete classes. If the getters are abstract, we go back to the CMP 2.x testing scenario of needing to test abstract objects. If the getters are concrete, we&rsquo;re routinely writing methods that are going to be overridden at runtime. Now that really is useless code, in my view. (In general, I&rsquo;m not a fan of overriding concrete methods, and avoid it where possible. I think I first read that suggestion in the <em>UML Reference Manual </em>and it makes a lot of sense.) There&rsquo;s also an element of magic involved in &ldquo;setter injection.&rdquo; If I can have a simple POJO, with no fancy container subclassing, I prefer it. As Cedric himself put it very well in a panel discussion at TSSS last May, &ldquo;use magic only when science fails.&rdquo;</p><p>I think the concept should be renamed <strong>Method Injection</strong>, and that its value is far greater for some other&ndash;less common&ndash;scenarios.</p><p>I wouldn&rsquo;t use it as an alternative to Setter or Constructor Injection in typical configuration of objects using Dependency Injection. Setter methods and constructors are plain Java constructs that work very well in a container, but aren&rsquo;t reliant on a container. That&rsquo;s good. Magic methods supplied by the IoC container create a bit more of a reliance on a container, although of course it&rsquo;s still possible to subclass objects outside the container, and although they&rsquo;re still just Java.</p><p>Essentially I see Method Injection as an alternative to subclassing in some corner cases, where the superclass should be kept isolated from a container dependency, and the container can more easily implement the necessary behaviour than a regular subclass. The method in question doesn&rsquo;t need to be a getter method (as in Setter Injection getters), although typically it will be a method that returns something.</p><p>I see three main cases for methods implemented by the container:</p><p>They can move a container dependency out of application code.<br />They can rely on infrastructure not known until deployment.<br />They can customize the behaviour of legacy code for the runtime environment. However, plain old subclassing also makes sense here.<br />Container-subclassing is also a bit more dynamic than regular subclassing. We can potentially take the one base class and deploy it in different ways without ever needing to manage source code for more than one class. However, because its magic quotient is higher than that of regular subclassing, Strategy interfaces or various alternatives, I feel that Method Injection shouldn&rsquo;t be used too eagerly.</p><p>The main appeal of Method Injection to me is as a way of getting rid of a container dependency I sometimes had to incur using Spring 1.0, and which will apply to any container that supports the concept of &ldquo;non-singleton&rdquo; or &ldquo;prototype&rdquo; objects. (That is, a container that gives you the option of getting a shared or new instance of an IoC-managed object on request, depending on configuration.) I love working with Spring, but I hate having to import Spring APIs for configuration.</p><p>The specific use case that caused me to implement this is when one &ldquo;singleton&rdquo; object configured via Spring needs to create instances of a non-singleton object&ndash;for example, a single-threaded, single-use processing object&ndash;yet wants that object to be configured using Dependency Injection, rather than just using new. For example, imagine that ThreadSafeService needs to create an instance of SingleShotHelper, which is itself configured via Dependency Injection. In Spring 1.0.x it&rsquo;s necessary for ThreadSafeService to implement the BeanFactoryAware lifecycle interface, save the BeanFactory reference and call</p><p><code>(SingleShotHelper) beanFactory.getBean(&ldquo;singleShotHelper&rdquo;)</code></p><p>each time it needs to create a helper. That works fine, it&rsquo;s not too hard to test (BeanFactory is a simple interface, so it&rsquo;s easy to mock), but it&rsquo;s a Spring dependency, and it would be ideal to get that bit closer to a perfectly non-invasive framework. The type cast is also a little inelegant, although no big deal.</p><p>I usually ended up with one case of this situation in maybe 10 classes. I&rsquo;d sometimes refactor this to extract a method, like this:</p><p><code>protected SingleShotHelper createSingleShotHelper() { return (SingleShotHelper) context.getBean(&ldquo;singleShotHelper&rdquo;); }</code><br />I could now subclass to implement this and keep the Spring dependency out of the superclass, but that seemed a bit excessive.</p><p>This kind of method is an ideal candidate for being implemented by the container, not the application developer. It&rsquo;s returning an object the container knows about; the whole thing can actually be expressed more concisely in configuration than code (when you allow for the little bit of code needed to save the BeanFactory reference).</p><p>With the new Method Injection functionality introduced in Spring 1.1, it&rsquo;s possible to use an abstract<br />(or concrete) method such as:</p><p><code>protected abstract SingleShotHelper createSingleShotHelper();</code> </p><p>and tell the container to override that method on deployment to return a specific bean from the same or a parent factory, like this:</p><p><code>&lt;lookup-method name=&ldquo;createSingleShotHelper&rdquo; bean=&ldquo;singleShotHelper&rdquo; &gt;</code></p><p>The methods can be protected or public. Any number of methods can be overridden. &lt;lookup-method&gt; elements can be used within bean definition elements just like property or constructor-arg elements.</p><p>I see the most compelling case for Method Injection being to return the result of looking up a named object managed by the container. (Of course this is not Spring-specific: any container could implement this.) The lookup will typically be of a non-singleton bean (in Spring parlance).</p><p>This way there are no dependencies in application code on Spring or any other IoC container. A corner case closed off without needing to import a Spring API. As I said, this feature was directly motivated by requirements in a client project I&rsquo;m working on, and has proven useful in practice.</p><p>Lookup methods can be combined with either Setter Injection or Constructor Injection. They don&rsquo;t take arguments, hence method overloading isn&rsquo;t an issue.</p><p>The implementation uses CGLIB to subclass the class. (It&rsquo;s only available if CGLIB is on the class path, to avoid making the Spring core container dependent on CGLIB.)</p><p>Spring goes a step further, allowing you to define arbitrary behaviour for the overridden method&ndash;not just a bean lookup. You might want to do this, for example, to use a generic behaviour based on the runtime infrastructure&ndash;such as transaction rollback using the Spring TransactionInterceptor class. (Of course, rollback rules should normally be used to avoid this.) Or there may be compelling cases for generic override behaviours&ndash;such as &ldquo;return transactional datasource DS1 if there&rsquo;s an active transaction, otherwise return nontransactional datasource DS2&rdquo;. Again, if we can conceal this kind of logic from application code, it&rsquo;s a win. Here we&rsquo;re beyond the scope of pure &ldquo;getters&rdquo;: we could override methods to publish an event, for example.</p><p>There are often alternatives to arbitrary container overrides, such as subclassing the class and overriding the method in the normal way (science, rather than magic), or using AOP. In the case of a bean lookup as in the example, there is a clear benefit in the container doing the override, as it eliminates dependency on a Spring API. It&rsquo;s also much simpler to describe in XML. With the more general case, it&rsquo;s necessary to have a way of resolving overloaded methods.</p><p>This is already longer than I planned&ndash;and has taken a while!&ndash;so I&rsquo;ll leave discussing Spring 1.1&rsquo;s arbitrary override mechanism (including how it resolves overloaded methods) to a future post, if anyone is interested. I&rsquo;m gaining a new admiration for all those indefatigable bloggers out there like Dion and Matt Raible, who seem to blog about 3 times a day. </p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 11;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>
Back
</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">All Posts</a>
<a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">Engineering</a>
<a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">Releases</a>
<a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">News and Events</a>
<a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>Get updates from The Spring Team delivered to your inbox</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">Tools</a></li>
<li><a href="https://store.pivotal.io/">Store</a></li>
<li><a href="/blog">Newsletter</a></li>
</ul>
</div>
</div>
&copy; <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a>, Inc. All Rights Reserved.
<a href="https://pivotal.io/terms-of-use">Terms of Use</a> &bullet;
<a href="https://pivotal.io/privacy-policy">Privacy</a> &bullet;
<a href="/trademarks">Trademark Guidelines</a>
<div id="teconsent" style="display:inline-block;"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>