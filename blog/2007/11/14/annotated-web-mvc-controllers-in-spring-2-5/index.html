<html dir="ltr" data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>Spring 2.5中带注释的Web MVC控制器</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>System.config({baseURL: "/b92013b"});</script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>System.import('app/main.js')</script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Annotated Web MVC Controllers in Spring 2.5 ">
<meta name="twitter:description" content="<p>Spring 2.5 introduces an approach for writing annotated Web MVC controllers, which we haven’t been blogging about much yet… I’ll take the opportunity to give you an overview of what Spring MVC is really about these days.</p>
<p>Spring MVC is essentially a request dispatcher framework, with a Servlet API variant and Portlet API variant. It operates very closely within its hosting environment - either Servlets or Portlets. Think about Spring MVC as providing foundational facilities and conveniences on top of the Servlet/Portlet container: e.g. flexible request mappings, separation between controller processing and view rendering phase, data binding, basic JSP tag libraries that complement the JSTL, etc. The building blocks of sophisticated HTTP request processing.</p>
">
<meta name="twitter:creator" content="@springjuergen">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/ba9686d8c567aabedc1b7f8b6a7fb3d6?s=200">

<meta property="og:title" content="Annotated Web MVC Controllers in Spring 2.5 ">
<meta property="og:image" content="https://gravatar.com/avatar/ba9686d8c567aabedc1b7f8b6a7fb3d6?s=200">
<meta property="og:description" content="<p>Spring 2.5 introduces an approach for writing annotated Web MVC controllers, which we haven’t been blogging about much yet… I’ll take the opportunity to give you an overview of what Spring MVC is really about these days.</p>
<p>Spring MVC is essentially a request dispatcher framework, with a Servlet API variant and Portlet API variant. It operates very closely within its hosting environment - either Servlets or Portlets. Think about Spring MVC as providing foundational facilities and conveniences on top of the Servlet/Portlet container: e.g. flexible request mappings, separation between controller processing and view rendering phase, data binding, basic JSP tag libraries that complement the JSTL, etc. The building blocks of sophisticated HTTP request processing.</p>
">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2007-11-14 16:17:00.0">
</head>
<body dir="ltr">

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">// Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }</script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Spring 2.5中带注释的Web MVC控制器</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/ba9686d8c567aabedc1b7f8b6a7fb3d6?s=20&d=mm"> <a class="author" rel="author" href="/team/jhoeller">于尔根·霍勒（Juergen Hoeller）</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2007-11-14 16:17:00.0">2007年11月14日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2007/11/14/annotated-web-mvc-controllers-in-spring-2-5#disqus_thread" data-disqus-identifier="115">
</a></div>
</div>
</header>
<div class="blog--post"><p>Spring 2.5引入了一种用于编写带注释的Web MVC控制器的方法，我们尚未对此进行过多博客讨论……我将借此机会向您概述Spring MVC的真正含义。</p><p>Spring MVC本质上是一个请求调度程序框架，具有Servlet API变体和Portlet API变体。它在其托管环境（Servlet或Portlet）中非常紧密地运行。将Spring MVC视为在Servlet / Portlet容器之上提供了基础设施和便利：例如灵活的请求映射，控制器处理和视图呈现阶段之间的分离，数据绑定，补充JSTL的基本JSP标签库等。复杂的HTTP请求处理。</p><p>Spring MVC是非常灵活的事情：其核心DispatcherServlet不仅可以承载其本机控制器，而且可以适应任何类型的动作。它可以托管处理基于HTTP的远程协议的普通HttpRequestHandlers：这是Spring用户在定义HTTP调用程序/ Hessian / Burlap服务导出程序或XFire Web Services导出程序时所利用的。DispatcherServlet甚至可以托管任意第三方Servlet，从而允许这些Servlet由Spring环境进行配置和管理。<br></p><h2>Spring 2.5的带注释的控制器</h2><br>那么Spring 2.5的基于注释的控制器方法如何适合这张图片呢？非常简单：它实际上是DispatcherServlet / DispatcherPortlet支持的替代控制器类型，它没有实现特定的接口，而是使用注释来表达特定处理程序方法的请求映射。它主要是用于实现多动作控制器的下一代样式，取代了Spring的旧式MultiActionController类。<p></p><p>让我们看一个示例，该示例取自Spring发行版随附的“ imagedb”示例应用程序。（注意：这是“ imagedb”的Spring 2.5最终版本，与RC版本略有不同。）<br></p><pre class="code">@Controller<br>public class ImageController {<p></p><p>private ImageDatabase imageDatabase;</p><p>@Autowired<br>public ImageController(ImageDatabase imageDatabase) {<br>this.imageDatabase = imageDatabase;<br>}</p><p>@RequestMapping(“/imageList”)<br>public String showImageList(ModelMap model) {<br>model.addAttribute(“images”, this.imageDatabase.getImages());<br>return “imageList”;<br>}</p><p>@RequestMapping(“/imageContent”)<br>public void streamImageContent(@RequestParam(“name”) String name, OutputStream outputStream)<br>throws IOException {</p><p>this.imageDatabase.streamImage(name, outputStream);<br>}</p><p>@RequestMapping(“/imageUpload”)<br>public String processImageUpload(<br>@RequestParam(“name”) String name, @RequestParam(“description”) String description,<br>@RequestParam(“image”) MultipartFile image) throws IOException {</p><p>this.imageDatabase.storeImage(name, image.getInputStream(), (int) image.getSize(), description);<br>return “redirect:imageList”;<br>}</p><p>@RequestMapping(“/clearDatabase”)<br>public String clearDatabase() {<br>this.imageDatabase.clearDatabase();<br>return “redirect:imageList”;<br>}<br>}</p></pre><br>该控制器类的真正作用是什么？其设计的重点是什么？让我们逐步进行一下…<br><h2>@Controller和@RequestMapping</h2><br>首先，该类使用<strong>@Controller构造</strong>型进行注释。这表明应扫描其方法以查找请求映射。<context:component-scan>就像其他构造型@ Component <context:component-scan>，@ Repository和@Service一样，它也允许通过Spring 2.5的组件扫描（ <context:component-scan>）自动检测<context:component-scan>。在“ imagedb”样本的情况下，仍然通过<bean>标签显式定义ImageController <bean>－仅因为自动检测仅在大量控制器的情况下才真正奏效<bean>。<p></p><p>构造函数被标记为<strong>@Autowired，</strong>并接受ImageDatabase类型的参数。这是Spring 2.5的核心功能，即注释驱动的依赖项注入：此构造函数将被称为传入类型为ImageDatabase的Spring bean，该类型是通过Spring ApplicationContext中的类型获得的。在我们的例子中，这是来自应用程序服务层的中央ImageDatabase服务。</p><p>实际的请求映射通过<strong>@RequestMapping</strong>注释在方法级别表示。这些映射均绑定到包含的DispatcherServlet中的特定HTTP路径。映射路径也可以从处理程序方法名称中推断出来，并在类型级别上表达一个通用的映射模式（例如“ * .image”）-重用InternalPathMethodNameResolver，就像从旧的MultiActionController中知道的那样！</p><p>因此，在类型级别使用@RequestMapping时，方法级别的注释将“缩小”特定处理程序方法的映射。@RequestMapping允许指定HTTP请求方法（例如<em>method = RequestMapping。GET</em> ）或特定的请求参数（例如<em>params =“ action = save”</em> ），都缩小了特定方法的类型级别映射。或者，也可以将类型级别的@RequestMapping与良好的旧Controller接口实现（例如SimpleFormController或MultiActionController）结合使用。<br></p><h2>灵活的处理程序方法签名</h2><br>映射是我称之为“显而易见的”部分，因为很明显在那里发生了什么。现在，不太明显的部分：处理程序方法签名。这是非常灵活的事情，没有像非常好的旧Controller或MultiActionController情况那样绑定到非常具体的签名。当然，您可能会使用标准的HttpServletRequest / HttpServletResponse / ModelAndView签名，但真正的功能在于使用更具体的参数。<p></p><p>“ imagedb”样本显示了两个基本变体：<br></p><pre class="code">@RequestMapping(“/imageList”)<br>public String showImageList(ModelMap model) {<br>model.addAttribute(“images”, this.imageDatabase.getImages());<br>return “imageList”;<br>}</pre><br>对于此处理程序方法，唯一要解析的参数是<strong>ModelMap</strong> 。ModelMap是Spring 2.0重新设计的ModelAndView对象的一部分，封装了将显示给视图的名称-值属性对的集合。上面的代码仅调用ImageDatabase服务以加载ImageDescriptor对象的列表，并将其公开为属性名称“ images”。或者，您可以调用不带属性名称的addAttribute变体，在这种情况下，将从给定的值类型（在本例中为“ imageDescriptorList”）中推断名称。<p></p><p><strong>返回值为String</strong> ，仅指示要呈现的视图的名称。本质上，您可以编写不带参数且返回ModelAndView返回值的相同方法-但以上内容通常更易于阅读，并且避免了对ModelAndView对象的依赖。（请注意，ModelMap是“ ui”包中的泛型类，而ModelAndView是“ web.servlet”包中的特定类。）<br></p><pre class="code">@RequestMapping(“/imageContent”)<br>public void streamImageContent(@RequestParam(“name”) String name, OutputStream outputStream)<br>throws IOException {<p></p><p>this.imageDatabase.streamImage(name, outputStream);<br>}</p></pre><br>此处理程序方法显示了完全不同的用例。其目的是将图像内容从数据库流式传输到HTTP响应。它直接写入响应，而不转发给视图；因此，其<strong>返回类型为void</strong> 。它使用Spring 2.5的新<strong>@RequestParam</strong>annotation接收方法参数形式的HTTP请求参数，以及用于响应流句柄的<strong>OutputStream</strong>类型的参数。图像内容的实际加载再次委托给ImageDatabase服务。<p></p><p>或者，您可以使用更传统的HttpServletRequest / HttpServletResponse签名实现相同的处理程序方法，从而获得对确切HTTP处理的更多控制。但是，这引入了与Servlet API的更强耦合，并且需要更多的精力进行单元测试。<br></p><pre class="code">@RequestMapping(“/imageContent”)<br>public void streamImageContent(HttpServletRequest request, HttpServletResponse response)<br>throws IOException {<p></p><p>this.imageDatabase.streamImage(request.getParameter(“name”), response.getOutputStream());<br>}</p></pre><br>这样的处理程序方法的目的应该已经很明显：它们是HTTP请求世界和服务层世界之间非常简单的“桥梁”，可以调整请求参数和响应内容。我们来看一个高级示例的图像上传处理程序。<br><pre class="code">@RequestMapping(“/imageUpload”)<br>public String processImageUpload(<br>@RequestParam(“name”) String name, @RequestParam(“description”) String description,<br>@RequestParam(“image”) MultipartFile image) throws IOException {<p></p><p>this.imageDatabase.storeImage(name, image.getInputStream(), (int) image.getSize(), description);<br>return “redirect:imageList”;<br>}</p></pre><br>基本目的是再次接受几个特定的HTTP请求参数，进行一些处理，然后返回视图的名称-在这种情况下，它指示重定向到“ imageList”路径。但是，此特定方法处理分段文件上载，这就是为什么将“ image”参数声明为<strong>MultipartFile</strong>类型的原因。Spring的@RequestParam处理将自动将此问题解析为多部分元素，以便处理程序方法能够获取文件大小并以InputStream的形式访问上载的文件内容。<p></p><p>有关带注释的处理程序方法支持的参数类型的完整列表，请参见<a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/bind/annotation/RequestMapping.html">@RequestMapping javadoc</a> 。<br></p><h2>超越无状态多动作控制器</h2><br>对于使用Spring 2.5的Web注释来实现多动作控制器而言，这是如此之多。相同的控制器样式也可以容纳基本的表单处理，以取代旧的SimpleFormController。在PetClinic的Spring 2.5版本中可以看到这一点，该版本的所有表单控制器现在都以注释样式实现，显示了表单对象和基于JavaBean的数据绑定的用法。有关这些表单处理功能的讨论将成为后续帖子的主题。<p></p><p>最后，我要指出Spring MVC的目的在哪里结束：确切地说是无状态控制器，基本的表单处理和灵活的视图呈现。从根本上说，MVC是Spring核心Web支持的以调度为中心的模块，可作为多种不同用法的运行时-并在其之上构建更高级别的功能。在这方面，它类似于Java EE 5的JSF运行时，该运行时还主要充当基本Web平台，以在其之上构建更高级别的功能。</p><p>这是<strong>Spring Web Flow</strong>进入画面的地方：SWF是我们的高级，面向会话的控制器引擎，对<em>MVC视图</em>和<em>JSF视图</em>都提供了强大的支持。我强烈建议您检查SWF以构建Web用户界面，尤其是在面对非平凡的导航和状态管理需求时。Spring Web Flow 2.0里程碑中发生了令人兴奋的事情，与Spring 2.5 MVC基础的发展方向保持一致-而且通过我们新的<strong>Spring Faces</strong>模块特别关注JSF。关注此空间！</p></bean></bean></bean></context:component-scan></context:component-scan></context:component-scan></context:component-scan></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">var disqus_shortname = 'spring-io';
      var disqus_identifier = 115;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));</script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>
 
<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });</script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>