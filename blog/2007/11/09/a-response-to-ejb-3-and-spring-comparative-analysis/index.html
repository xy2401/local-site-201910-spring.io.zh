<html dir="ltr" data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>回应：EJB 3和Spring比较分析</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>System.config({baseURL: "/b92013b"});</script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>System.import('app/main.js')</script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="A Response to: EJB 3 and Spring Comparative Analysis">
<meta name="twitter:description" content="<p> Last night I attended a New England Java User Group (<a href=" http:="" ="" www.nejug.or="=" _blan=""></head><body dir="ltr">NEJUG) meeting where Reza Rahman presented a "comparative analysis" of <a href="http://www.nejug.org/2007/nov07.jsp" target="_blank">EJB 3 and Spring</a>. Reza is one of the authors of <a href="http://www.manning.com/panda/" target="_blank">EJB 3 in Action</a>. I enjoyed meeting Reza and respect him for presenting what may be considered a controversial topic. Also I appreciate that he did attempt to address pros and cons for both EJB 3 and Spring. Nevertheless, I feel compelled to clarify a few points that were not wholly accurate in his coverage of Spring and which led me (and other attendees) to believe the presentation was motivated by a bias toward EJB 3. To be fair, unlike a fixed specification version, Spring is constantly evolving and some of the things that I will point out here are new features. On the other hand, some are Spring 2.0 features that have been available for more than a year. I personally believe that a "comparative analysis" must account for the up-to-date feature set of the latest stable version of the products being compared. I think it goes without saying that I might be a bit biased as well, but my motivation here is to provide a wholly objective response so that the presentation could perhaps be revised to reflect a more 'apples-to-apples' comparison. I will provide brief responses to 10 "themes" of the presentation. 
">
<meta name="twitter:creator" content="@m_f_">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/443e6ec0242c3f54001dae34374780e2?s=200">

<meta property="og:title" content="A Response to: EJB 3 and Spring Comparative Analysis">
<meta property="og:image" content="https://gravatar.com/avatar/443e6ec0242c3f54001dae34374780e2?s=200">
<meta property="og:description" content="<p> Last night I attended a New England Java User Group (<a href=" http:="" ="" www.nejug.or="=" _blan="">NEJUG) meeting where Reza Rahman presented a "comparative analysis" of <a href="http://www.nejug.org/2007/nov07.jsp" target="_blank">EJB 3 and Spring</a>. Reza is one of the authors of <a href="http://www.manning.com/panda/" target="_blank">EJB 3 in Action</a>. I enjoyed meeting Reza and respect him for presenting what may be considered a controversial topic. Also I appreciate that he did attempt to address pros and cons for both EJB 3 and Spring. Nevertheless, I feel compelled to clarify a few points that were not wholly accurate in his coverage of Spring and which led me (and other attendees) to believe the presentation was motivated by a bias toward EJB 3. To be fair, unlike a fixed specification version, Spring is constantly evolving and some of the things that I will point out here are new features. On the other hand, some are Spring 2.0 features that have been available for more than a year. I personally believe that a "comparative analysis" must account for the up-to-date feature set of the latest stable version of the products being compared. I think it goes without saying that I might be a bit biased as well, but my motivation here is to provide a wholly objective response so that the presentation could perhaps be revised to reflect a more 'apples-to-apples' comparison. I will provide brief responses to 10 "themes" of the presentation. 
">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2007-11-09 19:45:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">// Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }</script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">回应：EJB 3和Spring比较分析</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/443e6ec0242c3f54001dae34374780e2?s=20&d=mm"> <a class="author" rel="author" href="/team/mfisher">马克·费舍尔</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2007-11-09 19:45:00.0">2007年11月9日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2007/11/09/a-response-to-ejb-3-and-spring-comparative-analysis#disqus_thread" data-disqus-identifier="113">
</a></div>
</div>
</header>
<div class="blog--post"><p>昨晚，我参加了新英格兰Java用户组（ <a href="http://www.nejug.org" target="_blank">NEJUG</a> ）会议，Reza Rahman在会议上对<a href="http://www.nejug.org/2007/nov07.jsp" target="_blank">EJB 3和Spring进行</a>了“比较分析”。Reza是<a href="https://www.manning.com/panda/" target="_blank">EJB 3 in Action</a>的作者之一。我很高兴与Reza见面，并尊重他介绍了可能引起争议的话题。我也很欣赏他确实尝试解决EJB 3和Spring的优缺点。尽管如此，我还是不得不澄清一些在他对Spring的报道中并不完全准确的观点，这使我（和其他与会者）相信该演示文稿是由于对EJB 3的偏见所致。公平地说，与固定规范版本不同，Spring一直在发展，我在这里指出的一些功能是新功能。另一方面，一些Spring 2.0功能已经使用了一年多。我个人认为，“比较分析”必须考虑到所比较产品的最新稳定版本的最新功能集。我想我当然也有一点偏见，但是我在这里的动机是提供一个完全客观的回应，以便可以对演示文稿进行修改以反映出更多的“苹果对苹果”的比较。我将简要介绍演示文稿的10个“主题”。
</p>
<h2>1。EJB使用元数据注释。Spring使用XML。</h2>
<p>有人提到，Spring开始支持更多的注释，但是“要花些时间”。但是，Spring 2.0版本提供了与@PersistenceContext的完整JPA集成，用于注入EntityManager和具有Spring的@Transactional注释的注释驱动的事务管理（支持与@Stateless EJB相同的语义，并且默认传播为REQUIRED）。令我特别沮丧的是，比较的两面都没有包含JPA（请参见下面的第3点）。Spring 2.0还引入了完全基于注释的AspectJ支持（@ Aspect，@ Before，@ After，@ Around）和“定型”注释的概念。例如，@Repositoryannotation为直接使用JPA或Hibernate API（无需Spring模板）的数据访问代码启用非侵入性Exception转换。Spring甚至早在1.2版本就提供了注释支持，例如@ManagedResource，用于透明地将任何Spring管理的对象导出为JMX MBean。
</p>
<p>现在，这个问题对我来说是＃1的主要原因，是因为它“要花些时间”。作为Spring 2.5的注释驱动配置支持的主要开发者之一，我必须说Spring元数据模型非常灵活，因此我们能够以比预期的更快的速度提供全面的基于注释的模型。实际上，Spring 2.5提供了对JSR-250annotation的支持：@ Resource，@ PostConstruct和@PreDestroy-以及@WebServiceRef和@EJB。 @Resource特别令人感兴趣，因为它是EJB 3中用于依赖项注入的主要注释。在Spring中，@Resource注释不仅支持JNDI查找（与EJB 3一样），而且还支持注入<em>任何Spring管理的对象</em> 。这有效地结合了本演示文稿中提到的主要Spring优势（Spring支持任何类型的对象的DI）和主要的EJB 3优势（使用注释代替XML）。Spring 2.5还基于@Autowired和（可扩展的）@Qualifier注释引入了更细粒度的注释驱动的依赖项注入模型。Spring 2.5还扩展了“原型”注释，以包括@Service和@Controller。每个构造型注释都通过将其用作元注释来扩展通用@Component注释。通过应用相同的技术，@ Componentannotation为用户定义的构造型提供了扩展点。Spring甚至可以自动检测这些带注释的组件，以替代XML配置。例如，此摘录摘自PetClinic示例应用程序的2.5版本：</p>
<pre><code class="prettyprint xml"><br>   <context:component-scan base-package="org.springframework.samples.petclinic.web" />
</code></pre>
<p>
Web控制器<em>不需要</em>其他XML，因为它们使用注释驱动的依赖项注入和注释来进行请求映射。我指出这一点是因为演示特别强调了Web层配置的冗长性：</p>
<pre><code class="prettyprint java"><br>@Controller
public class ClinicController {

   private final Clinic clinic;

   @Autowired
   public ClinicController(Clinic clinic) {
      this.clinic = clinic;
   }
   ...
</code></pre>
<p>有关Spring注释支持的最新信息，请参见： <a href="http://www.theserverside.com/tt/articles/article.tss?l=IntrotoSpring25" target="_blank">服务器端Spring 2.5简介</a> ，或Spring参考手册的最新版本-特别是<a href="http://static.springframework.org/spring/docs/2.5.x/reference/beans.html#beans-annotation-config" target="_blank">基于Annotation的配置部分</a> 。另外，请关注此博客和<a href="http://www.springframework.org" target="_blank">Spring Framework主页，</a>以获取一些即将发布的有关2.5版的文章和博客。
</p>
<h2>2。Spring允许您支持多个部署环境，但需要更多配置。</h2>
<p>实际上，这是Spring的优势，但着重于配置开销。事实是，任何认真对待测试和敏捷开发的项目都将需要支持“多个部署环境”。换句话说，这个特定主题经常被扭曲，就好像它仅适用于多个<em>生产</em>环境一样。实际上，在每个开发和测试周期中必须部署到Application Server是灵活性的主要障碍。通常，Spring用户会将其配置模块化，以使“基础结构”配置（例如，DataSource，TransactionManager，JMS ConnectionFactory）分离并且将动态属性外部化。由于Spring提供了基于外部化属性替换'$ {placeholders}'的支持，因此包含不同的属性文件通常成为透明的问题。
</p>
<h2>3。带有JPA的EJB，带有Hibernate的Spring</h2>
<p>我必须承认这一点最困扰我。在比较滑动时，EJB 3实施例显示JPA经由<em>的EntityManager</em>和<em>EntityManager</em>实例数据访问被提供与所述注解@PersistenceContext。另一方面，Spring示例使用Hibernate，并显示了Hibernate SessionFactory的setter注入。在我看来，这违反了善意的“比较分析”的第一条规则：使用比较两边最相似的功能。在这种特殊情况下，Spring确实提供了直接使用JPA API的支持（即JpaTemplate是完全可选的；直接使用'entityManager'仍然参与Spring事务等），并且Spring还可以识别@PersistenceContext注释。自Spring 2.0（最终版本已于一年多以前）开始提供了这种支持，所以我不明白为什么在弹簧方面比较也不使用JPA。比较的其他部分显然基于Spring 2.0，因此留下的印象是有选择地过时并显示出偏差。如果将此特定示例修改为“从头到尾”，那么它将破坏主要的总体主题之一：Spring需要更多配置，而EJB 3依赖于标准注释。
</p>
<p>现在，即使我相信在Spring方面使用Hibernate而不是JPA扭曲了比较，但它同时显示了Spring的优势。如果您确实想直接使用Hibernate API而不是依赖于JPA API，Spring会启用它，并且在Spring事务管理和Exception转换方面以一致的方式进行。然后，这提供了使用超越JPA限制的Hibernate功能的机会，例如Hibernate的“条件”查询API。同样，如果您想添加一些直接的JDBC来进行ORM过度使用的数据访问，那么即使在与Hibernate或JPA数据访问相同的事务中调用时，Spring也支持该功能。
</p>
<h2>4。Spring不做任何假设，您必须提供配置。</h2>
<p>一个具体的例子是事务管理器的定义。据说必须配置容器供应商级别的知识才能配置Spring集成。这是不正确的。例如，以下bean定义不包含任何特定于容器的信息，但是Spring会在所有Java EE Application Server中自动检测事务管理器：</p>
<pre><code class="prettyprint xml"><br>   <bean id="transactionManager" class="org.springframework.transaction.jta.JtaTransactionManager"/>
</code></pre>
<p>如果确实要利用特定于容器的功能，例如按事务隔离级别，那么Spring还提供了一些专门的实现： <em>WebLogicJtaTransactionManager</em> <em>WebSphereUowTransactionManager</em>和<em>OC4JJtaTransactionManager</em> 。这些实现之间的切换仅是更改此单个定义的问题。
</p>
<p>除此之外，Spring配置幻灯片不必要地冗长。恐怕这可能也是出于强调EJB <em>不同于Spring</em>依赖智能默认设置的目的。例如，幻灯片显示：</p>
<pre><code class="prettyprint xml"><br>   <tx:annotation-driven transaction-manager="transactionManager"/>
</code></pre>
<p>实际上，如果在Spring上下文中定义了单个“ transactionManager”，则无需在“注释驱动”元素上显式提供该属性。<em>如果需要，</em>该属性仅可用于在一个应用程序中启用多个事务管理器。这些“自动检测”和“智能默认设置”技术在整个Spring都适用，例如消息监听器的JMS'connectionFactory'（在下面的＃6示例中隐含）以及现有MBean服务器的自动位置或RMI注册表。
</p>
<p>积极地讲，实际上提到了Spring允许“本地”事务管理的一个优点。尽管EJB需要使用JTA进行事务管理，但是许多应用程序并不需要跨两阶段可提交资源的分布式事务。在这种情况下，Spring允许使用开销更少的更简单的事务管理器：DataSourceTransactionManager（用于JDBC），HibernateTransactionManager或JpaTransactionManager。如果我们的目标是准确描述优缺点，我希望听到更多有关该特定弹簧强度的细节。例如，对于在容器外部进行测试或在轻量级IDE环境（例如Eclipse或IDEA）中进行开发，这是一个巨大的好处。</p>
<p>此外，如果您确实需要JTA进行分布式事务，但想在像Tomcat或Jetty这样的轻量级容器中运行，Spring会轻松支持独立的JTA提供程序，如Atomikos和JOTM。当然，Spring的事务管理器设置需要配置<em>单个</em> bean定义，但这确实是一次性的成本-值得这样做。
</p>
<h2>5，Spring没有状态应用程序范例。</h2>
<p>作为最佳实践，无状态服务层的好处已得到充分确立，Spring对此予以了认可。Spring确实提供了除单例之外的其他范围。Spring的“原型”范围为每次注入或查找启用了不同的实例，而Spring 2.0引入了Web范围：“请求”和“会话”。作用域机制本身甚至可以扩展；可以定义自定义范围并将其映射到对话的概念。Spring还通过CommonsPoolTargetSource支持简单的对象池，但是对象池很少是状态管理的最佳解决方案。
</p>
<p>更重要的是，Spring确实通过<a href="http://www.springframework.org/webflow">Spring Web Flow</a>为Web应用程序提供了非常健壮，高度可配置的状态管理。与该演示文稿声称开发人员必须直接与HTTP Session交互以管理Spring应用程序中的状态相反，此处的对话状态是透明管理的。此外，存储库配置是可插入的，因此各种策略可用于状态的物理存储（会话，客户端，后端高速缓存等）。最后，Spring Web Flow的最新发展包括对扩展的持久性上下文的支持以及对JSF的完全集成的支持。</p>
<h2>6。Spring需要为每个MessageListener配置一个容器。</h2>
<p>Spring 2.5提供了一个新的'jms'名称空间，以大大简化消息侦听器的配置。请注意，针对每个侦听器的容器没有单独的配置。多个侦听器共享配置，并且智能默认设置被广泛使用：</p>
<pre><code class="prettyprint xml"><br><jms:listener-container>
	<jms:listener destination="queue.confirm" ref="logger" method="log"/>
	<jms:listener destination="queue.order" ref="tradeService" method="placeOrder"/>
</jms:listener-container>
</code></pre>
<p>还提到线程管理始终是每个容器的问题。但是，事实并非如此。消息侦听器容器实际上使用Spring的TaskExecutor抽象，并且有许多可用的实现。例如，如果在Java 5+上运行，则可以配置线程池执行器，甚至可以配置CommonJ WorkManager执行器。如果需要，可以在多个侦听器容器之间轻松共享执行程序。实际上，“ task-executor”属性在“ listener-container”元素（如上所示）上可用，该属性在逻辑上将设置1次，但由在每个监听器定义内部创建的每个容器实例共享。
</p>
<h2>7。并发消费者不能大于1。</h2>
<p>好的，这确实是当晚最奇怪的时刻。代码幻灯片描述了MessageListener的完美无状态实现（应该如此！），然后配置幻灯片显示将'maxConcurrentConsumers'值设置为1。在这一点上，有人指出将值设置为除1以外的任何值都将导致线程安全问题。我很抱歉地说，但这是完全错误的信息。并发使用者设置可确定可用于接收消息的线程数，而'maxConcurrentConsumers'确定使用者池在高负载下可以增长到何种程度（随着需求的减少，使用者数会回落到设置为' parallelConsumers'）。只要MessageListener本身是线程安全的，就可以增加此值以控制吞吐量。就我个人而言，除了委托给“服务”外，我永远不会将MessageListener用于其他任何事情，这样，即使在（非常不可能的）情况下，我希望有状态对象最终处理Message的内容时，也将配置该目标对象与合并目标源。MessageListener本身始终是线程安全的，因此'concurrentConsumers'和'maxConcurrentConsumers'的值可用于管理吞吐量。
</p>
<p>这一主题提出了另一点。全面的比较将揭示Spring的另一个优点-即Spring的侦听器适配器。适配器提供了从JMS消息到简单Java有效负载的自动转换，然后委托给任何Spring管理的对象来处理该有效负载。例如，在上面的配置中，“ logger”和“ tradeService”侦听器甚至不必实现MessageListener接口。如果没有，Spring将自动使用适配器转换那些POJO，该适配器将转换Message并确定要调用的方法。它甚至将返回值（如果有的话）转换为JMS回复消息，并自动回复到由传入消息的“ reply-to”属性指定的目的地。由于JMS MessageListener处理方法具有“ void”返回类型，因此从头开始很难实现相同的行为：</p>
<pre><code class="prettyprint java"><br>public interface MessageListener {
   void onMessage(Message message);
}
</code></pre>
<h2>8。Spring对AspectJ表达式语言的用法很强大，但却很神秘。</h2>
<p>EJB 3被限制为@AroundInvoke，并且该示例通过通过拦截应用了一些简单的审核来展示了这一点。Spring的示例显示了@Before建议，因为审核仅需要在方法执行<em>之前</em>发生一些事情（而不是在方法执行<em>之前</em> ）。我赞赏该示例强调了在EJB 3端调用context.proceed（）的必要，而AspectJ @Before建议则要简单得多。但是，令我感到失望的是，有些与会者似乎认为AspectJ模型仅限于@Before，因此EJB 3 @AroundInvoke更强大。为了在此进行全面介绍，我将在Spring端提供一个@Around建议的示例-以阐明它受支持，但并非总是必须的。
</p>
<p>EJB 3拦截模型的最大局限性在于应被注释的方法（或类）是直接注释的，而AOP的基本目标之一是非侵入性的-最终甚至可以支持有关外部代码的建议您的控制权。鉴于该目标，可以说AspectJ表达式语言尽可能清晰，简洁，同时支持可能应用建议的所有可能构造。尽管乍一看似乎很神秘，但它很容易学习。例如，从概念上讲，它与正则表达式相似，但范围受到更大限制（有关详细信息，请参见<a href="https://www.eclipse.org/aspectj/" target="_blank">AspectJ主页</a>以获取表达式语言参考）。
</p>
<h2>9。Spring工具的支持很少。</h2>
<p>在这一点上，我首先要指出的是，使用Spring有助于减少开发/测试周期，从而使大部分开发人员的时间都花在IDE内<em>而不</em>部署到Application Server上，并且IDE是很好的工具。基于Eclipse的<a href="http://springide.org/blog/" target="_blank">Spring IDE</a>是一个非常有价值的插件，可以为Spring项目中的开发提供帮助，而IntelliJ也在IDEA中提供Spring支持。至于部署工具，基于Spring的应用程序当然可以部署到任何容器中，并且由于Spring可以利用基础资源（DataSource，TransactionManager，JMS ConnectionFactory等），因此这些资源的管理方式与部署的任何应用程序相同在特定的容器内。Spring可以将任何对象公开为JMX MBean（包括对前面提到的@ManagedResource的支持）以及对JMX通知/侦听器的支持，对于自定义监视和管理需求来说非常强大。
</p>
<p>也就是说，显然，Spring可以从增加的工具支持中受益。这就是为什么“ Spring Tool Suite”是最近成立的，目的是将Spring IDE，AJDT，AspectJ和Mylyn整合在一起，并进一步发展。有关更多信息，请参见<a href="http://www.springframework.org/node/554" target="_blank">此处</a>的文章和链接。
</p>
<h2>10。使用EJB作为标准，您可以从一个供应商迁移到另一个供应商。使用Spring，您仍然必须移植元数据。</h2>
<p>人人都知道，便携性“说起来容易做起来难”。尽管在这方面，EJB 3可能比EJB 2痛苦（配置中的详细程度更少），但事实是Application Server提供了不同的功能，因此提供了不同的配置选项。显然，如果要部署到应用服务器，你<em>应该</em>采取的某些特定功能。原始语句的问题在于，它隐含了应用程序配置级别的某些内容，从而使Spring本质上具有较低的可移植性。相反，从一个应用程序服务器迁移到另一个应用程序服务器的任何Spring用户都将同意Spring在这方面提供了大量的抽象。在上面的第4点中，我提到过Spring的JtaTransactionManager在任何Java EE应用服务器中使用自动检测，并且同样适用于MBean服务器和RMI注册表。同样，在使用JPA时，Spring会检测到persistence.xml并相应地创建EntityManagerFactory。在所有这些情况下，Spring元数据-无论是注释（@ PersistenceContext，@ Transactional，@ Resource等）还是XML（'jee：jndi-lookup'等），都可以像任何EJB 3应用程序一样移植。
</p>
<p>即使超越了典型EJB 3应用程序的功能，最小的配置更改也提供了极大的便利。在这方面，Spring实际上<em>促进了</em>到更广泛的环境中的可移植性：Tomcat，Jetty，独立，Eclipse，IDEA等。我的建议是获取Spring发行版的PetClinic示例应用程序，然后尝试将WAR文件构建并部署到多个Application Server中。然后，请注意，它可以轻松地在Tomcat中部署，并且可移植性实际上远远超过了EJB 3应用程序，而您想要在该应用程序所支持的不同数据访问策略之间进行切换就可以了： ，Hibernate和JPA。请仔细查看这些不同版本的不同配置文件（位于“ samples / petclinic / war / WEB-INF”目录中）。特别是在Spring 2.5中，配置非常简洁。请注意，在这些不同版本之间切换的唯一必要更改是web.xml中引导Spring上下文的一行。如果要与容器管理的数据源一起运行，请使用一行'jee：jndi-lookup'元素。否则，有一个使用独立DataSource的bean定义，并且实际的数据库属性被外部化到jdbc.properties中。
</p>
<h2>结论</h2>
<p>好吧，看来我还有话要说：)。我的意图是从Spring的角度提供一些客观的说明，希望读者能明白这一点。我知道这个演讲在JUG和会议上非常受欢迎，我认为这是一个重要的讨论。如今，许多Java开发人员对大量的选择感到不知所措，因此，重要的是，他们必须具备做出明智的决策所需的所有事实。尽管我在这里没有强调（您可能不希望我继续讲下去），但是与本书（ <a href="https://www.manning.com/panda/" target="_blank">EJB 3 in Action</a> ）一样，本文的要点是Spring和EJB 3不必互斥。Spring可以在EJB应用程序中使用，可以从Spring应用程序访问EJB，并且Spring现在支持大多数相同的annotation：@ Resource，@ PersistenceContext，@ PostConstruct，@ PreDestroy，@ EJB和@WebServiceRef。</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">var disqus_shortname = 'spring-io';
      var disqus_identifier = 113;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));</script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });</script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>