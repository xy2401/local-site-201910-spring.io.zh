<!DOCTYPE html>
<html data-code-prettify="" data-mobile-support="" data-search="">
<head>
<title>A Response to: EJB 3 and Spring Comparative Analysis</title>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no" id="Viewport" name="viewport" />
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png" />
<link href="https://fonts.googleapis.com/css?family=Varela+Round|Montserrat:400,700" rel="stylesheet" type="text/css" />
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css" />
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M" name="google-site-verification" />

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css" />

<meta content="summary" name="twitter:card" />
<meta content="@springcentral" name="twitter:site" />
<meta name="twitter:title" content="A Response to: EJB 3 and Spring Comparative Analysis" />
<meta name="twitter:description" content="&lt;p&gt; Last night I attended a New England Java User Group (&lt;a href=&quot;http://www.nejug.org&quot; target=&quot;_blank&quot;&gt;NEJUG&lt;/a&gt;) meeting where Reza Rahman presented a &quot;comparative analysis&quot; of &lt;a href=&quot;http://www.nejug.org/2007/nov07.jsp&quot; target=&quot;_blank&quot;&gt;EJB 3 and Spring&lt;/a&gt;. Reza is one of the authors of &lt;a href=&quot;http://www.manning.com/panda/&quot; target=&quot;_blank&quot;&gt;EJB 3 in Action&lt;/a&gt;. I enjoyed meeting Reza and respect him for presenting what may be considered a controversial topic. Also I appreciate that he did attempt to address pros and cons for both EJB 3 and Spring. Nevertheless, I feel compelled to clarify a few points that were not wholly accurate in his coverage of Spring and which led me (and other attendees) to believe the presentation was motivated by a bias toward EJB 3. To be fair, unlike a fixed specification version, Spring is constantly evolving and some of the things that I will point out here are new features. On the other hand, some are Spring 2.0 features that have been available for more than a year. I personally believe that a &quot;comparative analysis&quot; must account for the up-to-date feature set of the latest stable version of the products being compared. I think it goes without saying that I might be a bit biased as well, but my motivation here is to provide a wholly objective response so that the presentation could perhaps be revised to reflect a more &#39;apples-to-apples&#39; comparison. I will provide brief responses to 10 &quot;themes&quot; of the presentation. &lt;/p&gt;
" />
<meta name="twitter:creator" content="@m_f_" />
<meta name="twitter:image:src" content="https://gravatar.com/avatar/443e6ec0242c3f54001dae34374780e2?s=200" />

<meta property="og:title" content="A Response to: EJB 3 and Spring Comparative Analysis" />
<meta property="og:image" content="https://gravatar.com/avatar/443e6ec0242c3f54001dae34374780e2?s=200" />
<meta property="og:description" content="&lt;p&gt; Last night I attended a New England Java User Group (&lt;a href=&quot;http://www.nejug.org&quot; target=&quot;_blank&quot;&gt;NEJUG&lt;/a&gt;) meeting where Reza Rahman presented a &quot;comparative analysis&quot; of &lt;a href=&quot;http://www.nejug.org/2007/nov07.jsp&quot; target=&quot;_blank&quot;&gt;EJB 3 and Spring&lt;/a&gt;. Reza is one of the authors of &lt;a href=&quot;http://www.manning.com/panda/&quot; target=&quot;_blank&quot;&gt;EJB 3 in Action&lt;/a&gt;. I enjoyed meeting Reza and respect him for presenting what may be considered a controversial topic. Also I appreciate that he did attempt to address pros and cons for both EJB 3 and Spring. Nevertheless, I feel compelled to clarify a few points that were not wholly accurate in his coverage of Spring and which led me (and other attendees) to believe the presentation was motivated by a bias toward EJB 3. To be fair, unlike a fixed specification version, Spring is constantly evolving and some of the things that I will point out here are new features. On the other hand, some are Spring 2.0 features that have been available for more than a year. I personally believe that a &quot;comparative analysis&quot; must account for the up-to-date feature set of the latest stable version of the products being compared. I think it goes without saying that I might be a bit biased as well, but my motivation here is to provide a wholly objective response so that the presentation could perhaps be revised to reflect a more &#39;apples-to-apples&#39; comparison. I will provide brief responses to 10 &quot;themes&quot; of the presentation. &lt;/p&gt;
" />
<meta content="article" property="og:type" />
<meta property="og:article:published_time" content="2007-11-09 19:45:00.0" />
</head>
<body>

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" style="display:none;visibility:hidden" width="0"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">Projects</a>
</li>
<li class="navbar-link">
<a href="/guides">Guides</a>
</li>
<li class="navbar-link active">
<a href="/blog">Blog</a>
</li>
<li class="navbar-link">
<a href="/services">Training & Certification</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form action="/search" class="form-inline form-search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search for documentation, guides, and posts..." type="text" value="" />
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form action="/search" class="form-inline form-search" method="get">
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search..." type="text" value="" />
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">
Home
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">
Projects
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">
Guides
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">
Blog
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">
Training & Certification
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>Engineering</div>
</div>
<div class="blog-category content--title">
<div>Releases</div>
</div>
<div class="blog-category content--title">
<div>News and Events</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">A Response to: EJB 3 and Spring Comparative Analysis</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">Engineering</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/443e6ec0242c3f54001dae34374780e2?s=20&amp;d=mm" />
<a class="author" rel="author" href="/team/mfisher">Mark Fisher</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2007-11-09 19:45:00.0">November 09, 2007</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" data-disqus-identifier="113" href="/blog/2007/11/09/a-response-to-ejb-3-and-spring-comparative-analysis#disqus_thread">
</a></div>
</div>
</header>
<div class="blog--post"><p>
Last night I attended a New England Java User Group (<a href="http://www.nejug.org" target="_blank">NEJUG</a>) meeting where Reza Rahman presented a "comparative analysis" of <a href="http://www.nejug.org/2007/nov07.jsp" target="_blank">EJB 3 and Spring</a>. Reza is one of the authors of <a href="https://www.manning.com/panda/" target="_blank">EJB 3 in Action</a>. I enjoyed meeting Reza and respect him for presenting what may be considered a controversial topic. Also I appreciate that he did attempt to address pros and cons for both EJB 3 and Spring. Nevertheless, I feel compelled to clarify a few points that were not wholly accurate in his coverage of Spring and which led me (and other attendees) to believe the presentation was motivated by a bias toward EJB 3. To be fair, unlike a fixed specification version, Spring is constantly evolving and some of the things that I will point out here are new features. On the other hand, some are Spring 2.0 features that have been available for more than a year. I personally believe that a "comparative analysis" must account for the up-to-date feature set of the latest stable version of the products being compared. I think it goes without saying that I might be a bit biased as well, but my motivation here is to provide a wholly objective response so that the presentation could perhaps be revised to reflect a more 'apples-to-apples' comparison. I will provide brief responses to 10 "themes" of the presentation.
</p>
<h2>1. EJB uses annotations for metadata. Spring uses XML.</h2>
<p>
It was mentioned that Spring is beginning to support more annotations but that it is "going to take them a while". However, the Spring 2.0 release provided full JPA integration with @PersistenceContext for injecting the EntityManager and annotation-driven transaction management with Spring's @Transactional annotation (supporting the same semantics as a @Stateless EJB with the default propagation of REQUIRED). I was particularly discouraged that the comparison did not include JPA on both sides (see point #3 below). Spring 2.0 also introduced full annotation-based AspectJ support (@Aspect, @Before, @After, @Around) and the concept of "stereotype" annotations. For example, the @Repository annotation enables non-invasive Exception translation for data-access code that uses JPA or Hibernate APIs directly (without Spring's templates). Spring even provided annotation support as early as version 1.2, such as @ManagedResource for transparently exporting any Spring-managed object as a JMX MBean.
</p>
<p>
Now the main reason this issue is #1 for me, is the comment that it is "going to take them a while". As one of the main developers of Spring 2.5's annotation-driven configuration support, I must say that the Spring metadata model is extremely flexible and therefore we have been able to provide a comprehensive annotation-based model more quickly than one might expect. In fact, Spring 2.5 provides support for JSR-250 annotations: @Resource, @PostConstruct, and @PreDestroy - as well as @WebServiceRef and @EJB. Of particular interest is @Resource since it is the primary annotation used for dependency injection in EJB 3. With Spring, the @Resource annotation supports not only JNDI lookups (as with EJB 3) but also injection of <em>any Spring-managed object</em>. This effectively combines the main Spring advantage that was mentioned in this presentation (Spring supports DI of any type of object) with the main EJB 3 advantage (use of annotations instead of XML). Spring 2.5 also introduces an even more fine-grained annotation-driven dependency injection model based on @Autowired and the (extensible) @Qualifier annotation. Spring 2.5 also extends the "stereotype" annotations to include @Service and @Controller. Each of the stereotype annotations extends the generic @Component annotation by applying it as a meta-annotation. By applying the same technique, the @Component annotation provides an extension point for user-defined stereotypes. Spring can even auto-detect these annotated components as an alternative to XML configuration. For example, this excerpt is taken from the 2.5 version of the PetClinic sample application:
</p>
<pre><code class="prettyprint xml"><br />   &lt;context:component-scan base-package=&quot;org.springframework.samples.petclinic.web&quot; /&gt;
</code></pre>
<p>
<em>No</em> additional XML is required for the web controllers since they use annotation-driven dependency injection and annotations for request mapping. I point this out, because the presentation specifically emphasized the verbosity of configuration for the web-tier:
</p>
<pre><code class="prettyprint java"><br />@Controller
public class ClinicController {

   private final Clinic clinic;

   @Autowired
   public ClinicController(Clinic clinic) {
      this.clinic = clinic;
   }
   ...
</code></pre>
<p>
For up-to-date coverage of Spring's annotation support, see: <a href="http://www.theserverside.com/tt/articles/article.tss?l=IntrotoSpring25" target="_blank">Introduction to Spring 2.5 on The Server Side</a>, or the latest version of Spring's reference manual - specifically the <a href="http://static.springframework.org/spring/docs/2.5.x/reference/beans.html#beans-annotation-config" target="_blank">Annotation-based configuration section</a>. Also, stay tuned to this blog and the <a href="http://www.springframework.org" target="_blank">Spring Framework home</a> for some soon-to-be-released articles and blogs covering version 2.5.
</p>
<h2>2. Spring allows you to support multiple deployment environments but requires more configuration.</h2>
<p>
This one was actually presented as a Spring advantage but with an emphasis on the configuration overhead. The truth is any project where testing and agile development are taken seriously is going to require supporting "multiple deployment environments". In other words, this particular topic often gets distorted as if it applies only to multiple <em>production</em> environments. In reality, having to deploy to an Application Server during each development and testing cycle is a major obstacle to agility. Typically Spring users will modularize their configuration such that "infrastructure" configuration (e.g. DataSource, TransactionManager, JMS ConnectionFactory) is separate and dynamic properties are externalized. Since Spring provides support for replacing '${placeholders}' based on the externalized properties, the inclusion of different properties files typically becomes a transparent concern.
</p>
<h2>3. EJB with JPA, Spring with Hibernate</h2>
<p>
I must admit this one bothered me the most. In the comparison slides, the EJB 3 examples showed JPA with data-access via <em>entityManager</em> and the <em>entityManager</em> instance being provided with the @PersistenceContext annotation. On the other hand, the Spring examples used Hibernate and showed setter injection of the Hibernate SessionFactory. In my mind, this violates the first rule of a bona-fide "comparative analysis": use the most similar feature available on both sides of the comparison. In this particular case, Spring does provide support for using the JPA API directly (i.e. JpaTemplate is completely optional; direct usage of the 'entityManager' still participates in Spring transactions, etc), and Spring also recognizes the @PersistenceContext annotation. This support has been available since Spring 2.0 (final release was more than a year ago), so I don't understand why the comparison does not use JPA on the Spring side as well. Other parts of the comparison were clearly based on Spring 2.0, so this leaves the impression of being selectively out-of-date and revealing a bias. If this particular example were modified to be 'apples-to-apples', it would have undermined one of the main overall themes: that Spring requires more configuration whereas EJB 3 relies on standard annotations.
</p>
<p>
Now, even though I believe the usage of Hibernate rather than JPA on the Spring side distorted the comparison, it does simultaneously reveal a strength of Spring. If you do want to use the Hibernate API directly instead of relying on the JPA API, Spring enables that, and it does so in a consistent way with regard to Spring transaction management and Exception translation. This then opens up the opportunity to use Hibernate features that extend beyond the limitations of JPA, such as Hibernate's "criteria" query API. By the same token, if you would like to add some direct JDBC for data-access where ORM is overkill, that is also supported in Spring - even when invoked within the same transaction as Hibernate or JPA data-access.
</p>
<h2>4. Spring makes no assumptions, you have to provide configuration.</h2>
<p>
One specific example was the definition of a transaction manager. It was stated that you have to understand things at the container-vendor level to configure Spring integration. This is incorrect. For example, the following bean definition does not contain any container-specific information, yet Spring will auto-detect the transaction manager in all Java EE Application Servers:
</p>
<pre><code class="prettyprint xml"><br />   &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.transaction.jta.JtaTransactionManager&quot;/&gt;
</code></pre>
<p>
If you do want to leverage container-specific features such as per-transaction isolation levels, then Spring also provides a few specialized implementations: <em>WebLogicJtaTransactionManager</em> <em>WebSphereUowTransactionManager</em>, and <em>OC4JJtaTransactionManager</em>. Switching between these implementations is only a matter of changing this single definition.
</p>
<p>
In addition to this, the Spring configuration slides were unnecessarily verbose. I'm afraid this may also have been motivated by the goal of emphasizing that EJB <em>unlike Spring</em> relies on intelligent defaulting. For example, the slide showed:
</p>
<pre><code class="prettyprint xml"><br />   &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;
</code></pre>
<p>
Actually, if there is a single 'transactionManager' defined within a Spring context, then that attribute does not need to be provided explicitly on the 'annotation-driven' element. That attribute is available solely for enabling the usage of multiple transaction managers within one application <em>if necessary</em>. These techniques of "auto-detection" and "intelligent defaulting" apply throughout Spring, such as the JMS 'connectionFactory' for a message-listener (which is implicit in the example of #6 below) and the automatic location of an existing MBean server or RMI registry.
</p>
<p>
On a positive note, it was actually mentioned as an advantage that Spring allows for "local" transaction management. While EJB requires JTA for transaction management, many applications do not need distributed transactions across two-phase commit capable resources. In such cases, Spring allows for simpler transaction managers with less-overhead: DataSourceTransactionManager (for JDBC), HibernateTransactionManager, or JpaTransactionManager. I would have expected to hear a bit more detail on that particular Spring strength if the goal was to accurately describe the pros and cons. For example, this is a huge benefit for testing outside of the container or developing within a lightweight IDE environment such as Eclipse or IDEA.
</p>
<p>
Furthermore, if you do require JTA for distributed transactions but want to run in a lightweight container like Tomcat or Jetty, Spring easily supports standalone JTA providers like Atomikos and JOTM. Sure Spring's transaction manager setup requires configuration of a <em>single</em> bean definition, but it really is a one-time cost - and well worth the benefit.
</p>
<h2>5. Spring does not have a stateful application paradigm.</h2>
<p>
The benefits of a stateless service layer are fairly well-established as a best practice, and Spring embraces that. Spring does provide scopes other than singleton however. Spring's "prototype" scope enables a distinct instance for each injection or lookup, and Spring 2.0 introduced web scopes: "request" and "session". The scoping mechanism itself is even extensible; it's possible to define and map a custom scope to the notion of a conversation. Spring also supports simple object pooling with the CommonsPoolTargetSource, but object pooling is rarely the best solution for state management.
</p>
<p>
More importantly, Spring does provide very robust, highly configurable state-management for web applications via <a href="http://www.springframework.org/webflow">Spring Web Flow</a>. There the conversational state is managed transparently, contrary to the claim of this presentation that developers have to interact directly with the HTTP Session to manage state in Spring applications. Furthermore, the repository configuration is pluggable so that various strategies may be used for physical storage of the state (session, client, backend cache, etc.). Finally, the latest developments in Spring Web Flow include support for extended persistence context and fully integrated support for JSF.
</p>
<h2>6. Spring requires configuration of a container per MessageListener.</h2>
<p>
Spring 2.5 provides a new 'jms' namespace to greatly simplify the configuration of message-listeners. Notice that there is no separate configuration for a container per-listener. Multiple listeners share the configuration, and intelligent defaulting is used extensively:
</p>
<pre><code class="prettyprint xml"><br />&lt;jms:listener-container&gt;
	&lt;jms:listener destination=&quot;queue.confirm&quot; ref=&quot;logger&quot; method=&quot;log&quot;/&gt;
	&lt;jms:listener destination=&quot;queue.order&quot; ref=&quot;tradeService&quot; method=&quot;placeOrder&quot;/&gt;
&lt;/jms:listener-container&gt;
</code></pre>
<p>
It was also mentioned that thread management is always a per-container issue. However, this is not true. The message listener containers actually use Spring's TaskExecutor abstraction, and there are a number of implementations available. For example, if running on Java 5+, you can configure a thread-pool executor, or you can even configure a CommonJ WorkManager executor. The executors can easily be shared across multiple listener containers if desired. In fact, the 'task-executor' attribute is available on the 'listener-container' element (shown above) where it would be logically set 1 time but shared by each container instance that is created internally per listener definition.
</p>
<h2>7. Concurrent Consumers cannot be greater than 1.</h2>
<p>
Okay, this was truly the most bizarre moment of the night. The code slide depicted a perfectly stateless implementation of a MessageListener (as it should be!), and then the configuration slide showed the 'maxConcurrentConsumers' value set to 1. At this point, it was stated that setting the value to anything other than one would cause thread-safety issues. I'm sorry to say, but this is flat out misinformation. The concurrent consumers setting determines the number of threads that are available for receiving Messages, and the 'maxConcurrentConsumers' determines to what extent the consumer pool can grow under heavy load (as demand decreases, the number of consumers drops back to the value set as 'concurrentConsumers'). As long as the MessageListener itself is thread-safe, this value can be increased to control throughput. Personally I would never use a MessageListener for anything other than delegating to a "service" so that even in the (very unlikely) case that I wanted to have a stateful object ultimately handling the content of the Message, then that target object would be configured with a pooling target source. The MessageListener itself would always be thread-safe and therefore the values for 'concurrentConsumers' and 'maxConcurrentConsumers' can be used as intended for managing throughput.
</p>
<p>
This topic raises one other point. A comprehensive comparison would reveal another pro of Spring here - namely Spring's listener adapter. The adapter provides automatic conversion from the JMS Message to a simple Java payload and then delegates to any Spring-managed object to handle that payload. For example, in the configuration above, the "logger" and "tradeService" listeners do not even have to implement the MessageListener interface. If they do not, then Spring automatically wraps those POJOs with an adapter that converts the Message and determines which method to invoke. It even converts a return value (if there is one) into a JMS reply Message and automatically replies to the destination specified by the incoming Message's 'reply-to' property. This same behavior is extremely difficult to implement from scratch since the JMS MessageListener handling method has a 'void' return type:
</p>
<pre><code class="prettyprint java"><br />public interface MessageListener {
   void onMessage(Message message);
}
</code></pre>
<h2>8. Spring's usage of the AspectJ expression language is powerful but cryptic.</h2>
<p>
EJB 3 is limited to @AroundInvoke, and the example showed this with some simple auditing applied through interception. The Spring example showed @Before advice since the auditing only required something to happen <em>before</em> the method execution (not around). I appreciated that the example emphasized the need to call context.proceed() on the EJB 3 side while the AspectJ @Before advice is much simpler. I was disappointed however that some of the attendees seemed to think that the AspectJ model was limited to @Before and therefore that EJB 3 @AroundInvoke was more powerful. To be comprehensive here, I would have included an example of @Around advice on the Spring side - to clarify that it is supported, but it is simply not always necessary.
</p>
<p>
The greatest limitation of the EJB 3 interception model is that the method (or class) that should be intercepted is directly annotated, whereas one of the fundamental goals of AOP is to be non-invasive - ultimately even supporting advice on code that is outside of your control. Given that goal, the AspectJ expression language is arguably as clear and concise as it can be while supporting all of the possible constructs where advice may be applied. While it may appear cryptic at first, it is fairly easy to learn. For example, it is conceptually similar but much more limited in scope than regular expressions (see the <a href="https://www.eclipse.org/aspectj/" target="_blank">AspectJ homepage</a> for the expression language reference for details).
</p>
<h2>9. Spring tool support has been sparse.</h2>
<p>
On this particular point, I would first point out that using Spring helps to reduce the development/test cycle so that a majority of a developer's time is spent within the IDE <em>not</em> deploying to an Application Server, and IDEs are great tools. The Eclipse-based <a href="http://springide.org/blog/" target="_blank">Spring IDE</a> is an incredibly valuable add-on for development assistance in Spring projects, and IntelliJ also provides Spring support in IDEA. As far as deployment tools, Spring-based applications can of course be deployed into any container, and since Spring can utilize the underlying resources (DataSource, TransactionManager, JMS ConnectionFactory, etc), these are managed in the same way as with any application deployed within the particular container. Spring's ability to expose any object as a JMX MBean (including support for the aforementioned @ManagedResource) and its support for JMX notifications/listeners is very powerful for custom monitoring and management requirements.
</p>
<p>
That said, clearly Spring could benefit from increased tool support. This is why the 'Spring Tool Suite' was just recently established to bring together Spring IDE, AJDT, AspectJ, and Mylyn and evolve into much more. For more information, see the articles and links available <a href="http://www.springframework.org/node/554" target="_blank">here</a>.
</p>
<h2>10. With EJB as a standard, you can migrate from one vendor to another. With Spring, you still have to port the metadata.</h2>
<p>
Everyone knows that portability is "easier said than done". While EJB 3 may be less painful than EJB 2 in this regard (less verbosity in the configuration), the fact remains that Application Servers offer different features and thus different configuration options. Clearly if you are deploying to an Application Server, you probably <em>should</em> take advantage of certain specific features. The problem with the original statement is that it implies something at the level of application configuration that makes Spring inherently less portable. On the contrary, any Spring user who has migrated from one Application Server to another would agree that Spring provides a significant amount of abstraction in this regard. In point #4 above, I mentioned that Spring's JtaTransactionManager uses auto-detection within any Java EE Application Server and that the same applies for MBean servers, and RMI registries. Along these same lines, when using JPA, Spring detects persistence.xml and creates the EntityManagerFactory accordingly. In all of these cases, Spring metadata - whether it be annotations (@PersistenceContext, @Transactional, @Resource, etc) or XML ('jee:jndi-lookup', etc) is just as portable as any EJB 3 application.
</p>
<p>
Even when moving beyond the capabilities of a typical EJB 3 application, minimal configuration changes provide significant convenience. In this regard, Spring actually <em>facilitates</em> portability to a much wider variety of environments: Tomcat, Jetty, standalone, Eclipse, IDEA, and so on. My suggestion here would be to grab the Spring distribution's PetClinic sample application and try building and deploying the WAR file into multiple Application Servers. Then, notice that it can just as easily be deployed within Tomcat, and that the degree of portability actually far exceeds that of an EJB 3 application as soon as you want to switch between the different data access strategies that are supported by the application: JDBC, Hibernate and JPA. Take a close look at the different configuration files for those different versions (located within the 'samples/petclinic/war/WEB-INF' directory). Especially with the additions of Spring 2.5, the configuration is extremely concise. Notice that the only change necessary to switch between these different versions is one line in the web.xml where the Spring context is bootstrapped. If you want to run with a container-managed DataSource, use the one line 'jee:jndi-lookup' element. Otherwise there is a bean definition for using a standalone DataSource, and the actual database properties are externalized into jdbc.properties.
</p>
<h2>Conclusion</h2>
<p>
Well, it looks as though I had more to say than I thought :). My intention has been to provide some objective clarifications from the Spring perspective, and I hope that is evident to the reader. I know that this presentation has been very popular at JUGs and conferences, and I think it's an important discussion. Many Java developers are overwhelmed by the vast number of options today, and it's important that they have all of the facts necessary to make well-informed decisions. While I have not emphasized it here (and you probably don't want me to go on any further), one point of the presentation as well as the book (<a href="https://www.manning.com/panda/" target="_blank">EJB 3 in Action</a>) is that Spring and EJB 3 need not be mutually exclusive. Spring can be used within EJB applications, EJBs can be accessed from Spring applications, and Spring now supports most of the same annotations: @Resource, @PersistenceContext, @PostConstruct, @PreDestroy, @EJB, and @WebServiceRef.
</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 113;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>
Back
</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">All Posts</a>
<a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">Engineering</a>
<a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">Releases</a>
<a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">News and Events</a>
<a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>Get updates from The Spring Team delivered to your inbox</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">Tools</a></li>
<li><a href="https://store.pivotal.io/">Store</a></li>
<li><a href="/blog">Newsletter</a></li>
</ul>
</div>
</div>
&copy; <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a>, Inc. All Rights Reserved.
<a href="https://pivotal.io/terms-of-use">Terms of Use</a> &bullet;
<a href="https://pivotal.io/privacy-policy">Privacy</a> &bullet;
<a href="/trademarks">Trademark Guidelines</a>
<div id="teconsent" style="display:inline-block;"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>