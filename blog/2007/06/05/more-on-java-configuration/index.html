<html  data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>有关Java配置的更多信息</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="More on Java Configuration ">
<meta name="twitter:description" content="<p>As most of you already know by now, Spring is not <a href=" http: ="" blog.interface21.com="" main="" 2007="" 05="" 28="" conference-season-builds-up-to-springone="" ="=">just about XML as lately, a number of ‘official’ extensions to the core offer alternatives way for configuring the container.
<p>Spring Java Configuration 1.0 M2 was among the products <a href=" www.springframework.org node 455"></head><body >released <a href="http://blog.interface21.com/main/2007/05/25/new-releases-in-the-spring-portfolio/">around JavaOne</a> and, while still marked as a milestone, had an important number of updates and bugfixes:<p></p>
<ul> 
 <li>the root package has changed to <em>org.springframework.config.java</em></li> 
 <li>scoped beans are fully supported</li> 
 <li>the bean name generation can be customized</li> 
 <li>the distribution contains a 'transformed' sample (petclinic) which uses XML, JavaConfig and Groovy.</li> 
</ul>
">

<meta property="og:title" content="More on Java Configuration ">
<meta property="og:description" content="<p>As most of you already know by now, Spring is not <a href=" http: ="" blog.interface21.com="" main="" 2007="" 05="" 28="" conference-season-builds-up-to-springone="" ="=">just about XML as lately, a number of ‘official’ extensions to the core offer alternatives way for configuring the container.
<p>Spring Java Configuration 1.0 M2 was among the products <a href=" www.springframework.org node 455">released <a href="http://blog.interface21.com/main/2007/05/25/new-releases-in-the-spring-portfolio/">around JavaOne</a> and, while still marked as a milestone, had an important number of updates and bugfixes:<p></p>
<ul> 
 <li>the root package has changed to <em>org.springframework.config.java</em></li> 
 <li>scoped beans are fully supported</li> 
 <li>the bean name generation can be customized</li> 
 <li>the distribution contains a 'transformed' sample (petclinic) which uses XML, JavaConfig and Groovy.</li> 
</ul>
">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2007-06-05 06:07:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">有关Java配置的更多信息</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="null?s=20&d=mm"> <span class="author">Costin Leau</span>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2007-06-05 06:07:00.0">2007年6月5日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2007/06/05/more-on-java-configuration#disqus_thread" data-disqus-identifier="82">
</a></div>
</div>
</header>
<div class="blog--post"><p>众所周知，到目前为止，Spring <a href="http://blog.interface21.com/main/2007/05/28/conference-season-builds-up-to-springone/">不仅仅与XML有关</a> ，对核心的许多“官方”扩展为配置容器提供了替代方法。</p><p>Spring Java Configuration 1.0 M2是<a href="http://blog.interface21.com/main/2007/05/25/new-releases-in-the-spring-portfolio/">围绕JavaOne</a> <a href="http://www.springframework.org/node/455">发行</a>的产品之一，尽管仍被标记为里程碑，但它具有大量的更新和错误修正：</p>
<ul>
<li>根包已更改为<em>org.springframework.config.java</em></li>
<li>完全支持范围内的bean</li>
<li>Bean名称生成可以自定义</li>
<li>该发行版包含一个使用XML，JavaConfig和Groovy的“转换后的”样本（petclinic）。</li>
</ul><p>实际上，在1.0 M2上完成的大部分工作都将<a href="http://blog.interface21.com/main/2006/11/28/a-java-configuration-option-for-spring/#comments">收到</a>的反馈纳入初始公告中。非常感谢参与其中的每个人！</p><p>在此条目中，我想举一些Java配置示例，作为基于IoC注释的真正配置。<br>让我们开始与马克的例子，在他使用的<a href="http://blog.interface21.com/main/2007/05/14/annotation-driven-dependency-injection-in-spring-21/">入门</a>春2.1注解驱动的依赖注入。</p><p>回顾一下，下面是Mark使用的接口和类的图：</p><p><img id="image173" src="http://blog.interface21.com/main/wp-content/uploads/2007/06/blog-javaconfig-diagram.png" alt="图"></p><p>通过@Autowired完成连接，同时通过@PostConstruct和@PreDestroy将某些方法标记为生命周期的一部分。</p><p>将注释驱动的配置转换为Java配置非常简单：</p>
<pre><code class="prettyprint java"><br />@Configuration
public abstract class JavaCfg {

	@Bean (destroyMethodName = &quot;tearDownDatabase&quot;)
	public JdbcMessageRepository messageRepo() {
		JdbcMessageRepository repo = new JdbcMessageRepository();
		repo.createTemplate(dataSource());
		// call custom init method
		repo.setUpDatabase();

		return repo;
	}
	
	@Bean
	public GreetingService greetService() {
		GreetingServiceImpl impl = new GreetingServiceImpl();
		impl.setMessageRepository(messageRepo());
		return impl;
	}


	@ExternalBean
	public abstract DataSource dataSource();
}
</code></pre><p>首先，使用标记为@Configuration的Java类创建配置。其中声明了2个bean，并引用了一个外部bean。</p><p>声明的第一个bean是messageRepo（与方法名称相同），它还定义了销毁方法。注意，自定义init方法是通过代码调用的，因此不需要任何注释或声明。您仍然可以使用Spring InitializingBean接口或@Bean initMethodName参数，尽管我建议不要这样做。上面的代码更加简洁明了，更不用说您可以传递参数了，这在使用声明式init方法时不可用。</p><p>定义的第二个bean是greetService，它使用messageRepo作为依赖项。这是Java配置魔术发生的地方，因为每次创建greetService时，Spring容器都会在messageRepo之后提供bean实例。也就是说，如果messageRepo是单例，则每次都将返回相同的实例。但是，如果指定了不同的作用域，则在必须创建新实例时，将调用您的代码。Rod已经对此进行了解释，因此请参阅他的博客<a href="http://blog.interface21.com/main/2006/11/28/a-java-configuration-option-for-spring/">条目</a>以获取更多信息。</p><p>1.0 M2的一个附加功能是@ExternalBean批注，该批注引用了在当前配置之外声明的bean，同时仍依赖Java强类型，因此还需要进行IDE验证。@ExternalBean在运行时覆盖使用getBean（）查找声明的方法，如下所示：</p>
<pre><code class="prettyprint java"><br />   public DataSource dataSource() {
       return (DataSource) context.getBean(&quot;dataSource&quot;);
   }
</code></pre><p>当然，尤其是在使用<a href="http://static.springframework.org/spring-javaconfig/docs/1.0-m2a/api/org/springframework/config/java/support/ConfigurationSupport.html">ConfigurationSupport</a>类时，可以手动执行相同的操作，但是@ExternalBean使事情变得更加容易。请注意，在初始示例中，我使用了抽象方法来强调外部化，但是可以使用任何类型的非最终方法：</p>
<pre><code class="prettyprint java"><br />  @ExternalBean
  public DataSource dataSource() {
      throw new UnsupportedOperationException(&quot;this line will NEVER execute since the method will be overridden&quot;);
  }
</code></pre><p>现在已经创建了配置，将其与JavaConfiguration后处理器一起声明为普通bean：</p>
<pre><code class="prettyprint xml"><br /><br />&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
	xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans-2.0.xsd&quot;&gt;

	&lt;bean id=&quot;config&quot; class=&quot;blog.javaconfig.JavaCfg&quot; /&gt;

	&lt;bean id=&quot;processor&quot;
		class=&quot;org.springframework.config.java.process.ConfigurationPostProcessor&quot; /&gt;

	&lt;bean id=&quot;dataSource&quot;
		class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
		&lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot; /&gt;
		&lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;
		&lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;
		&lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;
	&lt;/bean&gt;

&lt;/beans&gt;
</code></pre><p>并且可以开始使用了（如果您正在运行Mark的测试，请确保使用Java配置xml文件）。</p><p>由于一张图片价值一千个单词，因此请通过<a href="http://springide.org/project/wiki">SpringIDE</a>查看以下相同设置：<br><a href="http://blog.interface21.com/main/wp-content/uploads/2007/06/springide.png"><img id="image174" src="http://blog.interface21.com/main/wp-content/uploads/2007/06/springide.png" width="800" height="454" border="0" alt="springIDE视图"></a></p><p>我使用了最新的SpringIDE快照，该快照提供了可视化，导航以及Java配置注释的验证（例如，插件检查<em>destroyMethodName</em>指向bean创建方法返回类型上的正确方法）。</p>
<h2>捉迷藏</h2><p>Java配置支持大多数XML声明功能，也就是说，您可以在Bean级别（通过@Bean）和默认值（通过@Configuration）指定范围，自动装配策略，延迟，依赖项以及自定义元数据。在1.0 M2中，您甚至可以获得@ScopedProxy批注，该批注直接替换为<aop:scoped-proxy></aop:scoped-proxy> 。</p><p>但是，Java Configuration在传统XML容器上提供的一项新功能是“ bean可见性”-定义不能在其配置之外使用的bean的能力。再次，让我们看一些代码：</p>
<pre><code class="prettyprint java"><br />@Configuration
public class VisibilityConfiguration {

	@Bean(scope = DefaultScopes.PROTOTYPE)
	public Object publicBean() {
		List list = new ArrayList();
		list.add(hiddenBean());
		list.add(secretBean());

		System.out.println(&quot;creating public bean&quot;);
		return list;
	}

	@Bean(scope = DefaultScopes.SINGLETON)
	protected Object hiddenBean() {
		System.out.println(&quot;creating hidden bean&quot;);
		return new String(&quot;hidden bean&quot;);
	}

	@Bean(scope = DefaultScopes.PROTOTYPE)
	private Object secretBean() {
		List list = new ArrayList();
		// hidden beans can access beans defined in the &#39;owning&#39; context
		list.add(hiddenBean());
		System.out.println(&quot;creating secret bean&quot;);
		return list;
	}
}
</code></pre><p>Java配置将使用方法可见性来确定某个bean是公共的（也就是说，可以在其声明配置之外使用）还是私有的（非公共）。因此，任何非公共的@Bean注释方法都将创建一个隐藏的bean。这使您可以提供bean定义封装，无论是否意外，都禁止访问。<br>需要特别注意的是，隐藏的bean不会转换为<a href="http://static.springframework.org/spring/docs/2.0.x/reference/beans.html#beans-inner-beans">嵌套bean-</a>它们是功能齐全的顶级bean：它们具有自己的生命周期并支持自定义范围，而不是依赖于父bean的内部bean。</p><p>为了证明这一点，我将hiddenBean标记为singleton，并将secretBean标记为原型。</p><p>让我们通过以下测试来测试行为：</p>
<pre><code class="prettyprint java"><br />public class VisibilityTest extends TestCase {
	private ConfigurableApplicationContext context;

	@Override
	protected void setUp() throws Exception {
		context = new AnnotationApplicationContext(&quot;**/VisibilityConfiguration.class&quot;);
	}

	@Override
	protected void tearDown() throws Exception {
		context.close();
	}

	public void testApplicationContext() {
		assertNotNull(context);
		System.out.println(Arrays.toString(context.getBeanDefinitionNames()));
		// I don&#39;t belive you container! I know you are hidding something 
		context.getBean(&quot;hiddenBean&quot;);
	}
}
</code></pre><p>测试应打印：</p>
<pre><code class="prettyprint code">[blog.javaconfig.VisibilityConfiguration, publicBean]
creating hidden bean
creating secret bean
creating public bean
creating secret bean
creating public bean
</code></pre><p>之后应该失败，例如：</p>
<pre><code class="prettyprint java"><br />org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named &#39;hiddenBean&#39; is defined
...
</code></pre><p>控制台的第一行显示，在我们持有的上下文中未定义secretBean和hiddenBean。但是，以下几行显示，对于每个publicBean，隐藏的bean创建一次（因为它是单例），而secretBean创建两次，因为它是原型。</p><p>那么隐藏的豆在哪里呢？在子容器内。</p><p>父容器（在我们的例子中为<em>上下文</em> ）完全不知道它，因此也不知道其中声明的任何bean。但是，在子上下文中声明的bean可以访问在父上下文中声明的任何bean，反之亦然。另一方面，公共Bean（例如publicBean）由父容器内的Java配置“推送”，但是由于它们以与隐藏Bean相同的配置声明，因此它们可以在实例化期间引用“秘密” Bean。</p>
<h2>看妈，没有XML！</h2><p>对于那些想完全放弃XML的人，Spring Java Configuration提供了<a href="http://static.springframework.org/spring-javaconfig/docs/1.0-m2a/api/org/springframework/config/java/context/AnnotationApplicationContext.html">AnnotationApplicationContext</a> ，它使用类而不是XML文件，如您从上面的测试用例中可以看到的。尽管我的示例有效，但它不是理想的，因为没有任何缓存，将为每个测试创建和销毁应用程序上下文。<br>一种替代方法是重用现有的<a href="http://static.springframework.org/spring/docs/2.0.x/api/org/springframework/test/AbstractDependencyInjectionSpringContextTests.html">AbstractDependencyInjectionSpringContextTests</a>并适当地覆盖上下文创建：</p>
<pre><code class="prettyprint java"><br />public class NoXMLTest extends AbstractDependencyInjectionSpringContextTests {

	@Override
	protected ConfigurableApplicationContext createApplicationContext(String[] locations) {
		GenericApplicationContext context = new GenericApplicationContext();
		customizeBeanFactory(context.getDefaultListableBeanFactory());
                // use Java Configuration annotation-based bean definition reader
		new ConfigurationClassScanningBeanDefinitionReader(context).loadBeanDefinitions(locations);
		context.refresh();
		return context;
	}

	@Override
	protected String[] getConfigLocations() {
		return new String[] { &quot;**/*.class&quot; };
	}

	public void testAppCtx() {
		assertNotNull(applicationContext);
	}
}
</code></pre><p>（这可以通过<a href="https://opensource.atlassian.com/projects/spring/browse/SPR-3550">SPR-3550</a>进一步简化）。</p>
<h2>哪种方法更好？</h2><p>你们中的一些人可能会怀疑最佳的注释配置方法是什么：注释驱动程序注入或Java配置？我的回答是：“取决于”。</p><p>Java配置遵循IoC原则，因为配置位于代码外部，这意味着您拥有真正的<strong>P</strong> OJO（即，代码内部没有配置注释）。</p><p>先前在此Blog上介绍的注释驱动注入使对象更加了解其配置。他们可以要求依赖关系，进行自动装配，甚至可以指定其范围。注入仍然发生（也就是说，对象仍由容器管理），但是配置的某些部分现在已包含在对象中。</p><p>使用JavaConfig，您可以像使用纯Java一样不受限制地配置对象。您可以使用任意数量的参数，任何类型，并可以调用任意数量的方法。由于它是Java，因此您的配置可以进行重构，并且可以从IDE自动补全中受益。这是极其灵活和强大的！</p><p>另一方面，通过注释驱动的注入，您可以对对象以及更多的上下文信息进行细粒度（类，方法甚至字段级）控制。</p><p>考虑@Autowire方法：</p>
<pre><code class="prettyprint java"><br />        @Autowired
        public void createTemplate(DataSource dataSource) {
                this.jdbcTemplate = new SimpleJdbcTemplate(dataSource);
        }
</code></pre><p>Spring不仅使用注释来确定自动装配的方法，还使用所需的类型。而且，可以使用multi-arg方法，这是使用JavaBeans约定并因此使用setter的“传统”自动装配不支持的功能。</p><p>最终，这两种方法都有一个目的：配置Spring容器。您可以使用其中之一，也可以同时使用XML和<a href="http://static.springframework.org/spring/docs/2.0.x/api/org/springframework/beans/factory/support/PropertiesBeanDefinitionReader.html">属性</a> 。实际上，Java配置发行版用XML，注释和基于<a href="http://groovy.codehaus.org/">Groovy</a>的配置替换了Petclinic的“传统” XML配置。考虑到此博客<a href="https://headius.blogspot.com/2007/05/adding-annotations-to-jruby-using-ruby.html">条目</a> ，不久之后将包括<a href="http://jruby.codehaus.org/">JRuby</a> 。</p><p>最重要的是，您可以选择更好地适合您的开发风格的东西。</p><p>PS如果您对此主题感兴趣，则可能需要参加以下SpringOne <a href="http://www.springone.com/display/SpringOne07/Ways+to+configure+the+Spring+container">会话</a>进行深入讨论：）</p><p>干杯，<br>科斯丁</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 82;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>