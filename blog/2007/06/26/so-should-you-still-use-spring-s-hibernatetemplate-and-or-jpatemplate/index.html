<html dir="ltr" data-code-prettify="" data-mobile-support="" data-search=""><head></head><body dir="ltr">﻿
<title>因此，您仍然应该使用Spring的HibernateTemplate和/或JpaTemplate吗？</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>System.config({baseURL: "/b92013b"});</script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>System.import('app/main.js')</script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="So should you still use Spring's HibernateTemplate and/or JpaTemplate??">
<meta name="twitter:description" content="<p>I was reading an <a href=" http:="" ="" www.infoq.com="" articles="" dynamic-routing-using-sprin="=">article by Vigil Bose on TSS the other day and saw the usage of the HibernateDaoSupport class. Since this is no longer a recommended way of using Hibernate from Spring, I thought I might as well just blog about it another time.
<p>With the advent of Spring 2.0, it has become possible to start using the Hibernate Session API directly again. The question is whether or not it is wise to abandon the use of the HibernateTemplate when working with Hibernate, or any other template-based approaches Spring features.</p>
">

<meta property="og:title" content="So should you still use Spring's HibernateTemplate and/or JpaTemplate??">
<meta property="og:description" content="<p>I was reading an <a href=" http:="" ="" www.infoq.com="" articles="" dynamic-routing-using-sprin="=">article by Vigil Bose on TSS the other day and saw the usage of the HibernateDaoSupport class. Since this is no longer a recommended way of using Hibernate from Spring, I thought I might as well just blog about it another time.
<p>With the advent of Spring 2.0, it has become possible to start using the Hibernate Session API directly again. The question is whether or not it is wise to abandon the use of the HibernateTemplate when working with Hibernate, or any other template-based approaches Spring features.</p>
">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2007-06-26 14:03:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">// Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }</script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">因此，您仍然应该使用Spring的HibernateTemplate和/或JpaTemplate吗？</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="null?s=20&d=mm"> <span class="author">阿列夫·阿伦森（Alef Arendsen）</span>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2007-06-26 14:03:00.0">2007年6月26日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2007/06/26/so-should-you-still-use-spring-s-hibernatetemplate-and-or-jpatemplate#disqus_thread" data-disqus-identifier="96">
</a></div>
</div>
</header>
<div class="blog--post"><p>前几天，我正在阅读<a href="http://www.infoq.com/articles/dynamic-routing-using-spring">Vigil Bose</a>在TSS上的<a href="http://www.infoq.com/articles/dynamic-routing-using-spring">一篇文章，</a>并看到了HibernateDaoSupport类的用法。由于这不再是从Spring使用Hibernate的推荐方式，因此我认为我不如再写一篇有关它的博客。</p><p>随着Spring 2.0的到来，再次直接使用Hibernate Session API成为可能。问题是，在使用Hibernate或任何其他基于模板的Spring功能时，放弃使用HibernateTemplate是否明智。</p>
<h2>使用Spring XxxTemplates</h2><p>在Spring 1.0中，我们引入了一种革命性的方法来处理引发检查异常的数据访问API。Spring所采用的模板方法及其事务同步管理器以及运行时异常的广泛使用，使得通常在数据访问代码中发现的任何TCFTC（我们在2005年提出的try / catch-finally-try / catch的缩写）都已过时。在下面，您可以看到（Spring的模板方法为您做了什么（简化版本，而并非完全精确的版本）（带有您必须编写的特定代码段）。</p><p><img id="image200" src="http://blog.interface21.com/main/wp-content/uploads/2007/06/template.png" alt="template.png"></p><p><b>获取连接</b> ：如果事务同步处于活动状态（如果您使用的是Spring的事务管理基础架构，则为同步状态），大多数情况下，任何Spring模板都在整个线程上使用相同的连接（实际上要多一些）比这复杂，但这会使我们过多地了解血腥细节）。</p><p><b>参与事务</b>再次，当使用事务管理功能时，Spring会自动将任何新连接与当前事务相关联。同样，这都取决于当前的传播设置，等等，但是无论您以哪种方式查看，您的核心代码都不会受到它的影响。</p><p><b>SQL规范</b> ：这（显然）是您必须要做的。SQL最好使用绑定参数，以避免发生SQL注入的任何机会。参数作为参数传递给JDBC模板。</p><p><b>创建/执行语句并遍历结果集</b> ：指定SQL后，Spring将为您创建语句，设置您可能指定的任何参数，执行该语句并为您遍历结果集。</p><p><b>从结果集中解析结果</b> ：如果愿意（或者如果您有复杂的解析要求），则可以选择自己解析结果集，或者可以让Spring结果包含一组基元，或者仅包含结果集中的一个值。</p><p><b>异常的处理和转换</b> ：Spring在这里将可能发生的任何异常转换为Spring自己的DataAccessException层次结构，从而自动将调用代码与所使用的数据访问技术隔离开。</p><p><b>释放连接</b> ：这是Spring释放所有使用资源的难题的最后一部分。当然，如果事务同步处于活动状态，则资源可能不会立即释放。</p><p>模板可用于多种API，例如：</p>
<ul>
<li>JDBC（JdbcTemplate）</li>
<li>休眠（HibernateTemplate）</li>
<li>iBatis（SqlMapClientTemplate）</li>
<li>JDO（JdoTemplate）</li>
<li>TopLink（TopLinkTemplate）</li>
<li>消息传递（JmsTempate）</li>
<li>交易管理（TransactionTemplate）</li>
<li>JNDI（JndiTemplate）</li>
</ul>
<h2>模板真的必要吗？</h2><p>当使用使用已检查的异常（与运行时异常或未检查的异常相对）的API时，这些模板会增加很多价值，而且还会为代码库增加很多一致性。学会了Spring的JdbcTemplate的人们可以很容易地开始使用Spring的JdoTemplate或Spring的HibernateTemplate-每种方法的使用方法都相似。</p><p>Spring模板方法最明显的影响是减少了代码，例如JDBC。这主要是因为已检查的异常已转换为模板内的运行时异常，从而无需在主线代码中捕获该异常。其他原因是透明的资源管理以及与当前正在运行的事务的自动同步。当然，更改框架以本机使用运行时异常非常容易，而不是Spring不必这样做，这就是Hibernate从3.0版开始就开始做的事情。Hibernate并非唯一做到这一点的技术-Java Persistence API也使用了运行时异常。</p><p>这些技术使用运行时异常的事实实质上使Spring模板对于这些技术的等效性毫无用处……至少在很大程度上，如果您从代码简化的角度来看它的话。如果您仅使用Spring HibernateTemplate来减少执行Hibernate数据访问操作所需的代码量，那么您将不必使用模板！但是，当查看上表时，我们可以看到Spring在幕后所做的工作比您想象的要多。</p><p>除了部分简化错误处理问题（我们仍然必须将特定于数据访问技术的异常转换为Spring的DataAccessExceptions）之外，还通过基础数据访问技术的一些更改来解决事务管理和资源管理问题。让我们更详细地看一下：</p><p><b>资源管理</b><br>自从Hibernate 3.0.1（以及从其首次发布以来的Java Persistence API开始）以来，Spring便有可能管理基础资源，而无需您浏览那些技术可用的任何模板。这意味着即使您直接使用Hibernate API（例如，通过SessionFactory.getCurrentSession（）），您仍将使用Spring管理的Hibernate Session。通过JPA EntityManagerFactory获得的EntityManager也是如此。这就是为什么您不必再使用Spring的HibernateTemplate来获得集成体验的另一个原因。</p><p><b>交易管理</b><br>现在，Spring能够为您处理基础资源，而无需您遍历模板，Spring还将能够在获取资源时将资源与正在进行的任何事务同步。这意味着无需您通过模板即可解决事务管理问题。同样，这意味着我们不必再使用Spring的HibernateTemplate。</p><p><b>错误处理</b><br>当您使用Hibernate或JPA附带的普通API（即Hibernate Session或JPA EntityManager）时无法直接使用的唯一一件事是将特定于技术的数据访问异常转换为Spring DataAccessException层次结构。我们很快就会解决此问题，我们将在稍后显示。</p>
<h2>无需模板</h2><p>那么，例如，如果我们不使用HibernateTemplate，那会是什么样？显示事情如何工作非常简单。我们要做的第一件事是直接开始使用Session API而不是HibernateTemplate。要访问Hibernate会话，我们需要SessionFactory，它将照常注入：</p>
<pre><code class="prettyprint java"><br>public class HibernateAccountRepository implements AccountRepository {

	private SessionFactory factory;
	
	public HibernateAccountRepository(SessionFactory factory) {
		this.factory = factory;
	}
	
	public Account loadAccount(String username) {
		return (Account)factory.getCurrentSession()
		    .createQuery("from Account acc where acc.name = :name")
		    .setParameter("name", "Alef").uniqueResult();
	}
}
</code></pre><p>以下是我们将用于组装应用程序的XML。如您所见，我们当然仍然使用Spring方式设置Hibernate（使用LocalSessionFactoryBean）。</p>
<pre><code class="prettyprint xml"><br><bean id="sessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean">
	<!-- the works -->
</bean>

<bean id="accountRepo" class="com.mycompany.HibernateAccountRepository">
	<constructor-arg ref="sessionFactory"/>
</bean>
</code></pre><p>现在，正如我之前所说，由于Hibernate 3.0.1中的微小更改，Spring能够为您管理Hibernate会话，而无需您通过Hibernate会话。缺少的一件事是异常翻译。为此，您只需要使用@Repositoryannotation（由Spring提供）annotation存储库，然后使用后处理器打开异常转换即可。</p>
<pre><code class="prettyprint java"><br>@Repository // from org.springframework.stereotype
public class HibernateAccountRepository implements AccountRepository {

	// see above for full impl...
}
</code></pre>
<pre><code class="prettyprint xml"><br><br><!-- for the other beans in the configuration, see above -->

<bean class="org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor"/>
</code></pre><p>后处理器将自动识别@Repositoryannotation，并发出Spring来为此bean打开异常转换。使用代理服务器工作的事实与讨论无关。</p><p><b>请注意</b> ，使用Java Persistence API（JPA）的存储库也是如此。实际上，您甚至根本不需要更改后处理器或注释。</p><p>如果您在注释不可用的环境（Java5之前的版本）中使用Hibernate，您仍然可以享受自动异常翻译的功能；使用AOP。首先声明一个异常转换器，然后声明一个AOP配置，如下所示：</p>
<pre><code class="prettyprint xml"><br><bean id=“persistenceExceptionInterceptor
    class=“org.springframework.dao.support.PersistenceExceptionTranslationInterceptor"/>

<aop:config>
    <aop:advisor pointcut=“execution(* *..*Repository+.*(..))" 
                          advice-ref=“persistenceExceptionInterceptor" />
</aop:config>
</code></pre><p>这里的切入点与实现了Repository接口的任何类（更确切地说，是以Repository结尾的接口）匹配。</p>
<h2>真正的问题是：选择哪种方法？</h2><p>用一个典型的顾问的答案来回答：“这一切都取决于” :)。让我告诉你，我个人更喜欢不使用HibernateTemplate和JpaTemplate，因为我认为它们不再提供足够的价值。为了保持一致性，您可能会争辩说，选择基于全面模板的方法会使您处在所有地方都相似的情况；您仍然必须学习Hibernate的工作原理，但是对于更复杂的情况，您可能仍然想直接使用Session API。请注意，如果您使用的是HibernateTemplate（通过Spring的HibernateCallback），这仍然可行。</p><p>简而言之（就像已经提到的<a href="http://www.springframework.org/docs/api/org/springframework/orm/hibernate3/HibernateTemplate.html">HibernateTemplate</a>和<a href="http://www.springframework.org/docs/api/org/springframework/orm/jpa/JpaTemplate.html">JpaTemplate</a>的JavaDoc），如果您要分别在新项目中分别使用Hibernate或JPA，我建议您直接开始使用Session和/或EntityManager API。请记住： <b>Spring尝试非侵入性，这是另一个很好的例子！</b></p><p>[更新：次要错字] [更新：添加了有关无注释异常翻译的信息]</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">var disqus_shortname = 'spring-io';
      var disqus_identifier = 96;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));</script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });</script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>