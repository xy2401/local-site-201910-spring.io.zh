<!DOCTYPE html>
<html data-code-prettify="" data-mobile-support="" data-search="">
<head>
<title>Debunking myths: proxies impact performance</title>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no" id="Viewport" name="viewport" />
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png" />
<link href="https://fonts.googleapis.com/css?family=Varela+Round|Montserrat:400,700" rel="stylesheet" type="text/css" />
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css" />
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M" name="google-site-verification" />

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css" />

<meta content="summary" name="twitter:card" />
<meta content="@springcentral" name="twitter:site" />
<meta name="twitter:title" content="Debunking myths: proxies impact performance" />
<meta name="twitter:description" content="&lt;p&gt;In a recent blog entry Marc Logemann &lt;a href=&quot;http://www.logemann.org/2007/07/16/how-much-slower-is-spring-proxies-compared-to-plain-pojo/&quot;&gt;touches on the subject of proxy performance&lt;/a&gt;. In his entry he asks for a white paper by ‘the Spring guys’. I don’t want to spend (p)ages and (p)ages on discussing the differences up to the nanosecond between proxies and byte code weaving mechanisms, but I do think it’s valuable to re-iterate once again what the differences are and whether or not this discussion matters at all.&lt;/p&gt;
&lt;h2&gt;What are proxies and why do we use them?&lt;/h2&gt;
&lt;p&gt;Let’s first shortly revisit what proxies are used for (in general, and in Spring). According the Gang of Four (GoF) &lt;a href=&quot;http://www.amazon.com/exec/obidos/tg/detail/-/0201633612&quot;&gt;book on Design Patterns&lt;/a&gt; a proxy is a surrogate object or placeholder for another object to control access to it. Because the proxy sits in between the caller of an object and the real object itself, it can decide to prevent the real (or target) object from being invoked, or do something before the target object is invoked.&lt;/p&gt;
" />

<meta property="og:title" content="Debunking myths: proxies impact performance" />
<meta property="og:description" content="&lt;p&gt;In a recent blog entry Marc Logemann &lt;a href=&quot;http://www.logemann.org/2007/07/16/how-much-slower-is-spring-proxies-compared-to-plain-pojo/&quot;&gt;touches on the subject of proxy performance&lt;/a&gt;. In his entry he asks for a white paper by ‘the Spring guys’. I don’t want to spend (p)ages and (p)ages on discussing the differences up to the nanosecond between proxies and byte code weaving mechanisms, but I do think it’s valuable to re-iterate once again what the differences are and whether or not this discussion matters at all.&lt;/p&gt;
&lt;h2&gt;What are proxies and why do we use them?&lt;/h2&gt;
&lt;p&gt;Let’s first shortly revisit what proxies are used for (in general, and in Spring). According the Gang of Four (GoF) &lt;a href=&quot;http://www.amazon.com/exec/obidos/tg/detail/-/0201633612&quot;&gt;book on Design Patterns&lt;/a&gt; a proxy is a surrogate object or placeholder for another object to control access to it. Because the proxy sits in between the caller of an object and the real object itself, it can decide to prevent the real (or target) object from being invoked, or do something before the target object is invoked.&lt;/p&gt;
" />
<meta content="article" property="og:type" />
<meta property="og:article:published_time" content="2007-07-19 11:00:00.0" />
</head>
<body>

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" style="display:none;visibility:hidden" width="0"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">Projects</a>
</li>
<li class="navbar-link">
<a href="/guides">Guides</a>
</li>
<li class="navbar-link active">
<a href="/blog">Blog</a>
</li>
<li class="navbar-link">
<a href="/services">Training & Certification</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form action="/search" class="form-inline form-search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search for documentation, guides, and posts..." type="text" value="" />
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form action="/search" class="form-inline form-search" method="get">
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search..." type="text" value="" />
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">
Home
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">
Projects
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">
Guides
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">
Blog
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">
Training & Certification
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>Engineering</div>
</div>
<div class="blog-category content--title">
<div>Releases</div>
</div>
<div class="blog-category content--title">
<div>News and Events</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Debunking myths: proxies impact performance</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">Engineering</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="null?s=20&amp;d=mm" />
<span class="author">Alef Arendsen</span>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2007-07-19 11:00:00.0">July 19, 2007</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" data-disqus-identifier="100" href="/blog/2007/07/19/debunking-myths-proxies-impact-performance#disqus_thread">
</a></div>
</div>
</header>
<div class="blog--post"><p>In a recent blog entry Marc Logemann <a href="http://www.logemann.org/2007/07/16/how-much-slower-is-spring-proxies-compared-to-plain-pojo/">touches on the subject of proxy performance</a>. In his entry he asks for a white paper by &lsquo;the Spring guys&rsquo;. I don&rsquo;t want to spend (p)ages and (p)ages on discussing the differences up to the nanosecond between proxies and byte code weaving mechanisms, but I do think it&rsquo;s valuable to re-iterate once again what the differences are and whether or not this discussion matters at all.</p>
<h2>What are proxies and why do we use them?</h2><p>Let&rsquo;s first shortly revisit what proxies are used for (in general, and in Spring). According the Gang of Four (GoF) <a href="https://www.amazon.com/exec/obidos/tg/detail/-/0201633612">book on Design Patterns</a> a proxy is a surrogate object or placeholder for another object to control access to it. Because the proxy sits in between the caller of an object and the real object itself, it can decide to prevent the real (or target) object from being invoked, or do something before the target object is invoked.</p><p><img id="image212" src="http://blog.interface21.com/main/wp-content/uploads/2007/07/prox.jpg" alt="prox.jpg" /></p><p>In other words, proxies can be used as stand-ins for real objects to apply extra behavior to those objects&ndash;be it security-related behavior, caching or maybe performance measurements.</p><p>Many modern frameworks use proxies to realize functionality that would not have been possible otherwise. Many object-relational mappers use proxies to implement behavior that prevents data from being loaded until it is actually really needed (this is sometimes called lazy loading). Spring also uses proxies to realize some of its functionality such as its remoting facilities, its transaction management facilities and the AOP framework.</p><p>An alternative to proxies is byte code weaving. When using byte code weaving mechanisms, there will never be a second object (aka the proxy). Instead, if behavior (such as transaction management or security) needs to be applied, it is woven &lsquo;into&rsquo; the existing code, instead of &lsquo;around it&rsquo;. One way to do do the weaving process is by using the Java5 -javaagent flag. Other ways are available to.</p><p>In other words: with proxies you end up with a proxy object that sits in front of the target object, whereas with a byte code weaving approach, there will not be a proxy that has to delegate calls.</p>
<h2>The cold hard truth</h2><p>Okay, let&rsquo;s get it over with: proxies add overhead to a plain method invocation&hellip; significant overhead. To my mind, that&rsquo;s absolutely not surprising. The fact that putting a proxy in between is totally natural. Generally one could say that an intermediate always adds overhead. Now the question is: <b>what do we get in return for the overhead a proxy adds?</b></p><p>Note that I&rsquo;m not going to bother with providing numbers here. As Stefan Hansel correctly points out in <a href="http://www.logemann.org/2007/07/16/how-much-slower-is-spring-proxies-compared-to-plain-pojo/">his comment on Marc&rsquo;s blog</a>, micro benchmarks measuring the difference between plain target invocation versus having a proxy in between (or any micro benchmark for that matter) don&rsquo;t really make sense because of a whole bunch of other factors that you have to take into account as well.</p>
<h3>Okay, but you <b>do</b> want numbers?</h3><p>Okay, let&rsquo;s get to it then. Let&rsquo;s consider the following piece of code where we have two objects, one which is proxied, one which is not. Let&rsquo;s assume the target object itself (the dotIt()) method does not do anything in particular. Let&rsquo;s also assume the proxy does not do any in particular also (it just delegates to the target object).</p><p>If I run this code on my laptop (MacBook) with a plain JDK dynamic proxy (more about those later), then one method invocation to <i>myRealObject</i> takes 9 nanoseconds (10<sup>-9</sup>). One invocation to the proxied object takes 500 nanoseconds (about 50 times as slow).</p>
<pre><code class="prettyprint java"><br />// real object
MyInterface myRealObject;
myRealObject.doIt();

// proxied object
MyInterface myProxiedObject;
myProxiedObject.doIt();
</code></pre><p>In contrast, if I a byte code weaving approach (in this case I&rsquo;m using AspectJ to simulate the same setup), I only end up with about 2 nanoseconds added to my invocation.</p><p>So concluding, I can&rsquo;t make it any better than it is: proxies add significant overhead to a plain method invocation.</p><p>Before we go on let&rsquo;s first realize that the overhead that&rsquo;s being added here is <b>fixed</b>. It is definitely <b>not</b> the case that if the doIt() method itself would take 5 seconds, the proxied invocation would take 50 times as long. No, instead, the invocation would take 5 seconds + ~500 nanoseconds.</p>
<h2>Putting things in context (or: should you care?)</h2><p>Okay, so now we know proxies aren&rsquo;t some kind of super-fast objects that work their magic without causing side-effects, the question is: &ldquo;do we need to worry about the overhead&rdquo;. The answer is pretty simple: &ldquo;no you don&rsquo;t&rdquo; ;-). I&rsquo;ll explain you why.</p><p>We&rsquo;re using proxies to transparently add behavior to an object. Maybe to decorate an object with security rules (administrators can access it, but normal users can&rsquo;t) or maybe it&rsquo;s because we want to enable lazy loading, only loading data from a database on first access. Another reason would be to enable transparent transaction management for our objects.</p>
<h3>Transaction management</h3><p>Let&rsquo;s look at the transaction management example. The following sequence diagram roughly depicts (a simplified view of) what happens in a situation where a service is called whereby beforehand a transaction is started and after successful completion the transaction is committed.</p><p><img id="image211" src="http://blog.interface21.com/main/wp-content/uploads/2007/07/seq.jpg" alt="seq.jpg" /></p><p>The invocation of the service itself now definitely involve a certain overhead (the overhead we already discussed before). The question however is, what do we get in exchange for the overhead?</p>
<h3>Benefits realized</h3><p>If we continue to look at the above example, we&rsquo;ve realized a couple of benefits.</p><p><b>Code simplification</b><br />We&rsquo;ve greatly simplified our code by putting a proxy in between. If we use the @Transactional annotation Spring provides, all we need to do is the following:</p>
<pre><code class="prettyprint java"><br />public class Service {

  @Transactional 
  public void executeService() { }

}
</code></pre><p>and</p>
<pre><code class="prettyprint xml"><br />&lt;tx:annotation-driven/&gt;

&lt;bean class=&quot;com.mycompany.Service&quot;/&gt;
</code></pre><p>An alternative (programmatic) approach would involve significantly modifying either the client (caller) or the service class itself.</p><p><b>Centralized transaction management</b><br />Transaction management is now taken care of by a central facility, allowing for much more optimization and a very consistent approach to doing transaction management. This would not have been possible if we&rsquo;d have implemented the transaction management code in our service or caller itself.</p>
<h3>And what does it matter anyway?</h3><p>If that&rsquo;s not enough, we can always start looking at the actual performance degradation that we get from the proxying mechanism and compare it to the actual time it takes to start and/or commit a transaction. I don&rsquo;t have any numbers available, but I can assure you, committing a transaction on a JDBC transaction definitely takes more time than 491 nanoseconds.</p>
<h3>But what if it's very fine-grained operations the proxy executes</h3><p>Ahh! That&rsquo;s an entirely different story. There are different classes of behavior you can transparently add of course (either using proxies or using a byte code weaving approach). I usually distinguish between fine-grained and coarse-grained behavior. Coarse-grained behavior to my mind is applied at a service level or only to a certain and limited set of operations in our application. A more fine-grained set of behavior would for example include logging of every method in our system. I would definitely not choose to use a proxy-based approach for such fine-grained approaches.</p>
<h3>Rules of thumb</h3><p>Concluding we can say the following:</p>
<ul>
<li>first of all proxies add overhead and that this overhead is negligible if the behavior applied to the objects that are proxied has something to do with longer running operations (such as database or file access or transaction management).</li>
<li>We can also say that if you need very fine-grained behavior and want to apply that to a large set of objects, it's probably safer to go for a byte code weaving approach, such as AspectJ.</li>
<li>If that's not enough, it's probably still safe to say that proxying (unless applied to thousands or more objects in your system) would never be the first place you should look for in a system that suffers from degraded performance.</li>
<li>Another rule of thumb might possibly be that any request in your system should probably not involve (calls to) more than 10 (or so) proxied methods. <b>10 proxy operations * 500 ns per proxy operation = 5 microseconds</b> (which is still negligible I would say), but <b>100,000 proxy operations * 500 ns per proxy operation = 50 millisecond</b> (which to my mind is no longer negligible).</li>
</ul>
<h2>Different types of proxies</h2><p>Apart from the discussion about whether or not proxies add overhead at all, it&rsquo;s also relevant to shortly discuss different types of proxies. There are several distinct types of proxies. In my little benchmark, I&rsquo;ve used the JDK dynamic proxying infrastructure (from the java.lang.reflect package) that is only capable of creating proxies for interfaces. Another proxying mechanism is CGLIB which uses a slightly different approach to proxying. The last time I did a small performance benchmark between the two, I didn&rsquo;t really find a significant difference and frankly, I don&rsquo;t care that much. What is important is the inner workings of the proxy that has been created. There are a lot of things that can go wrong if you start implementing proxies yourself. If you compare the following two pieces of code for example you might not expect there to be a <b>huge</b> difference in performance between the two. And when I&rsquo;m saying huge, I&rsquo;m saying a factor 10 or so&hellip;</p>
<pre><code class="prettyprint java"><br />public Object invoke(Object proxy, Method proxyMethod, Object[] args)
throws Throwable {
	Method targetMethod = null;
	if (!cachedMethodMap.containsKey(proxyMethod)) {
		targetMethod = target.getClass().getMethod(proxyMethod.getName(), 
			proxyMethod.getParameterTypes());
		cachedMethodMap.put(proxyMethod, targetMethod);
	} else {
		targetMethod = cachedMethodMap.get(proxyMethod);
	}
	Ojbect retVal = targetMethod.invoke(target, args);
	return retVal;
}
</code></pre>
<pre><code class="prettyprint java"><br />public Object invoke(Object proxy, Method proxyMethod, Object[] args)
throws Throwable {
	Method targetMethod = target.getClass().getMethod(proxyMethod.getName(), 
			proxyMethod.getParameterTypes());
	Ojbect retVal = targetMethod.invoke(target, args);
	return retVal;
}
</code></pre><p>In other words, leave generating or creating proxies to people or frameworks that know what they&rsquo;re doing. Fortunately for you, I wasn&rsquo;t involved in the proxy design and Rob, Juergen, Rod et. al. are way better at that than I am, so no worries there ;-).</p>
<h2>What about byte code weaving</h2><p>In general, one can say that a byte code weaving approach takes a little more time to set up depending on your environment. In some scenarios you need to set up a java agent, in other situations, you might need to modify your compilation process, other frameworks might require the use of a different class loader. In other words, byte code weaving is a little harder to set up. In my experience, (as always) the 80-20 rule applies here as well. 80% of all requirements can probably be solved using proxy-based systems. For the last mile, or the remaining 20%, opting for a byte code weaving approach might be a good option.</p>
<h2>The relation with AOP</h2><p>You might wonder why I haven&rsquo;t touched on the subject of AOP yet. Proxies and byte code weaving have a strong relation to AOP. Or maybe that&rsquo;s the other way around. In any case, Spring&rsquo;s AOP framework <i>uses</i> proxies to realize its functionality. Proxies to my mind are just an implementation detail (although a pretty important one) is strongly linked with AOP and Spring in general.</p>
<h2>Conclusion</h2><p>Concluding, we can say that proxies do add a little bit of overhead to a call to an object it proxies but that the discussion about this is not relevant under most circumstances. The reason for this lies partially in the great benefits proxies bring (such as way better maintenance of our code due to code simplification and centralized control) and also in the fact that things we do using proxies (such as transaction management or caching) usually have a far greater impact on performance as the proxying mechanism itself.</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 100;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>
Back
</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">All Posts</a>
<a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">Engineering</a>
<a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">Releases</a>
<a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">News and Events</a>
<a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>Get updates from The Spring Team delivered to your inbox</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">Tools</a></li>
<li><a href="https://store.pivotal.io/">Store</a></li>
<li><a href="/blog">Newsletter</a></li>
</ul>
</div>
</div>
&copy; <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a>, Inc. All Rights Reserved.
<a href="https://pivotal.io/terms-of-use">Terms of Use</a> &bullet;
<a href="https://pivotal.io/privacy-policy">Privacy</a> &bullet;
<a href="/trademarks">Trademark Guidelines</a>
<div id="teconsent" style="display:inline-block;"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>