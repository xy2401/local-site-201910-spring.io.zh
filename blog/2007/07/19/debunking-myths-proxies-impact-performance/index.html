<html  data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>揭穿神话：代理影响绩效</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Debunking myths: proxies impact performance">
<meta name="twitter:description" content="<p>In a recent blog entry Marc Logemann <a href=" http: ="" www.logemann.org="" 2007="" 07="" 16="" how-much-slower-is-spring-proxies-compared-to-plain-pojo="" ="=">touches on the subject of proxy performance. In his entry he asks for a white paper by ‘the Spring guys’. I don’t want to spend (p)ages and (p)ages on discussing the differences up to the nanosecond between proxies and byte code weaving mechanisms, but I do think it’s valuable to re-iterate once again what the differences are and whether or not this discussion matters at all.
<h2>What are proxies and why do we use them?</h2>
<p>Let’s first shortly revisit what proxies are used for (in general, and in Spring). According the Gang of Four (GoF) <a href=" www.amazon.com exec obidos tg detail - 0201633612"></head><body >book on Design Patterns a proxy is a surrogate object or placeholder for another object to control access to it. Because the proxy sits in between the caller of an object and the real object itself, it can decide to prevent the real (or target) object from being invoked, or do something before the target object is invoked.<p></p>
">

<meta property="og:title" content="Debunking myths: proxies impact performance">
<meta property="og:description" content="<p>In a recent blog entry Marc Logemann <a href=" http: ="" www.logemann.org="" 2007="" 07="" 16="" how-much-slower-is-spring-proxies-compared-to-plain-pojo="" ="=">touches on the subject of proxy performance. In his entry he asks for a white paper by ‘the Spring guys’. I don’t want to spend (p)ages and (p)ages on discussing the differences up to the nanosecond between proxies and byte code weaving mechanisms, but I do think it’s valuable to re-iterate once again what the differences are and whether or not this discussion matters at all.
<h2>What are proxies and why do we use them?</h2>
<p>Let’s first shortly revisit what proxies are used for (in general, and in Spring). According the Gang of Four (GoF) <a href=" www.amazon.com exec obidos tg detail - 0201633612">book on Design Patterns a proxy is a surrogate object or placeholder for another object to control access to it. Because the proxy sits in between the caller of an object and the real object itself, it can decide to prevent the real (or target) object from being invoked, or do something before the target object is invoked.<p></p>
">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2007-07-19 11:00:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">揭穿神话：代理影响绩效</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="null?s=20&d=mm"> <span class="author">阿列夫·阿伦森（Alef Arendsen）</span>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2007-07-19 11:00:00.0">2007年7月19日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2007/07/19/debunking-myths-proxies-impact-performance#disqus_thread" data-disqus-identifier="100">
</a></div>
</div>
</header>
<div class="blog--post"><p>在最近的博客文章中，马克·洛格曼（Marc Logemann）谈到<a href="http://www.logemann.org/2007/07/16/how-much-slower-is-spring-proxies-compared-to-plain-pojo/">了代理表现的问题</a> 。在他的文章中，他要求“ Spring Guys”撰写白皮书。我不想花费（p）age和（p）age来讨论代理和字节码编织机制之间的纳秒级差异，但我确实想再次重申这些差异是什么以及是否这个讨论根本不重要。</p>
<h2>什么是代理？为什么要使用它们？</h2><p>首先，让我们简短地回顾一下代理的用途（通常在Spring中）。根据<a href="https://www.amazon.com/exec/obidos/tg/detail/-/0201633612">有关设计模式</a>的“四人帮”（GoF） <a href="https://www.amazon.com/exec/obidos/tg/detail/-/0201633612">一书，</a>代理是另一个对象的替代对象或占位符，用于控制对其的访问。因为代理位于对象的调用者和实际对象本身之间，所以它可以决定阻止实际（或目标）对象被调用，或者在调用目标对象之前执行某些操作。</p><p><img id="image212" src="http://blog.interface21.com/main/wp-content/uploads/2007/07/prox.jpg" alt="prox.jpg"></p><p>换句话说，代理可以用作真实对象的替代品，以对这些对象施加额外的行为-无论是与安全相关的行为，缓存还是性能度量。</p><p>许多现代框架使用代理来实现原本不可能实现的功能。许多对象关系映射器使用代理来实现一些行为，以防止在真正需要数据之前才加载数据（有时称为延迟加载）。Spring还使用代理来实现其某些功能，例如其远程处理功能，其事务管理功能和AOP框架。</p><p>代理的替代方法是字节码编织。当使用字节码编织机制时，将永远不会有第二个对象（也称为代理）。相反，如果需要应用行为（例如事务管理或安全性），则将其“编织”到现有代码中，而不是“围绕它”。进行编织过程的一种方法是使用Java5 -javaagent标志。其他方法也可以使用。</p><p>换句话说：使用代理，您最终会得到一个位于目标对象前面的代理对象，而使用字节码编织方法，就不会有必须委托调用的代理。</p>
<h2>冷酷的硬道理</h2><p>好的，让我们克服它：代理将开销添加到普通方法调用中……相当大的开销。在我看来，这绝对不足为奇。在两者之间放置代理完全是自然的事实。通常，人们可以说中间体总是增加开销。现在的问题是： <b>代理增加的管理费用能带来什么回报？</b></p><p>请注意，我不会在这里提供数字。正如Stefan Hansel在<a href="http://www.logemann.org/2007/07/16/how-much-slower-is-spring-proxies-compared-to-plain-pojo/">对Marc博客的评论中</a>正确指出的那样，由于衡量了其他目标，衡量基准目标调用与代理之间的差异的微基准测试（或与此相关的任何微基准测试）实际上没有任何意义。您还必须考虑的因素。</p>
<h3>好吧，但<b>你</b>想的数字？</h3><p>好的，让我们开始吧。让我们考虑下面的代码，其中有两个对象，一个是代理对象，一个不是代理对象。让我们假设目标对象本身（dotIt（））方法没有做任何特别的事情。我们还要假设代理也没有做任何特别的事情（它只是委托给目标对象）。</p><p>如果我在带有普通JDK动态代理的笔记本电脑（MacBook）上运行此代码（稍后会详细介绍），则对<i>myRealObject的</i>一种方法调用将花费9纳秒（10 <sup>-9</sup> ）。对代理对象的一次调用需要500纳秒（约慢50倍）。</p>
<pre><code class="prettyprint java"><br />// real object
MyInterface myRealObject;
myRealObject.doIt();

// proxied object
MyInterface myProxiedObject;
myProxiedObject.doIt();
</code></pre><p>相反，如果我采用字节码编织方法（在这种情况下，我使用AspectJ来模拟相同的设置），则最终只增加了约2纳秒的调用时间。</p><p>因此，最后，我不能做得更好：代理给普通方法调用增加了可观的开销。</p><p>在继续之前，我们首先要意识到这里添加的开销是<b>固定的</b> 。如果doIt（）方法本身要花费5秒钟，则绝对<b>不是</b>这种情况，代理调用将花费50倍的时间。不，相反，调用将花费5秒+〜500纳秒。</p>
<h2>将事物放在上下文中（或：您应该在乎吗？）</h2><p>好的，所以现在我们知道代理不是某种超级快的对象，它们可以在不产生副作用的情况下发挥作用，问题是：“我们需要担心开销吗？”答案很简单：“不，你不” ;-)。我会向您解释原因。</p><p>我们正在使用代理来透明地向对象添加行为。也许用安全规则装饰对象（管理员可以访问它，而普通用户不能），或者这是因为我们要启用延迟加载，仅在首次访问时从数据库加载数据。另一个原因是为我们的对象启用透明的事务管理。</p>
<h3>交易管理</h3><p>让我们看一下事务管理示例。下面的顺序图粗略地描述了（简化的视图）在调用服务的情况下发生的情况，在该服务中，先启动事务，然后成功完成事务，然后再提交事务。</p><p><img id="image211" src="http://blog.interface21.com/main/wp-content/uploads/2007/07/seq.jpg" alt="seq.jpg"></p><p>现在，服务本身的调用肯定会涉及一定的开销（我们之前已经讨论过的开销）。但是，问题是，我们可以从中得到什么呢？</p>
<h3>实现的利益</h3><p>如果继续看上面的例子，我们已经意识到了很多好处。</p><p><b>简化代码</b><br>通过在两者之间放置一个代理，我们大大简化了代码。如果我们使用Spring提供的@Transactional批注，则我们需要做的是：</p>
<pre><code class="prettyprint java"><br />public class Service {

  @Transactional 
  public void executeService() { }

}
</code></pre><p>和</p>
<pre><code class="prettyprint xml"><br />&lt;tx:annotation-driven/&gt;

&lt;bean class=&quot;com.mycompany.Service&quot;/&gt;
</code></pre><p>另一种（编程）方法将涉及显着修改客户端（调用方）或服务类本身。</p><p><b>集中交易管理</b><br>现在，中央管理机构负责事务管理，从而可以进行更多优化，并采用非常一致的方法进行事务管理。如果我们已经在服务或调用者本身中实现了事务管理代码，这将是不可能的。</p>
<h3>到底有什么关系？</h3><p>如果那还不够，我们总是可以开始查看从代理机制获得的实际性能下降，并将其与启动和/或提交事务所需的实际时间进行比较。我没有任何可用的数字，但是可以向您保证，在JDBC事务上提交事务肯定要花费491纳秒以上的时间。</p>
<h3>但是，如果代理执行的是非常细粒度的操作，该怎么办</h3><p>啊！那是一个完全不同的故事。当然，您可以透明地添加不同种类的行为（使用代理或使用字节码编织方法）。我通常区分细粒度和粗粒度行为。我认为粗粒度的行为是在服务级别应用的，或者仅应用于我们应用程序中的某些特定操作集。例如，一套更细粒度的行为包括对系统中每种方法的记录。对于这种细粒度的方法，我绝对不会选择使用基于代理的方法。</p>
<h3>经验法则</h3><p>最后我们可以说以下几点：</p>
<ul>
<li>首先，代理会增加开销，并且如果应用于代理对象的行为与长时间运行的操作（例如数据库或文件访问或事务管理）有关，则此开销可以忽略不计。</li>
<li>我们也可以说，如果您需要非常细粒度的行为并将其应用于大量对象，那么使用字节码编织方法（例如AspectJ）可能更安全。</li>
<li>如果这还不够的话，也许仍然可以肯定地说代理（除非应用于系统中的数千个或更多对象）永远不会是您在性能下降的系统中寻找的第一位。</li>
<li>另一个经验法则可能是系统中的任何请求都不应涉及（调用）超过10个（或大约）代理方法。 <b>10个代理操作*每个代理操作500 ns = 5微秒</b> （我可以说仍然可以忽略不计），但是<b>100,000个代理操作*每个代理操作500 ns = 50毫秒</b> （在我看来，这已经可以忽略不计）。</li>
</ul>
<h2>不同类型的代理</h2><p>除了讨论代理是否完全增加开销之外，简短讨论不同类型的代理也很重要。有几种不同类型的代理。在我的小型基准测试中，我使用了JDK动态代理基础结构（来自java.lang.reflect包），该基础结构只能为接口创建代理。另一个代理机制是CGLIB，它使用稍微不同的代理方法。上一次我在两者之间做一个小的性能基准测试时，我并没有发现明显的区别，坦率地说，我不在乎。重要的是已创建的代理的内部工作方式。如果您自己开始实施代理，那么很多事情都会出错。例如，如果比较下面的两段代码，您可能不会期望两者之间的性能存在<b>巨大</b>差异。当我说巨大的时候，我说的是大约10倍...</p>
<pre><code class="prettyprint java"><br />public Object invoke(Object proxy, Method proxyMethod, Object[] args)
throws Throwable {
	Method targetMethod = null;
	if (!cachedMethodMap.containsKey(proxyMethod)) {
		targetMethod = target.getClass().getMethod(proxyMethod.getName(), 
			proxyMethod.getParameterTypes());
		cachedMethodMap.put(proxyMethod, targetMethod);
	} else {
		targetMethod = cachedMethodMap.get(proxyMethod);
	}
	Ojbect retVal = targetMethod.invoke(target, args);
	return retVal;
}
</code></pre>
<pre><code class="prettyprint java"><br />public Object invoke(Object proxy, Method proxyMethod, Object[] args)
throws Throwable {
	Method targetMethod = target.getClass().getMethod(proxyMethod.getName(), 
			proxyMethod.getParameterTypes());
	Ojbect retVal = targetMethod.invoke(target, args);
	return retVal;
}
</code></pre><p>换句话说，不要为知道他们在做什么的人或框架生成或创建代理。幸运的是，我没有参与代理设计，Rob，Juergen，Rod等也没有参与。等比我好得多，所以在那里不用担心；-)。</p>
<h2>字节码编织呢</h2><p>通常，可以说字节码编织方法需要花费更多时间才能根据您的环境进行设置。在某些情况下，您需要设置Java代理，在其他情况下，可能需要修改编译过程，其他框架可能需要使用其他类加载器。换句话说，字节码编织很难设置。以我的经验，（一如既往）80-20规则也适用于此。使用基于代理的系统可以解决所有需求的80％。对于最后一英里或剩余的20％，选择字节码编织方法可能是一个不错的选择。</p>
<h2>与AOP的关系</h2><p>您可能想知道为什么我还没有涉及AOP的问题。代理和字节码编织与AOP有很强的关系。也许那是另一回事。无论如何，Spring的AOP框架都<i>使用</i>代理来实现其功能。在我看来，代理只是一个实现细节（尽管很重要），通常与AOP和Spring紧密相关。</p>
<h2>结论</h2><p>最后，我们可以说代理确实会增加对其代理对象的调用的开销，但是在大多数情况下，关于此的讨论并不重要。造成这种情况的部分原因在于代理带来的巨大好处（例如，由于代码简化和集中控制而导致更好地维护我们的代码），以及事实上，我们使用代理所做的事情（例如事务管理或缓存）通常具有代理机制本身对性能的影响更大。</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 100;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>