<html  data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>存根和模拟的单元测试</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Unit Testing with Stubs and Mocks">
<meta name="twitter:description" >
<meta name="twitter:creator" content="@david_syer">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=200">

<meta property="og:title" content="Unit Testing with Stubs and Mocks">
<meta property="og:image" content="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=200">
<meta property="og:description" >
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2007-01-15 10:51:00.0">
</head>
<body >

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">存根和模拟的单元测试</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=20&d=mm"> <a class="author" rel="author" href="/team/dsyer">戴夫·瑟</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2007-01-15 10:51:00.0">2007年1月15日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2007/01/15/unit-testing-with-stubs-and-mocks#disqus_thread" data-disqus-identifier="46">
</a></div>
</div>
</header>
<div class="blog--post"><p>前几天，我和一些客户在现场，他们问我有关单元测试和模拟对象的问题。我决定写一些我们作为单元测试创建依赖关系（协作者）的教程的讨论。我们讨论了存根对象和模拟对象这两个选项，并给出了一些简单的示例来说明其用法以及两种方法的优缺点。</p><p>在单元测试中，通常会模拟或残存被测试类的协作者，因此测试独立于协作者的实现。能够精确控制测试所使用的测试数据，并验证设备是否按预期运行，也是一件有用的事情。</p>
<h2>存根</h2><p>存根方法易于使用，并且不涉及单元测试的任何额外依赖项。基本技术是将协作者实现为具体的类，这些类仅展示被测试类所需的协作者总体行为的一小部分。作为示例，请考虑测试服务实现的情况。该实现有一个合作者：</p>
<pre><code class="prettyprint java"><br />public class SimpleService implements Service {

    private Collaborator collaborator;
    public void setCollaborator(Collaborator collaborator) {
        this.collaborator = collaborator;
    }

    // part of Service interface
    public boolean isActive() {
        return collaborator.isActive();
    }
}
</code></pre><p>为了测试isActive的实现，我们可以进行如下的单元测试：</p>
<pre><code class="prettyprint java"><br />public void testActiveWhenCollaboratorIsActive() throws Exception {

    Service service = new SimpleService();
    service.setCollaborator(new StubCollaborator());
    assertTrue(service.isActive());

}

...

class StubCollaborator implements Collaborator {
    public boolean isActive() {
        return true;
    }
}
</code></pre><p>存根协作者所做的只是返回测试所需的值。</p><p>通常将这样的存根作为匿名内部类以内联方式实现，例如</p>
<pre><code class="prettyprint java"><br />public void testActiveWhenCollaboratorIsActive() throws Exception {

    Service service = new SimpleService();
    service.setCollaborator(new Collaborator() {
        public boolean isActive() {
           return true;
        }
    });
    assertTrue(service.isActive());

}
</code></pre><p>这为我们节省了将存根类作为单独的声明维护的大量时间，还有助于避免存根实现的常见陷阱：在单元测试中重用存根，以及项目中具体存根数量的爆炸式增长。</p><p>这幅画怎么了？好吧，像这样的服务中的协作者接口常常不像这个简单的例子那么简单，并且要实现内联存根，需要数十行未使用的方法的空声明。此外，如果协作者界面发生更改（例如，添加了方法），我们必须在所有测试用例中手动更改所有内联存根实现，这可能需要大量工作。</p><p>为了解决这两个问题，我们从基类开始，而不是为每个测试用例重新实现接口，我们扩展了基类。如果接口更改，我们只需要更改基类。通常，基类将存储在我们项目的单元测试目录中，而不是生产目录或主源目录中。</p><p>例如，这是所定义的接口的合适基类：</p>
<pre><code class="prettyprint java"><br />public class StubCollaboratorAdapter implements Collaborator {
   public boolean isActive() {
       return false;
   }
}
</code></pre><p>这是新的测试用例：</p>
<pre><code class="prettyprint java"><br />public void testActiveWhenCollaboratorIsActive() throws Exception {

    Service service = new SimpleService();
    service.setCollaborator(new StubCollaboratorAdapter() {
        public boolean isActive() {
           return true;
        }
    });
    assertTrue(service.isActive());

}
</code></pre><p>现在，测试用例与协作者界面的更改（不影响isActive方法）之间保持隔离。实际上，使用IDE，它也可以与确实影响isActive方法的接口中的某些更改隔离开来-例如，在所有测试用例中，IDE都可以自动进行名称或签名更改。</p><p>内联存根方法非常有用且易于实现，但是可以更好地控制测试用例，并确保如果服务对象的实现发生变化，那么测试用例也会相应地发生变化，那么模拟对象方法会更好。</p>
<h2>模拟对象</h2><p>使用模拟对象（例如来自<a href="http://www.easymock.org">EasyMock</a>或<a href="http://www.jmock.org">JMock</a> ），可以对测试被测单元实现的内部进行高度控制。</p><p>为了在实践中看到这一点，请考虑将上面的示例重写为使用EasyMock。首先，我们看一下EasyMock 1（即不利用EasyMock 2中的Java 5扩展）。测试用例如下所示：</p>
<pre><code class="prettyprint java"><br />MockControl control = MockControl.createControl(Collaborator.class);
Collaborator collaborator = (Collaborator) control.getMock();
control.expectAndReturn(collaborator.isActive(), true);
control.replay();

service.setCollaborator(collaborator);
assertTrue(service.isActive());

control.verify();
</code></pre><p>如果实现更改为以其他方式使用协作者，则单元测试将立即失败，并向开发人员发送信号，告知其需要重新编写。假设服务的内部更改为完全不使用协作者：</p>
<pre><code class="prettyprint java"><br />public class SimpleService implements Service {

    ...

    public boolean isActive() {
        return calculateActive();
    }

}
</code></pre><p>上面使用EasyMock的测试将失败，并显示一条明显的消息，提示未执行对协作者的预期方法调用。在存根实现中，测试可能会失败，也可能不会失败：如果失败，错误消息将是神秘的；如果没有，那只会是偶然的。</p><p>为了修复失败的测试，我们必须对其进行修改以反映服务的内部实现。不断地重做测试用例以反映实现内部的情况被某些人视为负担，但实际上，必须这样做是单元测试的本质。我们正在测试单元的实施，而不是与系统其余部分的合同。为了测试合同，我们将使用集成测试，并将服务视为由其接口而不是其实现定义的黑盒。</p>
<h2>EasyMock 2</h2><p>请注意，如果我们使用Java 5和EasyMock 2，则可以简化上述测试用例的实现：</p>
<pre><code class="prettyprint java"><br />Collaborator collaborator = EasyMock.createMock(Collaborator.class);
EasyMock.expect(collaborator.isActive()).andReturn(true);
EasyMock.replay(collaborator);

service.setCollaborator(collaborator);
assertTrue(service.isActive());

EasyMock.verify(collaborator);
</code></pre><p>在新的测试案例中，不需要MockControl。如果只有一个协作者（如此处），这没什么大不了的，但是如果有很多协作者，那么测试用例的编写和读取就变得非常容易。</p>
<h2>何时使用存根和模拟？</h2><p>如果模拟对象更好，为什么我们还要使用存根？这个问题很可能使我们进入宗教辩论的领域，我们现在将避免这样做。因此，简单的答案是：“做适合您的测试用例的工作，并创建最简单的代码来读取和维护”。如果使用存根进行的测试可以快速读写，并且您不太担心对协作者的更改或对测试单元内部使用协作者的担心，那就很好。如果协作者不受您的控制（例如，来自第三方库），则通常情况下，存根更难编写。</p><p>存根比模拟更易于实现（和读取）的一种常见情况是，被测单元需要在协作者上使用嵌套的方法调用。例如，考虑一下如果我们更改服务会发生什么，因此它不再直接使用协作者的isActive，而是将调用嵌套到另一个协作者（属于另一个类，例如Task）：</p>
<pre><code class="prettyprint java"><br />public class SimpleService implements Service {

    public boolean isActive() {
        return !collaborator.getTask().isActive();
    }

}
</code></pre><p>要在EasyMock 2中使用模拟对象对此进行测试：</p>
<pre><code class="prettyprint java"><br />Collaborator collaborator = EasyMock.createMock(Collaborator.class);
Task task = EasyMock.createMock(Task.class);

EasyMock.expect(collaborator.getTask()).andReturn(task);
EasyMock.expect(task.isActive()).andReturn(true);
EasyMock.replay(collaborator, task);

service.setCollaborator(collaborator);
assertTrue(service.isActive());

EasyMock.verify(collaborator, task);
</code></pre><p>相同测试的存根实现将是</p>
<pre><code class="prettyprint java"><br />Service service = new SimpleService();
service.setCollaborator(new StubCollaboratorAdapter() {
    public Task getTask() {
        return (new StubTaskAdapter() {
            public boolean isActive() {
                return true;
            }
        }
    }
});
assertTrue(service.isActive());
</code></pre><p>就长度而言，没有什么可区分两者（忽略适配器基类中的代码，我们可以在其他测试中重复使用）。模拟版本更健壮（出于上述原因），因此我们更喜欢它。但是，如果由于无法使用Java 5而不得不使用EasyMock 1，则情况可能会有所不同：实现模拟版本会更加难看。这里是：</p>
<pre><code class="prettyprint java"><br />MockControl controlCollaborator = MockControl.createControl(Collaborator.class);
Collaborator collaborator = (Collaborator) controlCollaborator.getMock();

MockControl controlTask = MockControl.createControl(Task.class);
Task task = (Task) controlTask.getMock();

controlCollaborator.expectAndReturn(collaborator.getTask(), task);
controlTask.expectAndReturn(task.isActive(), true);

controlTask.replay();
controlCollaborator.replay();

service.setCollaborator(collaborator);
assertTrue(service.isActive());

controlCollaborator.verify();
controlTask.verify();
</code></pre><p>测试时间又延长了一半，因此相应地更难以阅读和维护。在现实中事情很容易变得更糟。在这种情况下，为了方便生活，我们可能会考虑使用存根实现。当然，模拟对象的真正信奉者会指出，这是一种错误的经济做法，从长期来看，单元测试将比使用存根的测试更健壮和更好。</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 46;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>