<html  data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>使用AJAX和Spring集成进行Java到JavaScript的编译</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Java to JavaScript Compilation with AJAX and Spring Integration">
<meta name="twitter:description" >
<meta property="og:title" content="Java to JavaScript Compilation with AJAX and Spring Integration">
<meta property="og:description" >
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2007-01-22 03:47:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">使用AJAX和Spring集成进行Java到JavaScript的编译</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="null?s=20&d=mm"> <span class="author">本·亚历克斯</span>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2007-01-22 03:47:00.0">2007年1月22日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2007/01/22/java-to-javascript-compilation-with-ajax-and-spring-integration#disqus_thread" data-disqus-identifier="49">
</a></div>
</div>
</header>
<div class="blog--post"><p>一段时间以来，我一直对以客户端为中心的基于Web的用户界面感兴趣。这些第四代框架的特征在于它们基于组件的，事件驱动的编程模型，并且专注于完全驻留在客户端上的表示逻辑。以这种方式定位Web浏览器通常需要使用<a href="https://en.wikipedia.org/wiki/JavaScript">JavaScript</a>或<a href="https://en.wikipedia.org/wiki/Adobe_Flash">Flash</a> ，这本身就带来了许多独特的挑战。</p><p>如果我们可以使用Java编程并自动生成JavaScript或Flash运行时模块，则有可能解决许多挑战。今天实现这一目标的两个著名产品分别是<a href="https://code.google.com/webtoolkit/">Google Web Toolkit</a> （GWT）和<a href="http://www.openlaszlo.org/">Open Laszlo</a> 。两者都可以通过<a href="http://www.opensource.org/licenses/">OSI批准的许可证获得，</a>并且拥有活跃的社区以及它们自己独特的复杂性。一个考虑因素是它们在多大程度上实现了提供针对Web浏览器部署的基于Java的透明开发环境的目标。此注意事项有多个方面，包括IDE支持，调试集成，反射功能，运行时窗口小部件绑定等。当使用传统的Java技术（例如<a href="http://java.sun.com/javase/technologies/desktop/">Swing</a>和<a href="https://www.eclipse.org/swt/">Standard Widget Toolkit</a> （SWT））开发富客户端时，所有这些都是正常的考虑因素。</p><p>此博客条目的目的不是批评GWT或Open Laszlo。相反，我想探索一个名为<a href="http://j2s.sourceforge.net/">Java2Script Pacemaker</a> （J2S）的开源Java到JavaScript编译器，并提出初始的<a href="http://www.springframework.org/">Spring</a>集成。这个有趣的项目尚未广为人知，但仍以令人鼓舞的方式解决了透明Java到JavaScript开发的问题。J2S附带一个增量编译器，实际上完整的Java版本的java.lang，java.io和java.util软件包，JavaScript版本的Junit，Eclipse SWT JavaScript实现以及AJAX库。更重要的是，J2S可以将任何现有的Java代码转换为JavaScript，但要视源代码的可用性和依赖关系而定，它们也同样会转换为JavaScript。</p><p>着眼于技术方面的考虑，J2S当前以几种广泛的方式与GWT区别开来。首先是其编译器技术，该技术基于Eclipse <a href="https://www.eclipse.org/articles/Article-JavaCodeManipulation_AST/index.html">抽象语法树</a> （AST）构建，因此需要<a href="https://www.eclipse.org/">Eclipse</a> 。但是， <a href="https://www.eclipse.org/jdt/core/index.php">Eclipse JDT Core</a>支持无头模式，因此从<a href="https://ant.apache.org/">Ant</a>插件或<a href="https://maven.apache.org/">Maven</a> mojo执行J2S编译并不困难。第二个区别是J2S提供了全面的运行时反射和窗口小部件绑定功能。GWT首选编译时JavaScript优化，但要牺牲这些运行时服务。另一方面，J2S认识到， <a href="https://en.wikipedia.org/wiki/Moore's_law">摩尔定律</a> ，改进的浏览器JavaScript解释器和类似<a href="http://java.sun.com/j2se/1.4.2/docs/guide/jni/">JNI</a>的JavaScript优化相结合，共同提供了足够的性能，同时仍然享受更全面的JRE仿真和其他运行时服务。</p><p>最大的技术差异也许与用户界面方法有关。GWT提供了自己的类似Swing的API，旨在用于Web浏览器集成。另一方面，J2S旨在提供SWT的实现。 J2S的方法有很多好处：<br></p><ul><br> <li>您的应用程序可以定位富客户端（在JVM中）和Web UI（在Web浏览器中），而几乎不需要重新编码。</li><br> <li>开发和调试J2S应用程序与开发和调试普通的SWT应用程序基本相同，这大大减少了新开发人员的学习难度。</li><br> <li>组织有很好的机会吸引具有SWT技能的人员；</li><br> <li>SWT有大量<a href="https://www.eclipse.org/swt/docs.php">文献</a>和<a href="https://www.eclipse.org/swt/community.php">社区</a> <a href="https://www.eclipse.org/swt/examples.php">资源</a> ；</li><br> <li>SWT是稳定且经过生产验证的API；和</li><br> <li><a href="https://www.eclipse.org/vep/WebContent/main.php">开源</a>和<a href="http://www.swt-designer.com/">商业</a>工具都可用来帮助您构建SWT应用程序。</li><br></ul><br>但是，J2S确实有一些限制要考虑。这些包括：<br><ul><br> <li>互联网上的下载速度可能很慢。鉴于大多数JEE应用程序都用于Intranet部署，因此我不确定这是否会成为主要障碍。此外，JavaScript压缩和客户端缓存可最大程度地减少这些延迟。</li><br> <li>执行速度可能会很慢，尽管下载代码后我还没有发现它太糟糕。有各种优化措施可以提高速度。高级用户还可以选择下载由JVM托管的SWT版本的用户界面，由于共享的SWT代码库，这应该带来有限的额外开发成本。</li><br> <li>当前不支持<a href="https://wiki.eclipse.org/index.php/JFace">JFace</a> ，并且不模拟完整的JRE。一个明显的例外是<a href="http://java.sun.com/j2se/1.4.2/docs/api/java/io/File.html">java.io。文件</a> 。如果您依赖于此类，则您的应用程序将无法原生编译为JavaScript。相反，您需要使用J2S的<a href="http://j2s.sourceforge.net/articles/tutorial-advanced-programming-on-j2s.html#j2snative">@ j2sNative</a>功能将相关类编译为JavaScript。我还遇到了SWT实施中的几个小问题，但没有什么太严重的。</li><br> <li>J2S <a href="https://groups.google.com/group/java2script/topics">社区</a>相对较小，迄今为止，该框架尚未得到广泛使用。尽管如此，每个开源项目都从小规模开始，需要给其发展的机会。</li><br> <li>Eclipse以外的IDE的用户将无法使用其当前形式的J2S。如前所述，AST编译模型允许Eclipse JDT无头支持，因此这不是主要问题。</li><br></ul><br>可以理解的是，Spring社区也有兴趣知道“它是否与Spring兼容？”。答案确实取决于您要实现的目标。如果您打算构建标准的SWT或Swing应用程序，则通常会在用户界面层中使用这些技术来访问远程服务层。因此，您的主要Spring集成问题涉及合适的远程处理机制的可用性。Spring为Java到Java远程提供了经过验证的<a href="http://www.springframework.org/docs/reference/remoting.html">基础结构</a>的广泛选择，大多数项目都选择同步<a href="http://www.springframework.org/docs/api/org/springframework/remoting/httpinvoker/package-summary.html">HttpInvoker</a> ， <a href="http://java.sun.com/javase/technologies/core/basic/rmi/index.jsp">RMI</a>或<a href="https://www.w3.org/TR/soap/">SOAP</a> 。<p></p><p>通过生成基于JavaScript的客户端，J2S显然需要某种形式的Java到JavaScript远程处理。Java到JavaScript的远程处理实现通常采用异步方法，这意味着在远程处理调用之后立即继续执行，并且有单独的回调来处理接收到的调用结果。Java到JavaScript远程处理的两种主要方法是<a href="https://dwr.dev.java.net/">DWR</a>和<a href="http://oss.metaparadigm.com/jsonrpc/">JSON-RPC</a> ，尽管GWT和J2S都提供了自己的独立远程处理方法。GWT和J2S都没有提供现成的Spring集成，尽管Spring的灵活体系结构使其非常容易实现（如下面的J2S所示）。</p><p>在介绍Spring实现之前，让我们回顾一下J2S AJAX远程协议的工作方式。J2S为每个潜在的远程调用采用准<a href="https://en.wikipedia.org/wiki/Command_pattern">命令模式</a> 。SimpleRPCRunnable超类提供JavaScript到Java和Java到JavaScript的序列化，其子类指示远程URL，要序列化的字段和要远程执行的逻辑：</p>
<pre><code class="prettyprint java"><br />public class LZ77JSSimpleRPCRunnable extends SimpleRPCRunnable {

private transient SomeServicesLayer servicesLayer; // setter omitted
public String jsContent;
public String result;

public String getHttpURL() {
return &quot;http://localhost:8080/echotest/simplerpc&quot;;
}

public void ajaxRun() {
result = servicesLayer.computeTheAnswer(jsContent);
jsContent = null;
}
}
</code></pre><p>字段声明很重要。每个公共非临时字段都将由SimpleRPCRunnable序列化。getHttpURL（）指定J2S servlet的URL。相同的URL可以用于任何J2S命令，从而使其成为应用程序的J2S前端控制器。ajaxRun（）方法包含将在服务器端执行的逻辑。在这种情况下，我们的ajaxRun（）方法将访问本地（服务器端）Spring bean。请注意，servicesLayer字段被声明为临时字段，这意味着SimpleRPCRunnable将不会对其进行序列化。相反，Spring IoC容器将依赖关系将SomeServicesLayer实例注入到我们的服务器端命令对象中。因此，在J2S客户端上，servicesLayer始终为null。为了使客户端异步调用命令，他们将使用如下代码：</p>
<pre><code class="prettyprint java"><br />SimpleRPCSWTRequest.swtRequest(new LZ77JSSimpleRPCRunnable() {

public void ajaxIn() {
jsContent = sourceText.getText();
}

public void ajaxOut() {
resultText.setText(result);
}
});
</code></pre><p>如图所示，ajaxIn（）方法用于在客户端将公共字段设置为可接受的值。ajaxOut（）方法是异步回调处理程序，这意味着一旦命令对象从服务器返回并反序列化，就将执行该方法。在这种情况下，该命令将更新UI小部件。下面的屏幕快照显示了将命令作为JVM托管的SWT应用程序执行的结果：<br></p><div style="text-align:center"><img id="image119" alt="图1" src="http://blog.interface21.com/main/wp-content/uploads/2007/01/figure1.png"></div><br>下一个屏幕截图显示了与Firefox托管的SWT应用程序执行相同命令的结果。在这些运行时目标之间进行更改无需任何代码或远程配置，从而说明了J2S方法的灵活性和吸引力：<br><div style="text-align:center"><img alt="图2" id="image121" src="http://blog.interface21.com/main/wp-content/uploads/2007/01/figure2.png"></div><br>SimpleRPCSWTRequest还提供了两种静态方法来声明调用是否实际上应该在网络上发生。SimpleRPCSWTRequest.switchToLocalJavaThreadMode（）将导致ajaxRun（）方法在本地被调用，如果您在JVM托管的SWT应用程序中运行，这可能是合适的。要使调用通过网络进行序列化（从而使ajaxRun（）在服务器上执行），只需调用SimpleRPCSWTRequest.switchToAJAXMode（）。此模式与浏览器和JVM目标平台都兼容，因此使用J2S来构建多目标用户界面并不需要为JVM目标使用其他远程协议（例如HttpInvoker或RMI）。<p></p><p>在服务器端，我们没有使用普通的J2S SimpleRPCHttpServlet。取而代之的是，我们使用了一个称为SpringRpcHttpServlet的新类（可作为<a title="j2s-spring-integration" id="p122" href="http://blog.interface21.com/main/wp-content/uploads/2007/01/j2s-spring-integration.zip">ZIP附件</a> ，以及此博客文章中引用的其余代码）。SpringRpcHttpServlet的操作与普通SimpleRPCHttpServlet相同，只是它从Spring应用程序上下文中获取服务器端命令对象。该代码已被很好地记录，因此，如果您有兴趣了解它的详细工作原理，请查看ZIP附件。本质上，它允许您在Spring应用程序上下文文件中定义命令及其依赖关系。</p><p>如果您的应用程序需要其他命令，只需创建一个SimpleRPCRunnable子类，然后将其添加到您的应用程序上下文中即可。从事我的ROO工作的人可能有兴趣听到我打算提供J2S远程集成，从而使您无需编写命令对象或通过SimpleRPCSWTRequest进行调用。</p><p>总之，对于需要JavaScript编译或SWT的Web浏览器实现的项目，J2S有望带来一些吸引人的好处。它还可以与Spring后端成功互操作。J2S精心选择利用AST和SWT等经过验证的现有技术，这使其成为重用现有代码和开发人员技能的一个很好的例子，从而降低了采用障碍和实质性API更改的前景。如果您认为自己是SWT的早期采用者，或者需要以成熟的SWT UI框架为基础的以客户端为中心，基于Web的用户界面，那么绝对值得仔细研究一下J2S。</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 49;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>