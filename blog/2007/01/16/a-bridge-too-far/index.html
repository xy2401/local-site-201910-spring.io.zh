<html dir="ltr" data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>一座桥太远</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>System.config({baseURL: "/b92013b"});</script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>System.import('app/main.js')</script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="A Bridge Too Far">
<meta name="twitter:description" content="<p>In my <a href=" http:="" ="" blog.interface21.com="" main="" 2006="" 09="" 29="" exploiting-generics-metadata="" ="="></meta>last entry I presented a technique for creating strategy classes that take full advantage of any generic metadata that is present in your application. At the end of that entry I showed this code snippet:
<pre><code class=" prettyprint java"></head><body dir="ltr">EntitlementCalculator calculator = new DividendEntitlementCalculator();
calculator.calculateEntitlement(new MergerCorporateActionEvent());

<p>You'll remember that <tt>DividendEntitlementCalculator</tt> was defined as:</p>
<pre><code class="prettyprint java">public class DividendEntitlementCalculator implements EntitlementCalculator<DividendCorporateActionEvent> {

    public void calculateEntitlement(DividendCorporateActionEvent event) {

    }
}
</code></pre>
">

<meta property="og:title" content="A Bridge Too Far">
<meta property="og:description" content="<p>In my <a href=" http:="" ="" blog.interface21.com="" main="" 2006="" 09="" 29="" exploiting-generics-metadata="" ="="></meta>last entry I presented a technique for creating strategy classes that take full advantage of any generic metadata that is present in your application. At the end of that entry I showed this code snippet:
<pre><code class=" prettyprint java">EntitlementCalculator calculator = new DividendEntitlementCalculator();
calculator.calculateEntitlement(new MergerCorporateActionEvent());

<p>You'll remember that <tt>DividendEntitlementCalculator</tt> was defined as:</p>
<pre><code class="prettyprint java">public class DividendEntitlementCalculator implements EntitlementCalculator<DividendCorporateActionEvent> {

    public void calculateEntitlement(DividendCorporateActionEvent event) {

    }
}
</code></pre>
">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2007-01-16 22:19:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">// Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }</script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">一座桥太远</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="null?s=20&d=mm"> <span class="author">罗伯·哈罗普</span>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2007-01-16 22:19:00.0">2007年1月16日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2007/01/16/a-bridge-too-far#disqus_thread" data-disqus-identifier="47">
</a></div>
</div>
</header>
<div class="blog--post"><p>在<a href="http://blog.interface21.com/main/2006/09/29/exploiting-generics-metadata/">上一篇文章中，</a>我介绍了一种创建策略类的技术，该类可以充分利用应用程序中存在的任何通用元数据。在该条目的结尾，我显示了以下代码片段：</p>
<pre><code class="prettyprint java">EntitlementCalculator calculator = new DividendEntitlementCalculator();
calculator.calculateEntitlement(new MergerCorporateActionEvent());
</code></pre>
<p>您会记得<tt>DividendEntitlementCalculator</tt>定义为：</p>
<pre><code class="prettyprint java">public class DividendEntitlementCalculator implements EntitlementCalculator<DividendCorporateActionEvent> {

    public void calculateEntitlement(DividendCorporateActionEvent event) {

    }
}
</code></pre>
<p>因此，将<tt>MergerCorporateActionEvent</tt>的实例<tt>传递</tt>到<tt>DividendEntitlementCalculator</tt>类的<tt>calculateEntitlement</tt>方法中是不正确的。但是，正如我在上一篇文章中提到的那样，该代码将进行编译。为什么？好吧， <tt>EntitlementCalculator.calculateEntitlement（）</tt>被定义为接受扩展<tt>CorporateActionEvent的</tt>任何类型，因此<em>应进行</em>编译。那么在这种情况下，在运行时会发生什么，Java如何执行类型安全？好吧，正如您可能想象的那样，运行此代码将给您<tt>ClassCastException</tt> ，表明您无法将<tt>MergerCorporateActionEvent强制转换</tt>为<tt>DividendCoporateActionEvent</tt> 。这样，Java可以为您的应用程序强制执行类型安全-不可能将<tt>MergerCorporateActionEvent</tt>爬入期望<tt>DividendCorporateActionEvent</tt>的方法中。</p>
<p>真正的问题是：“ <tt>ClassCastException</tt>来自何处？答案很简单-Java编译器通过引入<em>桥方法</em>来添加代码以创建并适当地抛出它。桥方法是编译器将生成并添加到您的类中的综合方法，以确保面对泛型类型时的类型安全。</p>
<p>在上面显示的情况下，可以使用与<tt>CorporateActionEvent</tt>类型兼容的任何对象来调用<tt>EntitlementCalculator.calculateEntitlement</tt> 。但是， <tt>DividendEntitlementCalculator</tt>仅接受与<tt>DividendCorporateActionEvent</tt>类型兼容的对象， <em>但是</em> ，由于您可以通过<tt>EntitlementCalculator</tt>接口调用<tt>DividendEntitlementCalculator</tt> ，因此它也必须接受<tt>CorporateActionEvent</tt> 。那么，在已编译的类文件中，这意味着什么？我们有用户提供的方法：</p>
<pre><code class="prettyprint java">public void calculateEntitlement(DividendCorporateActionEvent event) {
    System.out.println(event);
}
</code></pre>
<p>转换为以下字节码：</p>
<pre><code class="prettyprint java">public void calculateEntitlement(bigbank.DividendCorporateActionEvent);
  Code:
   Stack=2, Locals=2, Args_size=2
   0:   getstatic       #2; //Field java/lang/System.out:Ljava/io/PrintStream;
   3:   aload_1
   4:   invokevirtual   #3; //Method java/io/PrintStream.println:(Ljava/lang/Object;)V
   7:   return
</code></pre>
<p>但是我们还有一个编译器生成的方法：</p>
<pre><code class="prettyprint java">public void calculateEntitlement(bigbank.CorporateActionEvent);
  Code:
   Stack=2, Locals=2, Args_size=2
   0:   aload_0
   1:   aload_1
   2:   checkcast       #4; //class bigbank/DividendCorporateActionEvent
   5:   invokevirtual   #5; //Method calculateEntitlement:(Lbigbank/DividendCorporateActionEvent;)V
   8:   return
</code></pre>
<p>转换为以下Java代码：</p>
<pre><code class="prettyprint java">public void calculateEntitlement(CorporateActionEvent event) {
    calculateEntitlement((DividendCorporateActionEvent)event);
}
</code></pre>
<p>因此，在这里您可以清楚地看到传入除<tt>DividendCorporateActionEvents</tt>之外的<tt>CorporateActionEvents</tt>时， <tt>ClassCastException</tt>来自何处-编译器生成的<em>bridge方法</em> 。</p>
<p>现在，这当然是一个出色的功能。我们不想在Java语言中添加泛型来破坏我们已经使用了很长时间的类型安全性。但是，正如这些事情所预期的那样，一切都不顺利。在当前JDK中实现的桥方法的主要问题是注释不会从桥方法复制到桥方法上。当您无意中掌握了bridge方法并尝试解析一些注释时，这将引起各种问题。</p>
<p>你们中有些人可能想知道如何错误地掌握桥接方法。这有点复杂。一个常见的原因（我们在Spring看到的最多）是在其中创建委托给某个对象的JDK代理，并尝试将方法从代理接口映射到委托上的相应实现方法（通常是解析注释） ）。考虑以下代码：</p>
<pre><code class="prettyprint java">public static void main(String[] args) {
    EntitlementCalculator ec = createProxy(new DividendEntitlementCalculator());
    ec.calculateEntitlement(null);
}

private static EntitlementCalculator createProxy(EntitlementCalculator calculator) {
    InvocationHandler handler = new TransactionLoggingInvocationHandler(calculator);
    return (EntitlementCalculator) Proxy.newProxyInstance(calculator.getClass().getClassLoader(),
                                                                calculator.getClass().getInterfaces(), handler);
}

private static class TransactionLoggingInvocationHandler implements InvocationHandler {

    private final EntitlementCalculator delegate;

    public TransactionLoggingInvocationHandler(EntitlementCalculator delegate) {
        this.delegate = delegate;
    }

    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Method delegateMethod = delegate.getClass().getMethod(method.getName(), method.getParameterTypes());
        Transactional annotation = delegateMethod.getAnnotation(Transactional.class);
        if(annotation != null) {
            System.out.println("Executing transactional method: " + delegateMethod);
        } else {
            System.out.println("Executing non-transactional method: " + delegateMethod);
        }
        return method.invoke(delegate, args);
    }
}
</code></pre>
<p>在这里，我们为给定的<tt>EntitlementCalculator</tt>对象创建一个代理，该代理将记录代理对象上的方法是否是事务性的。如果我们按如下所示注释<tt>DividendEntitlementCalculator</tt>类，则可以期望代理记录从<tt>main</tt>调用<tt>calculateEntitlement</tt>时正在执行事务方法的日志。</p>
<pre><code class="prettyprint java">@Transactional
public void calculateEntitlement(DividendCorporateActionEvent event) {
    System.out.println(event);
}
</code></pre>
<p>但是，执行上面的示例将导致以下结果：</p>
<pre><code class="prettyprint java">Executing non-transactional method: public volatile void bigbank.DividendEntitlementCalculator.calculateEntitlement(bigbank.CorporateActionEvent)
</code></pre>
<p>请注意，这与我们正在调用的<tt>DividendEntitlementCalculator</tt>上的方法不对应。当然，显然是这样。这里要说的是，接口方法和委托方法的签名<em>是</em>不同的。一个是根据父类型（在此情况下为<tt>CorporateActionEvent</tt> ）定义的，另一个是根据子类型（在此情况下为<tt>DividendCorporateActionEvent）定义的</tt> 。您还将注意到，实际上我们已经获得了桥方法-因为它的签名<em>确实</em>与接口方法的签名匹配（根据定义）。</p>
<p>查找委托方法的更好解决方案是使用传入参数的类型，而不是接口方法的类型。当面对使用继承的参数时，您可以简单地搜索与参数的类型层次匹配的类型。不幸的是，这种方法无法可靠地工作。考虑具有以下接口的情况：</p>
<pre><code class="prettyprint java">public interface Foo<T> {
    void bar(T t);
}
</code></pre>
<p>然后这个实现：</p>
<pre><code class="prettyprint java">public class FooImpl implements Foo<Number>{

    public void bar(Number t) {
    }

    public void bar(Serializable t) {
    }
}
</code></pre>
<p>如果您在解析委托方法时使用传递给<tt>InvocationHandler</tt>的具体参数的类型，那么面对<tt>Integer</tt>类型的参数时，您将选择以下哪种方法？您不能（从接口方法中）得知类型参数是<tt>Number，</tt>并且由于这两种方法都与<tt>Integer</tt>类型兼容，因此不可能一直以通用方式解析正确的方法。</p>
<p>（我知道） <em>只有</em>两种方法可以解决此问题。第一种方法涉及使用像<a href="http://asm.objectweb.org/">ASM</a>这样的库来读取bridge方法的字节码，并找出它调用的方法。使用ASM读取字节码是一个很好的解决方案，并且通常是万无一失的。但是，在安全环境中，它可能需要对不允许的库进行读取许可，这可能会引起问题。第二种解决方案涉及在bridge方法中使用通用元数据来解析实现类中的哪些方法正在桥接。</p>
<p>在上面的例子可以看出，接口方法是用<tt>T</tt>参数<tt>栏</tt> 。我们可以使用<tt>FooImpl</tt>的通用接口元数据（ <tt>Class.getGenericInterfaces（）</tt> ）确定将<tt>T</tt>实现为<tt>Number</tt> 。从那里开始，只需一个简单的步骤即可知道桥接方法是<tt>bar（Number）</tt>而不是<tt>bar（Serializable）</tt> 。不幸的是，面对涉及带有边界的多个类型参数的复杂层次结构，此方法变得越来越复杂。幸运的是，此逻辑封装在Spring的<tt>BridgeMethodResolver</tt>类中。这是Spring解决Java开发人员面临的基础设施难题并将其集成到应用程序堆栈中的完美示例。只要在Spring中执行注释查找，就可以透明地解析桥方法。</p>
<p><tt>BridgeMethodResolver</tt>的实现已基本完成；但是，我敢肯定，有些复杂的情况我们还没有解决，我很高兴收到在此领域遇到任何问题的用户的来信。</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">var disqus_shortname = 'spring-io';
      var disqus_identifier = 47;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));</script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });</script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>