<!DOCTYPE html>
<html data-code-prettify="" data-mobile-support="" data-search="">
<head>
<title>A Bridge Too Far</title>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no" id="Viewport" name="viewport" />
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png" />
<link href="https://fonts.googleapis.com/css?family=Varela+Round|Montserrat:400,700" rel="stylesheet" type="text/css" />
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css" />
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M" name="google-site-verification" />

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css" />

<meta content="summary" name="twitter:card" />
<meta content="@springcentral" name="twitter:site" />
<meta name="twitter:title" content="A Bridge Too Far" />
<meta name="twitter:description" content="&lt;p&gt;In my &lt;a href=&quot;http://blog.interface21.com/main/2006/09/29/exploiting-generics-metadata/&quot;&gt;last entry&lt;/a&gt; I presented a technique for creating strategy classes that take full advantage of any generic metadata that is present in your application. At the end of that entry I showed this code snippet:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint java&quot;&gt;EntitlementCalculator calculator = new DividendEntitlementCalculator();
calculator.calculateEntitlement(new MergerCorporateActionEvent());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You&#39;ll remember that &lt;tt&gt;DividendEntitlementCalculator&lt;/tt&gt; was defined as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint java&quot;&gt;public class DividendEntitlementCalculator implements EntitlementCalculator&amp;lt;DividendCorporateActionEvent&amp;gt; {

    public void calculateEntitlement(DividendCorporateActionEvent event) {

    }
}
&lt;/code&gt;&lt;/pre&gt;
" />

<meta property="og:title" content="A Bridge Too Far" />
<meta property="og:description" content="&lt;p&gt;In my &lt;a href=&quot;http://blog.interface21.com/main/2006/09/29/exploiting-generics-metadata/&quot;&gt;last entry&lt;/a&gt; I presented a technique for creating strategy classes that take full advantage of any generic metadata that is present in your application. At the end of that entry I showed this code snippet:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint java&quot;&gt;EntitlementCalculator calculator = new DividendEntitlementCalculator();
calculator.calculateEntitlement(new MergerCorporateActionEvent());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You&#39;ll remember that &lt;tt&gt;DividendEntitlementCalculator&lt;/tt&gt; was defined as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint java&quot;&gt;public class DividendEntitlementCalculator implements EntitlementCalculator&amp;lt;DividendCorporateActionEvent&amp;gt; {

    public void calculateEntitlement(DividendCorporateActionEvent event) {

    }
}
&lt;/code&gt;&lt;/pre&gt;
" />
<meta content="article" property="og:type" />
<meta property="og:article:published_time" content="2007-01-16 22:19:00.0" />
</head>
<body>

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" style="display:none;visibility:hidden" width="0"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">Projects</a>
</li>
<li class="navbar-link">
<a href="/guides">Guides</a>
</li>
<li class="navbar-link active">
<a href="/blog">Blog</a>
</li>
<li class="navbar-link">
<a href="/services">Training & Certification</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form action="/search" class="form-inline form-search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search for documentation, guides, and posts..." type="text" value="" />
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form action="/search" class="form-inline form-search" method="get">
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search..." type="text" value="" />
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">
Home
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">
Projects
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">
Guides
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">
Blog
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">
Training & Certification
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>Engineering</div>
</div>
<div class="blog-category content--title">
<div>Releases</div>
</div>
<div class="blog-category content--title">
<div>News and Events</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">A Bridge Too Far</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">Engineering</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="null?s=20&amp;d=mm" />
<span class="author">Rob Harrop</span>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2007-01-16 22:19:00.0">January 16, 2007</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" data-disqus-identifier="47" href="/blog/2007/01/16/a-bridge-too-far#disqus_thread">
</a></div>
</div>
</header>
<div class="blog--post"><p>In my <a href="http://blog.interface21.com/main/2006/09/29/exploiting-generics-metadata/">last entry</a> I presented a technique for creating strategy classes that take full advantage of any generic metadata that is present in your application. At the end of that entry I showed this code snippet:</p>
<pre><code class="prettyprint java">EntitlementCalculator calculator = new DividendEntitlementCalculator();
calculator.calculateEntitlement(new MergerCorporateActionEvent());
</code></pre>
<p>You'll remember that <tt>DividendEntitlementCalculator</tt> was defined as:</p>
<pre><code class="prettyprint java">public class DividendEntitlementCalculator implements EntitlementCalculator&lt;DividendCorporateActionEvent&gt; {

    public void calculateEntitlement(DividendCorporateActionEvent event) {

    }
}
</code></pre>
<p>As such it is not correct to pass an instance of <tt>MergerCorporateActionEvent</tt> into the <tt>calculateEntitlement</tt> method of the <tt>DividendEntitlementCalculator</tt> class. However, as I mentioned in my last entry that code will compile. Why? Well, <tt>EntitlementCalculator.calculateEntitlement()</tt> is defined to accept any type that extends <tt>CorporateActionEvent</tt> so it <em>should</em> compile. So in this scenario what happens at runtime and how does Java enforce type safety? Well, as you might imagine running this code gives you a <tt>ClassCastException</tt> saying that you cannot cast a <tt>MergerCorporateActionEvent</tt> to <tt>DividendCoporateActionEvent</tt>. In this way, Java can enforce type safety for you application - there is no way that the <tt>MergerCorporateActionEvent</tt> can creep into a method where <tt>DividendCorporateActionEvent</tt> is expected.</p>
<p>The real question here is: 'Where does that <tt>ClassCastException</tt> come from?' The answer is pretty simple - the Java compiler adds the code to create and throw it as appropriate by introducing a <em>bridge method</em>. Bridge methods are synthetic methods that the compiler will generate and add to your classes to ensure type safety in the face of generic types. </p>
<p>In the case shown above <tt>EntitlementCalculator.calculateEntitlement</tt> can be called with any object that is type compatible with <tt>CorporateActionEvent</tt>. However, <tt>DividendEntitlementCalculator</tt> accepts only objects that are type compatible with <tt>DividendCorporateActionEvent</tt>, <em>but</em>, since you can call the <tt>DividendEntitlementCalculator</tt> via the <tt>EntitlementCalculator</tt> interface it too must accept <tt>CorporateActionEvent</tt>. So what does this translate to in the compiled class file? We have the user supplied method:</p>
<pre><code class="prettyprint java">public void calculateEntitlement(DividendCorporateActionEvent event) {
    System.out.println(event);
}
</code></pre>
<p>Which translates to this bytecode:</p>
<pre><code class="prettyprint java">public void calculateEntitlement(bigbank.DividendCorporateActionEvent);
  Code:
   Stack=2, Locals=2, Args_size=2
   0:   getstatic       #2; //Field java/lang/System.out:Ljava/io/PrintStream;
   3:   aload_1
   4:   invokevirtual   #3; //Method java/io/PrintStream.println:(Ljava/lang/Object;)V
   7:   return
</code></pre>
<p>But we also have a compiler generated method:</p>
<pre><code class="prettyprint java">public void calculateEntitlement(bigbank.CorporateActionEvent);
  Code:
   Stack=2, Locals=2, Args_size=2
   0:   aload_0
   1:   aload_1
   2:   checkcast       #4; //class bigbank/DividendCorporateActionEvent
   5:   invokevirtual   #5; //Method calculateEntitlement:(Lbigbank/DividendCorporateActionEvent;)V
   8:   return
</code></pre>
<p>Which translates to this Java code:</p>
<pre><code class="prettyprint java">public void calculateEntitlement(CorporateActionEvent event) {
    calculateEntitlement((DividendCorporateActionEvent)event);
}
</code></pre>
<p>So, here you can clearly see where the <tt>ClassCastException</tt> comes from when passing in <tt>CorporateActionEvents</tt> other than <tt>DividendCorporateActionEvents</tt> - the compiler generated <em>bridge method</em>. </p>
<p>Now, this is, of course, an excellent feature. We wouldn't want the addition of generics into the Java language to break the type safety that we have all been used to for so long. However, as is to be expected with these things - all is not well. The main problem with bridge methods as they are implemented in the current JDK is that annotations are not copied from the bridged method on to the bridge method. This causes all manner of problems when you inadvertently get hold of the bridge method in reflection and try to resolve some annotations. </p>
<p>Some of you might be wondering how you can get hold of a bridge method by mistake. This is somewhat of a complex issue. A common cause (and where we see it occur most in Spring) is where you are creating JDK proxies that delegate to some object and you try to map the method from the proxy interface onto the corresponding implementation method on the delegate (often to resolve annotations). Consider this code:</p>
<pre><code class="prettyprint java">public static void main(String[] args) {
    EntitlementCalculator ec = createProxy(new DividendEntitlementCalculator());
    ec.calculateEntitlement(null);
}

private static EntitlementCalculator createProxy(EntitlementCalculator calculator) {
    InvocationHandler handler = new TransactionLoggingInvocationHandler(calculator);
    return (EntitlementCalculator) Proxy.newProxyInstance(calculator.getClass().getClassLoader(),
                                                                calculator.getClass().getInterfaces(), handler);
}

private static class TransactionLoggingInvocationHandler implements InvocationHandler {

    private final EntitlementCalculator delegate;

    public TransactionLoggingInvocationHandler(EntitlementCalculator delegate) {
        this.delegate = delegate;
    }

    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        Method delegateMethod = delegate.getClass().getMethod(method.getName(), method.getParameterTypes());
        Transactional annotation = delegateMethod.getAnnotation(Transactional.class);
        if(annotation != null) {
            System.out.println(&quot;Executing transactional method: &quot; + delegateMethod);
        } else {
            System.out.println(&quot;Executing non-transactional method: &quot; + delegateMethod);
        }
        return method.invoke(delegate, args);
    }
}
</code></pre>
<p>Here we are creating a proxy for a given <tt>EntitlementCalculator</tt> object that will log whether or not a method on the proxied object is transactional. If we annotate the <tt>DividendEntitlementCalculator</tt> class as below, we could expect the proxy to log that we are executing a transactional method when calling <tt>calculateEntitlement</tt> from <tt>main</tt>.</p>
<pre><code class="prettyprint java">@Transactional
public void calculateEntitlement(DividendCorporateActionEvent event) {
    System.out.println(event);
}
</code></pre>
<p>However, executing the example above results in this outcome:</p>
<pre><code class="prettyprint java">Executing non-transactional method: public volatile void bigbank.DividendEntitlementCalculator.calculateEntitlement(bigbank.CorporateActionEvent)
</code></pre>
<p>Notice that this doesn't correspond to the method on the <tt>DividendEntitlementCalculator</tt> that we are invoking. Of course this was obviously going to be the case; the point here is that the signatures of the interface method and the delegate method <em>are</em> different. One is defined in terms of the parent type, in this case <tt>CorporateActionEvent</tt>, and the other is defined in terms of the child type, in this case <tt>DividendCorporateActionEvent</tt>. What you'll also notice is that we have actually been given the bridge method back - since its signature <em>does</em> match that of the interface method (by definition).</p>
<p>Perhaps a better solution to looking up the delegate method is to use the types of the passed in arguments rather than those on the interface method. When faced with arguments that use inheritance, you can simply search for a type match up the type hierarchy of the arguments. Unfortunately, this approach cannot work reliably. Consider the case where you have the following interface:</p>
<pre><code class="prettyprint java">public interface Foo&lt;T&gt; {
    void bar(T t);
}
</code></pre>
<p>And then this implementation:</p>
<pre><code class="prettyprint java">public class FooImpl implements Foo&lt;Number&gt;{

    public void bar(Number t) {
    }

    public void bar(Serializable t) {
    }
}
</code></pre>
<p>If you were to use the types of the concrete arguments passed into the <tt>InvocationHandler</tt> when resolving the delegate method, which of these methods would you choose when faced with an argument of type <tt>Integer</tt>? You can't tell (from the interface method) that the type parameter is <tt>Number</tt> and since both methods are type compatible with <tt>Integer</tt>, it's going to be impossible to resolve the correct method all the time in a general fashion. </p>
<p>There are <em>only</em> two ways (that I know of) for solving this problem. The first method involves using a library like <a href="http://asm.objectweb.org/">ASM</a> to read the bytecode of the bridge method and find out which method it calls. The use of ASM to read bytecode is a great solution and it is generally foolproof. However, in secure environments it can require read permissions to libraries that are not allowed which may prove to be problematic. The second solution involves using the generic metadata in the bridge method to resolve which of the methods in the implementation class is being bridged.</p>
<p>In the example above we can see that the interface method is <tt>bar</tt> parameterized by <tt>T</tt>. We can use the generic interface metadata (<tt>Class.getGenericInterfaces()</tt>) of <tt>FooImpl</tt> to determine that <tt>T</tt> is realised as <tt>Number</tt>. From there it is a simple step to know that the bridged method is <tt>bar(Number)</tt> and not <tt>bar(Serializable)</tt>. Unfortunately, this method gets increasingly more complex in the face of complex hierarchies involving multiple type parameters with bounds. Fortunately, this logic is encapsulated in Spring's <tt>BridgeMethodResolver</tt> class. This is a perfect example of Spring solving the hard infrastructure problems that Java developers face and integrating them into the application stack. Any time an annotation lookup is performed in Spring, bridge methods are transparently resolved.</p>
<p>The implementation of <tt>BridgeMethodResolver</tt> is largely complete; however, I am sure there are some complex cases that we have not yet accounted for and I'll be happy to hear from users who are encountering any problems in this area.</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 47;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>
Back
</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">All Posts</a>
<a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">Engineering</a>
<a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">Releases</a>
<a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">News and Events</a>
<a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>Get updates from The Spring Team delivered to your inbox</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">Tools</a></li>
<li><a href="https://store.pivotal.io/">Store</a></li>
<li><a href="/blog">Newsletter</a></li>
</ul>
</div>
</div>
&copy; <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a>, Inc. All Rights Reserved.
<a href="https://pivotal.io/terms-of-use">Terms of Use</a> &bullet;
<a href="https://pivotal.io/privacy-policy">Privacy</a> &bullet;
<a href="/trademarks">Trademark Guidelines</a>
<div id="teconsent" style="display:inline-block;"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>