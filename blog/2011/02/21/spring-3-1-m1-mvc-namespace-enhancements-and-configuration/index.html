<html dir="ltr" data-code-prettify="" data-mobile-support="" data-search=""><head></head><body dir="ltr">﻿
<title>Spring 3.1 M1：MVC命名空间增强和@Configuration</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>System.config({baseURL: "/b92013b"});</script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>System.import('app/main.js')</script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Spring 3.1 M1: MVC Namespace Enhancements and @Configuration">
<meta name="twitter:description" content="<p>In this 5th post of the <a href=" http:="" ="" blog.springsource.com="" 2011="" 02="" 11="" spring-framework-3-1-m1-release="=">series <a href="http://blog.springsource.com/2011/02/14/spring-3-1-m1-introducing-profile/">describing</a> <a href="http://blog.springsource.com/2011/02/15/spring-3-1-m1-unified-property-management/">Spring 3.1 M1</a> <a href="http://blog.springsource.com/2011/02/17/spring-3-1-m1-featurespec/">features</a>, I will focus on web applications. In the first half I’ll discuss enhancements to the MVC XML namespace. Then I’ll show how to create the equivalent of the MVC namespace with all Java configuration. At the end I mention some of the Servlet 3.0 related configuration changes you can expect in 3.1 M2.
<h2>MVC Namespace Improvements</h2>
<p>Spring MVC 3.0 provided a custom MVC namespace. The centerpiece of the namespace – the <code><mvc:annotation-driven></code> element, configured everything required to process requests with annotated controller methods. More importantly though it set up a range of defaults that go along with having to do with type conversion, formatting, validation, reading and writing of the body of requests and respones and so on.</p>
">
<meta name="twitter:creator" content="@rstoya05">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/4b12b9c0c665bc0345467c1a218ed0f7?s=200">

<meta property="og:title" content="Spring 3.1 M1: MVC Namespace Enhancements and @Configuration">
<meta property="og:image" content="https://gravatar.com/avatar/4b12b9c0c665bc0345467c1a218ed0f7?s=200">
<meta property="og:description" content="<p>In this 5th post of the <a href=" http:="" ="" blog.springsource.com="" 2011="" 02="" 11="" spring-framework-3-1-m1-release="=">series <a href="http://blog.springsource.com/2011/02/14/spring-3-1-m1-introducing-profile/">describing</a> <a href="http://blog.springsource.com/2011/02/15/spring-3-1-m1-unified-property-management/">Spring 3.1 M1</a> <a href="http://blog.springsource.com/2011/02/17/spring-3-1-m1-featurespec/">features</a>, I will focus on web applications. In the first half I’ll discuss enhancements to the MVC XML namespace. Then I’ll show how to create the equivalent of the MVC namespace with all Java configuration. At the end I mention some of the Servlet 3.0 related configuration changes you can expect in 3.1 M2.
<h2>MVC Namespace Improvements</h2>
<p>Spring MVC 3.0 provided a custom MVC namespace. The centerpiece of the namespace – the <code><mvc:annotation-driven></code> element, configured everything required to process requests with annotated controller methods. More importantly though it set up a range of defaults that go along with having to do with type conversion, formatting, validation, reading and writing of the body of requests and respones and so on.</p>
">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2011-02-21 13:53:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">// Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }</script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
 </span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Spring 3.1 M1：MVC命名空间增强和@Configuration</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/4b12b9c0c665bc0345467c1a218ed0f7?s=20&d=mm"> <a class="author" rel="author" href="/team/rstoyanchev">罗森·斯托扬切夫（Rossen Stoyanchev）</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2011-02-21 13:53:00.0">2011年2月21日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2011/02/21/spring-3-1-m1-mvc-namespace-enhancements-and-configuration#disqus_thread" data-disqus-identifier="396">
</a></div>
</div>
</header>
<div class="blog--post"><p>在<a href="http://blog.springsource.com/2011/02/14/spring-3-1-m1-introducing-profile/">描述</a> <a href="http://blog.springsource.com/2011/02/15/spring-3-1-m1-unified-property-management/">Spring 3.1 M1</a> <a href="http://blog.springsource.com/2011/02/17/spring-3-1-m1-featurespec/">功能</a>的<a href="http://blog.springsource.com/2011/02/11/spring-framework-3-1-m1-released">系列</a>文章的第5部分中，我将重点介绍Web应用程序。在上半年中，我将讨论对MVC XML名称空间的增强。然后，我将展示如何使用所有Java配置创建等效的MVC命名空间。最后，我提到了在3.1 M2中可以预期的一些与Servlet 3.0相关的配置更改。</p>
<h2>MVC命名空间的改进</h2><p>Spring MVC 3.0提供了一个自定义的MVC名称空间。命名空间的核心– <code><mvc:annotation-driven></code>元素，使用注释的控制器方法配置了处理请求所需的一切。更重要的是，尽管它设置了一系列默认值，并且还必须处理类型转换，格式设置，验证，请求和响应主体的读写等。</p><p>随着时间的流逝，许多用户请求对上述默认配置的各个方面进行更多控制，并且我们在3.1 M1版本中解决了许多此类请求。</p>
<h4>格式器注册</h4><p>我们将从注册<code>Converters</code>和<code>Formatters</code> ，这是通过提供您自己的<code>ConversionService</code>实例来完成的，如下所示：</p>
<pre><code class="prettyprint xml"><br><mvc:annotation-driven conversion-service="..." />
</code></pre><p>对于自定义格式化程序，您可以将<code>FormattingConversionServiceFactoryBean</code>子类化，并在代码中注册格式化程序。从3.1 M1开始，您可以使用setter声明式地注册<code>Formatter</code>和<code>AnnontationFormatterFactory</code>类型：</p>
<pre><code class="prettyprint xml"><br><mvc:annotation-driven conversion-service="conversionService" />

<bean class="org.springframework.format.support.FormattingConversionServiceFactoryBean">
	<property name="formatters">
		<list>
			<bean class="org.example.EmailFormatter"/>
			<bean class="org.example.PhoneAnnotationFormatterFactory"/>
		</list>
	</property>
</bean>
</code></pre><p>您仍然可以选择在代码中注册<code>Converters</code>和<code>Formatters</code>程序。这是通过此版本中引入的<em><code>FormatterRegistrar</code></em>接口完成的。这是一个例子：</p>
<pre><code class="prettyprint java"><br>public class FinancialInstrumentFormatterRegistry implements FormatterRegistrar {

	public void registerFormatters(FormatterRegistry registry) {
		// Register custom Converters and Formatters here...
	}

}
</code></pre><p>这是您可以插入<code>FormatterRegistrary</code>方式：</p>
<pre><code class="prettyprint xml"><br><bean class="org.springframework.format.support.FormattingConversionServiceFactoryBean">
	<property name="formatterRegistrars">
		<list>
			<bean class="org.example.FinancialInstrumentFormatterRegistrar"/>
		</list>
	</property>
</bean>
</code></pre><p>因此，什么时候应该使用<code>FormatterRegistrar</code>而不是<code>FormatterRegistrar</code> setter？当您需要从一个地方为特定格式类别注册多个相关的转换器和格式器时， <code>FormatterRegistrar</code>很有用。另一种情况是注册一个<code>Formatter</code>比其自己的通用型<t>或也许登记其它字段类型下索引<t><code>Formatter</code>从一个<code>Printer</code> / <code>Parser</code>对。实际的<code>FormatterRegistrar</code>实现的一个很好的例子是Spring框架中的<code>JodaTimeFormatterRegistrar</code> ，因此可以在那儿看看。</t></t></p><p><code>FormattingConversionServiceFactoryBean</code>中的最后一个选项是能够通过<code>registerDefaultFormatters</code>标志完全关闭默认<code>Formatter</code>注册的功能。</p>
<h4>HttpMessageConverters的注册</h4><p>从3.1 M1开始，您可以通过<code>mvc:annotation-driven</code>的子元素注册<code>HttpMessageConverters</code> 。例如：</p>
<pre><code class="prettyprint xml"><br><mvc:annotation-driven>
	<mvc:message-converters>
		<bean class="com.google.protobuf.spring.http.ProtobufHttpMessageConverter"/>
		<bean class="org.springframework.http.converter.json.MappingJacksonHttpMessageConverter">
			<property name="prefixJson" value="true"/>
		</bean>
	</mvc:message-converters>
</mvc:annotation-driven>	
</code></pre><p>默认情况下，以这种方式提供的消息转换器列表优先于MVC名称空间寄存器中的消息转换器。例如，上面我们添加了一个自定义转换器<code>ProtobufHttpMessageConverter</code>并且还提供了根据应用程序需求自定义的Spring MVC <code>MappingJacksonHttpMessageConvert</code>的实例。</p><p>如果您不想默认注册任何消息转换器，请在上使用<code>register-defaults</code>属性。 <code><mvc:message-converters></code>元件。</p>
<h4>注册自定义WebArgumentResolvers</h4><p><code>WebArgumentResolver</code> （如果您从未见过）可用于解析<code>@RequestMapping</code>方法中的自定义参数。Spring Mobile项目具有一个<code>SitePreferenceWebArgumentResolver</code> 。它解析<code>SitePreference</code>方法参数类型，这些参数类型指示用户是页面的移动版本还是完整版本。从Spring 3.1 M1开始，您可以通过MVC命名空间注册自定义参数解析器：</p>
<pre><code class="prettyprint xml"><br><mvc:annotation-driven>
	<mvc:argument-resolvers>
		<bean class="org.springframework.mobile.device.site.SitePreferenceWebArgumentResolver"/>
	</mvc:argument-resolvers>
</mvc:annotation-driven>
</code></pre>
<h4>自定义MessageCodesResolver</h4><p>列表的最后是提供自定义<code>MessageCodesResolver</code> ：</p>
<pre><code class="prettyprint xml"><br><mvc:annotation-driven message-codes-resolver="messageCodesResolver" />

<bean id="messageCodesResolver" class="org.example.CustomMessageCodesResolver" />
</code></pre><p>MVC名称空间可以完成许多其他事情。上面的列表应该有助于涵盖最常见的用例，以增加灵活性，但是如果您认为我们还错过了其他重要的用例，请告诉我们。</p>
<h2>从XML到@Configuration</h2><p></p><div class="callout">
<div class="callout-title">更新资料</div>本节中的信息已过时。方法已在里程碑2中更改。请改为阅读<a href="http://blog.springsource.org/2011/06/13/spring-3-1-m2-spring-mvc-enhancements-2/">此Spring MVC 3.1 M2帖子</a> 。
</div><p></p><p>在文章的这一部分中，我将使用一个现有的示例应用程序：您可能会从<a href="http://blog.springsource.com/author/keithd/">Keith Donald的</a>先前文章中熟悉许多人所熟悉的<a href="https://src.springframework.org/svn/spring-samples/mvc-showcase">mvc-showcase</a> ，并将其XML配置替换为基于Java的配置。这样可以比较之前和之后的代码和配置。</p><p>生成的示例应用程序可在<a href="https://github.com/rstoyanchev/spring-3.1-mvc-java-config">spring-3.1-mvc-java-config</a>进行签出。您可以直接在GitHub上浏览源代码，也可以按照<a href="https://github.com/rstoyanchev/spring-3.1-mvc-java-config/blob/master/README">README</a>指令在本地获取代码。</p><p>我们的第一步是修改web.xml以指向基于Java的配置，并指定用于处理该配置的<code>ApplicationContext</code>类型。以下是相关的web.xml片段：</p>
<pre><code class="prettyprint xml"><br><servlet>
	<servlet-name>appServlet</servlet-name>
	<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
	<init-param>
		<param-name>contextClass</param-name>
		<param-value>
			org.springframework.web.context.support.AnnotationConfigWebApplicationContext
		</param-value>
	</init-param>
	<init-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>
			org.springframework.samples.mvc.config.MvcFeatures
			org.springframework.samples.mvc.config.MvcBeans
		</param-value>
	</init-param>
</servlet>
</code></pre><p>接下来，我们将在<code>MvcBeans</code>包中创建<code>MvcFeatures</code>和<code>MvcBeans</code> 。<code>MvcFeatures</code>贡献了<code>@Feature</code>方法，这是我们的主要兴趣点：</p>
<pre><code class="prettyprint java"><br>@FeatureConfiguration
class MvcFeatures {

	@Feature
	public MvcAnnotationDriven annotationDriven(ConversionService conversionService) {
		return new MvcAnnotationDriven().conversionService(conversionService)
			.argumentResolvers(new CustomArgumentResolver());
	}

	// ...

}
</code></pre><p>上面的代码片段等效于此XML名称空间配置：</p>
<pre><code class="prettyprint xml"><br><mvc:annotation-driven conversion-service="conversionService">
	<mvc:argument-resolvers>
		<bean class="org.springframework.samples.mvc.data.custom.CustomArgumentResolver"/>
	</mvc:argument-resolvers>
</mvc:annotation-driven>
</code></pre><p>如您所见， <code>MvcAnnotationDriven</code>使用便利的链接方法API提供与XML元素相同的选项。还要注意，我们已经声明了<code>ConversionService</code>方法参数。该参数按类型自动接线并注入。它的声明可以在<code>MvcBeans</code>找到：</p>
<pre><code class="prettyprint java"><br>@Configuration
public class MvcBeans {

	@Bean
	public ConversionService conversionService() {
		DefaultFormattingConversionService bean = new DefaultFormattingConversionService();
		bean.addFormatterForFieldAnnotation(new MaskFormatAnnotationFormatterFactory());
		return bean;
	}

	// ...
	
}
</code></pre><p>注意使用<code>DefaultFormattingConversionService</code>而不是XML配置中通常使用的熟悉的<code>FormattingConversionServiceFactoryBean</code> 。前者为我们提供了与后者相同的默认<code>Converter</code>和<code>Formatter</code>注册，但更适合与Java配置一起使用-它提供了一个简单的构造函数，而不是Spring使用XML时调用的<code>FactoryBean</code>生命周期初始化方法。</p><p><code>MvcFeatures</code>的其余部分声明了与<code><mvc:resources></code> ， <code><mvc:view-controller></code>和<code><context:component-scan></code>元素：</p>
<pre><code class="prettyprint java"><br>@FeatureConfiguration
class MvcFeatures {

	// ...

	@Feature
	public MvcResources resources() {
		return new MvcResources("/resources/**", "/resources/");
	}

	@Feature
	public MvcViewControllers viewController() {
		return new MvcViewControllers("/", "home");
	}

	@Feature
	public ComponentScanSpec componentScan() {
		return new ComponentScanSpec("org.springframework.samples").excludeFilters(
				new AnnotationTypeFilter(Configuration.class), 
				new AnnotationTypeFilter(FeatureConfiguration.class));
	}
}
</code></pre><p>有两件事值得注意。一种是需要使用<code>MvcViewControllers</code>的单个实例来使用链式方法调用定义任意数量的视图控制器。第二个是在<code>componentScan()</code>方法中使用排除过滤器，以防止<code>MvcFeatures</code>和<code>MvcBeans</code>两次注册-一次由<code>AnnotationConfigWebApplicationContext</code>注册，第二次由组件扫描进行注册。</p><p>为了完整，这是剩余部分<code>MvcBeans</code> ：</p>
<pre><code class="prettyprint java"><br>@Configuration
public class MvcBeans {

	// ...

	@Bean
	public InternalResourceViewResolver jspViewResolver() {
		InternalResourceViewResolver bean = new InternalResourceViewResolver();
		bean.setPrefix("/WEB-INF/views/");
		bean.setSuffix(".jsp");
		return bean;
	}

	@Bean
	public MultipartResolver multipartResolver() {
		return new CommonsMultipartResolver();
	}
}
</code></pre><p>最后一步是删除<code>/WEB-INF/spring</code>下的Spring XML配置。</p>
<h2>摘要</h2><p>我们到了。我们已经使用所有基于Java的Spring配置引导了Web应用程序。现在已经介绍了<code>@FeatureConfiguration</code>和<code>@Feature</code>您可以期望看到越来越多的<code>FeatureSpecification</code>实现，以替代自定义XML名称空间。我宁愿喜欢Java配置的最终结果，但是当然这并不意味着我现有的应用程序需要切换。这都是关于选择。如果您更喜欢XML的声明性，并且使用IDE在Spring XML配置中对类和方法名称进行代码完成的IDE，那么也可以使用XML名称空间。</p><p>正如最近在<a href="http://www.springsource.com/webinar/introducing-spring-framework-31">Spring 3.1简介</a>网络研讨会中听到的那样，在Spring 3.1的里程碑2中，您可以期望看到Servlet 3.0支持，包括无XML的Web应用程序设置（即没有web.xml），并结合了AnnotationConfigWebApplicationContext和本次演示的环境抽象以及本系列博客的先前文章。</p><p>我们希望您喜欢这些功能并发现它们有用。请让我们知道你的想法。</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">var disqus_shortname = 'spring-io';
      var disqus_identifier = 396;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));</script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });</script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>