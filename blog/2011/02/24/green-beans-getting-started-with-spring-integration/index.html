<!DOCTYPE html>
<html data-code-prettify="" data-mobile-support="" data-search="">
<head>
<title>Green Beans: Getting Started with Spring Integration</title>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no" id="Viewport" name="viewport" />
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png" />
<link href="https://fonts.googleapis.com/css?family=Varela+Round|Montserrat:400,700" rel="stylesheet" type="text/css" />
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css" />
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M" name="google-site-verification" />

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css" />

<meta content="summary" name="twitter:card" />
<meta content="@springcentral" name="twitter:site" />
<meta name="twitter:title" content="Green Beans: Getting Started with Spring Integration" />
<meta name="twitter:description" content="&lt;p&gt;Applications don’t exist in a vacuum. They need to communicate with their customers and with other applications. Application Integration is all about enabling this communication. Integration lets applications share services and data with each other, and, just as often, integration helps applications connect with their users.&lt;/p&gt;
&lt;p&gt;Spring Integration provides a framework to build integration solutions, to facilitate these kinds of solutions. Spring Integration solutions describe the flow of data through a pipeline. Data enters the processing pipeline as a message. The message is moved forward through named pipes (called channels) that route the data to different components (called endpoints). You can string as many endpoints and channels together as you like.&lt;/p&gt;
" />
<meta name="twitter:creator" content="@starbuxman" />
<meta name="twitter:image:src" content="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=200" />

<meta property="og:title" content="Green Beans: Getting Started with Spring Integration" />
<meta property="og:image" content="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=200" />
<meta property="og:description" content="&lt;p&gt;Applications don’t exist in a vacuum. They need to communicate with their customers and with other applications. Application Integration is all about enabling this communication. Integration lets applications share services and data with each other, and, just as often, integration helps applications connect with their users.&lt;/p&gt;
&lt;p&gt;Spring Integration provides a framework to build integration solutions, to facilitate these kinds of solutions. Spring Integration solutions describe the flow of data through a pipeline. Data enters the processing pipeline as a message. The message is moved forward through named pipes (called channels) that route the data to different components (called endpoints). You can string as many endpoints and channels together as you like.&lt;/p&gt;
" />
<meta content="article" property="og:type" />
<meta property="og:article:published_time" content="2011-02-24 01:33:00.0" />
</head>
<body>

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" style="display:none;visibility:hidden" width="0"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">Projects</a>
</li>
<li class="navbar-link">
<a href="/guides">Guides</a>
</li>
<li class="navbar-link active">
<a href="/blog">Blog</a>
</li>
<li class="navbar-link">
<a href="/services">Training & Certification</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form action="/search" class="form-inline form-search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search for documentation, guides, and posts..." type="text" value="" />
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form action="/search" class="form-inline form-search" method="get">
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search..." type="text" value="" />
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">
Home
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">
Projects
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">
Guides
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">
Blog
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">
Training & Certification
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>Engineering</div>
</div>
<div class="blog-category content--title">
<div>Releases</div>
</div>
<div class="blog-category content--title">
<div>News and Events</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Green Beans: Getting Started with Spring Integration</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">Engineering</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=20&amp;d=mm" />
<a class="author" rel="author" href="/team/jlong">Josh Long</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2011-02-24 01:33:00.0">February 24, 2011</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" data-disqus-identifier="399" href="/blog/2011/02/24/green-beans-getting-started-with-spring-integration#disqus_thread">
</a></div>
</div>
</header>
<div class="blog--post"><p>Applications don&rsquo;t exist in a vacuum. They need to communicate with their customers and with other applications. Application Integration is all about enabling this communication. Integration lets applications share services and data with each other, and, just as often, integration helps applications connect with their users.</p><p>Spring Integration provides a framework to build integration solutions, to facilitate these kinds of solutions. Spring Integration solutions describe the flow of data through a pipeline. Data enters the processing pipeline as a message. The message is moved forward through named pipes (called channels) that route the data to different components (called endpoints). You can string as many endpoints and channels together as you like.</p><p>This model is very similar in its simplicity to the Unix command line. Take for example the following Unix incantation:</p>
<pre><code class="prettyprint shell">cat spring.txt |grep spring |cut -f1 -d, | sort | uniq &gt; spring_cleaning.txt
</code></pre><p>In this command, data from an external resource (a file named <code>spring.txt</code>) is passed into the <code>grep</code> command line. <code>grep</code> sifts through the results and finds all lines that match the word &ldquo;spring&rdquo; and sends them as output. The output from the <code>grep</code> command is sent as the input to <code>cut</code> command, which will parse the results and split each line on commas (&ldquo;,&rdquo;) and only keep the first column of data (everything else after the first &ldquo;,&rdquo; is discarded). This relay continues until the end, where finally the output is written back to another external resource called <code>spring_cleaning.txt.</code> In this command, we connected the output of one command to the input of another using the Unix &ldquo;pipe&rdquo; (&ldquo;|&rdquo;). We read, cleaned, filtered, transformed and wrote the data by composing specialized. singly-focused commands into a pipeline. This approach is called the pipes and filters model, and Spring Integration lets you think about much bigger problems using this same simple model. In Spring Integration, channels are pipes, and endpoints are filters.<br /><h2>Spring Integration comes with Batteries Included</h2><br />Spring Integration supports many different use cases. Here are some common ones:<br /><ul><br /> <li><strong>Transform data</strong>: transformer endpoints might change the type of the payload from one class to another, or delete, add, or change the message headers.</li><br /> <li> <strong>Route data</strong>: router endpoints provide custom routing logic – perhaps the data from the input channel should be delivered to multiple output channels?</li><br /> <li> <strong>Filter data</strong>: perhaps input data isn&rsquo;t fit to proceed and should be weeded out. You use filter endpoints to conditionally stop the data from proceeding.</li><br /> <li> <strong>Adapt different systems to Spring Integration</strong>: Adapters provide the ability for data to enter and exit the Spring Integration solution.</li><br /> <li> <strong>Split data</strong>: when the payload is too big, or is intended to be partitioned into smaller pieces of data. An example might be a single file that should be split into rows.</li><br /> <li> <strong>Aggregate data</strong>: this is the inverse of splitting functionality: an aggregator waits for messages to arrive, one by one, and collects them until some condition is met. Then, it sends all the aggregate messages as one message.</li><br /></ul><br />These are the tools of the Spring Integration developer’s toolbox. Spring Integration is, at its core, just one Maven dependency with common abstractions and interfaces.</p>
<pre><code class="prettyprint xml"><br />&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;
    &lt;artifactId&gt;spring-integration-core&lt;/artifactId&gt;
    &lt;version&gt;2.0.3.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>Spring Integration provides many out-of-the-box modules, each with support appropriate to a specific type of requirement (for example: XML handling, or web services integration). As an example, the file namespace provides inbound and outbound adapters to read files from the file system and write files to the filesystem, respectively. The <code>file:inbound-channel-adapter</code> adapts the file system – it monitors a directory of your specification and, whenever a new file appears, produces Messages with a paylod of type <code>java.io.File</code> payload for the new file. A common use case is to transform files from a <code>java.io.File</code> to a representation of the file&rsquo;s contents - either a <code>String</code> or a <code>byte</code> array (<code>byte[]</code>). Since this is very common, the file namespace provides both a <code>file:file-to-string-transformer</code> endpoint as well as a <code>file:file-to-bytes-transformer</code>. Finally, a common scenario is that people want to write <code>String</code> or <code>byte</code> array data to the file system. For this, the <code>file</code> namespace provides the <code>file:outbound-channel-adapter</code> adapter. These are all simply file IO-oriented implementations of the basic endpoints described before, e.g., adapters and transformers.</p><p>Spring Integration comes with many pre-packaged modules that support a wide range of functionality in terms of these very same endpoint types. Some of the modules that ship with the Spring Integration 2.0 include File IO, JDBC, RSS/ATOM, FTP/FTPS, SFTP, TCP/IP, RMI, HTTP, JMX, e-mail, IO streams, Twitter, XMPP, web services, HTTP/REST, XML, and JMS. While this list is extensive, it is not complete. There&rsquo;s much more support that is either coming, or provided as part of other Spring portfolio projects, including Gemfire support, AMQP support, workflow system integration based on work done with the Activiti BPMN 2 business process management project, Ajax/Comet-based support, Flex BlazeDS messaging-based support and much more.<br /><h3>A Simple Example</h3><br />Let&rsquo;s look at a simple example – that of a hypothetical online retailer (&ldquo;e-tailer&rdquo;!) that handles transactions on the website and enlists several third-party companies to help fulfill orders. In particular, we&rsquo;re going to look at the flow of the data from the purchase point on the website through to the shipping company. The integration is triggered by a JMS message that is sent from the service. The shipping company is not affiliated with the e-tailer, and expects all orders to be submitted through its web-service endpoint, so the trigger JMS message must be used to invoke a webservice endpoint. Finally, all jobs submitted to the third parties (in this case, the shipping company) need to be audited, so information should be recorded in a reporting-oriented audit table in our database.</p>
<div align="center">
<a href="http://blog.springsource.com/wp-content/uploads/2011/02/SpringIntegration600x233.png"><img title="SpringIntegration600x233" src="http://blog.springsource.com/wp-content/uploads/2011/02/SpringIntegration600x233.png" alt="Spring Integration Example Process" width="600" height="233" /></a>
<em>A diagram of the example integration solution - this diagram was generated by SpringSource Tool Suite</em>
</div><p><strong>Processing JMS messages</strong>: the first step is to receive messages from the JMS broker. We will use a Spring Integration inbound adapter – an endpoint that receives messages from JMS brokers - to connect the JMS broker to our application code in a simple, declarative way.</p><p>Spring Integration lets you process individual chunks of data, wrapped in a <code>org.springframework.integration.core.Message</code>. Data doesn’t just show up, it has to come from somewhere. To get data into and out of Spring Integration, you use inbound and outbound adapters, respectively. Adapters are a specialized type of endpoint that tell you when interesting things have happened in an external system and they tell you what has happened in the external system. Because adapters only take in data, or send it out, they are <em>unidrectional</em>.</p>
<pre><code class="prettyprint xml"><br />    &lt;int-jms:message-driven-channel-adapter
      channel=&quot;partnerNotifications&quot;
      connection-factory=&quot;connectionFactory&quot;
      transaction-manager=&quot;jmsTransactionManager&quot;
      acknowledge=&quot;transacted&quot;
       destination-name=&quot;${jms.partnernotifications.destination}&quot;
    /&gt;

    &lt;int:channel id=&quot;partnerNotifications&quot;/&gt;
</code></pre><p>We won&rsquo;t cover the specifics of the <code>connectionFactory</code> and <code>jmsTransactionManager</code> beans as they are standard Spring JMS-oriented beans and can be examined in the source code. Whenever a message appears on the JMS broker (in a JMS <code>destination</code>), Spring Integration will publish a <code>org.springframework.integration.Message</code> on the channel named <code>partnerNotifications</code> where it can be consumed.</p><p><strong>Invoking the Partner Webservice</strong>: The Message payload is an XML document in a String. We&rsquo;ll cover how it got that way shortly, but suffice it to say that it&rsquo;s already in a common XML format that the etailer&rsquo;s partners can use. The next step is to make a web service call to the shipping company. The flow is like this: the message comes in from the JMS adapter and its payload is used as the payload of a web service call. It’s enqueued in the <code>partnerNotifications</code> channel after it’s been received from the JMS adapter, and before it’s sent out as a web service call.</p><p>This represents a different type of endpoint, similar to an adapter, called a gateway. A gateway is bidirectional, and handles request/reply scenarios. An outbound gateway sends a request to an external system and awaits a reply from that external system, which is delivered to you (the requester) as an inbound message. The web service call produces a response for each request. The reply data is sent as a Spring Integration message on the <code>partnerXmlShippingReplies</code> channel.</p><p><strong>Updating the Audit Table</strong>: once we&rsquo;ve received the successful reply from the webservice call, we need to update our audit table. This audit table is a data warehouse-oriented table; it contains de-normalized records that can be used to trace progress of orders through the fulfillment system and to drive reporting and analytics. The reply message from the web service is a simple XML document, and it contains the information we need to feed into the audit table.</p><p>Message has two important parts to it: its headers, and its payload. In Spring Integration, a payload can be any type of object. Message headers are basically a series of key/value pairs in a <code>java.util.Map</code>. The header keys are <code>String</code>s, but the values can be of any type. Headers usually carry metadata about the payload that endpoints can rely on when processing the payload.</p><p>In our example, we need to extract the salient XML attributes and make them available as message headers which can be fed into a JDBC query to update the table. We&rsquo;ll use Spring Integration&rsquo;s <code>xml:xpath-header-enricher</code> to evaluate XPath expressions against the response from the webservice, and extract the resolved expressions as values for message headers. In the example below, we create three headers: <code>customerId</code>, <code>purchaseId</code>, and <code>date</code>.</p>
<pre><code class="prettyprint xml"><br />    &lt;int-xml:xpath-header-enricher input-channel=&quot;partnerXmlShippingReplies&quot; output-channel=&quot;partnerShippingReplies&quot;&gt;
        &lt;int-xml:header name=&quot;purchaseId&quot; xpath-expression=&quot;//@purchase-id&quot;/&gt;
        &lt;int-xml:header name=&quot;customerId&quot; xpath-expression=&quot;//@customer-id&quot;/&gt;
        &lt;int-xml:header name=&quot;date&quot; xpath-expression=&quot;//@confirmation-date&quot;/&gt;
    &lt;/int-xml:xpath-header-enricher&gt;

   &lt;int:channel id=&quot;partnerShippingReplies&quot;/&gt;
</code></pre><p>The <code>xml:xpath-header-enricher</code> is a transformer endpoint: the message comes in as a <code>Message</code> with an XML document payload and headers and leaves as a <code>Message</code> with the same XML document payload and three new headers, in addition to the ones that were already there. In this example, the output is published on the <code>partnerShippingReplies</code> channel.</p><p>Next, we send the message and the new headers to the <code>jdbc:outbound-channel-adapter</code> where it will be used to execute a JDBC insert.</p>
<pre><code class="prettyprint xml"><br />    &lt;int-jdbc:outbound-channel-adapter
        data-source=&quot;dataSource&quot;
        channel=&quot;partnerShippingReplies&quot; &gt;
        &lt;int-jdbc:query&gt;
INSERT INTO purchase_fulfillment_log(
    PURCHASE_ID, CUSTOMER_ID, EVENT_DATE, EVENT)
VALUES( :headers[purchaseId], :headers[customerId],
               :headers[date], &#39;SHIPPED&#39; )
        &lt;/int-jdbc:query&gt;
    &lt;/int-jdbc:outbound-channel-adapter&gt;
</code></pre><p>This is a complete, working integration. We used Java-based configuration to configure all the necessary beans, but needed no Java to handle any of the business logic itself – all the real processing logic lived inside of the 25 or so lines of Spring Integration namespace elements and relied on technologies you&rsquo;re more than likely already familiar with. The Spring Integration JMS adapter, for example, builds on the support for JMS available in core Spring. The outbound web services gateway builds the Spring Web Services stack (just as the outbound HTTP gateway builds on the <code>RestTemplate</code>). The XML support, generally, builds on the Spring OXM support. Finally, the outbound JDBC adapter builds on the Spring JDBC support (in the example, we could have supplied an instance of Spring&rsquo;s JdbcTemplate insead of a <code> javax.sql.DataSource</code>, for example).<br /><h2>Error Handling in Spring Integration</h2><br /><strong>Transactions </strong> In the example, we consume messages from JMS, send the message through a web service and then transform the response, writing it to a database. There are lots of moving parts here, and if something goes wrong, and you should be aware of the various mechanisms in play to deal with errors. With JMS and JDBC, common intuition is to use transactions to rollback in the event of some sort of failure. In the <code>jms:message-driven-channel-adapter</code> used in the example, the <code>transaction-manager</code> reference is optional, but works as you&rsquo;d expect it to when in play: any exception in the same thread as the transaction will cause the JMS message receipt to rollback. The thread-local transaction extends to all the components in Spring Integration that execute in the same thread, which in the case of this solution, encompasses everything.</p><p>To try it, shutdown the database and then run the solution again – it will attempt to consume messages from the JMS broker, invoke the web service, transform the reply and then hit the database where it will incur an exception which will cause the JMS receive operation to rollback and ultimately be re-queued in the JMS broker (in ActiveMQ, by default, the messages eventually end up in the <code>ActiveMQ.DLQ</code> queue, the dead letter queue).</p><p><strong>Building Consistency into your Architecture</strong> Thus, transactions are one way of dealing with error conditions, but they are of little help with resources that don&rsquo;t work with transactions, like web services. One way to work without transactions is to address the problem at the implementation level. A web service call, or a database call, for example, might be made to be idempotent: multiple invocations with the same inputs should yield the same output with no side effects, if possible. Updating a single row in a database with the same values is idempotent, for example: you may run the same statement 100 times and the worst that could happen is that you get the same (correct) result as if you had run the update 1 time.<br />Another way to handle errors is to implement compensatory logic. If both the producer and consumer of a message are in the same thread, then normal Java error-handling logic applies if something goes wrong: an exception is thrown and can be handled (as appropriate) by the sender. If, however, the producer and consumer are in different threads, then the normal rules don&rsquo;t apply. In those cases, there is no consumer to feed the exception back to. By default, Spring Integration catches the exception and forwards it as a Message with an exception as its payload to a well-known, automatically created channel called <code>errorChannel</code>. You can specify an alternative channel to which errors should be forwarded by specifying a message header with the key <code>MessageHeaders.ERROR_CHANNEL</code> in your code. It’s up to you to consume messages from that channel and react to them appropriately.<br /><h2>The Spring Integration Component Model</h2><br />So far we’ve built everything by relying on the out-of-the-box support that served our goals. You’ll find this is true most of the time - Spring Integration really is a good toolbox. Like a box of Lego bricks, you can put together seemingly infinite combinations of the modules to solve most problems. However, that doesn’t mean every problem has been solved. Spring Integration can’t know the specifics of your domain model, for example, and it can’t know the specifics of your business logic and services. Sometimes you want to drop down to Java and just plug in the correct behavior.</p><p>To support custom logic, Spring Integration supports generic, pluggable (in the core namespace) implementations of all the core components (<code>transformers</code>, <code>splitters</code>, <code>routers</code>, <code>adapters</code>, <code>aggregators</code>, etc.) and expect that you will provide the custom Java logic to fulfill the duties of the component. In addition, Spring Integration provides a <code>service-activator</code> component, which is a an escape-hatch component: you use it to stick in custom Java processing logic, no matter what the purpose of this code is. You can use the<code>service-activator</code> for anything you&rsquo;d like – perhaps you simply want to write a PDF to the file system using iText or to perform some sort of intrinsic business calculation? All of these custom components permit POJO implementations. They all work by invoking a method on a bean of your specification. There are no strict rules as to the shape and form of the methods, as Spring Integration is very flexible. Generally, however, you should imagine that the component will sit between other components and so must both accept as a parameter the inbound message and produce as its return type an outbound message. Message in, messsage out.</p><p>The method specification tends to vary a bit based on the type of component: a transformer might take in a message of one type and produce an outbound message of an entirely different, transformed type (naturally!). A splitter takes in a single message and produces a collection of messages as its return type. An aggregator works in reverse: it takes as its input parameter a collection of messages and returns as its output a single, aggregate message. The list goes on, and the details are of course available in the documentation. For our example, let&rsquo;s look at a servce-activator to demonstrate the flexibility in the method mapping. To use a service-activator, we must first declare it in the XML DSL, like this:</p>
<pre><code class="prettyprint xml"><br /> &lt;service-activator
      input-channel = &quot;in&quot;
      ref = &quot;helloWorldServiceActivator&quot; method = &quot;sayHello&quot;
      output-channel = &quot;out&quot; /&gt;
</code></pre><p>This example is typical: the input channel produces a message, the component processes it, and sends the result of the processing out on the output channel. Here, however, the processing logic is up to you to supply. The <code>ref</code> attribute specifies which bean should be employed to transform the inbound message. It also stipulates which method to use. If the bean in question had only method, or if the bean had multiple methods but only method annotated with Spring Integration’s <code>@ServiceActivator</code> annotation, then there is no need to stipulate a particular method in the XML as we have here. Let’s look at the first-cut implementation for such a <code>service-activator</code>.</p>
<pre><code class="prettyprint java"><br />@Component
public class HelloWorldServiceActivator {

 public Message&lt;String&gt; sayHello( Message&lt;String&gt; inboundMessage) {
 Map&lt;String,Object&gt; headers = inboundMessage.getHeaders();
 String payload = inboundMessage.getPayload();
 System.out.println( &quot;In the sayHello method, printing out the  &quot;+
 &quot;payload of the inbound message: &quot;+payload + &quot;. Also, there are &quot; +
 headers.size() + &quot; headers.&quot; ) ;
 return MessageBuilder.withPayload( inboundMessage.getPayload() )            .copyHeadersIfAbsent( inboundMessage.getHeaders() )            .build();
 }
}
</code></pre><p>The bean is simple: it&rsquo;s a simple POJO and declares a single method that takes in a Spring Integration message and returns its input as the output. You don&rsquo;t have to depend on Spring Integration&rsquo;s message type if you don&rsquo;t want to, however. Spring Integration has some smart heuristics and can automatically do the right thing on your behalf in many cases. Let’s rework the code for that method a bit to work in terms of the payloads, and not the Message wrapper class:</p>
<pre><code class="prettyprint java"><br />  public String sayHello( String inboundPayload) {
    //  ... same as before
  }
</code></pre><p>This code works the same as before, except that now it depends only the type of the <code>Message</code> payload. The headers are automatically copied for you. You can also declare a place for Spring Integration to put the message headers (which are in a <code>java.util.Map&lt;String,Object&gt;</code>), if you like, like this:</p>
<pre><code class="prettyprint java"><br />  public String sayHello( Map&lt;String,Object&gt; headers, String inboundPayload) {
    // ... same as before
  }
</code></pre><p>If you want to exercise more control over what gets put where, perhaps to avoid ambiguity, you can use Spring Integration&rsquo;s annotations. Let&rsquo;s use the annotations to rework the last example:</p>
<pre><code class="prettyprint java"><br />  public String sayHello( @Headers Map&lt;String,Object&gt; headers, @Payload String inboundPayload) {
    // ... same as before
  }
</code></pre><p>There is one more annotation - <code>@Header</code> - of particular use here that tells Spring Integration that you want only the value of one specific header injected into your method:</p>
<pre><code class="prettyprint java"><br />  public String sayHello( @Header(&quot;id&quot;) UUID idHeaderValue, @Payload String inboundPayload) {
    // ... same as before
  }
</code></pre><p>This reduces the complexity of your code and allows you to write expressive integration code. All the other components support this dynamic mapping capability just like <code>@ServiceActivator</code> and <code>service-activator</code>: <code>@Transformer</code> and <code>transformer</code>, <code>@Splitter</code> and <code>splitter</code>, <code>@Aggregator</code> and <code>aggregator</code>, <code>@Router</code> and <code>router</code>, etc.<br /><h2>Using Spring Integration From Your Services</h2><br />Spring Integration solutions do not need to always be kicked off by an adapter. You can launch them from Java code. The previous example was initiated by a JMS message – processing began whenever a JMS message was consumed.</p><p>Lets look at the other side of that exchange – the producer of the JMS message. In the previous example, we looked at processing messages sent when a customer checked out their shopping cart in online e-tailer.<br />Using the Spring Integration API In this section, we’ll look at how to produce that message from the shopping cart, transform it into XML and then send it to a JMS broker where the previous example is waiting to process it.</p>
<pre><code class="prettyprint java"><br />  @Autowired @Qualifier(&quot;partnerNotifications&quot;)
  private MessageChannel messageChannel ;

  @Override
  @Transactional
  public void checkout(long purchaseId) {
    Purchase purchase = getPurchaseById(purchaseId);

    if (purchase.isFrozen())
      throw new RuntimeException(&quot;you can&#39;t check out Purchase(#&quot; + purchase.getId() + &quot;) that&#39;s already been checked out!&quot;);

    Date purchasedDate = new Date();
    Set&lt;LineItem&gt; lis = purchase.getLineItems();
    for (LineItem lineItem : lis) {
      lineItem.setPurchasedDate(purchasedDate);
      entityManager.merge(lineItem);
    }
    purchase.setFrozen(true);
    entityManager.merge(purchase);

    Message&lt;Purchase&gt; msg = MessageBuilder.withPayload(purchase).build();
    this.messageChannel.send(msg);
  }
</code></pre><p>Most of that code is typical service-tier code – the only parts of interest to us are the use of the <code>MessageChannel</code>. <code>MessageChannel</code> is the runtime base type for the various Spring Integration channel types that we configured in the XML. Once you have a reference to a <code>MessageChannel</code>, it&rsquo;s simply a matter of sending a message through it. You can use a <code>MessageChannel</code> and directly interact with it to send and receive messages, just as you might use the low level JMS and AMQP APIs to send and receive messages.</p><p><code>Message</code> objects in Spring Integration are immutable - you don&rsquo;t create <code>Message</code> objects directly. Instead, use the <code>MessageBuilder</code> class and its static methods to build a Message. The <code>MessageBuilder</code> class contains methods to factory new Messages based on an existing payload and based on an existing Headers map. The API is fluid - method calls can be chained together. In this example, we use the <code>MessageBuilder</code> class to build a Message based on the <code>Purchase</code> object (a JPA entity that&rsquo;s local to the shopping cart domain model).</p><p>We afford ourselves a bit of indirection by using Spring Integration: we are free to change the course of the message later, in Spring Integration. The service code need not change, as it only interfaces with Spring Integration.</p><p>The JMS consumer (the one we established in the first example) is slower as it needs to make a costly web service call. By sending the notification to JMS and then letting some other, out-of-process integration handle the web-service invocation, we buy ourselves two things: the checkout service is faster, and the slow processing can be scaled out independently of the service. For example, the checkout service might be deployed in a web application, once per machine. The notification processing that invokes the web service on the other hand is just a simple <code>main(String[])</code> class, and could be run many times on the same box with no problem to meet load.<br /><h2>Summary</h2><br />We’ve explored the wide world of integration, and learned how to use Spring Integration to tie together different systems in a clean, flexible way. We’ve explored how Spring Integration benefits from its position on top of the core Spring framework - how it is a natural next step for Spring developers looking to tackle integration problems. In this post, we’ve also explored Spring Integration’s friendly Spring XML DSL-based, as well as its POJO-based, programming model. Users can find the source code for this, as well as all the other &ldquo;Green Beans&rdquo; posts, in our <a href="http://git.springsource.org/spring-community-examples/spring-community-examples/trees/master">Git-based community samples project</a> under the <a href="http://git.springsource.org/spring-community-examples/spring-community-examples/trees/master/spring-integration/getting-started-with-spring-integration">Getting Started with Spring Integration folder.</a></p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 399;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>
Back
</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">All Posts</a>
<a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">Engineering</a>
<a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">Releases</a>
<a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">News and Events</a>
<a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>Get updates from The Spring Team delivered to your inbox</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">Tools</a></li>
<li><a href="https://store.pivotal.io/">Store</a></li>
<li><a href="/blog">Newsletter</a></li>
</ul>
</div>
</div>
&copy; <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a>, Inc. All Rights Reserved.
<a href="https://pivotal.io/terms-of-use">Terms of Use</a> &bullet;
<a href="https://pivotal.io/privacy-policy">Privacy</a> &bullet;
<a href="/trademarks">Trademark Guidelines</a>
<div id="teconsent" style="display:inline-block;"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>