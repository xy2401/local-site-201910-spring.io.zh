<html  data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>倒计时Grails 2.0：数据库迁移</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Countdown to Grails 2.0: Database Migrations">
<meta name="twitter:description" content="<p>One of the many nice features of Grails is the way it will automatically create your database schema for you from your domain model. Admittedly it’s a feature of Hibernate that Grails uses, but still, it helps you get started very quickly with database-driven web applications without having to worry about the database schema.</p>
<p>What happens once your application moves to production? During development, losing the data in between server runs isn’t a big issue. But you can’t just drop the database in production. So that rules out the “create” and “create-drop” values for the <tt>dbCreate</tt> data source setting. What about “update”? It won’t clear the data from your database, so it’s often used by people. Yet it doesn’t work well for production because it has significant limitations. For example, it can’t handle simple column renames and it certainly can’t handle modifications to existing data that might be a necessary part of an upgrade. Although it’s tempting to use <tt>dbCreate = “update”</tt> for your deployments to production, it is usually the wrong solution.</p>
">

<meta property="og:title" content="Countdown to Grails 2.0: Database Migrations">
<meta property="og:description" content="<p>One of the many nice features of Grails is the way it will automatically create your database schema for you from your domain model. Admittedly it’s a feature of Hibernate that Grails uses, but still, it helps you get started very quickly with database-driven web applications without having to worry about the database schema.</p>
<p>What happens once your application moves to production? During development, losing the data in between server runs isn’t a big issue. But you can’t just drop the database in production. So that rules out the “create” and “create-drop” values for the <tt>dbCreate</tt> data source setting. What about “update”? It won’t clear the data from your database, so it’s often used by people. Yet it doesn’t work well for production because it has significant limitations. For example, it can’t handle simple column renames and it certainly can’t handle modifications to existing data that might be a necessary part of an upgrade. Although it’s tempting to use <tt>dbCreate = “update”</tt> for your deployments to production, it is usually the wrong solution.</p>
">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2011-08-17 16:05:00.0">
</head>
<body >

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">倒计时Grails 2.0：数据库迁移</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="null?s=20&d=mm"> <span class="author">彼得·莱德布鲁克</span>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2011-08-17 16:05:00.0">2011年8月17日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2011/08/17/countdown-to-grails-2-0-database-migrations#disqus_thread" data-disqus-identifier="432">
</a></div>
</div>
</header>
<div class="blog--post"><p>Grails的许多不错的功能之一就是它将通过域模型自动为您创建数据库架构的方式。诚然，这是Grails使用的Hibernate功能，但仍然可以帮助您非常快速地开始使用数据库驱动的Web应用程序，而不必担心数据库架构。</p><p>一旦您的应用程序投入生产，会发生什么？在开发期间，在服务器运行之间丢失数据不是大问题。但是您不能只将数据库投入生产。这样就排除了<tt>dbCreate</tt>数据源设置的“ create”和“ create-drop”值。那“更新”呢？它不会清除数据库中的数据，因此人们经常使用它。但是，由于存在很大的局限性，因此不适用于生产。例如，它不能处理简单的列重命名，当然也不能处理可能是升级的必要部分的对现有数据的修改。尽管将<tt>dbCreate =“ update”</tt>用于生产部署很诱人，但这通常是错误的解决方案。</p><p>那给你留下了什么？用于执行迁移的SQL脚本？当然可以，但是要为GORM域模型中的给定更改创建适当的SQL并不容易。如果需要支持多种数据库类型，则不合适，因为每种类型的SQL可能不同。</p><p>幸运的是，有一个灵活的，与数据库无关的工具可以执行模式迁移： <a href="http://www.liquibase.org/">Liquibase</a> 。更好的是，有两个Grails插件使使用Liquibase变得比以前容易一些： <a href="http://grails.org/plugin/liquibase">Liquibase插件</a>和<a href="http://grails.org/plugin/autobase">Autobase</a> 。</p><p>因此，如果这些插件已经存在很长时间了，那么Grails 2.0有什么新功能？数据库迁移是使用Grails进行任何重要工作的重要组成部分，因此Grails团队决定应该有一种正式的方式来处理它们。结果是一个新的插件，它结合了Liquibase和Autobase插件的最佳部分： <a href="http://grails.org/plugin/database-migration">Database Migration插件</a> 。</p>
<h2>简单来说</h2><p>即使核心数据库迁移支持是Grails 2.0路线图的一部分，也没有理由将其绑定到该版本。这意味着您也可以在Grails 1.3项目上使用该插件。该插件为您的应用程序带来了以下功能：</p>
<ul>
<li>声明式数据库架构和数据迁移</li>
<li>Groovy和XML迁移脚本</li>
<li>手动或自动执行迁移</li>
<li>自动跟踪已应用的迁移</li>
<li>通过区分域模型和数据库来生成迁移</li>
</ul><p>它提供了20多个命令，使您可以进行大量控制。您可以从该插件的<a href="https://grails-plugins.github.com/grails-database-migration/docs/manual/index.html">用户指南中</a>找到更多信息，但简单地说，它为管理Grails应用程序新版本的数据库的受控升级提供了很多帮助。如果需要，您仍然可以使用其他插件，甚至可以使用完全不同的方法，但是对于大多数用户而言，这绝对是正确的方法。</p><p>本文的其余部分将向您展示该插件的常用用法。</p>
<h2>入门</h2><p>假设您一直在努力使用Grails应用程序，现在您想将第一个版本部署到生产中。现在是时候考虑如何管理数据库升级了。此时，甚至还没有创建生产数据库。因此，将数据库迁移插件声明为运行时依赖项，如下所示：</p>
<pre><code class="prettyprint groovy">grails.project.dependency.resolution = {
    inherits &quot;global&quot;
    ...
    plugins {
        runtime &quot;:database-migration:1.0&quot;

        compile &quot;:hibernate:$grailsVersion&quot;
        compile &quot;:jquery:1.6.1.1&quot;
        compile &quot;:resources:1.0.2&quot;

        build &quot;:tomcat:$grailsVersion&quot;
    }
    ...
}
</code></pre><p>并运行<tt>grails进行编译</tt> 。在撰写本文时，1.0是该插件的最新版本。检查Grails <a href="http://grails.org/plugin/database-migration">插件门户，</a>以了解在任何给定时间的最新版本。</p><p>使用可用的插件，您可以开始数据库迁移之旅。正如我所说的，尚未创建生产数据库。您可以使用<tt>dbCreate</tt>值“ update”部署应用程序的初始版本，这样可以正常工作。但是出于稍后将讨论的原因，我希望鼓励您从数据库迁移变更日志（即迁移脚本）中初始化数据库。别担心，这比您想象的要少得多的工作。</p><p>诀窍是使用插件的命令之一为我们生成迁移脚本。首先，请确保您的“ prod”数据库为空，然后删除该<tt>环境的</tt>所有<tt>dbCreate</tt>设置。然后你跑<br></p><pre><br />grails dbm-create-changelog<br />grails prod dbm-generate-gorm-changelog &ndash;add changelog-1.0.groovy<br /></pre><p></p><p>（现在将是尝试新的Grails 2交互模式的好时机！）</p><p>上面的代码将创建<tt>grails-app / migrations / changelog.groovy</tt>文件，该文件将成为您的父changelog文件。然后，第二个命令生成迁移脚本<tt>grails-app / migrations / changelog-1.0.groovy</tt> ，它将获取一个空数据库并为该应用程序的当前版本创建适当的架构。父变更日志也已更新为包括此新日志。请注意，您的数据库将保持为空！</p><p>尽管Liquibase的目标是与数据库无关，但是最好在具有配置了适当类型的数据源（通常是“生产”）的Grails环境中运行各种generation和diff命令。这将确保您不必对生成的变更日志进行太多更改。</p><p></p><div class="callout">
<div class="callout-title">变更日志名称</div>
<br>该插件不会强制您为changelog文件名使用任何特定的命名约定。在本文中，我只是使用'changelog- <appversion>'，因此每个变更日志都与应用程序的特定版本绑定。效果很好。<br>
</appversion></div><p></p><p>为什么我们创建一个1.0变更日志而不使用“ update” <tt>dbCreate</tt>设置？初始变更日志意味着您可以将应用程序部署到一个新的空数据库中。所有迁移将按您期望的那样工作，因为它们将从已知的固定模式（即空模式）中按顺序运行。“更新”设置的麻烦在于，它将无法创建与当前域模型匹配的架构。较旧的变更日志根本不会运行，因为数据库未处于他们期望的状态！如果需要，您仍然可以对第一个应用程序版本使用“更新”，但是上述方法意味着您有机会尽早测试初始变更日志。</p><p>此时，它正在审查<tt>changelog-1.0.groovy</tt>文件，以查看迁移的外观以及是否需要更改任何内容。您可能会看到比实际需要更多的索引和约束，因此可能需要进行一些调整。</p><p>好的，现在我们有了迁移脚本。但是，当我们运行<tt>grails prod run-app时，</tt>该应用程序将无法启动：数据库仍然为空。为什么？迁移脚本不会在启动时自动运行，这意味着您要么必须使用<tt>dbm-update之</tt>类的命令手动更新数据库，要么在启动时启用迁移执行。我更喜欢后者，尤其是在很多情况下，您根本无法从Grails命令行访问生产数据库。因此，将这些设置添加到<tt>Config.groovy</tt>文件中：</p>
<pre><code class="prettyprint groovy">grails.plugin.databasemigration.updateOnStart = true
grails.plugin.databasemigration.updateOnStartFileNames = [&quot;changelog.groovy&quot;]
</code></pre><p>现在，当您启动应用程序时，迁移脚本将运行，您的应用程序将运行！当您重新启动服务器时，该插件将检测到迁移已在运行，因此将忽略它们。</p>
<h2>后续变更</h2><p>数据库迁移的全部目的是随着应用程序的发展和对过程的控制，对数据库进行更改。因此，现在想象您已经在应用程序上做了一些工作，并且想要发布一个新版本，也许是1.0.1。要升级生产数据库，您将需要为域模型更改创建一个更改日志。您可以手动执行此操作，但是可以通过使用数据库迁移插件的“ diff”命令来节省大量精力。</p><p>要执行差异，您需要一个数据库，插件可以将当前域模型与该数据库进行比较。同样，最好使用与生产中使用的数据库类型相同的数据库。同样，数据库必须处于其原始状态，即在进行当前一组域模型更改之前。换句话说，不要在启用<tt>dbCreate =“ update”</tt>的数据库上运行您的应用程序！实际上，值得为应用程序的每个版本创建一个数据库转储，以便您回滚以防万一您以这种方式意外更新数据库。</p><p>好的，足够的警告。让我们创建下一个变更日志：</p>
<pre><code class="prettyprint groovy">grails prod dbm-gorm-diff --add changelog-1.0.1.groovy
</code></pre><p>和以前一样，这将在迁移目录中创建一个<tt>changelog-1.0.1.groovy</tt>文件，并将其包含在父<tt>变更</tt>日志中。您还需要检查生成的变更日志并可能对其进行调整，但是编辑现有文件比从头开始创建新文件要容易得多。而已！现在，您可以将此更改日志以及相应的域类更改提交给版本控制。实际上，我建议您始终在同一提交中包括域类更改和相应的迁移脚本修改。</p><p>更改日志文件本身如下所示：</p>
<pre><code class="prettyprint groovy">databaseChangeLog = {
    changeSet(id: &quot;UpdateDescriminatorForPluginTabs&quot;, author: &quot;pledbrook&quot;) {
        update(tableName: &quot;content&quot;) {
            column name: &quot;class&quot;, value: &quot;org.grails.plugin.PluginTab&quot;
            where &quot;title like &#39;description-%&#39; and class = &#39;org.grails.wiki.WikiPage&#39;&quot;
        }
    }

    changeSet(id: &quot;IssuesUrlForPlugins&quot;, author: &quot;pledbrook&quot;) {
        addColumn(tableName: &quot;plugin&quot;) {
            column name: &quot;issues_url&quot;, type: &quot;varchar(255)&quot;, {
                constraints nullable: true
            }
        }
    }
}
</code></pre><p>如您所见，它们只是变更集的集合，其中每个变更集都包含一些数据库重构。每个变更集每个变更日志的每个作者都需要一个唯一的ID，以便Liquibase可以跟踪其是否已应用（Liquibase跟踪变更集，而不是变更日志！）。上面的示例演示了如何更新现有数据（id为“ UpdateDescriminatorForPluginTabs”）以及添加新列。其他受支持的重构包括：</p>
<ul>
<li>添加/重命名/修改列（模式更改）</li>
<li>添加索引</li>
<li>添加/重命名/修改表</li>
<li>添加/删除唯一约束</li>
</ul><p><a href="http://www.liquibase.org/manual/home">Liquibase手册</a>中描述了完整的重构范围，尽管所有示例都使用XML。幸运的是，XML-> Groovy的映射非常简单：</p>
<ol>
<li>XML元素-> Groovy方法</li>
<li>属性->命名参数</li>
<li>嵌套元素->闭包内的嵌套方法</li>
</ol><p>最后，您可能想知道如何构建变更日志。您应该为每个重构设置一个更改集吗？还是每个变更日志设置一个变更？还是介于两者之间？这取决于您，但是每个源代码管理提交的更改集都可以正常工作。换句话说，您为包含域模型更改的每个提交创建一个更改集。或者，您可能希望为每个数据库表设置一个更改集。做任何对您有用的事情。</p><p>这就是本文的全部内容。如您所见，适当的数据库迁移支持是任何生产数据库支持的Web应用程序的重要组成部分，因此，现在有了一个受官方支持且功能强大的插件可以满足这一需求，这是一个好消息。它仅适用于关系数据库（恐怕无法进行Redis，MongoDB等的迁移），但仍应满足绝大多数Grails用户的要求。继续尝试一下！</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 432;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>