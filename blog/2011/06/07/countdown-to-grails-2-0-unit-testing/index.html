<html  data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>倒计时Grails 2.0：单元测试</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Countdown to Grails 2.0: Unit testing">
<meta name="twitter:description" content="<p>The first milestone of Grails 1.4 <ins datetime=" 2011-06-30t17:06:58+00:0="="></head><body >(now 2.0) has now been released and we are on the last stages of the journey towards <del datetime="2011-06-30T17:06:58+00:00">1.4</del> 2.0 final. As we approach that point, I will be writing a series of blog posts that cover the various new features and changes that the <del datetime="2011-06-30T17:06:58+00:00">1.4</del> 2.0 version brings. I’ll be starting with the new testing support.
<p>Since the beginning, Grails has provided three levels of testing support for developers: unit, integration, and functional. Unit tests had and still have the benefit of running independently of Grails, but they typically required a fair bit of extra work in the form of mocking. The unit test framework introduced with Grails 1.1 helped with that mocking, but it still didn’t cover all use cases and so developers needed to resort to integration tests, which run inside a bootstrapped Grails instance, earlier than was desirable.</p>
">

<meta property="og:title" content="Countdown to Grails 2.0: Unit testing">
<meta property="og:description" content="<p>The first milestone of Grails 1.4 <ins datetime=" 2011-06-30t17:06:58+00:0="=">(now 2.0) has now been released and we are on the last stages of the journey towards <del datetime="2011-06-30T17:06:58+00:00">1.4</del> 2.0 final. As we approach that point, I will be writing a series of blog posts that cover the various new features and changes that the <del datetime="2011-06-30T17:06:58+00:00">1.4</del> 2.0 version brings. I’ll be starting with the new testing support.
<p>Since the beginning, Grails has provided three levels of testing support for developers: unit, integration, and functional. Unit tests had and still have the benefit of running independently of Grails, but they typically required a fair bit of extra work in the form of mocking. The unit test framework introduced with Grails 1.1 helped with that mocking, but it still didn’t cover all use cases and so developers needed to resort to integration tests, which run inside a bootstrapped Grails instance, earlier than was desirable.</p>
">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2011-06-07 09:12:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">倒计时Grails 2.0：单元测试</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="null?s=20&d=mm"> <span class="author">彼得·莱德布鲁克</span>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2011-06-07 09:12:00.0">2011年6月7日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2011/06/07/countdown-to-grails-2-0-unit-testing#disqus_thread" data-disqus-identifier="418">
</a></div>
</div>
</header>
<div class="blog--post"><p>Grails 1.4的第一个里程碑<ins datetime="2011-06-30T17:06:58+00:00"> （现在为2.0） </ins>现在已经发布，我们正处在迈向旅程的最后阶段<del datetime="2011-06-30T17:06:58+00:00"> 1.4 </del> 2.0最终版。当我们接近这一点时，我将撰写一系列博客文章，其中涵盖了<del datetime="2011-06-30T17:06:58+00:00"> 1.4 </del> 2.0版本带来。我将从新的测试支持开始。</p><p>从一开始，Grails就为开发人员提供了三个级别的测试支持：单元，集成和功能。单元测试曾经并且仍然具有独立于Grails进行运行的好处，但是它们通常需要大量的模拟形式的额外工作。Grails 1.1引入的单元测试框架帮助进行了这种模拟，但是它仍然不能涵盖所有用例，因此开发人员需要比期望的早一些方法来进行集成测试，该集成测试在自举的Grails实例中运行。</p><p>Grails 2.0引入了重大更改，可以大大改善这种情况：<br></p><ul><br><li>单元测试支持可以集成到任何测试框架中（没有更多的基类）；</li><br><li>它具有完整的内存GORM实施；和</li><br><li>它更好地支持测试REST操作，文件上传等。</li><br></ul><p></p><p>那么，这些更改对您来说是什么样的用户？</p>
<h2>继承死的那一天</h2><p>原始的单元测试支持是作为您自己的测试用例必须扩展的类的层次结构提供的，其根源为<tt>GrailsUnitTestCase</tt> 。这是JUnit早期的一种古老的模式，并且众所周知。最初对Grails也很有效。当人们切换到除JUnit 3之外的其他测试框架（例如Spock）时，问题就开始了，这也需要您继承基类： <tt>spock.lang。规格</tt> 。</p><p>众所周知，Java不支持多重继承，因此Spock的结果是基于<tt>Specification</tt>类的<tt>GrailsUnitTestCase</tt>层次结构的重复。不完全理想！</p><p>Grails 2.0通过注解提供了<tt>GrailsUnitTestCase</tt>及其家族最初提供的所有功能，从而解决了此问题。因此，对于简单的控制器单元测试，您现在具有如下代码：</p>
<pre><code class="prettyprint groovy">package org.example

import grails.test.mixin.*

@TestFor(PostController)
class PostControllerTests {
    void testIndex() {
        controller.index()
        assert &quot;/post/list&quot; == response.redirectedUrl
    }
    ...
}
</code></pre><p>如您所见， <tt>TestFor</tt>注释的添加立即使<tt>控制器</tt>变量和<tt>响应</tt>变量（以及其他变量）可用于您的测试。而这一切都无需<tt>扩展</tt>在眼前！更好的是，使用最新的Spock插件，您还可以执行以下操作：</p>
<pre><code class="prettyprint groovy">package org.example

import grails.test.mixin.*

@TestFor(PostController)
class PostControllerSpec extends spock.lang.Specification {
    def &quot;Index action should redirect to list page&quot;() {
        when: &quot;The index action is hit&quot;
        controller.index()

        then: &quot;The user should be redirected to the list action&quot;
        response.redirectedUrl == &quot;/post/list&quot;
    }
    ...
}
</code></pre><p>换句话说，无论使用哪种测试框架，都可以立即利用对单元测试支持的任何改进。如果需要，您仍然可以使用旧的<tt>GrailsUnitTestCase</tt>层次结构，但是它不支持任何新功能。因此，强烈建议您尽快将测试迁移到基于注释的机制。</p><p>我在说什么新功能？如何正确实施GORM。</p>
<h2>内存中GORM实施</h2><p>自从引入单元测试框架以来，它已经支持域类的模拟。这省去了您自己显式模拟各种动态方法的工作，例如<tt>save（）</tt>和<tt>list（）</tt> 。但是它从来都不是完整的GORM实施，用户必须知道其局限性才能有效使用它。特别是，必须手动模拟条件查询，并且新的GORM方法通常在模拟实现中滞后。</p><p>GORM API的引入改变了事情：现在可以实现该API并对照TCK检查该实现。只要TCK测试通过，该实现就符合GORM。由于noSQL可用于GORM，因此我们现在有了内存中的GORM实现，可用于单元测试。</p><p>那么，如何在测试中使用该GORM实现？简单！只需在新注释中声明要测试的域类即可： <tt>@Mock</tt> 。然后，您可以像在普通Grails代码中那样与这些域类的实例进行交互。例如，考虑我们正在测试的<tt>PostController</tt>的<tt>list</tt>动作。此操作将对<tt>Post</tt>域类执行查询，并且我们要确保它返回适当的域实例。通过新的单元测试支持，我们可以这样做：</p>
<pre><code class="prettyprint groovy">package org.example

import grails.test.mixin.*

@TestFor(PostController)
@Mock(Post)
class PostControllerTests {
    void testList() {
        new Post(message: &quot;Test&quot;).save(validate: false)
        def model = controller.list()

        assert model.postInstanceList.size() == 1
        assert model.postInstanceList[0].message == &quot;Test&quot;
        assert model.postInstanceTotal == 1
    }
}
</code></pre><p>突出显示了两个关键行： <tt>@Mock</tt>注释和<tt>Post.save（）</tt>行。前者确保<tt>Post</tt>表现得像普通的域类，而后者则保存新的<tt>Post</tt>实例。然后，该实例将由<tt>index</tt>动作执行的查询拾取。如您所见，不需要<tt>mockDomain（）</tt>方法，只需简单易懂的GORM代码即可。</p><p>您可能会问的一个问题是，为什么上面的示例在保存新的域实例时为什么使用<tt>validate：false</tt>选项？您必须记住，您正在尝试使用完整的GORM实施，因此默认情况下验证会生效。对于简单的域类来说，这不是问题，但是如果您也具有数十个属性和一些必需的关系该怎么办？建立有效的域实例图可能涉及大量工作，但是被测方法或操作只能访问域类的一个或两个属性。禁用验证将消除繁重的要求。</p><p>例如，假设<tt>Post</tt>域类具有类型为<tt>User</tt>的必需<tt>用户</tt>属性。现在， <tt>list</tt>动作根本不关心用户-只是返回帖子列表。但是启用验证后，您将必须创建一个虚拟<tt>User</tt>实例并将其附加到<tt>Post</tt>实例。将其扩展到复杂的域模型，您会发现在这种特殊情况下验证不是您的朋友。</p><p>这种“模拟” GORM实施甚至可以扩展到条件查询，因此您现在可以轻松地在单元测试用例中进行测试。而且由于我们拥有GORM TCK，因此对GORM的任何更改都将立即反映在模拟实现中。在Grails中使用域类进行单元测试从未如此简单！</p><p>在继续之前，还有一件事要注意。GORM实现尚不完全支持事务，因此，如果您有任何要测试的<tt>withTransaction</tt>块，您仍将不得不依赖集成或功能测试。这并不意味着您不能对使用<tt>withTransaction的</tt>代码进行单元测试-可以-但是您将无法可靠地测试事务语义。对于大多数人，特别是那些使用事务服务的人，这根本不是问题。</p><p>GORM模拟仅仅是对单元测试支持的一项改进。现在已经简化了过去很难解决的其他几种情况。</p>
<h2>其余的部分</h2><p>您是否曾经尝试过对JSON响应进行单元测试？谷物过滤器？标签库？尽管每种方法都有可能，但这并不是特别容易，并且常常需要相当多的嘲笑。Grails 2.0带来了许多更改，这些更改使此类测试（以及更多）变得非常容易。<a href="http://grails.org/doc/1.4.0.M1/guide/9. Testing.html#9.1 Unit Testing">用户指南</a>中记录了所有可能性，因此在这里我仅着重介绍一些可以激发您食欲的方案。</p>
<h3>测试XML / JSON响应</h3><p>随着REST如此广泛地出现，越来越多的Grails应用程序可能会使用“以XML / JSON形式呈现”选项。但是如何对这些进行单元测试？假设<tt>PostController</tt>的<tt>列表</tt>动作如下所示：</p>
<pre><code class="prettyprint groovy">    def list = {
        params.max = Math.min(params.max ? params.int(&#39;max&#39;) : 10, 100)

        def postList = Post.list(params)
        withFormat {
            html {
                [postInstanceList: postList, postInstanceTotal: Post.count()]
            }
            xml {
                render(contentType: &quot;application/xml&quot;) {
                    for (p in postList) {
                        post(author: p.author, p.message)
                    }
                }
            }
            json {
                render(contentType: &quot;application/json&quot;) {
                    posts = postList.collect { p -&gt;
                        return { message = p.message; author = p.author }
                    }
                }
            }
        }
    }
</code></pre><p>首先，您需要设置要测试的格式，以便<tt>withFormat</tt>选择适当的代码块。然后，您必须以某种方式检查是否生成了正确的JSON字符串。通过自动注入到控制器单元测试用例中的<tt>响应</tt>属性，可以轻松实现这两个目标：</p>
<pre><code class="prettyprint groovy">    void testListWithJson() {
        new Post(message: &quot;Test&quot;, author: &quot;Peter&quot;).save()
        response.format = &quot;json&quot;
        controller.list()

        assert response.text == &#39;{&quot;posts&quot;:[{&quot;message&quot;:&quot;Test&quot;,&quot;author&quot;:&quot;Peter&quot;}]}&#39;
    }
</code></pre><p>当然，比较字符串通常很脆弱。对于上面的小JSON响应来说很好，但是如果控制器突然在JSON响应中包含<tt>dateCreated</tt>属性，该怎么办？以上测试将立即失败。那可能就是您想要的，但是也许您对是否包含<tt>dateCreated</tt>并不感兴趣？</p><p>幸运的是，您还可以询问JSON响应，就好像它是对象的层次结构而不是纯字符串。<tt>响应</tt>对象具有<tt>json</tt>和<tt>xml</tt>属性，它们是基础JSON或XML的对象表示形式：</p>
<pre><code class="prettyprint groovy">    void testListWithJson() {
        ...
        assert response.json.posts.size() == 1
        assert response.json.posts[0].message == &quot;Test&quot;
    }
</code></pre><p>这可以使您的单元测试更具可维护性和鲁棒性，并且可以通过仅查看JSON或XML文档的一部分来测试大型响应。</p>
<h3>标签库</h3><p>对于自定义标签，生活肯定变得更加轻松。您可以在之前对其进行测试，但是必须手动<tt>模拟</tt>对另一个标记的任何调用，例如，通过<tt>mockFor（）</tt> 。对于简单标签来说，这很好，但是对于较复杂的标签，它很快就会成为负担。</p><p>那有什么变化？首先，单元测试现在看起来更像是集成测试，因为您可以将<tt>applyTemplate（）</tt>方法与要测试的标记的标记形式一起使用。其次，您不必模拟对其他自定义标签的调用。标准Grails标记将正常工作，您可以通过使用相关的<tt>TagLib</tt>类简单地调用<tt>mockTagLib（）</tt>来启用其他标记。</p><p>例如，考虑以下非常简单的标记：</p>
<pre><code class="prettyprint groovy">package org.example

class FirstTagLib {
    static namespace = &quot;f&quot;

    def styledLink = { attrs, body -&gt;
        out &lt;&lt; &#39;&lt;span class=&quot;mylink&quot;&gt;&#39; &lt;&lt; s.postLink(attrs, body) &lt;&lt; &#39;&lt;/span&gt;&#39;
    }
}

class SecondTagLib {
    static namespace = &quot;s&quot;

    def postLink = { attrs, body -&gt;
        out &lt;&lt; g.link(controller: &quot;post&quot;, action: &quot;list&quot;, body)
    }
}
</code></pre><p>的<tt><f:styledlink></f:styledlink></tt>标签调用<tt><s:postlink></s:postlink></tt>一，这反过来称为标准<tt><g:link></g:link></tt>标签。因此，如果我们要测试<tt><f:styledlink></f:styledlink></tt>标签，我们模拟<tt>SecondTagLib</tt>以确保<tt><s:postlink></s:postlink></tt>是可操作的，然后像下面这样执行<tt>applyTemplate（）</tt> ：</p>
<pre><code class="prettyprint groovy">package org.example

import grails.test.mixin.*

@TestFor(FirstTagLib)
class FirstTagLibTests {
    void testStyledLink() {
        mockTagLib(SecondTagLib)
        assert applyTemplate(&#39;&lt;f:styledLink&gt;Test&lt;/f:styledLink&gt;&#39;) == &#39;&lt;span class=&quot;mylink&quot;&gt;&lt;a href=&quot;/post/list&quot;&gt;Test&lt;/a&gt;&lt;/span&gt;&#39;
    }
}
</code></pre><p>如您所见，Grails为您完成了很多繁重的工作，确保标记调用链可以像在应用程序中那样正常工作。您需要牢记的一件事是，诸如<tt><g:link></g:link></tt>将假定servlet上下文为“”，因此，为什么上面的示例检查<tt>href</tt>值为“ / post / list”而不是“ / my-app / post / list”。</p><p>这些只是改进的单元测试支持的两个示例。其他包括：<br></p><ul><br><li>谷物过滤器</li><br><li>文件上传</li><br><li>命令对象</li><br><li>视图和模板渲染</li><br></ul><br>如您所见，Grails代码中很少有部分现在无法进行单元测试。<p></p>
<h2>结论</h2><p>测试一直是应用程序开发的重要组成部分，测试的简便性直接影响测试范围：编写测试越容易，开发人员编写它们的可能性就越大。这就是Grails 2.0发行版中的单元测试更改如此重要的原因。对于过去比较棘手的场景，它们使编写单元测试变得更加容易。这样，普通Grails应用程序的测试范围可能会增加，并且开发人员最终将获得更强大的应用程序。</p><p>所有这些使单元测试改进成为Grails 2.0最重要的功能之一，并且是进行升级的引人注目的理由。因此，请下载最新的2.0版本，并尝试一下！</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 418;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>