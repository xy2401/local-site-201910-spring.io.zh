<html  data-code-prettify="" data-mobile-support="" data-search=""><head></head><body >﻿
<title>绿豆：Spring MVC入门</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Green Beans: Getting Started with Spring MVC">
<meta name="twitter:description" >
<meta property="og:title" content="Green Beans: Getting Started with Spring MVC">
<meta property="og:description" >
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2011-01-04 12:55:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">绿豆：Spring MVC入门</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="null?s=20&d=mm"> <span class="author">科林·桑帕林（Colin Sampaleanu）</span>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2011-01-04 12:55:00.0">2011年1月4日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2011/01/04/green-beans-getting-started-with-spring-mvc#disqus_thread" data-disqus-identifier="374">
</a></div>
</div>
</header>
<div class="blog--post"><p><a href="http://static.springsource.org/spring/docs/3.0.x/reference/mvc.html">Spring MVC</a>是Spring核心框架的一部分，是一个成熟且功能强大的动作响应样式Web框架，具有多种功能和选项，旨在处理各种以UI为重点和非以UI为重点的Web层用例。 。所有这些都可能使Spring MVC新手不知所措。我认为对这个观众来说，展示一个裸Spring MVC应用程序的启动和运行是一件多么有用的事（例如，考虑我的示例类似于<em>世界上最简单的Spring MVC应用程序</em> ），这是有用的，其余的我将花在这上面本文论证。</p><p>我假设您熟悉Java，Spring（ <a href="http://blog.springsource.com/2010/11/09/green-beans-putting-the-spring-in-your-step-and-application/">基本的依赖项注入概念</a> ）和基本的Servlet编程模型，但是不了解Spring MVC。阅读此博客文章后，读者可以通过查看Keith Donald的<a href="http://blog.springsource.com/2010/07/22/spring-mvc-3-showcase/">Spring MVC 3 Showcase</a>或涵盖Spring和Spring MVC的各种其他在线和印刷资源，继续学习Spring MVC。</p><p>有关依赖项和构建系统的注释：本文不假定您使用的是特定的构建系统，例如Maven，Gradle或Ant。本文末尾包含一个相当少的Maven POM示例文件作为示例。</p><p>Spring MVC包含与其他所谓的Web MVC框架相同的大多数基本概念。传入的请求通过<em>前端控制器</em>进入框架。对于Spring MVC，这是一个实际的Java Servlet，称为<code>DispatcherServlet</code> 。考虑到<code>DispatcherServlet</code>作为看门人。它不执行任何实际的Web或业务逻辑，而是委托到称为<em>Controllers的</em> POJO进行实际工作的完成（整体或通过后端）。完成工作后， <em>Views</em>负责以正确的格式（无论是JSP页面，Velocity模板还是JSON响应）产生输出。<em>策略</em>用于确定哪个Controller（以及该Controller内部的哪个方法）处理请求，以及哪个View呈现响应。弹簧容器用于将所有这些部件连接在一起。一切看起来像这样：</p><p><a href="http://blog.springsource.com/wp-content/uploads/2010/11/mvc.png"><img class="alignnone size-full wp-image-6144" title="多媒体" src="http://blog.springsource.com/wp-content/uploads/2010/11/mvc.png" alt="" width="600" height="513"></a><br></p><h3>引导DispatcherServlet和Spring容器</h3><br>如前所述，所有传入请求都流经<code>DispatcherServlet</code> 。像Java EE应用程序中的任何其他Servlet一样，我们告诉Java EE容器在Web应用程序启动时通过Web应用程序中的来加载此Servlet。 <code>WEB-INF/web.xml</code> 。的<code>DispatcherServlet</code>还负责加载Spring <code>ApplicationContext</code>用于执行连接和托管组件的依赖关系注入。在此基础上，我们为Servlet指定了一些用于配置应用程序上下文的初始化参数。我们来看一下<code>web.xml</code> ：<p></p><p><code>WEB-INF/web.xml</code><br>XML</p><p><!--?xml version="“1.0”" encoding="“UTF-8”?"--><br><web-app href="http://java.sun.com/xml/ns/javaee" version="“2.5”" xmlns="“<a">http://java.sun.com/xml/ns/javaee”<br>xmlns：xsi =“ <a href="https://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</a> ”<br>xsi：schemaLocation =“ <a href="http://java.sun.com/xml/ns/javaee">http://java.sun.com/xml/ns/javaee</a> <a href="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd">http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd”</a></web-app><!--?xml--></p>
<pre><code class="prettyprint">&lt;!-- Processes application requests --&gt;
&lt;servlet&gt;
    &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
       &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
       &lt;param-value&gt;/WEB-INF/spring/appServlet/servlet-context.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;appServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre><p><br>```</p><p>这里有很多事情要做：<br></p><ul><br> <li>我们将DispatcherServlet注册为称为的Servlet。<code>appServlet</code></li><br> <li>我们将此Servlet映射为处理以“ /”开头的传入请求（相对于应用程序路径）</li><br> <li>我们使用<code>ContextConfigLocation</code> init参数可为DispatcherServlet加载的Spring Application Context自定义基本配置XML文件的位置，而不是依赖于<em><servletname>-context.xml</servletname></em>的默认位置。</li><br></ul><br><em>等待，如果有人不想通过XML配置Spring怎么办？</em><p></p><p>DispatcheServlet加载的应用程序上下文的默认类型希望至少在具有Spring bean定义的XML文件上加载。如您所见，我们还将使Spring能够与XML一起加载基于Java的配置。</p><p>每个人在这方面都会有自己的观点（有时非常强烈），但是尽管我通常更喜欢基于Java的配置，但我确实相信，对于某些领域来说，在某些领域使用少量的XML配置有时仍会更有意义。原因（例如无需重新编译即可更改配置的能力，XML名称空间的简洁性，可工具性等）。在此基础上，此应用将使用混合方法，同时支持Java和XML。</p><p>请放心，如果您更喜欢纯Java方法，而根本没有Spring XML，则通过在其中设置一个init参数可以很简单地实现。 <code>web.xml</code>覆盖默认的应用程序上下文类型，并使用称为<code>AnnotationConfigWebApplicationContext</code>代替。<br></p><h3>控制器</h3><br>现在让我们创建一个最小的控制器：<p></p>
<pre><code class="prettyprint java"><br />package xyz.sample.baremvc;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

/**
 * Handles requests for the application home page.
 */
@Controller
public class HomeController {

	@RequestMapping(value = &quot;/&quot;)
	public String home() {
		System.out.println(&quot;HomeController: Passing through...&quot;);
		return &quot;WEB-INF/views/home.jsp&quot;;
	}
}
</code></pre><p>让我们遍历该类的关键方面：<br></p><ul><br> <li>该类已使用<code>@Controller</code>注释，表明这是一个能够处理Web请求的Spring MVC控制器。因为<code>@Controller</code>是Spring的专业<code>@Component</code> <em>构造型</em>注释，该类将作为容器组件扫描过程的一部分由Spring容器自动检测，创建一个bean定义，并允许实例像其他任何Spring托管组件一样进行依赖项注入。</li><br> <li>的<code>home</code>方法已用注释<code>@RequestMapping</code>注释，指定此方法应处理对路径“ /”（即应用程序的<em>原始</em>路径）的Web请求。</li><br> <li>的<code>home</code>方法只是将消息记录到系统中，然后返回<code>WEB-INF/views/home.jsp</code> ，指示应处理响应的视图，在本例中为JSP页面。（如果对包括WEB-INF前缀的整个视图路径进行硬编码，并且认为它是JSP，这对您来说似乎是错误的，那您是对的。我们稍后再处理）</li><br></ul><br>现在，我们需要创建视图。此JSP页面将仅打印问候语。<p></p><p><code>WEB-INF/views/home.jsp</code><br>html</p><p><％@ taglib uri =“ <a href="http://java.sun.com/jsp/jstl/core">http://java.sun.com/jsp/jstl/core</a> ”前缀=“ c”％><br><％@页面会话=“ false”％><br><br> <br> <title>家</title><br> <br> <br> </p><h1>你好，世界！</h1><br> <br><br>```<p></p><p>最后，如前所述，我们需要创建一个最小的Spring Application Context定义文件。</p><p><code>WEB-INF/spring/appServlet/servlet-context.xml</code><br>XML</p><p><!--?xml version="“1.0”" encoding="“UTF-8”?"--><br><beans href="http://www.springframework.org/schema/beans" xmlns="“<a">http://www.springframework.org/schema/beans”<br>xmlns：xsi =“ <a href="https://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</a> ”<br>xmlns：mvc =“ <a href="http://www.springframework.org/schema/mvc">http://www.springframework.org/schema/mvc</a> ”<br>xmlns：context =“ <a href="http://www.springframework.org/schema/context">http://www.springframework.org/schema/context</a> ”<br>xsi：schemaLocation =“<br> <a href="http://www.springframework.org/schema/mvc">http://www.springframework.org/schema/mvc</a> <a href="http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd">http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd</a><br> <a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a> <a href="http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</a><br> <a href="http://www.springframework.org/schema/context">http://www.springframework.org/schema/context</a> <a href="http://www.springframework.org/schema/context/spring-context-3.0.xsd">http://www.springframework.org/schema/context/spring-context-3.0.xsd“</a></beans><!--?xml--></p>
<pre><code class="prettyprint">&lt;!-- DispatcherServlet Context: defines this servlet&#39;s request-processing infrastructure --&gt;

&lt;!-- Scans within the base package of the application for @Components to configure as beans --&gt;
&lt;!-- @Controller, @Service, @Configuration, etc. --&gt;
&lt;context:component-scan base-package=&quot;xyz.sample.baremvc&quot; /&gt;

&lt;!-- Enables the Spring MVC @Controller programming model --&gt;
&lt;mvc:annotation-driven /&gt;
</code></pre><p><br>```</p><p>让我们检查该文件的内容：<br></p><ul><br> <li>您会注意到，使用了几种不同的Spring XML名称空间： <em>context</em> ， <em>mvc</em>和默认<em>bean</em></li><br> <li>该<context:component-scan>声明确保Spring容器进行组件扫描，以便任何带有注释的代码<code>@Component</code>诸如<code>@Controller</code>被自动发现。您会注意到，为了提高效率，我们将（ <code>xyz.sample.baremvc</code>在这种情况下）Spring应该在类路径中扫描包空间的哪一部分</context:component-scan></li><br> <li>该<mvc:annotation-driven>声明设置了Spring MVC对将请求路由到@Controller的支持，以及如何处理诸如转换，格式化和验证之类的事情（基于类路径中存在的（库）具有一些合理的默认值）以及覆盖的能力如果需要的话）</mvc:annotation-driven></li><br></ul><br>Web应用程序现在可以运行了。假设将Servlet容器（在我的情况下为tc Server）设置为在localhost：8080上侦听，启动应用程序，然后访问URL <code><a href="http://localhost:8080/baremvc">http://localhost:8080/baremvc</a></code>通过我们的浏览器显示预期的问候：<br><a href="http://blog.springsource.com/wp-content/uploads/2010/11/hello-world.png"><img class="alignnone size-full wp-image-6254" title="你好，世界" src="http://blog.springsource.com/wp-content/uploads/2010/11/hello-world.png" alt="" width="605" height="378"></a><p></p><p>尽管微不足道，但运行此应用程序涉及正常工作的Spring MVC应用程序的所有主要部分。让我们看一下主要的序列和组件交互：<br></p><ul><br> <li>当Web应用程序启动时，由于在其中输入了DispatcherServlet并进行了初始化<code>web.xml</code> 。</li><br> <li>DispatcherServlet加载基于注释的应用程序上下文，该上下文已配置为通过指定基础包的正则表达式来扫描带注释的组件。</li><br> <li>容器会检测带注释的组件，例如HomeController。</li><br> <li>HTTP请求<code><a href="http://localhost:8080/baremvc">http://localhost:8080/baremvc</a></code>到达这个servlet引擎和路由到我们的<em>（baremvc）</em>的web应用。</li><br> <li>URL末尾的隐式“ /”路径与为DispatcherServlet注册的正则表达式匹配，并将请求路由到该正则表达式。</li><br> <li>DispatcherServlet需要决定如何处理请求。它使用一种叫做<em>战略</em> <code>HandlerAdapter</code>决定将请求路由到何处。可以自定义要使用的特定HandlerAdapter类型（或多个类型，因为它们可以链接），但是默认情况下，使用基于注释的策略，该策略将请求适当地路由到注释为的类中的特定方法<code>@Controller</code> ，基于中的匹配条件<code>@RequestMapping</code>在这些类中找到的注释。在这种情况下，将匹配<em>home</em>方法上的正则表达式，并调用它来处理请求。</li><br> <li><em>home</em>方法可以完成其工作，在这种情况下，只是将某些内容打印到系统中。然后，它返回一个提示字符串（在这种情况下，这是一个非常明确的字符串， <code>WEB-INF/views/home.jsp</code> ）以帮助选择“视图”来呈现响应。</li><br> <li>DispatcherServlet再次依赖于一种称为“ <code>ViewResolver</code>决定哪个View负责呈现响应。可以根据应用程序的需要进行配置（以简单或链接的方式），但是默认情况下， <code>InternalResourceViewResolver</code>用来。这是一个非常简单的视图解析器，它会产生一个<code>JstlView</code>它只是委派给Servlet引擎的内部<code>RequestDispatcher</code>渲染，因此适合与JSP页面或HTML页面一起使用。</li><br> <li>Servlet引擎通过指定的JSP呈现响应</li><br></ul><br><h3>将其带入新的高度</h3><br>至此，我们已经有了一个可以肯定<em>是世界上最简单的Spring MVC应用程序的应用程序</em> ，但是坦率地说，它并没有真正符合该描述的精神。让我们将事物发展到另一个层次。<p></p><p>如前所述，将视图模板的路径硬编码到控制器中是不合适的，就像我们的控制器当前所做的那样。控制器关注点<em>分离的</em>一个示例是，控制器和视图之间的关系更加松散，更具<em>逻辑</em>性，控制器专注于执行某些Web或业务逻辑，并且通常不了解诸如视图路径或JSP之类的特定细节。这样可以实现控制器和视图的更大程度的重用，并且可以使彼此分离的情况下更轻松地进行开发，并且可能需要不同的人员来处理每种类型的代码。</p><p>本质上，理想情况下，控制器代码需要类似于此变体，其中返回纯逻辑视图名称（无论是简单的还是复合的）：</p>
<pre><code class="prettyprint java"><br />//...
@Controller
public class HomeController {

	@RequestMapping(value = &quot;/&quot;)
	public String home() {
		System.out.println(&quot;HomeController: Passing through...&quot;);
		return &quot;home&quot;;
	}
}
</code></pre><p>春季MVC <code>ViewResolver</code> <em>策略</em>实际上是用于实现控制器和视图之间这种松散耦合的机制。如前所述，在没有应用程序配置特定<code>ViewResolver</code> ，Spring MVC会设置默认的最低配置<code>InternalResourceViewResolver</code> ，这是一个非常简单的视图解析器，可以生成<code>JstlView</code> 。我们可能还可以使用其他视图解析器，但是为了获得更好的去耦水平，我们实际要做的就是设置自己的实例。 <code>InternalResourceViewResolver</code>略微调整配置。 <code>InternalResourceViewResolver</code>采用非常简单的策略；它只是获取控制器返回的视图名称，并在其前面添加一个可选的前缀（默认为空），并为其添加一个可选的后缀（默认为空），然后将该结果路径输入到<code>JstlView</code>它创建。的<code>JstlView</code>然后委托给Servlet引擎<code>RequestDispatcher</code>做真实的工作，即渲染模板。因此，允许控制器返回逻辑视图名称，例如<code>home</code>而不是像这样的特定视图模板路径<code>WEB-INF/views/home.jsp</code> ，我们只需要使用前缀配置此视图解析器<code>WEB-INF/views</code>和后缀<code>.jsp</code> ，以便将它们分别添加到控制器返回的逻辑名称之前并添加到其后。</p><p>配置视图解析器实例的一种简单方法是引入使用Spring的基于Java的容器配置，并将解析器作为bean定义：</p>
<pre><code class="prettyprint java"><br />package xyz.sample.baremvc;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.ViewResolver;
import org.springframework.web.servlet.view.InternalResourceViewResolver;

@Configuration
public class AppConfig {

	// Resolve logical view names to .jsp resources in the /WEB-INF/views directory
	@Bean
	ViewResolver viewResolver() {
		InternalResourceViewResolver resolver = new InternalResourceViewResolver();
		resolver.setPrefix(&quot;WEB-INF/views/&quot;);
		resolver.setSuffix(&quot;.jsp&quot;);
		return resolver;
	}
}
</code></pre><p>我们已经在进行组件扫描，因此<code>@Cofiguration</code>本身就是<code>@Component</code> ，这个新的配置定义（其中包含（解析器）bean）将由Spring容器自动获取。然后，Spring MVC扫描所有bean并找到解析器。</p><p>这是一种很好的方法，但是有些人可能更喜欢将解析器配置为XML定义文件中的Bean，例如</p>
<pre><code class="prettyprint xml"><br />	&lt;!-- Resolve logical view names to .jsp resources in the /WEB-INF/views directory --&gt;
	&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
		&lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot; /&gt;
		&lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
	&lt;/bean&gt;
</code></pre><p>很难为此目的证明一种特定的方法要比另一种方法好得多，因此在这种情况下，这实际上是个人喜好问题（而且我们实际上可以看到Spring的优势之一，即它的灵活性）。<br></p><h3>处理用户输入</h3><br>几乎所有的Web应用程序都需要从客户端获取一些输入，对其进行处理，然后返回或呈现结果。有很多方法可以获取到Spring MVC应用程序中的输入，也有很多方法可以呈现结果，但是至少让我们展示一个变体。在这个简单的示例中，我们将修改HomeController以添加一个新的处理程序方法，该方法接受两个字符串输入，将它们进行比较，然后返回结果。<p></p>
<pre><code class="prettyprint java"><br />package xyz.sample.baremvc;

import java.util.Comparator;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;

/**
 * Handles requests for the application home page.
 */
@Controller
public class HomeController {

	@Autowired
	Comparator&lt;String&gt; comparator;

	@RequestMapping(value = &quot;/&quot;)
	public String home() {
		System.out.println(&quot;HomeController: Passing through...&quot;);
		return &quot;home&quot;;
	}

	@RequestMapping(value = &quot;/compare&quot;, method = RequestMethod.GET)
	public String compare(@RequestParam(&quot;input1&quot;) String input1,
			@RequestParam(&quot;input2&quot;) String input2, Model model) {

		int result = comparator.compare(input1, input2);
		String inEnglish = (result &lt; 0) ? &quot;less than&quot; : (result &gt; 0 ? &quot;greater than&quot; : &quot;equal to&quot;);

		String output = &quot;According to our Comparator, &#39;&quot; + input1 + &quot;&#39; is &quot; + inEnglish + &quot;&#39;&quot; + input2 + &quot;&#39;&quot;;

		model.addAttribute(&quot;output&quot;, output);
		return &quot;compareResult&quot;;
	}
}
</code></pre><p>新代码中的关键元素：<br></p><ul><br> <li>我们正在使用另一个<code>@RequestMapping</code>批注以使请求以路径结尾<code>/compare</code>对新的<em>比较</em>方法</li><br> <li>我们期望调用方将两个String输入参数作为GET请求的一部分传递给我们，因此我们可以通过<code>@RequestParam</code>注解。请注意，我们依赖于此批注的默认处理，假定这些参数是必需的。如果缺少客户端，则客户端将收到HTTP 400错误。还要注意，这只是将参数传递给Spring MVC应用程序的一种方法。例如，很容易获取作为请求URL路径本身的一部分嵌入的参数，从而获得一种更具REST风格的方法</li><br> <li>我们使用Comparator实例比较两个字符串</li><br> <li>我们将比较结果填充到键下的<em>Model</em>对象中<code>result</code> ，以便视图可以访问它。用最简单的术语将模型视为美化的哈希图。</li><br></ul><br>虽然我们可以将exisitng视图修改为也可以用来显示比较结果，但是我们使用的是新的视图模板：<p></p><p><code>WEB-INF/views/compareResult.jsp</code><br>html</p><p><％@ taglib uri =“ <a href="http://java.sun.com/jsp/jstl/core">http://java.sun.com/jsp/jstl/core</a> ”前缀=“ c”％><br><％@页面会话=“ false”％><br><br> <br> <title>结果</title><br> <br> <br> </p><h1><c:out value="“${output}”"></c:out></h1><br> <br><br>```<p></p><p>最后，我们需要为控制器提供一个<code>Comparator</code>实例使用。我们已经注释了<code>comparator</code> Spring的控制器中的字段<code>@Autowired</code>注释（将在检测到控制器后自动检测到），并指示Spring容器注入<code>Comparator</code>进入那个领域。因此，我们需要确保该容器有一个可用的容器。为此，最小的<code>Comparator</code>实现已创建，仅执行不区分大小写的比较。为简单起见，该类本身已用Spring的注释<code>@Service</code> <em>刻板印象</em>注释，一种<code>@Component</code>因此，在容器的组件扫描过程中，Spring容器会自动检测到它，并将其注入到控制器中。</p>
<pre><code class="prettyprint java"><br />package xyz.sample.baremvc;

import java.util.Comparator;
import org.springframework.stereotype.Service;

@Service
public class CaseInsensitiveComparator implements Comparator&lt;String&gt; {
	public int compare(String s1, String s2) {
		assert s1 != null &amp;&amp; s2 != null;
		return String.CASE_INSENSITIVE_ORDER.compare(s1, s2);
	}
}
</code></pre><p>注意，我们可以通过基于Java的容器在容器中声明它的一个实例<code>@Bean</code>在一个定义<code>@Configuration</code>类或基于XML的bean定义，当然，在许多情况下，由于它们提供了更高的控制级别，因此这些变体可能是首选。</p><p>现在，我们可以启动应用程序并使用诸如<br><code><a href="http://localhost:8080/baremvc/compare?input1=Donkey&input2=dog">http://localhost:8080/baremvc/compare?input1=Donkey&input2=dog</a></code><br>执行新代码：</p><p><a href="http://blog.springsource.com/wp-content/uploads/2020/11/compareResult.png"><img class="alignnone size-full wp-image-7058" title="compareResult" src="http://blog.springsource.com/wp-content/uploads/2020/11/compareResult.png" alt="" width="600" height="204"></a><br></p><h3>下一步</h3><br>我真的只是从头开始了解Spring MVC的功能，但是希望这篇博客文章给您一个想法，让您可以轻松地使用Spring MVC，以及框架中的一些核心概念如何结合在一起。在这一点上可能还需要提到，为了使人们更容易理解核心概念，我的样本中有一些（希望非常明显）的区域没有像在较大区域或较大区域那样处理。例如，在生产应用程序中，在Java代码或某些包组织中对消息进行硬编码。<p></p><p>现在，我鼓励您学习和体验Spring MVC的完整功能集和综合功能，包括在请求到控制器和方法的映射，数据绑定和验证，语言环境和主题支持以及可定制的常规功能等方面处理几乎所有适合行动响应模型的网络层用例。</p><p>在此学习过程中，对您来说有价值的资源是Keith Donald的<a href="http://blog.springsource.com/2010/07/22/spring-mvc-3-showcase/">Spring MVC 3 Showcase</a> ，其中包括显示Spring MVC大部分功能的工作代码，您可以轻松地将其加载到<a href="http://www.springsource.com/developer/sts">SpringSource Tool Suite</a> （STS）或另一个Eclipse环境中并进行试验。顺便说一句，如果您不熟悉STS，我应该提到它是用于测试Spring技术集的绝佳工具，因为它对Spring的强大支持以及现成的项目模板等功能。在<a href="http://s3.springsource.org/MVC/mvc-in-sts-screencast.mp4">这段简短的录像中</a> ，我演示了如何通过STS模板使用新的Spring MVC应用程序。<br></p><h3>附录-依赖关系</h3><br>不管您使用哪个构建系统，以上代码都应该起作用（这些天，我通常更喜欢Gradle或Maven）。这是构建该项目的相对最小的Maven POM示例文件，可以用作基础项目或了解需要哪些依赖项。实际上，它并不是最小的，因为我已经明确切换了SLF4J的commons-logging，并添加了一些可选的存储库和Maven插件。唯一不明显的项目可能是对CGLIB的需要，这是使用@Configuration时Spring所需的可选依赖项。<p></p>
<pre><code class="prettyprint xml"><br />&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;
	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
	&lt;groupId&gt;xyz.sample&lt;/groupId&gt;
	&lt;artifactId&gt;baremvc&lt;/artifactId&gt;
	&lt;name&gt;Sprring MVC sample project&lt;/name&gt;
	&lt;packaging&gt;war&lt;/packaging&gt;
	&lt;version&gt;1.0.0-BUILD-SNAPSHOT&lt;/version&gt;
	&lt;properties&gt;
		&lt;java-version&gt;1.6&lt;/java-version&gt;
		&lt;org.springframework-version&gt;3.0.6.RELEASE&lt;/org.springframework-version&gt;
		&lt;org.slf4j-version&gt;1.6.1&lt;/org.slf4j-version&gt;
	&lt;/properties&gt;
	&lt;dependencies&gt;
		&lt;!-- Spring --&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework&lt;/groupId&gt;
			&lt;artifactId&gt;spring-context&lt;/artifactId&gt;
			&lt;version&gt;${org.springframework-version}&lt;/version&gt;
			&lt;exclusions&gt;
				&lt;!-- Exclude Commons Logging in favor of SLF4j --&gt;
				&lt;exclusion&gt;
					&lt;groupId&gt;commons-logging&lt;/groupId&gt;
					&lt;artifactId&gt;commons-logging&lt;/artifactId&gt;
				 &lt;/exclusion&gt;
			&lt;/exclusions&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework&lt;/groupId&gt;
			&lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
			&lt;version&gt;${org.springframework-version}&lt;/version&gt;
		&lt;/dependency&gt;

		&lt;!-- CGLIB, only required and used for @Configuration usage --&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;cglib&lt;/groupId&gt;
			&lt;artifactId&gt;cglib-nodep&lt;/artifactId&gt;
			&lt;version&gt;2.2&lt;/version&gt;
		&lt;/dependency&gt;

		&lt;!-- Logging --&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.slf4j&lt;/groupId&gt;
			&lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
			&lt;version&gt;${org.slf4j-version}&lt;/version&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.slf4j&lt;/groupId&gt;
			&lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt;
			&lt;version&gt;${org.slf4j-version}&lt;/version&gt;
			&lt;scope&gt;runtime&lt;/scope&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.slf4j&lt;/groupId&gt;
			&lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
			&lt;version&gt;${org.slf4j-version}&lt;/version&gt;
			&lt;scope&gt;runtime&lt;/scope&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;log4j&lt;/groupId&gt;
			&lt;artifactId&gt;log4j&lt;/artifactId&gt;
			&lt;version&gt;1.2.16&lt;/version&gt;
			&lt;scope&gt;runtime&lt;/scope&gt;
		&lt;/dependency&gt;

		&lt;!-- @Inject --&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;javax.inject&lt;/groupId&gt;
			&lt;artifactId&gt;javax.inject&lt;/artifactId&gt;
			&lt;version&gt;1&lt;/version&gt;
		&lt;/dependency&gt;

		&lt;!-- Servlet --&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;javax.servlet&lt;/groupId&gt;
			&lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
			&lt;version&gt;2.5&lt;/version&gt;
			&lt;scope&gt;provided&lt;/scope&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
			&lt;artifactId&gt;jsp-api&lt;/artifactId&gt;
			&lt;version&gt;2.1&lt;/version&gt;
			&lt;scope&gt;provided&lt;/scope&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;javax.servlet&lt;/groupId&gt;
			&lt;artifactId&gt;jstl&lt;/artifactId&gt;
			&lt;version&gt;1.2&lt;/version&gt;
		&lt;/dependency&gt;

		&lt;!-- Test --&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;junit&lt;/groupId&gt;
			&lt;artifactId&gt;junit&lt;/artifactId&gt;
			&lt;version&gt;4.7&lt;/version&gt;
			&lt;scope&gt;test&lt;/scope&gt;
		&lt;/dependency&gt;

	&lt;/dependencies&gt;
	&lt;repositories&gt;
		&lt;repository&gt;
			&lt;id&gt;org.springframework.maven.release&lt;/id&gt;
			&lt;name&gt;Spring Maven Release Repository&lt;/name&gt;
			&lt;url&gt;http://maven.springframework.org/release&lt;/url&gt;
			&lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt;
			&lt;snapshots&gt;&lt;enabled&gt;false&lt;/enabled&gt;&lt;/snapshots&gt;
		&lt;/repository&gt;
		&lt;!-- For testing against latest Spring snapshots --&gt;
		&lt;repository&gt;
			&lt;id&gt;org.springframework.maven.snapshot&lt;/id&gt;
			&lt;name&gt;Spring Maven Snapshot Repository&lt;/name&gt;
			&lt;url&gt;http://maven.springframework.org/snapshot&lt;/url&gt;
			&lt;releases&gt;&lt;enabled&gt;false&lt;/enabled&gt;&lt;/releases&gt;
			&lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt;
		&lt;/repository&gt;
		&lt;!-- For developing against latest Spring milestones --&gt;
		&lt;repository&gt;
			&lt;id&gt;org.springframework.maven.milestone&lt;/id&gt;
			&lt;name&gt;Spring Maven Milestone Repository&lt;/name&gt;
			&lt;url&gt;http://maven.springframework.org/milestone&lt;/url&gt;
			&lt;snapshots&gt;&lt;enabled&gt;false&lt;/enabled&gt;&lt;/snapshots&gt;
		&lt;/repository&gt;
	&lt;/repositories&gt;
	&lt;build&gt;
		&lt;plugins&gt;
			&lt;plugin&gt;
				&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
				&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
				&lt;configuration&gt;
					&lt;source&gt;${java-version}&lt;/source&gt;
					&lt;target&gt;${java-version}&lt;/target&gt;
				&lt;/configuration&gt;
			&lt;/plugin&gt;
			&lt;plugin&gt;
				&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
				&lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;
				&lt;configuration&gt;
					&lt;warName&gt;baremvc&lt;/warName&gt;
				&lt;/configuration&gt;
			&lt;/plugin&gt;
			&lt;plugin&gt;
				&lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
				&lt;artifactId&gt;tomcat-maven-plugin&lt;/artifactId&gt;
				&lt;version&gt;1.1&lt;/version&gt;
			&lt;/plugin&gt;
		&lt;/plugins&gt;
	&lt;/build&gt;
&lt;/project&gt;
</code></pre></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 374;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>