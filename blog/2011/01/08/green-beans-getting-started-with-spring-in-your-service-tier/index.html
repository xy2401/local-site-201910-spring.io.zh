<html dir="ltr" data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>绿豆：服务层中的Spring入门</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>System.config({baseURL: "/b92013b"});</script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>System.import('app/main.js')</script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Green Beans: Getting Started with Spring in your Service Tier">
<meta name="twitter:description" content="<p>All applications stem from a domain model. The term “domain model” describes the nouns, or data, in a system that is important to the problem you’re trying to solve. The service tier - where business logic lives - manipulates the application data and must ultimately persist it (typically, in a database). The explanation is simple, but in practice building a good service tier can be a daunting task for any developer. This post will introduce developers to the options available in the Spring framework for building a better service tier. It is assumed that the reader has some experience with the SQL language, and - more critically - that the reader is familiar with <a href=" http: ="" blog.springsource.com="" 2010="" 11="" 09="" green-beans-putting-the-spring-in-your-step-and-application="" ="="></meta>basic Spring dependency injection and configuration concepts. The source code for this project is in the <a href=" git.springsource.org spring-samples trees master showcases green-beans building-a-better-service-tier"></head><body dir="ltr">Spring Samples project under SpringSource’s Git repository. 
">
<meta name="twitter:creator" content="@starbuxman">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=200">

<meta property="og:title" content="Green Beans: Getting Started with Spring in your Service Tier">
<meta property="og:image" content="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=200">
<meta property="og:description" content="<p>All applications stem from a domain model. The term “domain model” describes the nouns, or data, in a system that is important to the problem you’re trying to solve. The service tier - where business logic lives - manipulates the application data and must ultimately persist it (typically, in a database). The explanation is simple, but in practice building a good service tier can be a daunting task for any developer. This post will introduce developers to the options available in the Spring framework for building a better service tier. It is assumed that the reader has some experience with the SQL language, and - more critically - that the reader is familiar with <a href=" http: ="" blog.springsource.com="" 2010="" 11="" 09="" green-beans-putting-the-spring-in-your-step-and-application="" ="="></meta>basic Spring dependency injection and configuration concepts. The source code for this project is in the <a href=" git.springsource.org spring-samples trees master showcases green-beans building-a-better-service-tier">Spring Samples project under SpringSource’s Git repository. 
">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2011-01-08 00:42:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">// Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }</script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">绿豆：服务层中的Spring入门</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=20&d=mm"> <a class="author" rel="author" href="/team/jlong">乔什·朗（Josh Long）</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2011-01-08 00:42:00.0">2011年1月8日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2011/01/08/green-beans-getting-started-with-spring-in-your-service-tier#disqus_thread" data-disqus-identifier="385">
</a></div>
</div>
</header>
<div class="blog--post"><p>所有应用程序都来自领域模型。术语“域模型”描述了系统中的名词或数据，该系统对您要解决的问题很重要。业务逻辑所在的服务层操纵着应用程序数据，并且必须最终将其持久化（通常在数据库中）。解释很简单，但是在实践中，建立良好的服务层对于任何开发人员而言都是艰巨的任务。这篇文章将向开发人员介绍Spring框架中可用的选项，以建立更好的服务层。假定读者具有一定的SQL语言经验，并且更为重要的是，读者熟悉<a href="http://blog.springsource.com/2010/11/09/green-beans-putting-the-spring-in-your-step-and-application/">基本的Spring依赖项注入和配置概念</a> 。该项目的源代码位于SpringSource的Git存储库下的<a href="http://git.springsource.org/spring-samples/spring-samples/trees/master/showcases/green-beans/building-a-better-service-tier">Spring Samples</a>项目中。</p>
<h2>名词和动词</h2><p>服务层描述系统中的动词（动作）。领域模型描述了名词（数据）。Grails和Spring Roo等工具可以通过查看域模型来自动推断和生成业务对象。这种方法称为模型驱动的开发，可以为高度交互的应用程序开发提供很大的帮助。了解构建基块最终将帮助您使用Spring Roo之类的工具来提高生产力。在这篇文章中，我们将构建一个服务来处理符合以下规则的客户数据：</p>
<ol>
<li>一个人只有从企业购买了东西，才是顾客。</li>
<li>一个人的购买称为购买，其中包含订单项。</li>
<li>订单项是给定订单的购买产品的记录。</li>
</ol><p>这种数据-具有较少记录计数的链接数据-很适合关系数据库管理系统（通常称为RDBMS）。RDBMS通过将域模型映射到表来工作。我们的服务表如下图所示：</p><p><img class="size-full wp-image-7102 " title="关于建立更好的服务层，Green Beans中的CRM系统的ERD图" src="http://blog.springsource.com/wp-content/uploads/2011/01/erd.jpg" alt="关于建立更好的服务层，Green Beans中的CRM系统的ERD图" width="495" height="354"> </p>
<h2>设置数据库</h2><p>我们的实现将所有数据存储在称为H2的RDBMS中。您当然可以自由选择喜欢的数据库。这篇文章将使用一些简单的数据库表作为示例。这些表的H2数据定义语言（DDL）脚本在源代码（ <a href="http://git.springsource.org/spring-samples/spring-samples/blobs/master/showcases/green-beans/building-a-better-service-tier/src/main/resources/crm.sql"><code>src/main/resources/crm.sql</code></a> ）中<a href="http://git.springsource.org/spring-samples/spring-samples/blobs/master/showcases/green-beans/building-a-better-service-tier/src/main/resources/crm.sql"><code>src/main/resources/crm.sql</code></a> 。DDL很简单，并且可以通过少量调整使其在大多数数据库中工作。如果您想使用H2，请按照以下说明进行设置（如果尚未设置）。否则，请随时跳到下一节“域模型”。H2是一个轻量级的嵌入式内存SQL数据库，可以快速设置和运行。首先，请从<a href="http://www.h2database.com">H2主页</a>下载最新发行版。选择您喜欢的发行版（Windows或“所有平台”），尽管出于本文的目的，我们将使用“所有平台”发行版。将发行版解压缩到您喜欢的文件夹中。在命令行上，导航到发行版中的bin文件夹，然后运行适合您平台的shell脚本（对于Windows为h2.bat，对于Unix或Linux环境为h2.sh）以启动数据库进程并启动一个shell，您可以用于与数据库进行交互。在“ JDBC URL：”字段中输入以下内容： <code>jdbc:h2:<a href="tcp://127.0.0.1/~/crm_example">tcp://127.0.0.1/~/crm_example</a></code> （不带引号），其余部分保持不变，然后单击“连接”按钮。通过在浏览器中打开URL <code><a href="http://localhost:8082/login.jsp">http://localhost:8082/login.jsp</a></code>来打开数据库控制台。H2可以是嵌入式的（相对于我们在此处作为服务器运行而言），但是像在此处将其用作服务器一样，可以提供更丰富的体验。登录后，您将可以在H2控制台中尝试查询。</p>
<h2>领域模型</h2><p>描述您的域模型的代码应尽可能避免持久性问题。理想情况下，您将能够使用干净的，面向对象的术语来描述域模型。我们的域模型的代码是：</p>
<pre><code class="prettyprint java"><br>package org.springsource.examples.crm.model;
…
public class Customer implements java.io.Serializable {
    private Long id;
    private String firstName;
    private String lastName;
    private Set purchases = new HashSet();
    // constructors, and accessor / mutator pairs omitted for brevity
}
</code></pre><p>客户实体具有对<code>Purchase</code>的引用，其定义为：</p>
<pre><code class="prettyprint java">package org.springsource.examples.crm.model;
…
public class Purchase implements java.io.Serializable {
    private Long id;
    private Customer customer;
    private double total;
    private Set lineItems = new HashSet();
    // constructors, and accessor / mutator pairs omitted for brevity
}
</code></pre><p>采购又引用了<code>LineItems</code>的集合，这些集合定义为：</p>
<pre><code class="prettyprint java">package org.springsource.examples.crm.model;
…
public class LineItem implements java.io.Serializable {
    private Long id;
    private Purchase purchase;
    private Product product;
    // constructors, and accessor / mutator pairs omitted for brevity
}
</code></pre><p>最后， <code>LineItem</code>引用一个<code>Product</code> 。<code>Product</code>是库存中某物的定义，定义如下：</p>
<pre><code class="prettyprint java">package org.springsource.examples.crm.model;
…
public class Product implements java.io.Serializable {
    private Long id;
    private String description;
    private String name;
    private double price;
    private Set lineItems = new HashSet();
    // constructors, and accessor / mutator pairs omitted for brevity
}
</code></pre>
<h2>建立客户资料库</h2><p>因此，我们的首要任务是建立一个存储库对象以保留<code>Customer</code>记录。现在，我们将忽略域模型中的其他实体。存储库应使用户与用于处理持久性的原始API隔离开。输入和输出应该是域模型对象，而不是较低级别的持久性原语。让我们看一下我们<code>Customer</code>库的界面。</p>
<pre><code class="prettyprint java">package org.springsource.examples.crm.services.jdbc.repositories;
import org.springsource.examples.crm.model.Customer;

public interface CustomerRepository {
  Customer saveCustomer(Customer customer) ;
  Customer getCustomerById(long id);
}
</code></pre><p>我们将使用JDBC构建存储库。JDBC（Java数据库连接API）是作为Java平台的一部分提供的标准数据库连接框架。它的使用有据可查，并且所有主要的供应商都以JDBC驱动程序的形式提供其数据库的连接性。这似乎使JDBC自然地开始构建存储库。但是，实际上，直接的JDBC实现可能很乏味。</p>
<pre><code class="prettyprint java">package org.springsource.examples.crm.services;
import org.springsource.examples.crm.model.Customer;

public interface CustomerService {
    Customer getCustomerById(long id);
    Customer createCustomer(String fn, String ln);
}
</code></pre><p>因为直接使用JDBC可能非常繁琐，所以我们不会对其进行过多探讨。我们鼓励您检查本文的源代码，在其中我们建立了一个直接的JDBC存储库，该存储库需要150多行令人眼花lines乱的代码来处理我们将要介绍的内容，包括线程安全以及资源获取和销毁。</p><p>相反，让我们介绍一个称为<code>JdbcTemplate</code>的Spring框架类，该类大大简化了基于JDBC的开发。</p><p>首先，我们已经设置了一个标准的Spring XML文件，该文件又设置了类路径组件扫描，并为文件<code>database.properties</code>属性引入了属性占位符解析。我们不会在此处重印XML，因为它已经在源代码中了（本文的示例XML文件在<a href="http://git.springsource.org/spring-samples/spring-samples/trees/master/showcases/green-beans/building-a-better-service-tier/src/main/resources"><code>src/main/resources</code></a> ），并且代表了非常基本的Spring配置。Spring类路径组件扫描又选择了Java配置类，这是我们将在本文中重点介绍和扩展的内容。基本的通用Java配置类称为<code>CrmConfiguration</code> ，如下所示。<code>CrmConfiguration</code>类仅配置一个<code>javax.sql.DataSource</code> 。</p>
<pre><code class="prettyprint java">package org.springsource.examples.crm.services.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.*;
import org.springframework.jdbc.datasource.SimpleDriverDataSource;
import javax.sql.DataSource;

@Configuration
public class CrmConfiguration {
    @Value("${dataSource.driverClassName}")
    private String driverName;

    @Value("${dataSource.url}")
    private String url;

    @Value("${dataSource.user}")
    private String user;

    @Value("${dataSource.password}")
    private String password;

    @Bean
    public DataSource dataSource() {
        SimpleDriverDataSource simpleDriverDataSource = new SimpleDriverDataSource();
        simpleDriverDataSource.setPassword(this.password);
        simpleDriverDataSource.setUrl(this.url);
        simpleDriverDataSource.setUsername(this.user);
        simpleDriverDataSource.setDriverClass(org.h2.Driver.class);
        return simpleDriverDataSource;
    }
}
</code></pre><p>为了有效地使用JDBC，我们将使用Spring的<code>JdbcTemplate</code>来减少样板代码。<code>JdbcTemplate</code>将我们与资源管理隔离开来，并大大简化了JDBC API的使用。以下是<code>CustomerRepository</code>接口的基于<code>JdbcTemplate</code>的实现的配置。在配置中，我们定义了<code>JdbcTemplate</code>的实例。</p>
<pre><code class="prettyprint java">package org.springsource.examples.crm.services.jdbc;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.support.TransactionTemplate;
import org.springsource.examples.crm.services.config.CrmConfiguration;

import javax.sql.DataSource;

@Configuration
public class JdbcConfiguration extends CrmConfiguration {
    @Bean
    public JdbcTemplate jdbcTemplate() {
        DataSource ds = dataSource(); // this comes from the parent class
        return new JdbcTemplate(ds);
    }
}
</code></pre><p>以下是基于<code>JdbcTemplate</code>的<code>CustomerRepository</code>实现。</p>
<pre><code class="prettyprint java">package org.springsource.examples.crm.services.jdbc.repositories;

import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.simple.SimpleJdbcInsert;
import org.springframework.stereotype.Repository;
import org.springframework.util.Assert;
import org.springsource.examples.crm.model.Customer;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

@Repository
public class JdbcTemplateCustomerRepository implements CustomerRepository, InitializingBean {

  @Value("${jdbc.sql.customers.queryById}")
  private String customerByIdQuery;

  @Value("${jdbc.sql.customers.insert}")
  private String insertCustomerQuery;

  @Autowired
  private JdbcTemplate jdbcTemplate;

  public Customer getCustomerById(long id) {
    return jdbcTemplate.queryForObject(customerByIdQuery, customerRowMapper, id);
  }

  public Customer saveCustomer(Customer customer) {

    SimpleJdbcInsert simpleJdbcInsert = new SimpleJdbcInsert(jdbcTemplate);
    simpleJdbcInsert.setTableName("customer");
    simpleJdbcInsert.setColumnNames(Arrays.asList("first_name", "last_name"));
    simpleJdbcInsert.setGeneratedKeyName("id");

    Map<String, Object> args = new HashMap<String, Object>();
    args.put("first_name", customer.getFirstName());
    args.put("last_name", customer.getLastName());

    Number id = simpleJdbcInsert.execute(args);
    return getCustomerById(id.longValue());
  }

  public void afterPropertiesSet() throws Exception {
    Assert.notNull(this.jdbcTemplate, "the jdbcTemplate can't be null!");
    Assert.notNull(this.customerByIdQuery, "the customerByIdQuery can't be null");
    Assert.notNull(this.insertCustomerQuery, "the insertCustomerQuery can't be null");
  }

  private RowMapper<Customer> customerRowMapper = new RowMapper<Customer>() {

    public Customer mapRow(ResultSet resultSet, int i) throws SQLException {
      long id = resultSet.getInt("id");
      String firstName = resultSet.getString("first_name");
      String lastName = resultSet.getString("last_name");
      return new Customer(id, firstName, lastName);
    }
  };
}
</code></pre><p>在这个例子中的仓储类与@Repository，这是Spring框架<em>的刻板印象</em>注释，相当于注释（除了在一些小的方面，我们不用担心在这里）Spring框架<code>@Component</code> <em>构造型</em>注释。在这个特定示例中，我们可以轻松使用<code>@Component</code> 。</p><p>第一种方法<code>getCustomerById(long)</code> –使用<code>jdbcTemplate</code>实例发出查询。<code>JdbcTemplate</code>的<code>query</code>将SQL语句作为第一个参数，并将<code>RowMapper<T></code>的实例作为第二个参数<code>RowMapper<T></code> 。RowMapper是一个Spring接口，客户端可以实现该接口，以将结果集数据映射到对象（在这种情况下，是<code>Customer</code>实例）。对于返回结果集中的每一行， <code>JdbcTemplate</code>将调用<code>mapRow(ResultSet,int)</code> 。</p><p>RowMapper实例是无状态的（因此：线程安全），并且应该为映射客户记录的任何其他查询缓存。在SQL字符串和RowMapper实例之后， <code>jdbcTemplate.queryForObject</code>方法支持Java 5的varargs语法，用于将参数以数字顺序绑定到查询：第一个变量参数绑定到第一个“？”在查询中，第二到第二个“？”，依此类推。</p><p>第二种方法插入一条记录（简单），然后检索新插入的记录的ID。我们使用<code>SimpleJdbcInsert</code>对象描述我们的表，所需的参数，然后以与数据库无关的方式执行插入。</p><p>现在，我们有了一个可以正常工作的存储库。该存储库是一个哑对象。它不了解事务，也不了解业务逻辑。业务对象利用存储库实现并对其进行编排。业务对象具有“全局”，其中存储库仅关心持久化域模型。在决定去哪里时，请记住这一点。</p><p>首先，让我们检查我们的<code>CustomerService</code>接口。</p>
<pre><code class="prettyprint java">package org.springsource.examples.crm.services;
import org.springsource.examples.crm.model.Customer;

public interface CustomerService {
    Customer getCustomerById(long id);
    Customer createCustomer(String fn, String ln);
}
</code></pre><p>这似乎类似于存储库界面，并且可能会怀疑为什么应该使用存储库。应该理解，服务关心业务状态，而不关心应用程序状态。服务关心业务事件。如果存储库涉及将<code>Customer</code>记录保存到数据库中的机制（例如），则服务会关心确保<code>Customer</code>记录处于有效状态，并且<code>Customer</code>尚未（例如）已经注册该公司的免费产品试用活动。因此，尽管服务和存储库似乎都具有一种似乎可以“创建客户”的方法，但它们应该有很大的不同，并且应仅关注目标。考虑到这一点，让我们看一下我们基于JDBC的简单CustomerService实现。</p>
<pre><code class="prettyprint java">package org.springsource.examples.crm.services.jdbc.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springsource.examples.crm.model.Customer;
import org.springsource.examples.crm.services.CustomerService;
import org.springsource.examples.crm.services.jdbc.repositories.CustomerRepository;

@Service
public class JdbcCustomerService implements CustomerService {

  @Autowired
  private CustomerRepository customerRepository;

  public Customer getCustomerById(long id) {
    return this.customerRepository.getCustomerById(id);
  }

  public Customer createCustomer(String fn, String ln) {
    Customer customer = new Customer(fn, ln);
    return this.customerRepository.saveCustomer(customer);
  }
}
</code></pre><p>这项服务很简单。正如我们对存储库所做的那样，我们使用Spring注释<code>@Service</code>型<code>@Service</code>对该服务进行注释。这个注释比<code>@Component,</code>更好地传达了类的意图<code>@Component,</code>但是没有理由不能使用<code>@Component</code> 。典型的服务应具有比存储库更细粒度的方法，因此通常会看到具有多个存储库的服务在起作用。该服务协调了多个存储库。这意味着服务需要确保跨多个存储库，跨多个客户端的状态一致。不难想象，不一致的国家会带来怎样的灾难。假设您有一项服务，该服务代表电子商务站点中的用户管理购物车结帐。当用户单击“提交订单”时，服务需要从库存中预留购物车中的所有行项目，并从用户帐户中扣除费用。如果同时有另一个用户尝试签出相同的商品（不幸的是，该商品仅剩一个库存）并且足够快地完成结账，那么第一个用户将为商家无法交付的商品付款上！</p>
<h2>交易次数</h2><p>这种情况很常见，也是数据库支持事务处理概念的原因。事务在数据库中划分活动块，并缓冲该活动期间的所有更改。数据库将保持不变，直到事务中的<em>所有</em>操作无意外执行且事务已<em>提交</em>为止。如果另一个客户端读取事务中被改变的数据，该客户端将“看”的对象和记录，因为他们开始交易<em>之前</em> 。在第一个事务提交之前，这些相同的客户端将无法对数据库进行更改。事务可确保并发读取之间的状态一致。</p><p>单个操作（可能是查询和更新）转换为单个<code>jdbcTemplate</code>调用。通过使用Spring的<code>TransactionTemplate</code>和Spring的PlatformTransactionManager层次结构的实例，可以使这些单独的调用共享同一事务。然后， <code>TransactionTemplate</code>根据需要使用事务管理器启动和提交事务。Spring框架提供<code>TransactionTemplate</code>来提供事务同步。我们的服务仅使用一种事务性资源<code>javax.sql.DataSource</code>因此，一个<code>DataSourceTransactionManager</code>实例就足够了。将以下内容添加到<code>JdbcConfiguration</code>类中。</p>
<pre><code class="prettyprint java">    @Bean
    public PlatformTransactionManager transactionManager() {
        DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager();
        dataSourceTransactionManager.setDataSource(this.dataSource());
        return dataSourceTransactionManager;
    }

    @Bean
    public TransactionTemplate transactionTemplate() {
        TransactionTemplate tt = new TransactionTemplate();
        tt.setTransactionManager( this.transactionManager() );
        return tt;
    }
</code></pre><p>使用事务模板来执行服务类中应包含在事务中的逻辑。该服务的代码的重要部分显示如下。</p>
<pre><code class="prettyprint java"><br>    @Autowired 
    private TransactionTemplate transactionTemplate; 

     public Customer getCustomerById(final long id) {
        return this.transactionTemplate.execute(new TransactionCallback() {
            public Customer doInTransaction(TransactionStatus status) {
               // … all the same business logic as before
            }
        });
    }

    public Customer createCustomer( final String firstName, final String lastName) {
        return this.transactionTemplate.execute(new TransactionCallback() {
            public Customer doInTransaction(TransactionStatus status) {
               // … all the same business logic as before
            }
        });
    }
</code></pre><p>和瞧！<code>JdbcTemplate</code>使处理JDBC变得简单，而<code>TransactionTemplate</code>使事务管理变得轻而易举。这种实现方式明显比我们可以手工完成的任何操作都要简单。我称之为成功。</p><p>但是，我们可以做得更好。该代码的许多改进都是从我们的代码中消除了横切关注点。在可能的情况下，Spring在API（例如JDBC）之上提供了更简单的抽象。Spring还支持引入功能，这些功能可以使用面向方面的编程（AOP）来系统地应用有用的行为。在前面的示例中，如果斜视，很明显， <code>transactionTemplate</code>只是将方法本身的执行包装在事务上下文中，而不是包装方法执行的任何部分。开始执行方法时，将创建或重用事务。方法执行完成后，如果该事务不是嵌套事务，则将提交该事务。可以用方法执行边界来描述的任何问题都可以通过AOP方法很好地解决。毫不奇怪，Spring附带了现成的基于AOP的事务支持，该支持可以沿着方法执行的边界启动和提交事务。</p><p>要启用Spring的事务支持，请将其添加到您的Spring XML配置文件中：</p>
<pre><code class="prettyprint xml">	<tx:annotation-driven transaction-manager = "transactionManager" />
</code></pre><p>这个<code><tx:annotation-driven/></code>引用在Java配置中配置的<code>transactionManager</code> bean。该声明打开Spring框架中的功能，该功能可检测Service Bean中方法上是否存在Spring的<code>@Transactional</code>annotation。<code>transactionTemplate</code>引用变得无关紧要，并且可以在配置类和实现中都将其删除。剩下的就是在服务方法定义中添加<code>@Transactional</code> 。</p><p>可以对<code>@Transactional</code>annotation进行参数化以自定义事务行为。<code>getCustomerById</code>方法的注释为<code>@Transaction(readOnly = true)</code>因为该方法不会修改该数据库中的任何内容。将其设置为<code>readOnly</code>只会告诉Spring框架不要费心创建事务。创建交易并不总是便宜的，应该谨慎使用。有关Spring框架中有关事务处理支持的更多信息，建议读者查看Juergen Hoeller（非常酷） <a href="http://www.infoq.com/presentations/transaction-management-strategies">记录的交易演示</a> 。</p><p>修改后的实现如下所示：</p>
<pre><code class="prettyprint java">    @Transactional(readOnly = true)
    public Customer getCustomerById(final long id) {
	// … same as before, with transactionTemplate removed
    }

    @Transactional
    public Customer createCustomer(final String firstName, final String lastName) {
	// … same as before, with transactionTemplate removed
    }
</code></pre>
<h2>致力于建立关系（使用Java Persistence API）</h2><p>使用基于JDBC的存储库，我们有一个完整且有效的<code>CustomerService</code>实现。使我们能够使用JDBC在域模型方面与数据存储进行干净对话的所有方法均已完成。这些示例非常简单，因为到目前为止，我们正在尝试做的很简单。我们正在处理一种类型的对象-客户-尚未开始编写代码来处理客户购买等关系。回想一下，购买中有订单项，而订单项是参考产品。即使在我们的简单领域中，该对象图也可能很深。虽然当然可以用对象来处理我们的数据库表，但这不是自然的。数据库所强加的模型（行，列和外键）与我们域的模型之间的这种分裂被称为<em>对象关系阻抗不匹配</em> ，并且是所有面向对象的语言（不仅仅是Java）所共有的。Java Persistence API（JPA）标准化了对象关系映射技术（ORM）。ORM通常采用对象类型和数据库表之间的映射，并提供一种基于该映射来持久化，操作和查询对象的干净方法。在JPA中，此映射主要由域类本身的元数据注释驱动。JPA实现通常支持多个数据库供应商。</p><p>首先，您应该选择一个数据库（前面的示例已经建立了H2数据库，因此我们将使用它）和一个JPA实现。有许多不同的JPA提供程序。许多JPA实现与标准之前的其他ORM解决方案打包在一起。出于此解决方案的目的，我们使用了Hibernate JPA实现。</p><p>让我们修改第一个使用JPA的示例。首先，修改Customer类，使其包含针对JPA引擎的正确的注释驱动元数据。元数据使用默认值派生，并且在需要显式配置的情况下使用Java语言注释派生。我在以下代码中省略了变种器。</p>
<pre><code class="prettyprint java">package org.springsource.examples.crm.model;

import javax.persistence.*;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "customer")
public class Customer implements java.io.Serializable {
    // private variables and mutators omitted
    @Id
    @GeneratedValue
    @Column(name = "id", unique = true, nullable = false)
    public Long getId() {
        return this.id;
    }

    @Column(name = "first_name", nullable = false)
    public String getFirstName() {
        return this.firstName;
    }

    @Column(name = "last_name", nullable = false)
    public String getLastName() {
        return this.lastName;
    }

    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY, mappedBy = "customer")
    public Set getPurchases() {
        return this.purchases;
    }
}
</code></pre><p>用<code>@Entity</code>annotation的类已在JPA实现中注册。由于我们的<code>CustomerService</code>实现与预先存在的数据库架构一起使用，因此我们添加了<code>@Table</code>annotation，并特别指定了映射到该类的表。接下来，使用<code>@Id</code>annotation指定哪个字段映射到表的主键。<code>@GeneratedValue</code>annotation告诉JPA期望数据库系统将自动增加（或生成）此列。<code>@Column</code>annotation在该类中是多余的，因为JPA引擎将自动从类的JavaBean样式属性中推断列名，但是如果存在不匹配，则可用于控制JavaBean属性如何映射到表中的列名。 。</p><p>最重要的是购买者增变器上的注释，因为它描述了一种关系。注释- <code>@OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY, mappedBy = “customer”)</code> -有点密集，但是却有很多麻烦！该注释告诉JPA引擎，该<code>Customer</code>对象属于零个或多个Purchase对象。JPA的引擎知道所有<code>Purchase</code>的是有对象<code>“customer”</code>属性（类型的<code>Customer</code> ）使用相同的ID作为当前一个属于这个客户。那些购买对象（用数据库的话来说）具有引用此客户记录的外键，这由<code>mappedBy = “customer.”</code>表示<code>mappedBy = “customer.”</code> 因此，Customer类具有用于购买的JavaBean属性（一个集合），而<code>Purchase</code>具有用于<code>Customer</code>的JavaBean属性。相互映射摘自下面的Purchase类：</p>
<pre><code class="prettyprint java">    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "customer_id", nullable = false)
    public Customer getCustomer() {
        return this.customer;
    }
</code></pre><p>通过查看<code>PURCHASE</code>表的<code>CUSTOMER_ID</code>列，然后加载一个<code>Customer</code>实例，JPA引擎知道“ <code>Purchase</code>上的<code>Customer</code>对象已到达。让我们重新访问<code>CustomerService</code>实现，并查看如何通过基于<code>JdbcTemplate</code>的实现对其进行改进。一，新配置：</p>
<pre><code class="prettyprint java">package org.springsource.examples.crm.services.jpa;

import org.springframework.context.annotation.*;
import org.springframework.orm.jpa.*;
import org.springframework.transaction.PlatformTransactionManager;
import org.springsource.examples.crm.services.config.CrmConfiguration;
import javax.persistence.EntityManagerFactory;

@Configuration
public class JpaConfiguration extends CrmConfiguration {

  @Bean
  public LocalContainerEntityManagerFactoryBean entityManagerFactory() {
    LocalContainerEntityManagerFactoryBean localContainerEntityManagerFactoryBean = new LocalContainerEntityManagerFactoryBean();
    localContainerEntityManagerFactoryBean.setDataSource(this.dataSource());
    return localContainerEntityManagerFactoryBean;
  }

  // this is required to replace JpaTemplate's exception translation
  @Bean
  public PersistenceExceptionTranslationPostProcessor persistenceExceptionTranslationPostProcessor() {
    PersistenceExceptionTranslationPostProcessor persistenceExceptionTranslationPostProcessor =  new PersistenceExceptionTranslationPostProcessor();
    persistenceExceptionTranslationPostProcessor.setRepositoryAnnotationType( Service.class);
    // do this to make the persistence bean post processor pick up our @Service class. Normally it only picks up @Repository
    return persistenceExceptionTranslationPostProcessor;
  }

  @Bean
  public PlatformTransactionManager transactionManager() {
    EntityManagerFactory entityManagerFactory = entityManagerFactory().getObject();
    return new JpaTransactionManager(entityManagerFactory);
  }

}
</code></pre><p>事务管理器实现是<code>JpaTransactionManager</code> ，它是一个<code>PlatformTransactionManager</code>实现，它知道如何管理JPA本地事务。<code>LocalContainerEntityManagerFactoryBean</code>创建<code>javax.persistence.EntityManagerFactory</code></p><p><code>javax.persistence.EntityManagerFactory</code></p><p><code>javax.persistence.EntityManagerFactory</code></p><p><code>javax.persistence.EntityManagerFactory</code></p><code>javax.persistence.EntityManagerFactory</code></div><code>javax.persistence.EntityManagerFactory</code></div><code>javax.persistence.EntityManagerFactory</code></article><code>javax.persistence.EntityManagerFactory</code></div><code>javax.persistence.EntityManagerFactory</code></div><code>javax.persistence.EntityManagerFactory</code></div><code>javax.persistence.EntityManagerFactory</code></div><code>javax.persistence.EntityManagerFactory</code></body></html>