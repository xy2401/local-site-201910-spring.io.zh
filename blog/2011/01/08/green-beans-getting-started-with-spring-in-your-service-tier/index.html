<html  data-code-prettify="" data-mobile-support="" data-search=""><head></head><body >﻿
<title>绿豆：服务层中的Spring入门</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Green Beans: Getting Started with Spring in your Service Tier">
<meta name="twitter:description" >
<meta name="twitter:creator" content="@starbuxman">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=200">

<meta property="og:title" content="Green Beans: Getting Started with Spring in your Service Tier">
<meta property="og:image" content="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=200">
<meta property="og:description" >
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2011-01-08 00:42:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">绿豆：服务层中的Spring入门</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=20&d=mm"> <a class="author" rel="author" href="/team/jlong">乔什·朗（Josh Long）</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2011-01-08 00:42:00.0">2011年1月8日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2011/01/08/green-beans-getting-started-with-spring-in-your-service-tier#disqus_thread" data-disqus-identifier="385">
</a></div>
</div>
</header>
<div class="blog--post"><p>所有应用程序都来自领域模型。术语“域模型”描述了系统中的名词或数据，该系统对您要解决的问题很重要。业务逻辑所在的服务层操纵着应用程序数据，并且必须最终将其持久化（通常在数据库中）。解释很简单，但是在实践中，建立良好的服务层对于任何开发人员而言都是艰巨的任务。这篇文章将向开发人员介绍Spring Framework 中可用的选项，以建立更好的服务层。假定读者具有一定的SQL语言经验，并且更为关键的是，读者熟悉<a href="http://blog.springsource.com/2010/11/09/green-beans-putting-the-spring-in-your-step-and-application/">基本的Spring依赖项注入和配置概念</a> 。该项目的源代码位于SpringSource的Git存储库下的<a href="http://git.springsource.org/spring-samples/spring-samples/trees/master/showcases/green-beans/building-a-better-service-tier">Spring Samples</a>项目中。</p>
<h2>名词和动词</h2><p>服务层描述系统中的动词（动作）。领域模型描述了名词（数据）。Grails和Spring Roo等工具可以通过查看域模型来自动推断和生成业务对象。这种方法称为模型驱动的开发，可以为高度交互的应用程序开发提供很大的帮助。了解构建基块最终将帮助您使用Spring Roo之类的工具来提高生产力。在这篇文章中，我们将构建一个服务来处理符合以下规则的客户数据：</p>
<ol>
<li>一个人只有从企业购买了东西，才是顾客。</li>
<li>一个人的购买称为购买，其中包含订单项。</li>
<li>订单项是给定订单的购买产品的记录。</li>
</ol><p>这种数据-具有较少记录计数的链接数据-很适合关系数据库管理系统（通常称为RDBMS）。RDBMS通过将域模型映射到表来工作。我们的服务表如下图所示：</p><p><img class="size-full wp-image-7102 " title="关于建立更好的服务层，Green Beans中的CRM系统的ERD图" src="http://blog.springsource.com/wp-content/uploads/2011/01/erd.jpg" alt="关于建立更好的服务层，Green Beans中的CRM系统的ERD图" width="495" height="354"> </p>
<h2>设置数据库</h2><p>我们的实现将所有数据存储在称为H2的RDBMS中。您当然可以自由选择喜欢的数据库。这篇文章将使用一些简单的数据库表作为示例。这些表的H2数据定义语言（DDL）脚本可在源代码中找到（ <a href="http://git.springsource.org/spring-samples/spring-samples/blobs/master/showcases/green-beans/building-a-better-service-tier/src/main/resources/crm.sql"><code>src/main/resources/crm.sql</code></a> ）。DDL很简单，并且可以通过少量调整使其在大多数数据库中工作。如果您想使用H2，请按照以下说明进行设置（如果尚未设置）。否则，请随时跳到下一节“域模型”。H2是一个轻量级的嵌入式内存SQL数据库，可以快速设置和运行。首先，请从<a href="http://www.h2database.com">H2主页</a>下载最新发行版。选择您喜欢的发行版（Windows或“所有平台”），尽管出于本文的目的，我们将使用“所有平台”发行版。将发行版解压缩到您喜欢的文件夹中。在命令行上，导航到发行版中的bin文件夹，然后运行适合您平台的shell脚本（对于Windows为h2.bat，对于Unix或Linux环境为h2.sh）以启动数据库进程并启动一个shell，您可以用于与数据库进行交互。在“ JDBC URL：”字段中输入以下内容： <code>jdbc:h2:<a href="tcp://127.0.0.1/~/crm_example">tcp://127.0.0.1/~/crm_example</a></code> （不带引号），其余部分保持不变，然后单击“连接”按钮。通过打开URL调出数据库控制台<code><a href="http://localhost:8082/login.jsp">http://localhost:8082/login.jsp</a></code>在浏览器中。H2可以是嵌入式的（就像我们在此处相对于作为服务器运行），但是像在此处将其用作服务器一样，可以提供更丰富的体验。登录后，您将可以在H2控制台中尝试查询。</p>
<h2>领域模型</h2><p>描述您的域模型的代码应尽可能避免持久性问题。理想情况下，您将能够使用干净的，面向对象的术语来描述域模型。我们的域模型的代码是：</p>
<pre><code class="prettyprint java"><br />package org.springsource.examples.crm.model;
…
public class Customer implements java.io.Serializable {
    private Long id;
    private String firstName;
    private String lastName;
    private Set purchases = new HashSet();
    // constructors, and accessor / mutator pairs omitted for brevity
}
</code></pre><p>客户实体引用了<code>Purchase</code> s，其定义为：</p>
<pre><code class="prettyprint java">package org.springsource.examples.crm.model;
…
public class Purchase implements java.io.Serializable {
    private Long id;
    private Customer customer;
    private double total;
    private Set lineItems = new HashSet();
    // constructors, and accessor / mutator pairs omitted for brevity
}
</code></pre><p>采购反过来引用了<code>LineItems</code> ，其定义为：</p>
<pre><code class="prettyprint java">package org.springsource.examples.crm.model;
…
public class LineItem implements java.io.Serializable {
    private Long id;
    private Purchase purchase;
    private Product product;
    // constructors, and accessor / mutator pairs omitted for brevity
}
</code></pre><p>最后， <code>LineItem</code>引用一个<code>Product</code> 。一种<code>Product</code>是清单中某物的定义，定义如下：</p>
<pre><code class="prettyprint java">package org.springsource.examples.crm.model;
…
public class Product implements java.io.Serializable {
    private Long id;
    private String description;
    private String name;
    private double price;
    private Set lineItems = new HashSet();
    // constructors, and accessor / mutator pairs omitted for brevity
}
</code></pre>
<h2>建立客户资料库</h2><p>因此，我们的首要任务是建立一个存储库对象以持久保存<code>Customer</code>记录。现在，我们将忽略域模型中的其他实体。存储库应使用户与用于处理持久性的原始API隔离开。输入和输出应该是域模型对象，而不是较低级别的持久性原语。让我们看看我们的界面<code>Customer</code>资料库。</p>
<pre><code class="prettyprint java">package org.springsource.examples.crm.services.jdbc.repositories;
import org.springsource.examples.crm.model.Customer;

public interface CustomerRepository {
  Customer saveCustomer(Customer customer) ;
  Customer getCustomerById(long id);
}
</code></pre><p>我们将使用JDBC构建存储库。JDBC（Java数据库连接API）是作为Java平台的一部分提供的标准数据库连接框架。它的使用有据可查，并且所有主要的供应商都以JDBC驱动程序的形式提供其数据库的连接性。这似乎使JDBC自然地开始构建存储库。但是，实际上，直接的JDBC实现可能很乏味。</p>
<pre><code class="prettyprint java">package org.springsource.examples.crm.services;
import org.springsource.examples.crm.model.Customer;

public interface CustomerService {
    Customer getCustomerById(long id);
    Customer createCustomer(String fn, String ln);
}
</code></pre><p>因为直接使用JDBC可能非常繁琐，所以我们不会对其进行过多探讨。我们鼓励您检查本文的源代码，在其中我们建立了一个直接的JDBC存储库，该存储库需要150多行令人眼花lines乱的代码来处理我们将要介绍的内容，包括线程安全以及资源获取和销毁。</p><p>相反，让我们介绍一个称为the的Spring Framework 类。 <code>JdbcTemplate</code>这大大简化了基于JDBC的开发。</p><p>首先，我们已经设置了一个标准的Spring XML文件，该文件又设置了类路径组件扫描，并为文件中的属性引入了属性占位符解析<code>database.properties</code> 。我们不会在此处重印XML，因为它已经在源代码中了（本文的示例XML文件位于<a href="http://git.springsource.org/spring-samples/spring-samples/trees/master/showcases/green-beans/building-a-better-service-tier/src/main/resources"><code>src/main/resources</code></a> ），它代表了非常基本的Spring配置。Spring类路径组件扫描又选择了Java配置类，这是我们将在本文中重点介绍和扩展的内容。基本的通用Java配置类，称为<code>CrmConfiguration</code> ，如下所示。的<code>CrmConfiguration</code>类只配置一个<code>javax.sql.DataSource</code> 。</p>
<pre><code class="prettyprint java">package org.springsource.examples.crm.services.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.*;
import org.springframework.jdbc.datasource.SimpleDriverDataSource;
import javax.sql.DataSource;

@Configuration
public class CrmConfiguration {
    @Value(&quot;${dataSource.driverClassName}&quot;)
    private String driverName;

    @Value(&quot;${dataSource.url}&quot;)
    private String url;

    @Value(&quot;${dataSource.user}&quot;)
    private String user;

    @Value(&quot;${dataSource.password}&quot;)
    private String password;

    @Bean
    public DataSource dataSource() {
        SimpleDriverDataSource simpleDriverDataSource = new SimpleDriverDataSource();
        simpleDriverDataSource.setPassword(this.password);
        simpleDriverDataSource.setUrl(this.url);
        simpleDriverDataSource.setUsername(this.user);
        simpleDriverDataSource.setDriverClass(org.h2.Driver.class);
        return simpleDriverDataSource;
    }
}
</code></pre><p>为了有效地使用JDBC，我们将使用Spring的<code>JdbcTemplate</code>尽量减少样板代码。 <code>JdbcTemplate</code>将使我们与资源管理隔离，并大大简化了JDBC API的使用。下面是一个配置<code>JdbcTemplate</code>基于的实现<code>CustomerRepository</code>接口。在配置中，我们定义了一个实例<code>JdbcTemplate</code> 。</p>
<pre><code class="prettyprint java">package org.springsource.examples.crm.services.jdbc;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.support.TransactionTemplate;
import org.springsource.examples.crm.services.config.CrmConfiguration;

import javax.sql.DataSource;

@Configuration
public class JdbcConfiguration extends CrmConfiguration {
    @Bean
    public JdbcTemplate jdbcTemplate() {
        DataSource ds = dataSource(); // this comes from the parent class
        return new JdbcTemplate(ds);
    }
}
</code></pre><p>下面是<code>JdbcTemplate</code>基于<code>CustomerRepository</code>实施。</p>
<pre><code class="prettyprint java">package org.springsource.examples.crm.services.jdbc.repositories;

import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.simple.SimpleJdbcInsert;
import org.springframework.stereotype.Repository;
import org.springframework.util.Assert;
import org.springsource.examples.crm.model.Customer;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

@Repository
public class JdbcTemplateCustomerRepository implements CustomerRepository, InitializingBean {

  @Value(&quot;${jdbc.sql.customers.queryById}&quot;)
  private String customerByIdQuery;

  @Value(&quot;${jdbc.sql.customers.insert}&quot;)
  private String insertCustomerQuery;

  @Autowired
  private JdbcTemplate jdbcTemplate;

  public Customer getCustomerById(long id) {
    return jdbcTemplate.queryForObject(customerByIdQuery, customerRowMapper, id);
  }

  public Customer saveCustomer(Customer customer) {

    SimpleJdbcInsert simpleJdbcInsert = new SimpleJdbcInsert(jdbcTemplate);
    simpleJdbcInsert.setTableName(&quot;customer&quot;);
    simpleJdbcInsert.setColumnNames(Arrays.asList(&quot;first_name&quot;, &quot;last_name&quot;));
    simpleJdbcInsert.setGeneratedKeyName(&quot;id&quot;);

    Map&lt;String, Object&gt; args = new HashMap&lt;String, Object&gt;();
    args.put(&quot;first_name&quot;, customer.getFirstName());
    args.put(&quot;last_name&quot;, customer.getLastName());

    Number id = simpleJdbcInsert.execute(args);
    return getCustomerById(id.longValue());
  }

  public void afterPropertiesSet() throws Exception {
    Assert.notNull(this.jdbcTemplate, &quot;the jdbcTemplate can&#39;t be null!&quot;);
    Assert.notNull(this.customerByIdQuery, &quot;the customerByIdQuery can&#39;t be null&quot;);
    Assert.notNull(this.insertCustomerQuery, &quot;the insertCustomerQuery can&#39;t be null&quot;);
  }

  private RowMapper&lt;Customer&gt; customerRowMapper = new RowMapper&lt;Customer&gt;() {

    public Customer mapRow(ResultSet resultSet, int i) throws SQLException {
      long id = resultSet.getInt(&quot;id&quot;);
      String firstName = resultSet.getString(&quot;first_name&quot;);
      String lastName = resultSet.getString(&quot;last_name&quot;);
      return new Customer(id, firstName, lastName);
    }
  };
}
</code></pre><p>在示例中，存储库类使用@Repository进行注释，这是一个Spring Framework <em>构造型</em>注释，与Spring Framework 等效（除了一些我们不需要担心的小方法） <code>@Component</code> <em>构造型</em>注释。在这个特定示例中，我们可以轻松地使用<code>@Component</code> 。</p><p>第一种方法– <code>getCustomerById(long)</code> –使用<code>jdbcTemplate</code>实例发出查询。的<code>JdbcTemplate</code>的<code>query</code>将一个SQL语句作为其第一个参数，并将一个实例作为其第二个参数<code>RowMapper<T></code> 。RowMapper是一个Spring接口，客户端可以实现该接口，以将结果集数据映射到对象中（在这种情况下， <code>Customer</code> ）。对于返回结果集中的每一行， <code>JdbcTemplate</code>将会通知<code>mapRow(ResultSet,int)</code> 。</p><p>RowMapper实例是无状态的（因此：线程安全），并且应为映射客户记录的任何其他查询缓存。在SQL字符串和RowMapper实例之后， <code>jdbcTemplate.queryForObject</code>方法支持Java 5的varargs语法，用于将参数以数字顺序绑定到查询：第一个变量参数绑定到第一个“？”在查询中，第二到第二个“？”，依此类推。</p><p>第二种方法插入一条记录（简单），然后检索新插入的记录的ID。我们使用<code>SimpleJdbcInsert</code>对象来描述我们的表，所需的参数，然后以与数据库无关的方式执行插入操作。</p><p>现在，我们有了一个可以正常工作的存储库。该存储库是一个哑对象。它不了解事务，也不了解业务逻辑。业务对象利用存储库实现并对其进行编排。业务对象具有“全局”，其中存储库仅关心持久化域模型。在决定去哪里时，请记住这一点。</p><p>让我们检查一下<code>CustomerService</code>界面，首先。</p>
<pre><code class="prettyprint java">package org.springsource.examples.crm.services;
import org.springsource.examples.crm.model.Customer;

public interface CustomerService {
    Customer getCustomerById(long id);
    Customer createCustomer(String fn, String ln);
}
</code></pre><p>这似乎类似于存储库界面，并且可能会怀疑为什么应该使用存储库。应该理解，服务关心业务状态，而不关心应用程序状态。服务关心业务事件。当存储库涉及到持久性的机制时<code>Customer</code>记录到数据库（例如）中，服务在乎确保<code>Customer</code>记录处于有效状态，并且<code>Customer</code> （例如）尚未注册该公司的免费产品试用活动。因此，尽管服务和存储库似乎都具有一种似乎可以“创建客户”的方法，但它们应该有很大的不同，并且应仅关注目标。考虑到这一点，让我们看一下我们基于JDBC的简单CustomerService实现。</p>
<pre><code class="prettyprint java">package org.springsource.examples.crm.services.jdbc.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springsource.examples.crm.model.Customer;
import org.springsource.examples.crm.services.CustomerService;
import org.springsource.examples.crm.services.jdbc.repositories.CustomerRepository;

@Service
public class JdbcCustomerService implements CustomerService {

  @Autowired
  private CustomerRepository customerRepository;

  public Customer getCustomerById(long id) {
    return this.customerRepository.getCustomerById(id);
  }

  public Customer createCustomer(String fn, String ln) {
    Customer customer = new Customer(fn, ln);
    return this.customerRepository.saveCustomer(customer);
  }
}
</code></pre><p>这项服务很简单。正如我们对存储库所做的那样，我们使用Spring注释构造型为该服务注释， <code>@Service</code> 。这个注释比起简单地传达类的意图要好得多<code>@Component,</code>但是没有理由<code>@Component</code>不能代替使用。典型的服务应具有比存储库更细粒度的方法，因此通常会看到具有多个存储库的服务在起作用。该服务协调了多个存储库。这意味着服务需要确保跨多个存储库，跨多个客户端的状态一致。不难想象，不一致的国家会带来怎样的灾难。假设您有一项服务，该服务代表电子商务站点中的用户管理购物车结帐。当用户单击“提交订单”时，该服务需要从库存中预留购物车中的所有行项目，并从用户帐户中扣除费用。如果同时有另一位用户尝试签出相同的商品（不幸的是，该商品仅剩一个库存）并且足够快地完成结账，那么第一个用户将为商家无法交付的商品付款上！</p>
<h2>交易次数</h2><p>这种情况很常见，也是数据库支持事务处理概念的原因。事务在数据库中划分活动块，并缓冲该活动期间的所有更改。数据库将保持不变，直到事务中的<em>所有</em>操作无意外执行且事务已<em>提交</em>为止。如果另一个客户端读取在事务中更改的数据，则该客户端将“看到”对象和记录，就像在事务开始<em>之前一样</em> 。在第一个事务提交之前，这些相同的客户端将无法对数据库进行更改。事务可确保并发读取之间的状态一致。</p><p>个别动作-可能是查询和更新-转化为个别动作<code>jdbcTemplate</code>电话。可以通过使用Spring的<code>TransactionTemplate</code>带有Spring的PlatformTransactionManager层次结构的实例。的<code>TransactionTemplate</code>然后根据需要使用事务管理器启动和提交事务。Spring Framework 提供了<code>TransactionTemplate</code>提供事务同步。我们的服务仅使用一种交易资源- <code>javax.sql.DataSource</code> -因此<code>DataSourceTransactionManager</code>就足够了。将以下内容添加到<code>JdbcConfiguration</code>类。</p>
<pre><code class="prettyprint java">    @Bean
    public PlatformTransactionManager transactionManager() {
        DataSourceTransactionManager dataSourceTransactionManager = new DataSourceTransactionManager();
        dataSourceTransactionManager.setDataSource(this.dataSource());
        return dataSourceTransactionManager;
    }

    @Bean
    public TransactionTemplate transactionTemplate() {
        TransactionTemplate tt = new TransactionTemplate();
        tt.setTransactionManager( this.transactionManager() );
        return tt;
    }
</code></pre><p>使用事务模板来执行服务类中应包含在事务中的逻辑。该服务的代码的重要部分显示如下。</p>
<pre><code class="prettyprint java"><br />    @Autowired 
    private TransactionTemplate transactionTemplate; 

     public Customer getCustomerById(final long id) {
        return this.transactionTemplate.execute(new TransactionCallback() {
            public Customer doInTransaction(TransactionStatus status) {
               // … all the same business logic as before
            }
        });
    }

    public Customer createCustomer( final String firstName, final String lastName) {
        return this.transactionTemplate.execute(new TransactionCallback() {
            public Customer doInTransaction(TransactionStatus status) {
               // … all the same business logic as before
            }
        });
    }
</code></pre><p>和瞧！ <code>JdbcTemplate</code> 使处理JDBC死变得简单，并且<code>TransactionTemplate</code>使交易管理变得轻而易举。这种实现方式明显比我们可以手工完成的任何操作都要简单。我称之为成功。</p><p>但是，我们可以做得更好。该代码的许多改进都是从我们的代码中消除了横切关注点。在可能的情况下，Spring在API（例如JDBC）之上提供了更简单的抽象。Spring还支持引入功能，这些功能可以使用面向切面的编程（AOP）来系统地应用有用的行为。在前面的示例中，如果斜视，很明显<code>transactionTemplate</code>只是在事务上下文中包装了方法本身的执行，而不是方法执行的任何单个部分。开始执行方法时，将创建或重用事务。方法执行完成后，如果该事务不是嵌套事务，则将提交该事务。可以用方法执行边界来描述的任何问题都可以通过AOP方法很好地解决。毫不奇怪，Spring附带了现成的基于AOP的事务支持，该支持可以沿着方法执行的边界启动和提交事务。</p><p>要启用Spring的事务支持，请将其添加到您的Spring XML配置文件中：</p>
<pre><code class="prettyprint xml">	&lt;tx:annotation-driven transaction-manager = &quot;transactionManager&quot; /&gt;
</code></pre><p>这个<code><tx:annotation-driven/></code>引用<code>transactionManager</code> Java配置中配置的bean。该声明打开Spring Framework 中检测Spring的存在的功能。 <code>@Transactional</code>服务bean中方法的注释。的<code>transactionTemplate</code>引用变得无关紧要，并且可以在配置类和实现中都将其删除。剩下的就是添加<code>@Transactional</code>服务方法定义。</p><p>的<code>@Transactional</code>注释可以参数化以自定义交易行为。的<code>getCustomerById</code>方法被注释为<code>@Transaction(readOnly = true)</code>因为该方法不会修改该数据库中的任何内容。设置为<code>readOnly</code>只是告诉Spring Framework 不要打扰创建事务。创建交易并不总是便宜的，应该谨慎使用。有关Spring Framework 中有关事务处理支持的更多信息，建议读者查看Juergen Hoeller（非常酷） <a href="http://www.infoq.com/presentations/transaction-management-strategies">记录的交易演示</a> 。</p><p>修改后的实现如下所示：</p>
<pre><code class="prettyprint java">    @Transactional(readOnly = true)
    public Customer getCustomerById(final long id) {
	// … same as before, with transactionTemplate removed
    }

    @Transactional
    public Customer createCustomer(final String firstName, final String lastName) {
	// … same as before, with transactionTemplate removed
    }
</code></pre>
<h2>致力于建立关系（使用Java Persistence API）</h2><p>我们有一个完整的工作<code>CustomerService</code>使用我们基于JDBC的存储库实现。使用JDBC，可以做的一切工作都已经完成，可以让我们根据域模型与数据存储进行干净的交谈。这些示例非常简单，因为到目前为止，我们正在尝试做的很简单。我们正在处理一种类型的对象-客户-尚未开始编写代码来处理客户购买等关系。回想一下，购买有订单项，而订单项则参考产品。即使在我们的简单领域中，该对象图也可能很深。虽然当然可以用对象来处理我们的数据库表，但这不是自然的。数据库所强加的模型（行，列和外键）与我们域的模型之间的这种分裂称为<em>对象关系阻抗不匹配</em> ，并且对所有面向对象的语言（不仅仅是Java）都是常见的。Java Persistence API（JPA）标准化了对象关系映射技术（ORM）。ORM通常采用对象类型和数据库表之间的映射，并提供一种基于此映射来持久化，操作和查询对象的干净方法。在JPA中，此映射主要由域类本身的元数据注释驱动。JPA实现通常支持多个数据库供应商。</p><p>首先，您应该选择一个数据库（前面的示例已经建立了H2数据库，因此我们将使用它）和一个JPA实现。有许多不同的JPA提供程序。许多JPA实现与标准之前的其他ORM解决方案打包在一起。出于此解决方案的目的，我们使用了Hibernate JPA实现。</p><p>让我们修改第一个使用JPA的示例。首先，修改Customer类，使其包含针对JPA引擎的正确的注释驱动元数据。元数据使用默认值派生，并且在需要显式配置的情况下使用Java语言注释派生。我在以下代码中省略了变种器。</p>
<pre><code class="prettyprint java">package org.springsource.examples.crm.model;

import javax.persistence.*;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = &quot;customer&quot;)
public class Customer implements java.io.Serializable {
    // private variables and mutators omitted
    @Id
    @GeneratedValue
    @Column(name = &quot;id&quot;, unique = true, nullable = false)
    public Long getId() {
        return this.id;
    }

    @Column(name = &quot;first_name&quot;, nullable = false)
    public String getFirstName() {
        return this.firstName;
    }

    @Column(name = &quot;last_name&quot;, nullable = false)
    public String getLastName() {
        return this.lastName;
    }

    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY, mappedBy = &quot;customer&quot;)
    public Set getPurchases() {
        return this.purchases;
    }
}
</code></pre><p>用注释的类<code>@Entity</code>已在JPA实施中注册。作为我们的<code>CustomerService</code>实现与预先存在的数据库架构一起使用，我们添加了<code>@Table</code>批注并指定要映射到此类的表。接下来，使用来指定哪个字段映射到表的主键<code>@Id</code>注解。的<code>@GeneratedValue</code>注释告诉JPA期望数据库系统将自动增加（或生成）此列。的<code>@Column</code>注释在该类中是多余的，因为JPA引擎将自动从类的JavaBean样式属性中推断列名，但是如果存在不匹配，则可用于控制JavaBean属性如何映射到表中的列名。</p><p>最重要的是购买者增变器上的注释，因为它描述了一种关系。注释- <code>@OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY, mappedBy = “customer”)</code> -有点稠密，但有很多冲击力！此注释告诉JPA引擎，存在零个或多个属于此对象的Purchase对象<code>Customer</code>宾语。JPA引擎知道所有<code>Purchase</code>具有<code>“customer”</code>属性（类型<code>Customer</code> ），其ID与该客户当前的ID相同。这些购买对象（按照数据库的说法）具有引用此客户记录的外键，并由以下方式表示： <code>mappedBy = “customer.”</code>因此，Customer类具有用于购买的JavaBean属性（一个集合），并且<code>Purchase</code>有一个JavaBean属性<code>Customer</code> 。相互映射摘自下面的Purchase类：</p>
<pre><code class="prettyprint java">    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = &quot;customer_id&quot;, nullable = false)
    public Customer getCustomer() {
        return this.customer;
    }
</code></pre><p>JPA引擎知道<code>Customer</code>上的对象<code>Purchase</code>通过查看到达<code>PURCHASE</code>桌子的<code>CUSTOMER_ID</code>列，然后加载<code>Customer</code>实例。让我们回顾一下<code>CustomerService</code>实施，并查看如何在<code>JdbcTemplate</code>基于实施。一，新配置：</p>
<pre><code class="prettyprint java">package org.springsource.examples.crm.services.jpa;

import org.springframework.context.annotation.*;
import org.springframework.orm.jpa.*;
import org.springframework.transaction.PlatformTransactionManager;
import org.springsource.examples.crm.services.config.CrmConfiguration;
import javax.persistence.EntityManagerFactory;

@Configuration
public class JpaConfiguration extends CrmConfiguration {

  @Bean
  public LocalContainerEntityManagerFactoryBean entityManagerFactory() {
    LocalContainerEntityManagerFactoryBean localContainerEntityManagerFactoryBean = new LocalContainerEntityManagerFactoryBean();
    localContainerEntityManagerFactoryBean.setDataSource(this.dataSource());
    return localContainerEntityManagerFactoryBean;
  }

  // this is required to replace JpaTemplate&#39;s exception translation
  @Bean
  public PersistenceExceptionTranslationPostProcessor persistenceExceptionTranslationPostProcessor() {
    PersistenceExceptionTranslationPostProcessor persistenceExceptionTranslationPostProcessor =  new PersistenceExceptionTranslationPostProcessor();
    persistenceExceptionTranslationPostProcessor.setRepositoryAnnotationType( Service.class);
    // do this to make the persistence bean post processor pick up our @Service class. Normally it only picks up @Repository
    return persistenceExceptionTranslationPostProcessor;
  }

  @Bean
  public PlatformTransactionManager transactionManager() {
    EntityManagerFactory entityManagerFactory = entityManagerFactory().getObject();
    return new JpaTransactionManager(entityManagerFactory);
  }

}
</code></pre><p>事务管理器的实现是<code>JpaTransactionManager</code> ，这是一个<code>PlatformTransactionManager</code>知道如何管理JPA本地事务的实现。的<code>LocalContainerEntityManagerFactoryBean</code>创建的实现<code>javax.persistence.EntityManagerFactory</code> ，可用于创建的实例的JPA类<code>javax.persistence.EntityManager</code> ，这是根据JPA API与数据源进行交互的中央API。该API是您使用JPA可能要做的一切的关键。 JPA提供的简单性使适当的存储库对象对象显得有些<em>多余。</em> 毕竟，存储库的全部价值主张是，它可以让客户根据域模型来处理持久性问题，而JPA已经做到了。欢迎您仍然保留单独的层，尤其是在您确实具有持久性的持久性要求时。但是，出于本文的目的，我们将利用JPA的简洁性，并将存储库层折叠到服务层中。</p><p>您会注意到缺少的一件事是Template类。Spring确实附带了<code>JpaTemplate</code> ，但最好还是让Spring直接为您注入EntityManager。当您使用组件扫描（如我们现在）时，Spring会自动寻找<code>@javax.persistence.PersistenceContext</code> （标准注释）并注入已配置的<code>EntityManager</code>您的实例<em>代理</em> 。为什么要代理？因为<code>EntityManager</code> s不是线程安全的，因此Spring会进行繁重的工作以确保不同的客户端请求可以使用本地线程<code>EntityManager</code>实例。如果我们使用过<code>JpaTemplate</code>类，我们将从Spring的异常翻译中受益。对于Spring Framework 附带的所有ORM模板类，Spring都会自动将特定于技术（已检查）的异常转换为Spring ORM包中的标准运行时异常层次结构（植根于<code>org.springframework.dao.DataAccessException</code> ）。这样，您可以以标准方式处理代码中的不同异常。我们选择仅在此处注入实体管理器，因此我们需要保留异常翻译。通过注册一个<code>PersistenceExceptionTranslationPostProcessor</code> ，如果没有，它将为我们处理异常翻译<code>JpaTemplate</code> 。</p><p>下面的代码代表基于JPA的服务。不比我们长<code>JdbcTemplateCustomerService</code> ，但与存储库<em>和</em>我们的服务均达到同等水平！</p><p>以下是基于JPA的CustomerService实现的代码。</p>
<pre><code class="prettyprint java">package org.springsource.examples.crm.services.jpa;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.orm.jpa.JpaTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springsource.examples.crm.model.Customer;
import org.springsource.examples.crm.services.CustomerService;

@Service
public class JpaDatabaseCustomerService implements CustomerService {

  @PersistenceContext
  private EntityManager entityManager;

  @Transactional(readOnly = true)
  public Customer getCustomerById(long id) {
    return this.entityManager.find(Customer.class, id);
  }

  @Transactional
  public Customer createCustomer(String fn, String ln) {
    Customer newCustomer = new Customer();
    newCustomer.setFirstName(fn);
    newCustomer.setLastName(ln);
    this.entityManager.persist(newCustomer);
    return newCustomer;
  }
}
</code></pre><p>不错！我们的实施已成为您眼前一闪的标本。导入语句与方法主体的实际行数一样多！一旦外围问题消除了，JPA本身就可以让您根据域中的对象解决问题。注入<code>EntityManager</code> proxy将JDBC中许多繁琐的操作减少为单行，并且线程安全！最后，Spring的基于AOP的事务支持使管理我们业务对象中的应用程序状态（通常都带有注释！）的通常复杂，并发性难题的工作缩短了。</p>
<h2>摘要</h2><p>在本文中，我们探讨了一个任性的开发人员面临的一些更常见的选择。我们使用Spring来尽可能地提高生产力，并且拥有Spring可以为我们简化的所有知识，我们来到这里，是一个<em>非常</em>简单的最终实现。</p><p>Spring Framework 还为它提供了许多其他的数据持久性选项支持。这些选项都遵循与本文中建立的支持相同的常规模板，因此如果您决定使用它们，它们将很容易实现。这篇文章没有涵盖其他许多ORM解决方案（如Hibernate，JDO，TopLink等）可用的Spring支持。例如，有关Hibernate支持的更多信息，您可以查看Alef关于该主题的<a href="http://blog.springsource.com/2007/06/26/so-should-you-still-use-springs-hibernatetemplate-andor-jpatemplate/">精彩文章</a> 。该文章还没有涉及Spring Data项目提供的NoSQL支持的广泛领域。这篇文章中的示例逐渐得到简化，并且越来越依赖于约定而不是配置。随着示例在抽象堆栈中的移动，总是有一种方法可以充分利用基础API的全部功能。</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 385;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>