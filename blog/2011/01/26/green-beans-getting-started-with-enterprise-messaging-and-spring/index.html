<!DOCTYPE html>
<html data-code-prettify="" data-mobile-support="" data-search="">
<head>
<title>Green Beans: Getting Started with Enterprise Messaging and Spring</title>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no" id="Viewport" name="viewport" />
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png" />
<link href="https://fonts.googleapis.com/css?family=Varela+Round|Montserrat:400,700" rel="stylesheet" type="text/css" />
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css" />
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M" name="google-site-verification" />

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css" />

<meta content="summary" name="twitter:card" />
<meta content="@springcentral" name="twitter:site" />
<meta name="twitter:title" content="Green Beans: Getting Started with Enterprise Messaging and Spring" />
<meta name="twitter:description" content="&lt;p&gt;&lt;/p&gt;
&lt;p&gt;In this post, we will introduce the core concepts of messaging, as well as the rich support for various types of messaging that the Spring framework and its sister projects provide.&lt;/p&gt;
&lt;p&gt;What is Messaging? To best explain this, I’ll paraphrase the example offered by the groundbreaking &lt;em&gt;Enterprise Integration Patterns&lt;/em&gt; book by Gregor Hohpe and Bobby Woolf (Addison Wesley, 2004). When you make a telephone call, you attempt to relay information to another party. This only works if the second party is available when you place the phone call. Because it is not always possible to answer phone calls, we use a voice-mail boxes to queue the messages. Callers leave messages in the voice-mail box and the callee is then free to retrieve the message (or, indeed, many messages) at a later point, asynchronously. &lt;/p&gt;
" />
<meta name="twitter:creator" content="@starbuxman" />
<meta name="twitter:image:src" content="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=200" />

<meta property="og:title" content="Green Beans: Getting Started with Enterprise Messaging and Spring" />
<meta property="og:image" content="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=200" />
<meta property="og:description" content="&lt;p&gt;&lt;/p&gt;
&lt;p&gt;In this post, we will introduce the core concepts of messaging, as well as the rich support for various types of messaging that the Spring framework and its sister projects provide.&lt;/p&gt;
&lt;p&gt;What is Messaging? To best explain this, I’ll paraphrase the example offered by the groundbreaking &lt;em&gt;Enterprise Integration Patterns&lt;/em&gt; book by Gregor Hohpe and Bobby Woolf (Addison Wesley, 2004). When you make a telephone call, you attempt to relay information to another party. This only works if the second party is available when you place the phone call. Because it is not always possible to answer phone calls, we use a voice-mail boxes to queue the messages. Callers leave messages in the voice-mail box and the callee is then free to retrieve the message (or, indeed, many messages) at a later point, asynchronously. &lt;/p&gt;
" />
<meta content="article" property="og:type" />
<meta property="og:article:published_time" content="2011-01-26 01:18:00.0" />
</head>
<body>

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" style="display:none;visibility:hidden" width="0"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">Projects</a>
</li>
<li class="navbar-link">
<a href="/guides">Guides</a>
</li>
<li class="navbar-link active">
<a href="/blog">Blog</a>
</li>
<li class="navbar-link">
<a href="/services">Training & Certification</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form action="/search" class="form-inline form-search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search for documentation, guides, and posts..." type="text" value="" />
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form action="/search" class="form-inline form-search" method="get">
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search..." type="text" value="" />
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">
Home
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">
Projects
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">
Guides
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">
Blog
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">
Training & Certification
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
 </div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>Engineering</div>
</div>
<div class="blog-category content--title">
<div>Releases</div>
</div>
<div class="blog-category content--title">
<div>News and Events</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Green Beans: Getting Started with Enterprise Messaging and Spring</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">Engineering</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=20&amp;d=mm" />
<a class="author" rel="author" href="/team/jlong">Josh Long</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2011-01-26 01:18:00.0">January 26, 2011</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" data-disqus-identifier="389" href="/blog/2011/01/26/green-beans-getting-started-with-enterprise-messaging-and-spring#disqus_thread">
</a></div>
</div>
</header>
<div class="blog--post"><p><p>In this post, we will introduce the core concepts of messaging, as well as the rich support for various types of messaging that the Spring framework and its sister projects provide.</p><p>What is Messaging? To best explain this, I&rsquo;ll paraphrase the example offered by the groundbreaking <em>Enterprise Integration Patterns</em> book by Gregor Hohpe and Bobby Woolf (Addison Wesley, 2004). When you make a telephone call, you attempt to relay information to another party. This only works if the second party is available when you place the phone call. Because it is not always possible to answer phone calls, we use a voice-mail boxes to queue the messages. Callers leave messages in the voice-mail box and the callee is then free to retrieve the message (or, indeed, many messages) at a later point, asynchronously. </p><p>In that example, a voice-mail box sits in the middle of the two parties. It stores the message and then delivers it when the callee – the recipient – retrieves it. In the world of enterprise messaging, things work very much the same: a party sends a message to a messaging broker (also known as messaging-oriented middle-ware – MOM) and another party – when that party can – takes delivery of, or explicitly queries for, any messages from the message broker.</p><p> Here is where the analogy stops being useful. Message brokers, in contrast to voice-mail boxes, have a lot of options. Message brokers are ideally positioned to provide extra services, like routing, and to make guarantees about message delivery. Message brokers can be optimized for different use cases, for example, you can trade speed for durability. Message brokers may persist messages to an external store to ensure durability, though this is typically a configuration that can be toggled in the name of speed. </p></p>
<p> In the voice-mail box example, a message was sent by one party and then delivered to another – the communication was <em>point-to-point</em>. Message brokers support this, as well as another type of communication called <em>publish-subscribe</em>, where messages are delivered to multiple clients. </p>
<p>A common use of message brokers is to solve integration problems between two different systems. Data sent to a message broker is usually of a format common to both the sender and recipient of the message. The only thing that two systems need to agree on to use a message broker is the data contract. Messages typically have a message body, in which the contents of the message itself are stored, and message headers, which are key / value pairs that provide meta-data about the body of the message that can be used to aid consumers of the messages in processing the message. Message headers can be anything you like, but they typically relate to the message itself, or to the processor of the message. </p>
<h2>Java Message Service </h2>
<p>The Java Message Service (JMS) API specifies client interfaces for interacting with message brokers. Each message broker provides its own implementation of the API, very much like JDBC drivers do for the JDBC API. This implies that JMS clients should generally use the same version of the client as the server. There are many, many fine JMS broker implementations to choose from. One reason for this is that messaging ihas always been an important part of application development, and continues to be even more so today. JMS has been a part of the J2EE (now Java EE) specifications since 1.1. The JMS specification has been at version 1.1 for most of the last decade. </p>
<p>In JMS, clients use a <code>javax.jms.ConnectionFactory</code> to create a <code>javax.jms.Connection</code>. The <code>Connection</code> can then be used to create a <code>javax.jms.Session</code>. The <code>Session</code> represents the client interaction with the broker and allows for sending and receiving messages as well as other less obvious operations. </p><p><p>The most useful methods on the interface concern the creation of a message producers, and message consumers that send and receive messages to and from a <code>javax.jms.Destination</code>. A <code>Destination</code> maps the JMS concept of an &ldquo;address&rdquo; on a message broker. It also maps the concept of where a broker stores messages. In JMS, messages are sent to, stored in, and consumed from the same place, all represented by a <code>javax.jms.Destination</code> instance.</p>[caption id=&ldquo;attachment_7506&rdquo; align=&ldquo;alignnone&rdquo; width=&ldquo;573&rdquo; caption=&ldquo;Above, blue elements represent producers and consumers. The orange elements represent destinations in the broker where messages are buffered. In JMS, these are either topics or queues.&rdquo;]<a href="http://blog.springsource.com/wp-content/uploads/2011/01/jms.jpg"><img src="http://blog.springsource.com/wp-content/uploads/2011/01/jms.jpg" alt="" title="jms" width="573" height="322" class="size-full wp-image-7506" /></a>[/caption]<p> <code>Destination</code> is an interface and has two more specific sub-interfaces, <code>javax.jms.Queue</code> and <code>javax.jms.Topic.</code> A <code>Queue</code> represents a standard queue, which is a point-to-point construct as described before. A <code>Topic</code> provides publish-subscribe messaging and can deliver a single message to multiple recipients.<br /></p></p>
<p>To send a message to a <code>Destination</code>, you must create a <code>javax.jms.MessageProducer</code>. The <code>MessageProducer </code> can then be used to send <code>javax.jms.Message</code>s.</p>
<p>JMS supports two different mechanisms to receive messages. The first way is to ask for a message, using the <code>javax.jmx.MessageConsumer#receive()</code> method, which returns an individual message from a <code>Destination</code> in a <em>synchronous</em> manner; the method blocks until a message is received, by default. Instead of using a <code>MessageConsumer</code>, clients may install a <code>javax.jms.MessageListener</code> by calling <code>javax.jms.Session#setMessageListener(MessageListener)</code>. <code>MessageListener</code> is an interface and has only one method, <code>public void onMessage(javax.jms.Message)</code>, which will be called whenever a <code>javax.jms.Message</code> is available for consumption on a <code>Destination</code>. A <code>MessageListener</code> provides <em>asynchronous</em> message processing: as messages arrive, they are processed.</p>
<p>There is quite a bit more to learn in the JMS API, but these classes and concepts will help you most in our discussion of Spring's support for JMS messaging. The first level of support is the <code> org.springframework.jms.core.JmsTemplate</code>, which provides simplifying methods to reduce the things we just discussed to one-liners. The <code>JmsTemplate</code>, requires a <code>javax.jms.ConnectionFactory</code> instance to do its work. <code>JmsTemplate</code> can do a lot of work for you. For example, to send a message, the <code>JmsTemplate</code> establishes a <code>javax.jms.Session</code>, sets up a <code>javax.jms.MessageConsumer</code> or <code>javax.jms.MessageProducer</code>, sets up all the machinery for transactions, and provide you with a reference to the current <code>javax.jms.Session</code> so you can create the message of your choice and send it. With all the error handling and construction logic, that's easily a savings of dozens of lines of code. Once your message has been sent, it destroys or closes most of those objects. This is standard practice in application servers (like a Java EE server) because the <code>ConnectionFactory</code> instances are created by the server, managed by the server, and are pooled. They cache the instances after use. Closing resources in those environments simply returns them to a pool. So, the <code>JmsTemplate</code> does the right thing in the standard case, assuming the <code>ConnectionFactory</code> caches or pools instances. </p>
<p>In a managed environment like an application server, you will typically need to acquire the <code>javax.jms.ConnectionFactory</code> from JNDI. You can use Spring to lookup that reference for you and configure a <code>JmsTemplate</code>. In our examples, we want to operate more loosely, so we will use the standalone ActiveMQ message broker. ActiveMQ is a popular, <a href="http://activemq.apache.org/">open-source message broker</a>. To use it, download it, and then run the startup script appropriate to your operating system in the bin folder. In your application, you'll need the client libraries to connect for the corresponding version of ActiveMQ. At the time of this writing, the latest version of ActiveMQ was 5.4.2. If you are using Maven, add the following dependencies to your Maven pom file: </p>
<pre><code class="prettyprint xml"><br /><br />            &lt;dependency&gt;
                &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;
                &lt;artifactId&gt;activemq-core&lt;/artifactId&gt;
                &lt;version&gt;${activemq.version}&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;
                &lt;artifactId&gt;activemq-optional&lt;/artifactId&gt;
                &lt;version&gt;${activemq.version}&lt;/version&gt;
            &lt;/dependency&gt;

</code></pre>
<p>Be sure to either create a Maven property for <code>${activemq.version}</code> or replace the string manually with the appropriate version. There is an <code>activemq-all</code> dependency out there as well, but it brings down a lot of perhaps unnecessary jars. For our application, the two dependencies above suffice. </p>
<h3>Using Spring with JMS</h3>
<p>Let's examine the configuration for a basic JMS application. First, let's examine the basic Spring XML configuration:</p>
<pre><code class="prettyprint xml"><br /><br />&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xsi:schemaLocation=&quot;
       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd
       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
       &quot;&gt;

    &lt;context:property-placeholder location=&quot;jms.properties&quot;/&gt;
    &lt;context:component-scan base-package=&quot;org.springsource.greenbeans.examples.jms.core&quot;/&gt;
    &lt;context:component-scan base-package=&quot;org.springsource.greenbeans.examples.jms.jmstemplate&quot;/&gt;
    &lt;tx:annotation-driven transaction-manager=&quot;jmsTransactionManager&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<p>You can see that the XML mainly sets up property placeholder resolution and enables classpath scanning. The most interesting part is the <tx:annotation-driven transaction-manager /> element that tells Spring to enable transactions on all methods that have the <code>@Transactional</code> annotation on it. The element references another bean in the Spring context, <code>jmsTransactionManager</code>, which is defined in the following Java configuration class.</p>
<pre><code class="prettyprint java"><br /><br />package org.springsource.greenbeans.examples.jms.core;

import org.apache.activemq.ActiveMQConnectionFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.*
import org.springframework.jms.connection.*
import org.springframework.jms.core.JmsTemplate;

import javax.jms.ConnectionFactory;

@Configuration
public class JmsConfiguration {

  @Value(&quot;${broker.url}&quot;)
  private String brokerUrl;

  @Bean
  public ConnectionFactory connectionFactory() {
    ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory();
    activeMQConnectionFactory.setBrokerURL(this.brokerUrl);
    return new CachingConnectionFactory(activeMQConnectionFactory);
  }

  @Bean
  public JmsTransactionManager jmsTransactionManager() {
    return new JmsTransactionManager(this.connectionFactory());
  }

  @Bean
  public JmsTemplate jmsTemplate() {
    return new JmsTemplate(this.connectionFactory());
  }
}
</code></pre>
<p> The configuration is pretty tame. First, we define an <code>ActiveMQConnectionFactory</code> instance and then give it to an instance of the Spring framework's <code>CachingConnectionFactory</code>. Some brokers provide their own caching <code>ConnectionFactory</code> implementation. If yours doesn't, however, then you can always use the Spring Caching ConnectionFactory implementation to achieve the speed boost. </p>
<p>Next, we have a <code>JmsTransactionManager</code>, which provides JMS-local transactions. In JMS, there are only two outcomes for a transaction rollback: on failed send operations, messages are unsent, and on failed receive operations, messages are re-queued with the message broker. This last case can be complicated. </p>
<p> If you receive a message, and then experience an error in its processing, and assuming you've kept a transaction open, the transaction is rolled back and the message is returned to the broker. What happens once its in the broker depends on the broker and your configuration. Typically, a message will simply be redelivered immediately. This isn't always the desired behavior, however. So, most (if not all) brokers support some notion of a dead letter queue to which messages that can't be delivered are sent. Messages in this queue can be handled however you want – perhaps some monitoring tool can wake somebody up when this error condition strikes. Most brokers provide even more control, however. It might be possible to set up rules on the routing of an in-error message. For example, the broker might attempt to redeliver a message immediately, then, if it fails again, it might wait a while and try again, and, if that fails, wait a while longer. This is typically called a backing off period. Perhaps after a certain threshold the message could be delivered to the dead letter queue, or outright discarded. Check your broker's documentation, in any case.</p>
<p>Finally, we create a <code>JmsTemplate</code> by giving it a reference to the <code>ConnectionFactory</code>.</p>
<p>Let's look at the <code>JmsTemplate</code> in action. To keep the examples simple, we'll first discuss how to send messages in an aptly-named <code>Producer</code> class. A common use of messaging is to send notifications to a (or many) different systems as a synchronization mechanism so that interested systems have the latest version of some piece of data. Let's assume in this example that we have a simple <code>Customer</code> POJO with the standard fields: <code>firstName</code>, <code> lastName</code>, <code>email</code>, and <code>id</code>. </p>
<pre><code class="prettyprint java"><br />package org.springsource.greenbeans.examples.jms.core;

import org.apache.commons.lang.builder.ToStringBuilder;
import org.apache.commons.logging.*
import org.springframework.beans.factory.annotation.*
import org.springframework.jms.core.*;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;
import org.springsource.greenbeans.examples.Customer;
import javax.jms.*;


@Component
public class Producer {

  @Value(&quot;${jms.customer.destination}&quot;)
  private String customerDestination;

  @Autowired
  private JmsTemplate jmsTemplate;

  private Log log = LogFactory.getLog(getClass());

  @Transactional
  public void sendCustomerUpdate(final Customer customer) throws Exception {
    this.jmsTemplate.send(this.customerDestination, new MessageCreator() {
      @Override
      public Message createMessage(Session session) throws JMSException {
           log.info(&quot;Sending customer data &quot; + ToStringBuilder.reflectionToString(customer));
           MapMessage mapMessage = session.createMapMessage();
           mapMessage.setLong(&quot;id&quot;, customer.getId());
           mapMessage.setString(&quot;firstName&quot;, customer.getFirstName());
           mapMessage.setString(&quot;lastName&quot;, customer.getLastName());
           mapMessage.setString(&quot;email&quot;, customer.getEmail());
      }
    });
  }
}
</code></pre>
<p>In the class, we see a <code>sendCustomerUpdate</code> method that takes as its arguments a Customer reference. Using the <code>JmsTemplate</code>'s send method – which takes two parameters: the first a String for the name of the destination ("customers"), and the second a reference to the Spring framework class <code>MessageCreator</code> – we build a JMS message using the <code>javax.jms.Session</code> reference passed into our implementation of the <code> createMessage(javax.jms.Session)</code> method. There are many types of messages that you can create in JMS: <code>javax.jms.TextMessage</code>, <code>javax.jms.ObjectMessage</code>, <code>javax.jms.MapMessage</code>, etc. The <code>ObjectMessage </code> does exactly what you'd expect – it lets you transmit a serialized object as the payload a JMS message. Generally, this is to be avoided. A serialized data type couples both the producer and consumer of a message to the same API contracts, which may not always be tenable. Even if it is feasible to guarantee that the type will be available, and of the same class version, on both sides of the message exchange, it is often inefficent to do so in comparison to other more flexible options. Instead, prefer decomposition – perhaps you can marshal the object as an XML or JSON String using the <code>javax.jms.TextMessage</code>. Or, send the constituent, primitive parts of the object, not the object itself using a <code>javax.jms.MapMessage</code>, which is simply a message with known key/value pairs just like in a <code>java.util.Map</code>. This is the approach we have taken here. All JVM's have <code>ints</code>, <code>longs,</code> <code>Strings</code>, etc. and can deserialize data transmitted this way. </p><p><P> Let&rsquo;s now look to receiving messages in JMS. The first approach is to synchronously ask for them, one at a time.</p></p>
<pre><code class="prettyprint java"><br /><br />package org.springsource.greenbeans.examples.jms.jmstemplate;

import org.apache.commons.logging.*;
import org.springframework.beans.factory.annotation.*;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;
import org.springsource.greenbeans.examples.Customer;
import javax.jms.*

@Component
public class RawJmsTemplatePollingMessageConsumer {

  @Autowired
  protected JmsTemplate jmsTemplate;

  @Value(&quot;${jms.customer.destination}&quot;)
  private String destination;

  private Log log = LogFactory.getLog(getClass());

  @Transactional
  public void receiveAndProcessCustomerUpdates() throws Exception {
    Message message = this.jmsTemplate.receive(this.destination);
    if (message instanceof MapMessage) {

      MapMessage mapMessage = (MapMessage) message ;
      String firstName = mapMessage.getString(&quot;firstName&quot;);
      String lastName = mapMessage.getString(&quot;lastName&quot;);
      String email = mapMessage.getString(&quot;email&quot;);
      Long id = mapMessage.getLong(&quot;id&quot;);

      Customer customer = new Customer(id, firstName, lastName, email );

      log.info(&quot;receiving customer message: &quot; + customer);

    }
  }
}
</code></pre>
<p>This example uses the <code>JmsTemplate</code> instance to receive a new message when one available and then transform it into a Customer object, in steps that are the reverse of what we did when we sent it, where it is oh-so-usefully written out to the log. This kind of packing and unpacking of JMS messages becomes tedious if you have to repeat it more than once. There is often value in extracting this sort of logic into a separate class. The Spring JMS hierarchy supports the use of instances of the <code>MessageConverter</code> hierarchy to let you override how objects are serialized. The default – <code>SimpleMessageConverter</code> – is in play when nothing is otherwise specified and it does a good job for the most case, so we don't override it here. If, however, we decided that we wanted to transmit objects as XML, we could take advantage of the <code>MarshallingMessageConverter</code>, which leverages the Spring framework's OXM (object-to-XML marshaling) support. Finally, note that the <code>receiveAndProcessCustomerUpdates</code> method is decorated with the <code>@Transactional</code> annotation. If anything should go wrong when a message is received, and should an <code>Exception</code> be thrown, Spring will rollback the receipt and return the message to the broker.</p>
<h3>Listening Makes It More Simple</h3>
<p>This example is simple enough, but has some limitations. First, our code is tightly coupled to the JMS and Spring APIs. Second, this only handles one message, and only when the method is invoked. It is the implementers responsibility to see that the method is called. Typically, implementers want messages processed as soon as they've arrived, asynchronously. A natural next step might be to then invoke the receive method in succession from within an endless loop to ensure that all messages in the queue are handled as quickly as possible. After that, to achieve higher throughput for particularly long running tasks and to ensure the queue is always drained, you might add threading so that multiple loops are always running. These are logical next steps, but they're also a lot of work just to receive messages and process them. Really, the only business logic here is the code that takes the payload of the message and does something with it. </p>
<p>The Spring framework provides a solution for this problem out of the box, and using it is simple! There are two implementations that are suitable for different situations that provide this functionality in the Spring framework. They are both rooted at the <code>AbstractJmsListeningContainer</code> class. You could work with this hierarchy directly, if you wanted, but as it happens, there's an even simpler way to configure this using Spring's JMS namespace.</p>
<p>Let's revisit our previous Spring XML configuration, adding the <code>http://www.springframework.org/schema/jms </code> namespace and then the appropriate configuration.</p>
<pre><code class="prettyprint xml"><br /><br />&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:jms=&quot;http://www.springframework.org/schema/jms&quot;
       ...
       xsi:schemaLocation=&quot;…  http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-3.0.xsd&quot;&gt;
       ….

    &lt;jms:listener-container  connection-factory=&quot;connectionFactory&quot; acknowledge=&quot;auto&quot; transaction-manager=&quot;jmsTransactionManager&quot;&gt;
        &lt;jms:listener destination=&quot;${jms.customer.destination}&quot; ref=&quot;messageListenerContainerConsumer&quot; method=&quot;receiveMessage&quot; /&gt;
    &lt;/jms:listener-container&gt;

&lt;/beans&gt;
</code></pre>
<p>We've excerpted only the parts that have been added to the configuration file. The <code>&lt;jms:listener-container&gt;</code> element requires a reference to the connection factory and the transaction manager in play. Note that the Spring message listener provides its own caching, so you should use a regular <code>ConnectionFactory</code> here: <code>CachingConnectionFactory</code> is redundant here, and should not be used. In the elemnt, you can configure as many <code>&lt;jms:listener&gt;</code> elements as you like, each specifying the name of a <code>javax.jms.Destination</code> instance and a reference to a Spring bean that will be given new messages. Optionally, you can configure which method should be invoked in the configured bean reference. If the Spring bean implements one of either <code>javax.jms.MessageListener</code> or Spring's own <code>SessionAwareMessageListener</code> interface, then the unique method on each of those interfaces will be invoked with the <code>javax.jms.Message</code>, and there is no need to specify a method. If a method is configured, the method should take as its parameters an object of the same type as the <code>javax.jms.Message</code>'s payload. For our examples, this would be a <code>java.util.Map</code> instance since we're expecting a <code>javax.jms.MapMessage</code> instance.</p>
<p>The revised code is:</p>
<pre><code class="prettyprint java"><br />package org.springsource.greenbeans.examples.jms.messagelistenercontainer;

import org.apache.commons.logging.*;
import org.springframework.stereotype.Component;
import org.springsource.greenbeans.examples.Customer;

import java.util.Map;

@Component
public class MessageListenerContainerConsumer {

  private Log log = LogFactory.getLog(getClass());

  public void receiveMessage(Map&lt;String, Object&gt; message) throws Exception {
    String firstName = (String) message.get(&quot;firstName&quot;);
    String lastName = (String) message.get(&quot;lastName&quot;);
    String email = (String) message.get(&quot;email&quot;);
    Long id = (Long) message.get(&quot;id&quot;);
    Customer customer = new Customer(id, firstName, lastName, email);
    log.info(&quot;receiving customer message: &quot; + customer);
  }
}
</code></pre>
<p> Not bad, huh? Your code is unaware of JMS and almost completely unaware even of Spring (it is, save for the <code>@Component</code> annotation. Naturally, you can simply configure this bean using XML or Java Configuration and this dependency would be avoided, too.) Additionally, your code's much easier to follow. All the same rules apply – exceptions thrown during receipt will trigger a rollback, for example. You can ratchet up concurrency by specifying how many listeners you want using the XML <code>&lt;jms:listener-container &gt;</code> element. You can also control which type of transaction management is in play. </p>
<h2>AMQP</h2>
<p>While JMS is a very powerful option, it is not without its limitations. Clients are coupled to the version of the broker, and it quickly becomes tedious to arrange flag-day upgrades of deployed systems and brokers. JMS is by definition Java-centric. Clients use Java-language drivers to connect to a given broker. Messaging is all about integration, and we can't always assume we're integrating with other Java clients, especially in a world with so many different platforms. While some of the JMS message brokers (even the open source ones) can scale to incredible throughputs, there are simply faster messaging options out there and if your situation demands it then it's at least worth investigating alternatives. JMS is a good API, but nobody would call it the best API. For this reason, while many message brokers support JMS, they also support their proprietary APIs or alternative APIs that are more powerful or expressive. One example is the lack of routing capabilities in JMS once a message is sent. </p>
<p>One popular option that meets these challenges is the AMQP standard. AMQP (advanced message queuing protocol) is a standard that was born, initially, of challenges faced in mission critical applications at JPMorgan Chase bank. From the beginnings of their work emerged a specification, around which eventually formed a working group that today includes numerous companies like Goldman Sachs, Progress Software, Microsoft, Novell, Red Hat, WS02, Goldman Sachs, Bank of America, Barclays, Cisco, Credit Suisse, Deutsche Borse Systems, and, of course, the SpringSource division of VMware. SpringSource, in particular, develops the most popular AMQP-based message broker implementation, RabbitMQ.</p>
<p>RabbitMQ is an <a href="http://www.rabbitmq.org">open-source message broker</a>. It is easy to install, and particularly so if you are running one of the many systems whose package manager has RabbitMQ already available. RabbitMQ is written in the Erlang language. Normally, implementation details should not matter, but this particular detail is salient because of RabbitMQ's speed. You see, Erlang is a lightweight language that originally saw deployment in mission-critical telephony systems. Erlang features a very lightweight, intuitive threading model that makes Erlang programs able to achieve far more concurrency than the JVM is currently capable of. Additionally, Erlang's threading model blends seemlessly with its networking model. This means that scaling out into multiple threads or multiple machines is done in basically the same way. All of this is to say that RabbitMQ is fast. Really fast, and that it's resilient to errors, which is one of the reasons companies like Ericsson have enjoyed nine nines (99.9999999%) of availability. </p>
<p>AMQP is a wire protocol (like HTTP), not an API. This makes it language-agnostic (indeed there are dozens of known clients for different languages and platforms), and it means that RabbitMQ enjoys support in all sorts of tools that you wouldn't normally expect to care about message brokers, like WireShark, a networking traffic monitoring tool. Conceptually, any AMQP client should be able to talk to any other AMQP implementation. </p>
<h3>A Peek Inside the AMQP Broker</h3>
<p>The AMQP specification specifies all the constructs on the client side as well as server side, as well as routine management options. In AMQP, a client creates a connection to a server. Clients may send messages to exchanges. Exchanges route messages to queues inside the broker, or stop them all together. Whereas exchanges are stateless gatekeepers, queues actually queue and store the messages.</p>
<p> Clients may consume messages from the queues. There is no relationship between an exchange and a queue: you may create as many queues as you like and bind one or many of them to an exchange. The relationship between an exchange and a queue is called a binding. An exchange will deliver up to one copy of a message to a queue if the routing key in the message matches a binding. This is important, because I said before, it is possible to specify many exchanges, and bindings, for a single queue. Multiple matches do not yield multiple messages. Exchanges dictate what is a match. There are several well-known exchanges, and they specify different matching algorithms.</p>
<UL>
<li><b>fanout exchange</b>: a fanout exchange routes all messages received to every queue bound to that exchange (this is most simialar to a <code>javax.jms.Topic</code>, for publish-subscribe-style messaging)</li>
<li><b>direct exchange</b>: matches when the routing key (a common header in a message) and the binding key are identical (this is most simialar to a <code>javax.jms.Queue</code>, for point-to-point messaging)</li>
<li><b>topic exchange</b>: a topic exchange has no API-specific equivalent in JMS. It is most like hierarchical topics in some message brokers. A topic exchange matches the routing key header to a exchange binding that uses a special syntax to allow for wildcards. The binding key might specify the following, for example: ".years.#". This wildcard would match any one word, followed by a dot ("."), followed "years," and another dot ("."), followed by zero or more words. Thus, "taxes.years.2011" would match, as would "taxes.years," but "years.2322" would not. </li>
<li><b>headers exchange</b>: matches the presence of header keys or header key-value pairs. </li><p></ul><br />[caption id=&ldquo;attachment_7484&rdquo; align=&ldquo;alignnone&rdquo; width=&ldquo;698&rdquo; caption=&ldquo;Above, the blue circles are producers and consumers, the green elements are the exchanges, and the orange elements are the AMQP queues where messages are stored. They are simply named storage for messages, and don&rsquo;t have any relationship to a queue in the JMS sense.&rdquo;]<a href="http://blog.springsource.com/wp-content/uploads/2011/01/amqp.jpg"><img src="http://blog.springsource.com/wp-content/uploads/2011/01/amqp.jpg" alt="" title="amqp" width="698" height="312" class="size-full wp-image-7484" /></a>[/caption]<br /><p>The specification also permits special exchanges to be added, as well. For example, RabbitMQ adds the plugin exchange, which is basically an extension point for third parties (Or, indeed, RabbitMQ itself) to provide extra functionality. This has fostered an ever-growing list of installable plugins that do everything from send XMPP messages, handle replication and display a web UI for management. </p></p>
<h3>Using Spring with AMQP</h3>
<p> We're going to investigate the use of <a href="http://www.springsource.org/spring-amqp">Spring AMQP,</a> the Spring portfolio project that lets you work with RabbitMQ to do all the things mandated by the specification, but also more advanced RabbitMQ-specific operations. </p>
<p>Let's start building our example - of basically the same design as our JMS example - using RabbitMQ and the Spring AMQP client. The first thing you'll need are the appropriate dependencies. If you're using Maven, add the following dependencies to your <code>pom.xml</code> file:</p>
<pre><code class="prettyprint xml"><br />            &lt;dependency&gt;
                &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;
                &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;
                &lt;version&gt;${com.rabbitmq.version}&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt;
                &lt;artifactId&gt;spring-rabbit&lt;/artifactId&gt;
                &lt;version&gt;${spring.amqp.version}&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt;
                &lt;artifactId&gt;spring-amqp&lt;/artifactId&gt;
                &lt;version&gt;${spring.amqp.version}&lt;/version&gt;
            &lt;/dependency&gt;
</code></pre>
<p>Be sure to create Maven properties for the <code>${spring.amqp.version}</code>, and <code>${com.rabbitmq.version}</code> property placeholders, or simply replace them expressly with the appropriate version. At the time of this wiriting, <code>${spring.amqp.version}</code> is<code> 1.0.0.M2,</code> and <code>${com.rabbitmq.version}</code> is<code> 2.1.0</code>. As we did in the previous example, we've installed a simple Spring XML configuration file to bootstrap everything else. The only thing different is the name of the transaction manager implementation referenced from the use of the <code>&lt;tx:annotation-driven&gt;</code> element, the packages scanned and the name of the property file that was loaded! So, let's not waste too much time on the setup and get straight to the configuration for our AMQP-based example.</p>
<pre><code class="prettyprint java"><br />package org.springsource.greenbeans.examples.amqp.core;

import org.springframework.amqp.core.*;
import org.springframework.amqp.rabbit.connection.*;
import org.springframework.amqp.rabbit.core.*
import org.springframework.amqp.rabbit.transaction.RabbitTransactionManager;
import org.springframework.amqp.support.converter.*
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.*;

@Configuration
@SuppressWarnings(&quot;unused&quot;)
public class AmqpConfiguration {

  @Value(&quot;${broker.url}&quot;)
  private String brokerUrl;

  @Value(&quot;${broker.username}&quot;)
  private String username;

  @Value(&quot;${broker.password}&quot;)
  private String password;

  @Value(&quot;${amqp.customer.queue}&quot;)
  private String customerQueueName;

  @Bean
  public RabbitTemplate rabbitTemplate() {
    RabbitTemplate rabbitTemplate = new RabbitTemplate(singleConnectionFactory());
    rabbitTemplate.setMessageConverter(jsonMessageConverter());
    return rabbitTemplate;
  }

  @Bean
  public RabbitTransactionManager rabbitTransactionManager() {
    return new RabbitTransactionManager(this.singleConnectionFactory());
  }

  @Bean
  public MessageConverter jsonMessageConverter() {
    return new JsonMessageConverter();
  }

  @Bean
  public ConnectionFactory singleConnectionFactory() {
    SingleConnectionFactory connectionFactory = new SingleConnectionFactory(this.brokerUrl);
    connectionFactory.setUsername(this.username);
    connectionFactory.setPassword(this.password);
    return connectionFactory;
  }

  @Bean
  public AmqpAdmin amqpAdmin() {
    return new RabbitAdmin(this.rabbitTemplate());
  }

  @Bean
  public Queue customerQueue() {
    Queue q = new Queue(this.customerQueueName);
    amqpAdmin().declareQueue(q);
    return q;
  }

  @Bean
  public DirectExchange customerExchange() {
    DirectExchange directExchange = new DirectExchange(customerQueueName);
    this.amqpAdmin().declareExchange(directExchange);
    return directExchange ;
  }

  @Bean
  public Binding marketDataBinding() {
    return BindingBuilder.from(customerQueue()).to(customerExchange()).with(this.customerQueueName);
  }
}
</code></pre>
<p>As you can see there's a bit more going on here than there was for our <code>JmsTemplate</code>, but don't fret, the big parts are identical in form and function to their JMS counterparts. The rest are just details. First, we configure the usual suspects – the <code>TransactionManager</code> (<code>RabbitTransactionManager</code>), the <code>ConnectionFactory </code> instance and the <code>RabbitTemplate</code>. Most of that should be pretty self explanatory.</p>
<p>Let's dive into the areas that don't line up. The first nuance is that we configure a reference to <code>JsonMessageConverter</code> on <code>RabbitTemplate</code>. Remember: AMQP is language and platform independent. Messages sent to an AMQP broker from Java may well be consumed by a client on .NET or Python or PHP. When messages are packaged and sent over the wire, the payload goes as a stream of bytes. The recipient of the message needs to be able to restore those bytes to something that can be read on the recipient's platform. If the message used Java objects, those bytes would be serialized Java objects and only a Java client with the same class on the other side would be able to deserialize it. So, just as in the Spring JMS support, Spring AMQP provides a <code>MessageConverter </code> hierarchy. The Spring AMQP hierarchy has a <code>MarshallingMessageConverter</code>, as well as a <code>SimpleMessageConverter</code>, and – in addition – it features a <code>JsonMessageConverter</code> (which is unique to the Spring AMQP project, at the moment) that converts objects to and from JSON (the JavaScript Object Notation format that's parse-able by all major languages and platforms and less verbose / porous than XML). In JMS, smart serialization was a matter of efficiency and design, but in AMQP, it is a far more pressing concern, so pay attention to the configured <code>MessageConverter</code>. </p>
<p> You'll find four objects in the configuration that have no analog in the JMS example. The first is the <code>AmqpAdmin</code>. AMQP defines – at the protocol level – commands for creating everything your application needs to work including the exchanges, queues and binding. In the Spring AMQP API, the <code>AmqpAdmin </code> is the key interface to those commands. </p>
<p>In the <code>customerQueue</code> method, we configure an AMQP queue, and a <code>DirectExchange </code> in the <code>customerExchange</code> method. Finally, we use the Spring AMQP fluid <code>BindingBuilder </code> API to connect the queue to our exchange. In our specific example – we're sending a message with a routing key of <code>"customers"</code> to a queue named "customers." In our specific example, we don't need to declare anything besides the queue for this to work, as the no-name exchange will kick in and simply route the message based on the routing key. However, it's useful to see how it's done, even if it is a bit redundant. We use the <code>AmqpAdmin</code> instance to "declare" these constructs. These objects are idempotent. You may "declare" them a million times and if they already exist, then nothing will happen for any but one of those declarations, so it's harmless to repeat the calls when your application starts up. Additionally, if these constructs are made <em>persistent</em>, then there is no need to even declare them each time.</p>
<p> Let's look at how to send a message. </p>
<pre><code class="prettyprint java"><br /><br />package org.springsource.greenbeans.examples.amqp.core;

import org.apache.commons.lang.builder.ToStringBuilder;
import org.apache.commons.logging.*;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.*
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;
import org.springsource.greenbeans.examples.Customer;

@Component
public class Producer {

  @Value(&quot;${amqp.customer.exchange}&quot;)
  private String exchange;
  
  @Value(&quot;${amqp.customer.queue}&quot;)
  private String routingKey;

  @Autowired
  private RabbitTemplate rabbitTemplate;

  private Log log = LogFactory.getLog(getClass());

  @Transactional
  public void sendCustomerUpdate(Customer customer) {
    log.info(&quot;sending customer update &quot; + ToStringBuilder.reflectionToString(customer));
    this.rabbitTemplate.convertAndSend(this.exchange , this.routingKey, customer);
  }
}
</code></pre>
<p>In this class, we use the <code>RabbitTemplate</code> to send a message and convert it to JSON. We specify which <code>routingKey</code> we want to use and which exchange should be used (both "customers," in keeping with the type of binding we set up in the configuration.) We've configured the class to use <code>@Transactional</code> and so any failures to send a message will behave the same as if there were a failure using JMS. </p>
<p>Now, let's look at our options for receiving messages using AMQP. </p>
<pre><code class="prettyprint java"><br /><br />package org.springsource.greenbeans.examples.amqp.amqptemplate;

import org.apache.commons.lang.builder.ToStringBuilder;
import org.apache.commons.logging.*;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.*;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;
import org.springsource.greenbeans.examples.Customer;

@Component
public class RawAmqpTemplatePollingMessageConsumer {

  @Autowired
  protected RabbitTemplate amqpTemplate;

  @Value(&quot;${amqp.customer.queue}&quot;)
  private String queue;

  private Log log = LogFactory.getLog(getClass());

  @Transactional
  public void receiveAndProcessCustomerUpdates() throws Exception {
    Customer msg = (Customer)this.amqpTemplate.receiveAndConvert(this.queue);
    log.info(&quot;receiving customer message: &quot; + ToStringBuilder.reflectionToString(  msg));
  }
}
</code></pre>
<p>Unsurprisingly, this looks virtually identical (save for the <code>RabbitTemplate</code>) as the first, synchronous JMS example. We are spared a bit of the conversion logic that we had to work with in the first example, but otherwise it's basically the same. If a transaction rollback occurs on message receipt the message will be returned to the end of the queue where it will eventually be redelivered. </p>
<p>Spring AMQP also supports asynchronous message receipt, just as in the Spring JMS suppport. However, as the Spring AMQP project is still a nascent project, there's no equivalent namespace support. So, we need to configure the object oursevles. Add the following to your configuration.</p>
<pre><code class="prettyprint java"><br /><br />  @Autowired
  private MessageListenerContainerConsumer messageListenerContainerConsumer;

  @Bean
  public SimpleMessageListenerContainer listenerContainer() {
    SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();
    container.setTransactionManager(this.rabbitTransactionManager());
    container.setConnectionFactory(singleConnectionFactory());
    container.setQueueName(this.customerQueueName);

    MessageListenerAdapter messageListenerAdapter = new MessageListenerAdapter(
           this.messageListenerContainerConsumer, this.jsonMessageConverter());
    container.setMessageListener(messageListenerAdapter);
    return container;
  }
</code></pre>
<p>This configuration injects the component that will do the processing (see below, the <code>messageListenerContainerConsumer</code> instance is picked up by component-scanning and automatically registered with Spring, which is why we autowirte it here) and then configures a <code>SimpleMessageListenerContainer</code> instance that will handle receiving messages, managing transactions, and converting the incoming messges before giving it to the POJO. </p>
<p>The POJO itself looks like this:</p>
<pre><code class="prettyprint java"><br /><br />package org.springsource.greenbeans.examples.amqp.messagelistenercontainer;

import org.apache.commons.lang.builder.ToStringBuilder;
import org.apache.commons.logging.*;
import org.springframework.stereotype.Component;
import org.springsource.greenbeans.examples.Customer;

@Component
public class MessageListenerContainerConsumer {
  
  private Log log = LogFactory.getLog(getClass() );
  
  public void handleMessage(Customer cu){
    log.info(&quot;Received customer &quot; + ToStringBuilder.reflectionToString(cu)) ;
  }
}
</code></pre>
<p>This class benefits from the message converter a bit more than the other one. Here, we're able to declare a method that takes a parameter of type Customer, and the <code>MessageListenerContainer</code> knows how to convert it and then pass it to the <code>handleMessage</code> method. All the same rules apply, however. Exceptions will trigger a rollback, etc.</p>
<h2>Summary</h2>
<p> In this post, we've explored the two options available to developers that want to incorporate enterprise messaging in their application today with the Spring framework. We introduced both the Java Message Service (JMS) API and the Advanced Message Queueing Protocol (AMQP) for dealing with enterprise messages. We have provided both synchronous and asynchronous examples using the core Spring framework and the Spring AMQP project. We touched on how messaging can help scale applications and how it can be a handy way to integrate applications. I hope that this will make it easier for you to understand the choices possible when using enterprise messaging and how Spring makes it easier to make the correct choice for your application. As usual, the code for this blog post can be found in our <a href="http://git.springsource.org/spring-samples/spring-samples">Spring Samples</a> repository. </p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 389;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>
Back
</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">All Posts</a>
<a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">Engineering</a>
<a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">Releases</a>
<a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">News and Events</a>
<a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>Get updates from The Spring Team delivered to your inbox</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">Tools</a></li>
<li><a href="https://store.pivotal.io/">Store</a></li>
<li><a href="/blog">Newsletter</a></li>
</ul>
</div>
</div>
&copy; <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a>, Inc. All Rights Reserved.
<a href="https://pivotal.io/terms-of-use">Terms of Use</a> &bullet;
<a href="https://pivotal.io/privacy-policy">Privacy</a> &bullet;
<a href="/trademarks">Trademark Guidelines</a>
<div id="teconsent" style="display:inline-block;"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>