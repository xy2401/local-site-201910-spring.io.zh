<!DOCTYPE html>
<html data-code-prettify="" data-mobile-support="" data-search="">
<head>
<title>Routing Topologies for Performance and Scalability with RabbitMQ</title>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no" id="Viewport" name="viewport" />
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png" />
<link href="https://fonts.googleapis.com/css?family=Varela+Round|Montserrat:400,700" rel="stylesheet" type="text/css" />
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css" />
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M" name="google-site-verification" />

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css" />

<meta content="summary" name="twitter:card" />
<meta content="@springcentral" name="twitter:site" />
<meta name="twitter:title" content="Routing Topologies for Performance and Scalability with RabbitMQ" />
<meta name="twitter:description" content="&lt;p&gt;Designing a good routing topology for a highly-scalable system can be like mapping a graph. Many things need to be considered, for instance the problem, constraints of the environment, those of the messaging implementation, and performance strategies. What we often run up against is a lack of flexibility and expressivity in fitting routing to our needs. Here is where RabbitMQ stands out.&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Basic Concepts&lt;/h2&gt;
&lt;br&gt;
&lt;br&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;a href=&quot;http://blog.springsource.com/wp-content/uploads/2011/03/tree-nodes.png&quot;&gt;&lt;img class=&quot;size-full wp-image-8329  aligncenter&quot; title=&quot;Hierarchical nodes in message routing topology&quot; src=&quot;http://blog.springsource.com/wp-content/uploads/2011/03/tree-nodes.png&quot; alt=&quot;Hierarchical nodes in message routing topology&quot; width=&quot;170&quot; height=&quot;236&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;
&lt;a href=&quot;http://en.wikipedia.org/wiki/AMQP &quot;&gt;AMQP&lt;/a&gt;
&lt;a href=&quot;http://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol&quot;&gt;STOMP&lt;/a&gt;
&lt;br&gt;
&lt;ul&gt;
 &lt;br&gt; 
 &lt;li&gt;&lt;strong&gt;Exchange&lt;/strong&gt; The entity within the server which receives messages from producer applications and optionally routes these to message queues within the server&lt;/li&gt;
 &lt;br&gt; 
 &lt;li&gt;&lt;strong&gt;Exchange type&lt;/strong&gt; The algorithm and implementation of a particular model of exchange. In contrast to the “exchange instance”, which is the entity that receives and routes messages within the server&lt;/li&gt;
 &lt;br&gt; 
 &lt;li&gt;&lt;strong&gt;Message queue&lt;/strong&gt; A named entity that holds messages and forwards them to consumer applications&lt;/li&gt;
 &lt;br&gt; 
 &lt;li&gt;&lt;strong&gt;Binding&lt;/strong&gt; An entity that creates a relationship between a message queue and an exchange&lt;/li&gt;
 &lt;br&gt; 
 &lt;li&gt;&lt;strong&gt;Routing key&lt;/strong&gt; A virtual address that an exchange may use to decide how to route a specific message&lt;/li&gt;
 &lt;br&gt;
&lt;/ul&gt;
" />

<meta property="og:title" content="Routing Topologies for Performance and Scalability with RabbitMQ" />
<meta property="og:description" content="&lt;p&gt;Designing a good routing topology for a highly-scalable system can be like mapping a graph. Many things need to be considered, for instance the problem, constraints of the environment, those of the messaging implementation, and performance strategies. What we often run up against is a lack of flexibility and expressivity in fitting routing to our needs. Here is where RabbitMQ stands out.&lt;br&gt;&lt;/p&gt;
&lt;h2&gt;Basic Concepts&lt;/h2&gt;
&lt;br&gt;
&lt;br&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;&lt;a href=&quot;http://blog.springsource.com/wp-content/uploads/2011/03/tree-nodes.png&quot;&gt;&lt;img class=&quot;size-full wp-image-8329  aligncenter&quot; title=&quot;Hierarchical nodes in message routing topology&quot; src=&quot;http://blog.springsource.com/wp-content/uploads/2011/03/tree-nodes.png&quot; alt=&quot;Hierarchical nodes in message routing topology&quot; width=&quot;170&quot; height=&quot;236&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;br&gt;
&lt;a href=&quot;http://en.wikipedia.org/wiki/AMQP &quot;&gt;AMQP&lt;/a&gt;
&lt;a href=&quot;http://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol&quot;&gt;STOMP&lt;/a&gt;
&lt;br&gt;
&lt;ul&gt;
 &lt;br&gt; 
 &lt;li&gt;&lt;strong&gt;Exchange&lt;/strong&gt; The entity within the server which receives messages from producer applications and optionally routes these to message queues within the server&lt;/li&gt;
 &lt;br&gt; 
 &lt;li&gt;&lt;strong&gt;Exchange type&lt;/strong&gt; The algorithm and implementation of a particular model of exchange. In contrast to the “exchange instance”, which is the entity that receives and routes messages within the server&lt;/li&gt;
 &lt;br&gt; 
 &lt;li&gt;&lt;strong&gt;Message queue&lt;/strong&gt; A named entity that holds messages and forwards them to consumer applications&lt;/li&gt;
 &lt;br&gt; 
 &lt;li&gt;&lt;strong&gt;Binding&lt;/strong&gt; An entity that creates a relationship between a message queue and an exchange&lt;/li&gt;
 &lt;br&gt; 
 &lt;li&gt;&lt;strong&gt;Routing key&lt;/strong&gt; A virtual address that an exchange may use to decide how to route a specific message&lt;/li&gt;
 &lt;br&gt;
&lt;/ul&gt;
" />
<meta content="article" property="og:type" />
<meta property="og:article:published_time" content="2011-04-01 17:43:00.0" />
</head>
<body>

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" style="display:none;visibility:hidden" width="0"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">Projects</a>
</li>
<li class="navbar-link">
<a href="/guides">Guides</a>
</li>
<li class="navbar-link active">
<a href="/blog">Blog</a>
</li>
<li class="navbar-link">
<a href="/services">Training & Certification</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form action="/search" class="form-inline form-search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search for documentation, guides, and posts..." type="text" value="" />
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form action="/search" class="form-inline form-search" method="get">
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search..." type="text" value="" />
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">
Home
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">
Projects
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">
Guides
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">
Blog
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">
Training & Certification
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>Engineering</div>
</div>
<div class="blog-category content--title">
<div>Releases</div>
</div>
<div class="blog-category content--title">
<div>News and Events</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Routing Topologies for Performance and Scalability with RabbitMQ</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">Engineering</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="null?s=20&amp;d=mm" />
<span class="author">Helena Edelson</span>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2011-04-01 17:43:00.0">April 01, 2011</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" data-disqus-identifier="404" href="/blog/2011/04/01/routing-topologies-for-performance-and-scalability-with-rabbitmq#disqus_thread">
</a></div>
</div>
</header>
<div class="blog--post"><p>Designing a good routing topology for a highly-scalable system can be like mapping a graph. Many things need to be considered, for instance the problem, constraints of the environment, those of the messaging implementation, and performance strategies. What we often run up against is a lack of flexibility and expressivity in fitting routing to our needs. Here is where RabbitMQ stands out.<br /><h2>Basic Concepts</h2><br />Anyone familiar with messaging in general knows the concept of routing messages from A to B. Routing can be simplistic or quite complex, and when designing a routing topology for a scalable, complex system it must be elegant. Kept clean and decoupled, components can throttle nicely with varying loads. This can be expressed as a simple map or complex graph. In its simplest form a routing topology can be expressed as nodes, for instance hierarchical nodes:<br /><p style="text-align: center;"><a href="http://blog.springsource.com/wp-content/uploads/2011/03/tree-nodes.png"><img class="size-full wp-image-8329  aligncenter" title="Hierarchical nodes in message routing topology" src="http://blog.springsource.com/wp-content/uploads/2011/03/tree-nodes.png" alt="Hierarchical nodes in message routing topology" width="170" height="236" /></a></p><br />For those new to RabbitMQ or <a href="https://en.wikipedia.org/wiki/AMQP ">AMQP</a> (note that Rabbit works with many protocols including <a href="https://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol">STOMP</a>, HTTP, HTTPS, XMPP, and SMTP), here are some basic component descriptions:<br /><ul><br /> <li><strong>Exchange</strong> The entity within the server which receives messages from producer applications and optionally routes these to message queues within the server</li><br /> <li><strong>Exchange type</strong> The algorithm and implementation of a particular model of exchange. In contrast to the &ldquo;exchange instance&rdquo;, which is the entity that receives and routes messages within the server</li><br /> <li><strong>Message queue</strong> A named entity that holds messages and forwards them to consumer applications</li><br /> <li><strong>Binding</strong> An entity that creates a relationship between a message queue and an exchange</li><br /> <li><strong>Routing key</strong> A virtual address that an exchange may use to decide how to route a specific message</li><br /></ul><br />For point-to-point routing, the routing key is usually the name of a message queue. For topic pub-sub routing the routing key is usually hierarchical in nature:</p><p><code>api.agents.agent-{id}.operations.{operationName}</code></p><p>In more complex cases the routing key may be combined with routing on message header fields and/or its content. An exchange examines a message&rsquo;s properties, header fields, body content, and possibly data from other sources, then decides how to route the message. A binding pattern derived from the above routing key idea might look like<code> api.agents.*.operations.*</code> where we bind exchange <code>E1</code> to queue <code>Q1</code> with binding pattern <code>api.agents.*.operations.*</code> so that any messages sent to <code>E1</code> route to <code>Q1</code> if their routing key matches the binding pattern.</p><p>A Rabbit broker is structured differently than a JMS Broker. Each RabbitMQ server is comprised of at least one node (broker), or more typically, nodes in a cluster. Each node has a default virtual host, &ldquo;/&rdquo;, and further virtual hosts can be created such as &ldquo;/develoment&rdquo;. Rabbit virtual hosts are like Tomcat virtual hosts and partition broker data into sub-sets. Within these virtual hosts are exchanges and queues. When a user connects with its credentials, it is connecting to a virtual host on a Rabbit node.</p><p>Here we connect to a Rabbit node, declare an exchange to publish to, a queue to consume from, a binding pattern, then publish a few messages, using the <a href="https://www.rabbitmq.com/java-client.html">RabbitMQ java client api</a>:</p>
<pre><code class="prettyprint java">package org.demo.simple.rabbit;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;
import com.rabbitmq.client.QueueingConsumer;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

public final class RocketSender {

 public void sendRockets() throws IOException {
     List&lt;String&gt; rocketsWithRoutings = new RocketRouter().build();

     Connection connection = new ConnectionFactory().newConnection();
     Channel channel = connection.createChannel();

     String rocketExchange = &quot;rockets.launched&quot;;
     channel.exchangeDeclare(rocketExchange, &quot;topic&quot;);
     String rocketQueue = channel.queueDeclare().getQueue();
     channel.queueBind(rocketQueue, rocketExchange, &quot;galaxies.*.planets.*&quot;);

     for (String rocketTo : rocketsWithRoutings) {
         channel.basicPublish(rocketExchange, &quot;galaxies.*.planets.&quot; + rocketTo, null, rocketTo.getBytes());
     }

     channel.close();
     connection.close();
 }
}
</code></pre><p>A simple consume of &ldquo;landed&rdquo; rockets could look like:</p>
<pre><code class="prettyprint java"><br /> QueueingConsumer queueingConsumer = new QueueingConsumer(channel);
 channel.basicConsume(rocketQueue, false, queueingConsumer);

 int landed = 0;
 while (landed &lt; launched) {
     QueueingConsumer.Delivery delivery = queueingConsumer.nextDelivery();
     channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
     String rocketLanded = new String(delivery.getBody());

     if (rocketLanded.equalsIgnoreCase(&quot;Alderaan&quot;)) {
         System.out.println(&quot;That&#39;s no moon, that&#39;s a space station.&quot;);
     }
     landed++;
 }
</code></pre>
<h2>The Problem</h2><p>In considering what routing strategies perform best in scalable environments where performance itself can also be improved, there many options. One of the great things about messaging in general is the variety of configurations available, and figuring out the right ones that solve both current and growing requirements.</p><p>To keep things simple let&rsquo;s consider two strategies:<br /><ol><br /> <li>Highly-partitioned routing with hierarchical routing keys, fewer topic exchanges</li><br /> <li>A larger number of direct exchanges and queues with far less routing partitions</li><br /></ol><br />Each scenario follows this use case: each application that must scale is both producer and consumer:<br /><p style="text-align: center;"><a href="http://blog.springsource.com/wp-content/uploads/2011/03/producer-consumer.png"><img class="aligncenter size-full wp-image-8318" title="Producer Consumer" src="http://blog.springsource.com/wp-content/uploads/2011/03/producer-consumer.png" alt="" width="311" height="95" align="center" /></a></p></p>
<h3>Where To Start</h3><p>It is a good idea to take stock of your environment and its components before delving into a routing solution that will scale cleanly and efficiently over time. For example, what lends to scaling? Generally, decoupling, distribution, asynchrony, parallelism, levels of abstraction and indirection to name a few. Then consider what elements are current or potential bottlenecks. It is a basic principle that high traffic/volume pathways require more efficient throughput or you incur risk of bottlenecks in your distribution. One exercise is to rank these in terms of traffic or as a heat map. Next, can you classify your traffic - are there overarching patterns, topics or similar message types, and what are the relationships? Now start to consider consolidation, how and where might efficiency be improved, and apply tested patterns that resolve those heat points, decouple for scale, and increase performance.<br /><h2>General Routing Considerations</h2><br />All exchange types behave differently. Here are a few general rules:<br /><ul><br /> <li>If you have a finite domain of routing keys in an application&rsquo;s graph then many fanout exchanges might be the right fit  (1:1 mapping of exchange per routing  key)</li><br /> <li>If you have a potentially infinite number of routing keys, consider topic exchanges</li><br /> <li>For topic routing, performance decreases as the number of bindings increase</li><br /> <li>Fanout exchanges are very fast because they have no routing to process yet if bound to a large number of queues that changes</li><br /> <li>Direct exchanges are a faster form of topic exchanges, provided you do not need the wild card</li><br /> <li>Troubleshooting problems across 100,000+ queues could be tedious versus a topology with more bindings, fewer exchanges and queues</li><br /> <li>A very high number of exchanges and queues take up more memory which may be significant but this really depends</li><br /></ul><br />As of RabbitMQ 2.4.0, released March 23, 2011, a new topic routing algorithm optimization is available that is 60 times faster at peak than the previous topic algorithm. Due to this, one recommendation is to go for less exchanges and queues, and more routing because the time increase is now minimal.<br /><h2>Performance</h2><br /><h3>What is Cheap?</h3><br />In terms of memory cost, exchanges and bindings. In <a title="Erlang" href="http://www.erlang.org">Erlang</a>, which RabbitMQ is built on, each node (broker) is a process, as is each queue. By default the Erlang VM process limit is set to 1M, which can be raised. However, an exchange is not a process for scalability reasons, it is simply a row in RabbitMQ&rsquo;s built-in Mnesia database. In a cluster, declaring an exchange causes it to appear on all nodes of the cluster, while declaring a queue creates it on only one of the nodes. This explains why exchanges survive node restarts or creating a node in a cluster, yet queues do not.</p><p>Be wary of binding churn. In strategy number 2, if you create many new queues and their bindings, whenever consumers attach you might run into problems. For instance, given exchanges <code>E1&hellip;En</code> to which many messages are being published, whenever consumer <code>Cm</code> connects, it creates bindings from its own queue to all of <code>E1&hellip;En</code> which may cause problems, depending on the rate of connections.</p><p>To alleviate binding churn, consider exchange-to-exchange bindings, new as of version 2.3.1. Each consumer could have its own secondary exchange <code>Ym</code> which must not be auto-delete. Then bind all of <code>E1&hellip;En</code> to <code>Ym</code>. In this way these bindings always exist. In this scenario, whenever consumer <code>Cm</code> connects it simply has to declare its queue and bind that queue to <code>Ym</code>. If Ym is a fanout exchange, it will be very fast and reduce the binding churn rate to 1 per connection, rather than potentially n per connection.<br /><p style="text-align: center;"><a href="http://blog.springsource.com/wp-content/uploads/2011/04/exchange-exchange.png"><img class="aligncenter size-full wp-image-8355" title="Exchange-to-Exchange Binding" src="http://blog.springsource.com/wp-content/uploads/2011/04/exchange-exchange.png" alt="Exchange-to-Exchange Binding" width="533" height="159" align="center" /></a></p></p>
<h2>Use Cases</h2>
<h3>Exchange-to-Exchange Scalable Use Case</h3><p>Consider a server application with autonomous agents. Each agent is on a virtual machine that is part of an elastically-scaled system. As each agent starts up it sends a message to the server that it is online, followed by many other messages such authentication and data transfer. If we have 1,000 agents, each declaring 50 direct exchanges, queues and bindings, then each agent must know the server&rsquo;s queues in order to fulfill the binding contract on queue.declare operations. That is not a scalable solution.</p><p>Now consider creating shared topic exchanges: one exchange for the agent to server pathway,  another for the server to agent pathway, and a third to handle unauthenticated agents which routes only to those queues that do not require security. Now we partition with binding patterns, message routing keys and bring one set of those up for each server to be shared by all agents that connect to it. Then, in its simplest form, as each agent comes online it declares a private exchange and queue, and binds its exchange to the shared topic exchanges.</p><p>Our relationships are now expressed by exchange-to-exchange mappings which reduces churn rate and decouples agents from having to &lsquo;know&rsquo; the server queues. Using this pattern the system is  clean, decoupled, and scalable.<br /><p style="text-align: center;"><a href="http://blog.springsource.com/wp-content/uploads/2011/04/routing-topology.png"><img class="aligncenter size-full wp-image-8374" title="Basic Routing Topology" src="http://blog.springsource.com/wp-content/uploads/2011/04/routing-topology.png" alt="" width="926" height="655" /></a></p></p>
<h3>Elastic-Scaling Use Case</h3><p>Let&rsquo;s take the previous scenario a step further. We are already using topic pub-sub routing over scenario 2: many direct routings. Now let&rsquo;s say the system requirement bumps up to scale clusters of our server application in a data center with 50,000 or more agents. How can we throttle varying loads?</p><p>The authenticated client exchange routes messages from agent to server. It handles all operations publishing messages to singular-consumer queues, including those producing the highest frequency of messages. This is a potential bottleneck under the current topology with roughly 60,000 messages per minute for 10,000 clients or 86,400,000 messages per day. This is easily resolvable, RabbitMQ can handle over 1 billion messages per day depending on your configuration, for example whether or not you are persisting messages.</p><p>Our server applications are running a RabbitMQ cluster. Remember that in a cluster, declaring an exchange causes it to appear on all nodes, while declaring a queue creates it on only one of the nodes, so we have to configure a solution.<br /><h3>Load-Balancing Between Producers and Consumers</h3><br />To efficiently handle these potentially very high loads as more client applications (Agents) come online, we can modify this topology in several ways. First, an optimization from the above configuration to load-balance messages across a Rabbit cluster. We can create one queue for each node in the Rabbit cluster. If we have four nodes, for each high-traffic queue we create hfq.{0,1,2,3} for that operation. Now each agent can randomly pick a node by a number between zero and three, or a more sophisticated round-robin implementation, to publish to. With RabbitMQ there are RPC calls or you can use the <a title="Rabbit management plugin" href="https://www.rabbitmq.com/management.html">Rabbit management plugin</a> to GET the number of nodes, which you can use in your round-robin algorithm.<br /><h3>Worker Queues With Round-Robin Dispatching</h3><br />Worker Queues, or Task Queues, are generally used to efficiently distribute time-consuming tasks among multiple workers and easily parallelise work. In addition, this topology applies to eliminating the need to execute resource-intensive tasks and having to block until they complete. Running several worker queues allows these tasks to be distributed among them.<br /><p style="text-align: center;"><a href="http://blog.springsource.com/wp-content/uploads/2011/03/multiple-consumers.png"><img class="aligncenter size-full wp-image-8325" title="Worker Queues" src="http://blog.springsource.com/wp-content/uploads/2011/03/multiple-consumers.png" alt="" width="297" height="124" /></a></p><br />With Worker Queues, by default, Rabbit uses a round-robin distribution method, sending each message to the next consumer in sequence. Each consumer receives roughly the same number of messages. If you declare a queue and spin up 3 competing consumers, bind them to the exchange, and send 20,000 messages, messages zero will route to the first consumer, message one to the second, message two to the third and so on. If we begin building up a backlog of tasks, we can simply add more workers, allowing the system to scale easily.<br /><h2>Performance</h2><br /><h3>Memory</h3><br />Neither option above will necessarily induce high load in RabbitMQ. There are no hard limits to the number of exchanges and queues, one can create, and running 100,000 queues on one broker is fine. With the right tuning and enough RAM you can run well over a million queues.</p><p>RabbitMQ dynamically pushes messages to disk to free up RAM, thus the memory footprint of a queue is not dependent on its contents. After a queue is idle for 10 seconds or more it will &ldquo;hibernate&rdquo; which causes GC on that queue. As a result, the amount of memory a queue requires can dramatically shrink. For example, it might be possible for 1000 empty, idle queues to take up 10MB of RAM. When they&rsquo;re all active (even if empty), they might of course, depending on memory fragmentation, consume much more memory. Forcing them back into hibernation to test behavior is difficult because the Erlang VM does not hand back memory to the OS immediately.</p><p>You can, however, observe a large process that hibernates and has very fragmented memory because the amount reclaimed can be sufficient to force the VM to hand back memory to the OS. If you run a test that steadily increases the memory footprint of Rabbit you could observe the effect of hibernation on idle processes as it reduces the rate of increase of memory use.</p><p>Erlang is a multi-threaded VM which takes advantage of multiple cores. It presents green threads to the developer which are called &lsquo;processes&rsquo; because unlike threads, they conceptually do not share an address space. Here is an interesting confession on <a href="http://www.infoq.com/news/2011/04/erlang-copied-jvm-and-scala" target="_new">the Erlang VM and Processes</a>.<br /><h3>Transactions</h3><br />Transactions on 10,000 messages can take as along as four minutes to publish. A new RabbitMQ feature called <a href="https://www.rabbitmq.com/blog/2011/02/10/introducing-publisher-confirms/">Publisher Confirms</a> is more than 100 times faster than the same, but transactional, code. If you are not explicitly required to implement transactions but do need the verification you might consider this option.<br /><h2>The Take-Away</h2><br />Here are some final takeaways to help you squeeze the greatest performance gains out of your implementation:<br /><ul><br /> <li>The new topic routing algorithm optimization is 60 times faster at peak</li><br /> <li>Topic binding patterns using wildcards &lsquo;<em>&lsquo;, which matches a single word, is much faster than &rsquo;#&lsquo;, which matches zero or more words. Wildcard &rsquo;#&lsquo; takes longer to process in the routing table than &rsquo;</em>&rsquo;</li><br /> <li>Exchange-to-exchange bindings improve decoupling, increase topology flexibility, reduce binding churn, and help increase performance</li><br /> <li>Exchanges and bindings are very light weight</li><br /> <li>RabbitMQ Publisher Confirms are more than 100 times faster than AMQP transactions</li><br /> <li>After a queue is idle for &gt;=10 seconds it will &ldquo;hibernate&rdquo;, inducing GC on the queue, resulting in a dramatic decrease in memory required for that queue</li><br /> <li>Worker Queues help parallelize and distribute workloads</li><br /> <li>Distributing worker queues in the Rabbit cluster helps scale</li><br /> <li>Load-balance your topology</li><br /></ul><br />This is by no means a thesis on the subject, there are indeed many more patterns, topologies and performance details to consider. A strategy, as always, depends on so many factors but I hope this encapsulates enough to help or at least get one thinking in the right directions.<br /><h2>Get It</h2><br /><a href="https://github.com/rabbitmq">RabbitMQ Source on GitHub</a><br /><a href="https://www.rabbitmq.com/download.html">RabbitMQ Binary Downloads and Plugins</a><br /><a href="http://www.erlang.org/download.html">Erlang Downloads</a><br /><a href="http://www.springsource.org/spring-amqp">Spring AMQP</a> API for RabbitMQ in Java and .NET<br /><a href="http://www.hyperic.com/downloads">Hyperic to monitor RabbitMQ</a><br />Maven<br /><blockquote><code><br />&lt;dependency&gt;<br />&lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;<br />&lt;artifactId&gt;amqp-client&lt;/artifactId&gt;<br />&lt;version&gt;${rabbitmq.version}&lt;/version&gt;<br />&lt;exclusions&gt;<br />&lt;exclusion&gt;<br />&lt;groupId&gt;commons-cli&lt;/groupId&gt;<br />&lt;artifactId&gt;commons-cli&lt;/artifactId&gt;<br />&lt;/exclusion&gt;<br />&lt;/exclusions&gt;<br />&lt;/dependency&gt;<br />&lt;dependency&gt;<br />&lt;groupId&gt;commons-io&lt;/groupId&gt;<br />&lt;artifactId&gt;commons-io&lt;/artifactId&gt;<br />&lt;/dependency&gt;<br /></code></blockquote></p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 404;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>
Back
</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">All Posts</a>
<a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">Engineering</a>
<a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">Releases</a>
<a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">News and Events</a>
<a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>Get updates from The Spring Team delivered to your inbox</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">Tools</a></li>
<li><a href="https://store.pivotal.io/">Store</a></li>
<li><a href="/blog">Newsletter</a></li>
</ul>
</div>
</div>
&copy; <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a>, Inc. All Rights Reserved.
<a href="https://pivotal.io/terms-of-use">Terms of Use</a> &bullet;
<a href="https://pivotal.io/privacy-policy">Privacy</a> &bullet;
<a href="/trademarks">Trademark Guidelines</a>
<div id="teconsent" style="display:inline-block;"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>