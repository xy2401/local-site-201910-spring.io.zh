<html  data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>在单个Cloud Foundry应用程序中使用MongoDB，Redis，Node.js和Spring MVC</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Using MongoDB, Redis, Node.js, and Spring MVC in a single Cloud Foundry Application">
<meta name="twitter:description" >
<meta name="twitter:creator" content="@j_brisbin">
<meta name="twitter:image:src" content="http://gravatar.com/avatar/5500b5cf634f9a3921e4619778a1425f?s=200">

<meta property="og:title" content="Using MongoDB, Redis, Node.js, and Spring MVC in a single Cloud Foundry Application">
<meta property="og:image" content="http://gravatar.com/avatar/5500b5cf634f9a3921e4619778a1425f?s=200">
<meta property="og:description" >
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2011-05-03 21:39:00.0">
</head>
<body >

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">在单个Cloud Foundry应用程序中使用MongoDB，Redis，Node.js和Spring MVC</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/5500b5cf634f9a3921e4619778a1425f?s=20&d=mm"> <span class="author">乔恩·布里斯宾</span>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2011-05-03 21:39:00.0">2011年5月3日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2011/05/03/using-mongodb-redis-node-js-and-spring-mvc-in-a-single-cloud-foundry-application#disqus_thread" data-disqus-identifier="415">
</a></div>
</div>
</header>
<div class="blog--post"><p>传统上，应用程序是由使用的原理技术定义的。如果您要构建Spring MVC应用程序，我们将其称为“ Java应用程序”。由于我们的应用程序主要由Java组件组成，因此我们倾向于待在自己的院子里，直到我们被迫与邻居互动之前，对邻居并不十分友好。我们建立了基于Java的应用程序服务器，并且倾向于首先考虑使用Java语言来解决应用程序中的问题，无论该语言是否是最佳选择。通常很难为我们的应用程序维护多组运行时环境，因此我们要通过纯粹的惯性来精打细算。</p><p><a href="http://cloudfoundry.com/">Cloud Foundry改变了</a>这种动态，因为使用正确的工具完成工作不再麻烦。我们根本不被迫再将我们的应用程序精简为一个物种（“ Java应用程序”或“ Node应用程序”）。如果我们需要具有XHR长轮询支持的真正大容量，无阻塞吞吐量，则可以在应用程序的那部分使用<a href="https://nodejs.org/" title="Node.js主页">Node.js。</a>如果我们需要Spring项目系列中的库支持的灵活性和深度，我们可以通过在应用程序的那部分使用Java来轻松利用它们。如果我们既需要用于缓存或事件总线的快速键值存储，又需要用于持久化数据的功能强大的文档存储，则可以在同一应用程序中使用这两种存储，而不必担心单独设置这些服务并自己进行管理所涉及的后勤工作（或将它们丢给<a href="https://www.youtube.com/watch?v=d0KIF7i5yIM">我们已经忙碌的运营人员</a> ）。</p><p>部署这两种应用程序就像从我们最喜欢的shell发出“ push”命令一样简单，这也不会伤害我们的情况。</p>
<h3>多种语言编程^ N</h3><p>那句<a href="https://www.goodreads.com/quotes/show/37300">老话是</a>什么？“如果值得做，那就值得过度”？这个示例应用程序就是这种情绪的发源地！</p><p><a href="http://ticker-analysis.cloudfoundry.com">此应用程序</a>包含多个组件：</p>
<ol>
<li>重复发生的事件，用于生成随机代码数据并将其发送到事件总线。</li>
<li>一个Node.js应用程序为使用<a href="http://socket.io/" title="Socket.IO Home">Socket的Web前端提供动力</a><a href="http://socket.io/" title="插座。IO首页">。IO</a>用于长期轮询Ajax。</li>
<li>一个Spring MVC应用程序，用于从事件总线中读取单个数据点，并将它们汇总到存储在MongoDB中的文档中。</li>
</ol><p>数字1和2在同一应用程序中处理：即为Web前端供电的Node.js应用程序。Number 3是标准的Spring MVC应用程序，它使用<a href="http://www.springsource.org/spring-data" title=" Spring Data 主页">Spring Data项目系列的NoSQL支持</a>在单个帮助器类中连接到Redis和MongoDB。</p>
<h3>Node.js</h3><p>我们之所以使用Node.js，是因为：a）它轻巧，快速且无阻塞，并且：b）它是网络世界的拉链帽衫（这是当今所有酷孩子所穿的东西）。</p><p>认真地说，Node.js是部署Web前端的绝佳选择。我们正在使用它来使用Socket异步将代码事件发送到浏览器。IO，使用Mongoose MongoDB库连接到数据库，并通过我们应用程序的事件总线（在本例中为Redis），以供另一个应用程序中运行的代码使用。</p><p>这里有很多东西，所以我们将每个部分分成大块。</p>
<h3>组态</h3><p>在深入了解应用程序之前，我们需要讨论如何从Cloud Foundry环境获取配置信息。连接到预配服务所需的主机名，端口，用户和密码被编码为存储在名为“ VCAP_SERVICES”的环境变量中的JSON文档。涌现出各种帮助程序实用程序，以帮助开发人员使用这些配置值（或在本地运行应用程序时的默认值）。我们将在此处使用的Node.js模块不一定反映我们在编写本文时正在使用的官方Node.js Cloud Foundry运行时模块。</p>
<h5>连接到MongoDB</h5><p>要获取配置信息，您需要在Cloud Foundry中运行时连接到MongoDB实例，需要使用“ cloudfoundry”模块，如下所示：</p>
<pre><code class="prettyprint javascript"><br />var cf       = require(&quot;cloudfoundry&quot;);
var mongoConfig = cf.getServiceConfig(&quot;ticker-analysis&quot;)
		|| { username: &quot;admin&quot;, password: &quot;password&quot;, hostname: &quot;localhost&quot;, port: 27017, db: &quot;tickeranalysis&quot; };
</code></pre><p>这可以从VCAP_SERVICES环境变量中提取我们的配置信息，也可以提供一组默认值以供在本地运行时使用。</p>
<h5>设置Javascript实体的映射</h5><p>我们正在使用Mongoose MongoDB映射库来连接到我们的数据库。我们将保存我们的个人事件代码，并读取Spring MVC应用程序保存的事件。使用文档存储来持久存储数据的好处在于，它为我们提供了全面的跨语言支持。我们可以使用Spring Data映射基础结构保存一个对象，然后使用Mongoose将其读入Node.js应用程序。</p><p>要配置Mongoose库，我们需要定义模型：</p>
<pre><code class="prettyprint javascript"><br />var mongoose = require(&quot;mongoose&quot;),
    Schema   = mongoose.Schema,
    ObjectId = Schema.ObjectId,
    DocumentObjectId = mongoose.Types.ObjectId;

var TickerEvent = new Schema({
	symbol: { type: String },
	 price: { type: Number },
	volume: { type: Number }
});
mongoose.model(&#39;TickerEvent&#39;, TickerEvent);
var TickerSummary = new Schema({
	      _id: { type: String },
	timestamp: { type: Number },
	      max: { type: Number },
	      min: { type: Number },
	  average: { type: Number },
	   volume: { type: Number }
});
mongoose.model(&#39;TickerSummary&#39;, TickerSummary);
</code></pre><p>Java端的相应域对象如下所示：</p>
<pre><code class="prettyprint java"><br />@Document(collection = &quot;tickersummary&quot;)
public class Summary {

	@Id
	private final String symbol;
	private final Long timestamp;
	private Float total = new Float(0);
	private Integer samples = 0;
	private Float min = Float.MAX_VALUE;
	private Float average = new Float(0);
	private Float max = Float.MIN_VALUE;
	private Integer volume = 0;

  // Constructors, getters, and setters...
}
</code></pre>
<h5>Express.js</h5><p>为了为Web前端提供动力，我们将为Node.js使用<a href="https://expressjs.com/" title="Express.js主页">express.js Web框架</a> 。在此块中值得注意的是，我们在Cloud Foundry Node.js模块上使用了一种特殊方法来告诉我们我们是否在云中运行。如果是这样，那么我们就不想像在开发中运行时那样将异常转储到浏览器中。</p>
<pre><code class="prettyprint javascript"><br />var express  = require(&quot;express&quot;);
var app      = express.createServer();
app.configure(function() {
  
  // Standard express setup
	app.use(express.methodOverride());
	app.use(express.bodyParser());
	app.use(app.router);	
	app.use(express.static(__dirname + &#39;/public&#39;));
	
	// Use the Jade template engine
	app.set(&#39;view engine&#39;, &#39;jade&#39;);
	app.set(&#39;running in cloud&#39;, cf.isRunningInCloud());
	
  // Don&#39;t give away information about our environment in production
	if(!cf.isRunningInCloud()) {
		app.use(express.errorHandler({ dumpExceptions: true, showStack: true }));
	}
	
});
</code></pre>
<h5>插座。IO</h5><p>我们正在使用Socket。IO for Ajax进行长期轮询，将我们的服务器端事件通过管道传输到正在监听的浏览器。由于Cloud Foundry仅处于测试阶段，因此它尚不支持功能完善的Websocket（正在规划中）。要进行设置，我们将指定该Socket。IO使用长时间轮询，因为我们已经知道动态路由基础结构不会使我们感到满意。我们还必须在10秒后重置此连接，以防止超时策略人员没收我们的连接。随着Cloud Foundry平台的发展，这可能是一个有争议的话题。但是暂时，如果将Ajax push与Cloud Foundry结合使用，请记住这些警告。</p>
<pre><code class="prettyprint javascript"><br />var io = require(&quot;socket.io&quot;).listen(app, {
	transports: [&#39;xhr-polling&#39;], 
	transportOptions: {
		&#39;xhr-polling&#39;: {duration: 10000} 
	} 
});
</code></pre>
<h3>事件发射器</h3><p>为了生成实际的数据点，我们可以选择订阅任何公开可用的股票报价器提要。由于在这种情况下，数据的构成实际上并不重要，并且通过这样做，我们有更好的机会在更深层次上说明跨运行时集成，因此，我们将随机生成行情自动收录器数据。</p><p>要将这些事件发布到另一个监听应用程序，我们需要使用Redis的pub / sub功能作为事件总线。为此，我们在Node.js中设置了两个单独的Redis客户端实例。一个将用于侦听要发送到浏览器的事件，另一个将用作出站发布者客户端。</p>
<pre><code class="prettyprint javascript"><br />// Get our Cloud Foundry config information or default to localhost
var redisConfig = cf.getServiceConfig(&quot;ticker-stream&quot;)
		|| { hostname: &quot;localhost&quot;, port: 6379, password: false };

// Create Redis client instances
var redisClient = redis.createClient(redisConfig.port, redisConfig.hostname);
var redisPublisher = redis.createClient(redisConfig.port, redisConfig.hostname);
if(redisConfig.password) {
  // Cloud Foundry Redis instances are secured with a password
	redisClient.auth(redisConfig.password);
	redisPublisher.auth(redisConfig.password);
}

redisClient.subscribe(&quot;ticker-stream&quot;);
redisClient.on(&quot;message&quot;, function(channel, json) {
	var data = JSON.parse(json);
	
	// Save this event to the database
	var TickerEvent = db.model(&#39;TickerEvent&#39;, &#39;tickerdata&#39;);
	var te = new TickerEvent({
		symbol: data.symbol,
		price: data.price,
		volume: data.volume
	});
	te.save(function(err) {
		if(err) {
			throw(err);
		}
	});
	
	// Broadcast this event to the browser
	io.broadcast(json);
	
});
</code></pre><p>要发送数据，我们有一个辅助方法，我们将setTimeout称为on，并传递3-7秒的随机等待时间。</p>
<pre><code class="prettyprint javascript"><br />var tickerSender;
function sendTickerEvent() {
	var symbolInfo = {
		symbol: getRandomSymbol(), 
		price: getRandomPrice(),
		volume: getRandomVolume()
	};
	redisPublisher.publish(&quot;ticker-stream&quot;, JSON.stringify(symbolInfo));

	// Call ourselves again after 3-7 seconds
	tickerSender = setTimeout(sendTickerEvent, getRandomTimeout());
}
</code></pre>
<h5>Express.js路线</h5><p>我们针对Web应用程序的路线非常稀疏。我们需要在其中渲染带有Javascript魔术的主页，以为UI供电，并提供一种途径，当用户单击股票代码符号链接时，可从MongoDB获取摘要文档以显示在页面的右侧。</p>
<pre><code class="prettyprint javascript"><br />app.get(&quot;/&quot;, function(req, resp) {
	resp.render(&quot;home&quot;, {
		pageTitle: &quot;Ticker Analysis Sample&quot;
	});
});

app.get(&quot;/summary/:symbol&quot;, function(req, resp) {
	var TickerSummary = db.model(&quot;TickerSummary&quot;, &quot;tickersummary&quot;);
	TickerSummary.findById(req.params.symbol, function(err, data) {
		if(err) {
			// Handle error
		}
		resp.send(JSON.stringify(data));
	});
});
</code></pre><p>要初始化数据生成，我们需要确保随机事件发射器正在运行。但是，由于我们不希望在没有人看页面的情况下填充数据库，因此，我们只会在用户首次点击我们的应用程序时启动事件发射器。之后，我们将使其保持运行状态直到清除“ tickerSender”超时（如果需要，您可以添加一条路由来执行此操作）。</p>
<pre><code class="prettyprint javascript"><br />// Socket.IO-based Ticker Stream
io.on(&quot;connection&quot;, function(client) {
	if(!tickerSender) {
	  // Start the ticker stream if one hasn&#39;t been already
		sendTickerEvent();
	}
});
</code></pre>
<h5>获取应用程序端口号</h5><p>为了告诉Express.js我们的应用程序应在哪个端口上运行，我们需要读取环境变量VCAP_APP_PORT。 Cloud Foundry Node.js模块上还有另一种方法可以为我们完成此任务。因此，我们对listen（）的调用如下所示：</p>
<pre><code class="prettyprint javascript"><br />app.listen(cf.getAppPort());
</code></pre>
<h3>春季MVC</h3><p>我们<em>可以</em>将其保留在系列中，并在Node.js中处理汇总计算。但有时出于商业原因，有一部分应用程序使用Java / Spring组件。我们的目的是说明如何做到这一点，以便您可以为工作选择合适的工具。</p>
<h5>Spring 配置</h5><p>您会记得当我们处理Node.js部分时，在Cloud Foundry中运行时必须从环境中获取配置参数。我们的Spring应用程序具有相同的需求。但是，由于已经有一个功能强大的Java Java Cloud Foundry运行时库，我们将使用它来提取连接到预配置的MongoDB实例所需的位。</p><p>我们需要做的第一件事是声明几个其他的命名空间。一种用于Cloud Foundry运行时，另一种用于MongoDB支持。</p>
<pre><code class="prettyprint xml"><br />&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
			 xmlns:cloud=&quot;http://schema.cloudfoundry.org/spring&quot;
			 xmlns:mongo=&quot;http://www.springframework.org/schema/data/mongo&quot;
			 xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
			 xmlns:util=&quot;http://www.springframework.org/schema/util&quot;
			 xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
			 xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd
			 http://schema.cloudfoundry.org/spring http://schema.cloudfoundry.org/spring/cloudfoundry-spring-0.6.xsd
			 http://www.springframework.org/schema/data/mongo http://www.springframework.org/schema/data/mongo/spring-mongo-1.0.xsd
			 http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-2.0.xsd&quot;&gt;
</code></pre><p>特别要注意的是，我们将使用仍处于预发行状态的Spring 3.1。您不必使用Spring 3.1即可使用Cloud Foundry。但是<a href="javascript:void(0);">http://blog.springsource.com/2011/02/14/spring-3-1-m1-introducing-profile//</a> Spring 3.1的“关于个人资料的博客文章”>个人资料功能将使我们的配置更加容易。</p><p>要配置MongoDB连接，我们将使用<mongo:mongo></mongo:mongo>本地运行时的名称空间配置助手，这是表亲<cloud:mongo></cloud:mongo>在云中运行时的名称空间配置帮助器。在“默认”配置文件中，我们将设置一些属性，以模仿在云中运行时可用的属性，我们将它们设置为本地MongoDB服务器。</p>
<pre><code class="prettyprint xml"><br />&lt;!-- Use this when running locally --&gt;
&lt;beans profile=&quot;default&quot;&gt;
	&lt;util:properties id=&quot;serviceProperties&quot;&gt;
		&lt;prop key=&quot;ticker-analysis.db&quot;&gt;tickeranalysis&lt;/prop&gt;
		&lt;prop key=&quot;ticker-analysis.username&quot;&gt;admin&lt;/prop&gt;
		&lt;prop key=&quot;ticker-analysis.password&quot;&gt;passwd&lt;/prop&gt;
	&lt;/util:properties&gt;
	&lt;mongo:mongo id=&quot;mongo&quot;/&gt;
	&lt;bean id=&quot;redisConnectionFactory&quot;
				class=&quot;org.springframework.data.keyvalue.redis.connection.jedis.JedisConnectionFactory&quot;/&gt;
&lt;/beans&gt;

&lt;!-- Use this when running in the cloud --&gt;
&lt;beans profile=&quot;cloud&quot;&gt;
	&lt;cloud:service-properties id=&quot;serviceProperties&quot;/&gt;
	&lt;cloud:mongo id=&quot;mongo&quot;/&gt;
	&lt;cloud:redis-connection-factory id=&quot;redisConnectionFactory&quot;/&gt;
&lt;/beans&gt;

&lt;!-- MongoDB --&gt;
&lt;mongo:mapping-converter id=&quot;mappingConverter&quot;/&gt;
&lt;bean id=&quot;mongoTemplate&quot; class=&quot;org.springframework.data.document.mongodb.MongoTemplate&quot;
			p:username=&quot;#{serviceProperties[&#39;ticker-analysis.username&#39;]}&quot;
			p:password=&quot;#{serviceProperties[&#39;ticker-analysis.password&#39;]}&quot;&gt;
	&lt;constructor-arg ref=&quot;mongo&quot;/&gt;
	&lt;constructor-arg name=&quot;databaseName&quot; value=&quot;#{serviceProperties[&#39;ticker-analysis.db&#39;]}&quot;/&gt;
	&lt;constructor-arg name=&quot;defaultCollectionName&quot; value=&quot;tickerdata&quot;/&gt;
	&lt;constructor-arg ref=&quot;mappingConverter&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>您会注意到，我们提供的服务的属性遵循约定SERVICE_NAME.PROPERTY_NAME。在此示例中，我提供了一个名称为“ ticker-analysis”的MongoDB服务：</p>
<pre><code class="prettyprint code">&gt; vmc services

============== System Services ==============
... [omitted for brevity]

=========== Provisioned Services ============

+-----------------+---------+
| Name            | Service |
+-----------------+---------+
| ticker-stream   | redis   |
| ticker-analysis | mongodb |
+-----------------+---------+
</code></pre><p>您可能现在已经猜到了，我的Redis连接遵循类似的模式。</p>
<h5>选择要使用的配置文件</h5><p>精明的读者会立即想到：“但是它怎么知道要使用哪个配置文件？”在我们的例子中，我们将使用ApplicationContextInitializer，它根据是否有适当的环境变量来设置我们的配置文件。</p><p>我们需要在运行时设置配置文件，以便在开发过程中可以使用“默认”配置文件运行，而在Cloud Foundry中运行时可以使用“ cloud”配置文件运行：</p>
<pre><code class="prettyprint java"><br />public class CloudApplicationContextInitializer implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; {

	@Override
	public void initialize(ConfigurableApplicationContext applicationContext) {
		CloudEnvironment env = new CloudEnvironment();
		if (env.getInstanceInfo() != null) {
			// We&#39;re running in the cloud, set the profile accordingly
			applicationContext.getEnvironment().setActiveProfiles(&quot;cloud&quot;);
		}
		else {
			applicationContext.getEnvironment().setActiveProfiles(&quot;default&quot;);
		}
	}

}
</code></pre><p>要激活此ApplicationContextInitializer，我们将其添加到web.xml中：</p>
<pre><code class="prettyprint xml"><br />&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app version=&quot;2.5&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;
	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;&gt;

	&lt;context-param&gt;
		&lt;param-name&gt;contextInitializerClasses&lt;/param-name&gt;
		&lt;param-value&gt;org.cloudfoundry.services.CloudApplicationContextInitializer&lt;/param-value&gt;
	&lt;/context-param&gt;
	
&lt;/web-app&gt;
</code></pre>
<h5>弹簧层</h5><p>我们的Spring层非常简单。我们有一个帮助程序类，该类利用<a href="http://www.springsource.org/spring-data/redis" title="Spring Data Redis主页">Spring Data Redis支持中</a>的MessageListenerAdapter。每当Redis收到该事件的消息时，就会调用我们的bean。在该处理程序内，我们将使用<a href="http://www.springsource.org/spring-data/mongodb" title="Spring Data MongoDB主页">Spring Data MongoDB支持</a>将POJO映射到该文档，以便我们可以更新最小值，最大值和平均值。</p>
<pre><code class="prettyprint java"><br />public void handleMessage(String json) throws IOException {

  // Use the Jackson ObjectMapper to turn a JSON document into a POJO
	TickerEvent event = mapper.readValue(new StringReader(json), TickerEvent.class);

  // Load the existing document or start a new one
	Summary summ = mongoTemplate.findOne(query(where(&quot;_id&quot;).is(event.getSymbol())), Summary.class);
	if (null == summ) {
		summ = new Summary(event.getSymbol(), System.currentTimeMillis());
	}
	// Recalculate min, max, and average
	summ.addTickerEvent(event);

  // Save the modified document back
	mongoTemplate.save(summ);
	
}
</code></pre>
<h5>如果需要，提供REST端点</h5><p>我们不需要将Spring层中的任何内容公开到Web。它脱机进行工作，不需要用户输入，也不将摘要数据直接提供给Web客户端。</p><p>话虽这么说，我们可能想在其中放一个简单的Controller，让我们知道Java helper类中正在发生的事情。我们在示例应用程序中创建了此类。</p>
<pre><code class="prettyprint java"><br />@Controller
@RequestMapping(&quot;/summaries&quot;)
public class SummariesController {

	@Autowired
	private SummaryService summaryService;

	@RequestMapping(value = &quot;/&quot;, method = RequestMethod.GET)
	public @ResponseBody List&lt;Summary&gt; summaries() {
	  // Return all summaries
		return summaryService.getSummaries();
	}

	@RequestMapping(value = &quot;/{symbol}&quot;, method = RequestMethod.GET)
	public @ResponseBody Summary summary(@PathVariable String symbol) {
	  // Return a specific summary document
		return summaryService.getSummary(symbol);
	}
}
</code></pre><p>这不是您要在生产应用程序中执行的操作。但是，为了在Cloud Foundry上进行开发并深入了解有时感觉像黑盒子的东西，可能有必要放入一些控制器方法来暴露Spring层的内在条件。</p>
<h3>像泥一样清澈？</h3><p>我不了解您，但是我对许多示例和教程的简单性感到有些无聊。诚然，此示例应用程序没有任何简化！这似乎有点像从消防水带喝水，但目标是为您提供足够的骨头上的肉，以便您在调查Cloud Foundry并获得云[sea]腿时保持一会儿忙碌。</p><p>该示例应用程序可在Cloud Foundry上运行：<br></p><ul><li><a href="http://ticker-analysis.cloudfoundry.com"></a> <a href="http://ticker-analysis.cloudfoundry.com">http://ticker-analysis.cloudfoundry.com</a></li></ul><p></p><p>所有源代码都在GitHub上的Cloud Foundry示例存储库中：<br></p><ul><li><a href="https://github.com/SpringSource/cloudfoundry-samples/tree/master/ticker-analysis"></a> <a href="https://github.com/SpringSource/cloudfoundry-samples/tree/master/ticker-analysis">https://github.com/SpringSource/cloudfoundry-samples/tree/master/ticker-analysis</a></li></ul><p></p><p>要获得有关Cloud Foundry的最新信息，您可以访问以下论坛：<br></p><ul><li><a href="http://support.cloudfoundry.com/forums/373015-knowledge-base"></a> <a href="http://support.cloudfoundry.com/forums/373015-knowledge-base">http://support.cloudfoundry.com/forums/373015-knowledge-base</a></li></ul><p></p><p>坦率地说，综合文档仍在不断发展，因为Cloud Foundry平台也是如此。目前，这是一个移动的目标。社区正在<a href="https://github.com/SpringSource/cloudfoundry-samples/wiki/Node">github上</a>维护<a href="https://github.com/SpringSource/cloudfoundry-samples/wiki/Node">一些wiki页面</a> ，这应该会有所帮助。</p><p><a href="https://github.com/SpringSource/cloudfoundry-samples/tree/master/ticker-analysis/node-ticker-analysis/node_modules/cloudfoundry">早先引用</a>的<a href="https://github.com/SpringSource/cloudfoundry-samples/tree/master/ticker-analysis/node-ticker-analysis/node_modules/cloudfoundry">Node.js模块</a> （以便更轻松地访问Cloud Foundry环境变量）实际上是示例应用程序的一部分，直到为Node.js发布了功能完善的Cloud Foundry运行时为止。</p><p>骇客入侵！</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 415;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>