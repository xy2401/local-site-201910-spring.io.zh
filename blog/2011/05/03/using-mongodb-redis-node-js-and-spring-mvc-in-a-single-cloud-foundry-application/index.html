<html dir="ltr" data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>在单个Cloud Foundry应用程序中使用MongoDB，Redis，Node.js和Spring MVC</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>System.config({baseURL: "/b92013b"});</script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>System.import('app/main.js')</script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Using MongoDB, Redis, Node.js, and Spring MVC in a single Cloud Foundry Application">
<meta name="twitter:description" content="<p>Traditionally, applications have been defined by the principle technology they use. If you’re building a Spring MVC application, we call it a “Java app”. Since our application is primarily composed of Java components, we tend to stay in our own yards and not be terribly friendly with our neighbors until we’re forced to interact with them. We set up Java-based application servers and tend to think first of going to the Java language to solve a problem in our application whether that language is the best choice or not. It has usually just been too difficult to maintain multiple sets of runtime environments for our applications, so we stovepipe ourselves through sheer inertia.</p>
">
<meta name="twitter:creator" content="@j_brisbin">
<meta name="twitter:image:src" content="http://gravatar.com/avatar/5500b5cf634f9a3921e4619778a1425f?s=200">

<meta property="og:title" content="Using MongoDB, Redis, Node.js, and Spring MVC in a single Cloud Foundry Application">
<meta property="og:image" content="http://gravatar.com/avatar/5500b5cf634f9a3921e4619778a1425f?s=200">
<meta property="og:description" content="<p>Traditionally, applications have been defined by the principle technology they use. If you’re building a Spring MVC application, we call it a “Java app”. Since our application is primarily composed of Java components, we tend to stay in our own yards and not be terribly friendly with our neighbors until we’re forced to interact with them. We set up Java-based application servers and tend to think first of going to the Java language to solve a problem in our application whether that language is the best choice or not. It has usually just been too difficult to maintain multiple sets of runtime environments for our applications, so we stovepipe ourselves through sheer inertia.</p>
">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2011-05-03 21:39:00.0">
</head>
<body dir="ltr">

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">// Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }</script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">在单个Cloud Foundry应用程序中使用MongoDB，Redis，Node.js和Spring MVC</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/5500b5cf634f9a3921e4619778a1425f?s=20&d=mm"> <span class="author">乔恩·布里斯宾</span>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2011-05-03 21:39:00.0">2011年5月3日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2011/05/03/using-mongodb-redis-node-js-and-spring-mvc-in-a-single-cloud-foundry-application#disqus_thread" data-disqus-identifier="415">
</a></div>
</div>
</header>
<div class="blog--post"><p>传统上，应用程序是由使用的原理技术定义的。如果您要构建Spring MVC应用程序，我们将其称为“ Java应用程序”。由于我们的应用程序主要由Java组件组成，因此我们倾向于待在自己的院子里，直到我们被迫与邻居互动之前，对邻居并不十分友好。我们建立了基于Java的应用程序服务器，并且倾向于首先考虑使用Java语言来解决应用程序中的问题，无论该语言是否是最佳选择。通常很难为我们的应用程序维护多组运行时环境，因此我们要通过纯粹的惯性来精打细算。</p><p><a href="http://cloudfoundry.com/">Cloud Foundry改变了</a>这种动态，因为使用正确的工具完成工作不再麻烦。我们根本不被迫再将我们的应用程序精简为一个物种（“ Java应用程序”或“ Node应用程序”）。如果我们需要具有XHR长轮询支持的真正大容量，无阻塞吞吐量，则可以在应用程序的那部分使用<a href="https://nodejs.org/" title="Node.js主页">Node.js。</a>如果我们需要Spring项目系列中的库支持的灵活性和深度，我们可以通过在应用程序的那部分使用Java来轻松利用它们。如果我们既需要用于缓存或事件总线的快速键值存储，又需要用于持久化数据的功能强大的文档存储，则可以在同一应用程序中使用这两种存储，而不必担心单独设置这些服务并自己进行管理所涉及的后勤工作（或将它们丢给<a href="https://www.youtube.com/watch?v=d0KIF7i5yIM">我们已经忙碌的运营人员</a> ）。</p><p>部署这两种应用程序就像从我们最喜欢的shell发出“ push”命令一样简单，这也不会伤害我们的情况。</p>
<h3>多种语言编程^ N</h3><p>那句<a href="https://www.goodreads.com/quotes/show/37300">老话是</a>什么？“如果值得做，那就值得过度”？这个示例应用程序就是这种情绪的发源地！</p><p><a href="http://ticker-analysis.cloudfoundry.com">此应用程序</a>包含多个组件：</p>
<ol>
<li>重复发生的事件，用于生成随机代码数据并将其发送到事件总线。</li>
<li>一个Node.js应用程序为使用<a href="http://socket.io/" title="Socket.IO Home">Socket的Web前端提供动力</a><a href="http://socket.io/" title="插座。IO首页">。IO</a>用于长期轮询Ajax。</li>
<li>一个Spring MVC应用程序，用于从事件总线中读取单个数据点，并将它们汇总到存储在MongoDB中的文档中。</li>
</ol><p>数字1和2在同一应用程序中处理：即为Web前端供电的Node.js应用程序。Number 3是标准的Spring MVC应用程序，它使用<a href="http://www.springsource.org/spring-data" title="春季数据主页">Spring Data项目系列的NoSQL支持</a>在单个帮助器类中连接到Redis和MongoDB。</p>
<h3>Node.js</h3><p>我们之所以使用Node.js，是因为：a）它轻巧，快速且无阻塞，并且：b）它是网络世界的拉链帽衫（这是当今所有酷孩子所穿的东西）。</p><p>认真地说，Node.js是部署Web前端的绝佳选择。我们正在使用它来使用Socket异步将代码事件发送到浏览器。IO，使用Mongoose MongoDB库连接到数据库，并通过我们应用程序的事件总线（在本例中为Redis），以供另一个应用程序中运行的代码使用。</p><p>这里有很多东西，所以我们将每个部分分成大块。</p>
<h3>组态</h3><p>在深入了解应用程序之前，我们需要讨论如何从Cloud Foundry环境获取配置信息。连接到预配服务所需的主机名，端口，用户和密码被编码为存储在名为“ VCAP_SERVICES”的环境变量中的JSON文档。涌现出各种帮助程序实用程序，以帮助开发人员使用这些配置值（或在本地运行应用程序时的默认值）。我们将在此处使用的Node.js模块不一定反映我们在编写本文时正在使用的官方Node.js Cloud Foundry运行时模块。</p>
<h5>连接到MongoDB</h5><p>要获取配置信息，您需要在Cloud Foundry中运行时连接到MongoDB实例，需要使用“ cloudfoundry”模块，如下所示：</p>
<pre><code class="prettyprint javascript"><br>var cf       = require("cloudfoundry");
var mongoConfig = cf.getServiceConfig("ticker-analysis")
		|| { username: "admin", password: "password", hostname: "localhost", port: 27017, db: "tickeranalysis" };
</code></pre><p>这要么从VCAP_SERVICES环境变量中提取我们的配置信息，要么提供一组默认值以供在本地运行时使用。</p>
<h5>设置Javascript实体的映射</h5><p>我们正在使用Mongoose MongoDB映射库来连接到我们的数据库。我们将保存我们的个人事件代码，并读取Spring MVC应用程序保存的事件。使用文档存储来持久存储数据的好处在于，它为我们提供了全面的跨语言支持。我们可以使用Spring Data映射基础结构保存一个对象，然后使用Mongoose将其读入Node.js应用程序。</p><p>要配置Mongoose库，我们需要定义模型：</p>
<pre><code class="prettyprint javascript"><br>var mongoose = require("mongoose"),
    Schema   = mongoose.Schema,
    ObjectId = Schema.ObjectId,
    DocumentObjectId = mongoose.Types.ObjectId;

var TickerEvent = new Schema({
	symbol: { type: String },
	 price: { type: Number },
	volume: { type: Number }
});
mongoose.model('TickerEvent', TickerEvent);
var TickerSummary = new Schema({
	      _id: { type: String },
	timestamp: { type: Number },
	      max: { type: Number },
	      min: { type: Number },
	  average: { type: Number },
	   volume: { type: Number }
});
mongoose.model('TickerSummary', TickerSummary);
</code></pre><p>Java端的相应域对象如下所示：</p>
<pre><code class="prettyprint java"><br>@Document(collection = "tickersummary")
public class Summary {

	@Id
	private final String symbol;
	private final Long timestamp;
	private Float total = new Float(0);
	private Integer samples = 0;
	private Float min = Float.MAX_VALUE;
	private Float average = new Float(0);
	private Float max = Float.MIN_VALUE;
	private Integer volume = 0;

  // Constructors, getters, and setters...
}
</code></pre>
<h5>Express.js</h5><p>为了为Web前端提供动力，我们将为Node.js使用<a href="https://expressjs.com/" title="Express.js主页">express.js Web框架</a> 。在此块中值得注意的是，我们在Cloud Foundry Node.js模块上使用了一种特殊方法来告诉我们我们是否在云中运行。如果是这样，那么我们就不想像在开发中运行时那样将异常转储到浏览器中。</p>
<pre><code class="prettyprint javascript"><br>var express  = require("express");
var app      = express.createServer();
app.configure(function() {
  
  // Standard express setup
	app.use(express.methodOverride());
	app.use(express.bodyParser());
	app.use(app.router);	
	app.use(express.static(__dirname + '/public'));
	
	// Use the Jade template engine
	app.set('view engine', 'jade');
	app.set('running in cloud', cf.isRunningInCloud());
	
  // Don't give away information about our environment in production
	if(!cf.isRunningInCloud()) {
		app.use(express.errorHandler({ dumpExceptions: true, showStack: true }));
	}
	
});
</code></pre>
<h5>插座。IO</h5><p>我们正在使用Socket。IO for Ajax进行长期轮询，将我们的服务器端事件通过管道传输到正在监听的浏览器。由于Cloud Foundry仅处于测试阶段，因此它尚不支持功能完善的Websocket（正在规划中）。要进行设置，我们将指定该Socket。IO使用长时间轮询，因为我们已经知道动态路由基础结构不会使我们感到满意。我们还必须在10秒后重置此连接，以防止超时策略人员没收我们的连接。随着Cloud Foundry平台的发展，这可能是一个有争议的话题。但是暂时，如果将Ajax push与Cloud Foundry结合使用，请记住这些警告。</p>
<pre><code class="prettyprint javascript"><br>var io = require("socket.io").listen(app, {
	transports: ['xhr-polling'], 
	transportOptions: {
		'xhr-polling': {duration: 10000} 
	} 
});
</code></pre>
<h3>事件发射器</h3><p>为了生成实际的数据点，我们可以选择订阅任何公开可用的股票报价器提要。由于在这种情况下，数据的构成实际上并不重要，并且通过这样做，我们有更好的机会在更深层次上说明跨运行时集成，因此，我们将随机生成行情自动收录器数据。</p><p>要将这些事件发布到另一个监听应用程序，我们需要使用Redis的pub / sub功能作为事件总线。为此，我们在Node.js中设置了两个单独的Redis客户端实例。一个将用于侦听要发送到浏览器的事件，另一个将用作出站发布者客户端。</p>
<pre><code class="prettyprint javascript"><br>// Get our Cloud Foundry config information or default to localhost
var redisConfig = cf.getServiceConfig("ticker-stream")
		|| { hostname: "localhost", port: 6379, password: false };

// Create Redis client instances
var redisClient = redis.createClient(redisConfig.port, redisConfig.hostname);
var redisPublisher = redis.createClient(redisConfig.port, redisConfig.hostname);
if(redisConfig.password) {
  // Cloud Foundry Redis instances are secured with a password
	redisClient.auth(redisConfig.password);
	redisPublisher.auth(redisConfig.password);
}

redisClient.subscribe("ticker-stream");
redisClient.on("message", function(channel, json) {
	var data = JSON.parse(json);
	
	// Save this event to the database
	var TickerEvent = db.model('TickerEvent', 'tickerdata');
	var te = new TickerEvent({
		symbol: data.symbol,
		price: data.price,
		volume: data.volume
	});
	te.save(function(err) {
		if(err) {
			throw(err);
		}
	});
	
	// Broadcast this event to the browser
	io.broadcast(json);
	
});
</code></pre><p>要发送数据，我们有一个辅助方法，我们将setTimeout称为on，并传递3-7秒的随机等待时间。</p>
<pre><code class="prettyprint javascript"><br>var tickerSender;
function sendTickerEvent() {
	var symbolInfo = {
		symbol: getRandomSymbol(), 
		price: getRandomPrice(),
		volume: getRandomVolume()
	};
	redisPublisher.publish("ticker-stream", JSON.stringify(symbolInfo));

	// Call ourselves again after 3-7 seconds
	tickerSender = setTimeout(sendTickerEvent, getRandomTimeout());
}
</code></pre>
<h5>Express.js路线</h5><p>我们针对Web应用程序的路线非常稀疏。我们需要在其中渲染带有Javascript魔术的主页，以为UI供电，并提供一种途径，当用户单击股票代码符号链接时，可从MongoDB获取摘要文档以显示在页面的右侧。</p>
<pre><code class="prettyprint javascript"><br>app.get("/", function(req, resp) {
	resp.render("home", {
		pageTitle: "Ticker Analysis Sample"
	});
});

app.get("/summary/:symbol", function(req, resp) {
	var TickerSummary = db.model("TickerSummary", "tickersummary");
	TickerSummary.findById(req.params.symbol, function(err, data) {
		if(err) {
			// Handle error
		}
		resp.send(JSON.stringify(data));
	});
});
</code></pre><p>要初始化数据生成，我们需要确保随机事件发射器正在运行。但是，由于我们不希望在没有人看页面的情况下填充数据库，因此，我们只会在用户首次点击我们的应用程序时启动事件发射器。之后，我们将使其保持运行状态直到清除超时“ tickerSender”（如果需要，您可以添加一条路由来执行此操作）。</p>
<pre><code class="prettyprint javascript"><br>// Socket.IO-based Ticker Stream
io.on("connection", function(client) {
	if(!tickerSender) {
	  // Start the ticker stream if one hasn't been already
		sendTickerEvent();
	}
});
</code></pre>
<h5>获取应用程序端口号</h5><p>为了告诉Express.js我们的应用程序应在哪个端口上运行，我们需要读取环境变量VCAP_APP_PORT。 Cloud Foundry Node.js模块上还有另一种方法可以为我们完成此任务。因此，我们对listen（）的调用如下所示：</p>
<pre><code class="prettyprint javascript"><br>app.listen(cf.getAppPort());
</code></pre>
<h3>春季MVC</h3><p>我们<em>可以</em>将其保留在系列中，并在Node.js中处理汇总计算。但有时出于商业原因，有一部分应用程序使用Java / Spring组件。我们的目的是说明如何做到这一点，以便您可以为工作选择合适的工具。</p>
<h5>弹簧配置</h5><p>您会记得当我们处理Node.js部分时，在Cloud Foundry中运行时必须从环境中获取配置参数。我们的Spring应用程序具有相同的需求。但是，由于已经有一个功能强大的Java Java Cloud Foundry运行时库，我们将使用它来提取连接到预配置的MongoDB实例所需的位。</p><p>我们需要做的第一件事是声明几个其他的命名空间。一种用于Cloud Foundry运行时，另一种用于MongoDB支持。</p>
<pre><code class="prettyprint xml"><br><?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
			 xmlns:cloud="http://schema.cloudfoundry.org/spring"
			 xmlns:mongo="http://www.springframework.org/schema/data/mongo"
			 xmlns:p="http://www.springframework.org/schema/p"
			 xmlns:util="http://www.springframework.org/schema/util"
			 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd
			 http://schema.cloudfoundry.org/spring http://schema.cloudfoundry.org/spring/cloudfoundry-spring-0.6.xsd
			 http://www.springframework.org/schema/data/mongo http://www.springframework.org/schema/data/mongo/spring-mongo-1.0.xsd
			 http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-2.0.xsd">
</code></pre><p>特别要注意的是，我们将使用仍处于预发行状态的Spring 3.1。您无需使用Spring 3.1即可使用Cloud Foundry。但是<a href="javascript:void(0);">http://blog.springsource.com/2011/02/14/spring-3-1-m1-introducing-profile//</a> Spring 3.1的“关于个人资料的博客文章”>个人资料功能将使我们的配置更加容易。</p><p>要配置MongoDB连接，我们将使用<mongo:mongo></mongo:mongo>本地运行时的名称空间配置助手，这是表亲<cloud:mongo></cloud:mongo>在云中运行时的名称空间配置帮助器。在“默认”配置文件中，我们将设置一些属性，以模仿在云中运行时可用的属性，我们将它们设置为本地MongoDB服务器。</p>
<pre><code class="prettyprint xml"><br><!-- Use this when running locally -->
<beans profile="default">
	<util:properties id="serviceProperties">
		<prop key="ticker-analysis.db">tickeranalysis</prop>
		<prop key="ticker-analysis.username">admin</prop>
		<prop key="ticker-analysis.password">passwd</prop>
	</util:properties>
	<mongo:mongo id="mongo"/>
	<bean id="redisConnectionFactory"
				class="org.springframework.data.keyvalue.redis.connection.jedis.JedisConnectionFactory"/>
</beans>

<!-- Use this when running in the cloud -->
<beans profile="cloud">
	<cloud:service-properties id="serviceProperties"/>
	<cloud:mongo id="mongo"/>
	<cloud:redis-connection-factory id="redisConnectionFactory"/>
</beans>

<!-- MongoDB -->
<mongo:mapping-converter id="mappingConverter"/>
<bean id="mongoTemplate" class="org.springframework.data.document.mongodb.MongoTemplate"
			p:username="#{serviceProperties['ticker-analysis.username']}"
			p:password="#{serviceProperties['ticker-analysis.password']}">
	<constructor-arg ref="mongo"/>
	<constructor-arg name="databaseName" value="#{serviceProperties['ticker-analysis.db']}"/>
	<constructor-arg name="defaultCollectionName" value="tickerdata"/>
	<constructor-arg ref="mappingConverter"/>
</bean>
</code></pre><p>您会注意到，我们提供的服务的属性遵循SERVICE_NAME.PROPERTY_NAME的约定。在此示例中，我提供了一个名称为“ ticker-analysis”的MongoDB服务：</p>
<pre><code class="prettyprint code">> vmc services

============== System Services ==============
... [omitted for brevity]

=========== Provisioned Services ============

+-----------------+---------+
| Name            | Service |
+-----------------+---------+
| ticker-stream   | redis   |
| ticker-analysis | mongodb |
+-----------------+---------+
</code></pre><p>您可能现在已经猜到了，我的Redis连接遵循类似的模式。</p>
<h5>选择要使用的配置文件</h5><p>精明的读者会立即想到：“但是它怎么知道要使用哪个配置文件？”在我们的例子中，我们将使用ApplicationContextInitializer，它根据是否可用适当的环境变量来设置我们的配置文件。</p><p>我们需要在运行时设置配置文件，以便在开发过程中可以使用“默认”配置文件运行，而在Cloud Foundry中运行时可以使用“ cloud”配置文件运行：</p>
<pre><code class="prettyprint java"><br>public class CloudApplicationContextInitializer implements ApplicationContextInitializer<ConfigurableApplicationContext> {

	@Override
	public void initialize(ConfigurableApplicationContext applicationContext) {
		CloudEnvironment env = new CloudEnvironment();
		if (env.getInstanceInfo() != null) {
			// We're running in the cloud, set the profile accordingly
			applicationContext.getEnvironment().setActiveProfiles("cloud");
		}
		else {
			applicationContext.getEnvironment().setActiveProfiles("default");
		}
	}

}
</code></pre><p>要激活此ApplicationContextInitializer，我们将其添加到web.xml中：</p>
<pre><code class="prettyprint xml"><br><?xml version="1.0" encoding="UTF-8"?>
<web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd">

	<context-param>
		<param-name>contextInitializerClasses</param-name>
		<param-value>org.cloudfoundry.services.CloudApplicationContextInitializer</param-value>
	</context-param>
	
</web-app>
</code></pre>
<h5>弹簧层</h5><p>我们的Spring层非常简单。我们有一个帮助程序类，该类利用<a href="http://www.springsource.org/spring-data/redis" title="Spring Data Redis主页">Spring Data Redis支持中</a>的MessageListenerAdapter。每当Redis收到该事件的消息时，就会调用我们的bean。在该处理程序内，我们将使用<a href="http://www.springsource.org/spring-data/mongodb" title="Spring Data MongoDB主页">Spring Data MongoDB支持</a>将POJO映射到该文档，以便我们可以更新最小值，最大值和平均值。</p>
<pre><code class="prettyprint java"><br>public void handleMessage(String json) throws IOException {

  // Use the Jackson ObjectMapper to turn a JSON document into a POJO
	TickerEvent event = mapper.readValue(new StringReader(json), TickerEvent.class);

  // Load the existing document or start a new one
	Summary summ = mongoTemplate.findOne(query(where("_id").is(event.getSymbol())), Summary.class);
	if (null == summ) {
		summ = new Summary(event.getSymbol(), System.currentTimeMillis());
	}
	// Recalculate min, max, and average
	summ.addTickerEvent(event);

  // Save the modified document back
	mongoTemplate.save(summ);
	
}
</code></pre>
<h5>如果需要，提供REST端点</h5><p>我们不需要将Spring层中的任何内容公开到Web。它脱机进行工作，不需要用户输入，也不将摘要数据直接提供给Web客户端。</p><p>话虽这么说，我们可能想在其中放一个简单的Controller，让我们知道Java helper类中正在发生什么。我们在示例应用程序中创建了此类。</p>
<pre><code class="prettyprint java"><br>@Controller
@RequestMapping("/summaries")
public class SummariesController {

	@Autowired
	private SummaryService summaryService;

	@RequestMapping(value = "/", method = RequestMethod.GET)
	public @ResponseBody List<Summary> summaries() {
	  // Return all summaries
		return summaryService.getSummaries();
	}

	@RequestMapping(value = "/{symbol}", method = RequestMethod.GET)
	public @ResponseBody Summary summary(@PathVariable String symbol) {
	  // Return a specific summary document
		return summaryService.getSummary(symbol);
	}
}
</code></pre><p>这不是您要在生产应用程序中执行的操作。但是，为了在Cloud Foundry上进行开发并深入了解有时感觉像黑盒子的东西，可能有必要放入一些控制器方法来暴露Spring层的内在条件。</p>
<h3>像泥一样清澈？</h3><p>我不了解您，但是我对许多示例和教程的简单性感到有些无聊。诚然，此示例应用程序没有任何简化！这似乎有点像从消防水带喝水，但目标是为您提供足够的骨头上的肉，以便您在调查Cloud Foundry并获得云[sea]腿时保持一会儿忙碌。</p><p>该示例应用程序可在Cloud Foundry上运行：<br></p><ul><li><a href="http://ticker-analysis.cloudfoundry.com"></a> <a href="http://ticker-analysis.cloudfoundry.com">http://ticker-analysis.cloudfoundry.com</a></li></ul><p></p><p>所有源代码都在GitHub上的Cloud Foundry示例存储库中：<br></p><ul><li><a href="https://github.com/SpringSource/cloudfoundry-samples/tree/master/ticker-analysis"></a> <a href="https://github.com/SpringSource/cloudfoundry-samples/tree/master/ticker-analysis">https://github.com/SpringSource/cloudfoundry-samples/tree/master/ticker-analysis</a></li></ul><p></p><p>要获得有关Cloud Foundry的最新信息，您可以访问以下论坛：<br></p><ul><li><a href="http://support.cloudfoundry.com/forums/373015-knowledge-base"></a> <a href="http://support.cloudfoundry.com/forums/373015-knowledge-base">http://support.cloudfoundry.com/forums/373015-knowledge-base</a></li></ul><p></p><p>坦率地说，综合文档仍在不断发展，因为Cloud Foundry平台也是如此。目前，这是一个移动的目标。社区正在<a href="https://github.com/SpringSource/cloudfoundry-samples/wiki/Node">github上</a>维护<a href="https://github.com/SpringSource/cloudfoundry-samples/wiki/Node">一些wiki页面</a> ，这应该有所帮助。</p><p><a href="https://github.com/SpringSource/cloudfoundry-samples/tree/master/ticker-analysis/node-ticker-analysis/node_modules/cloudfoundry">早先引用</a>的<a href="https://github.com/SpringSource/cloudfoundry-samples/tree/master/ticker-analysis/node-ticker-analysis/node_modules/cloudfoundry">Node.js模块</a> （以便更轻松地访问Cloud Foundry环境变量）实际上是示例应用程序的一部分，直到为Node.js发布了功能完善的Cloud Foundry运行时为止。</p><p>骇客入侵！</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">var disqus_shortname = 'spring-io';
      var disqus_identifier = 415;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));</script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });</script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>