<html dir="ltr" data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>扩展Spring Social的服务提供商框架</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>System.config({baseURL: "/b92013b"});</script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>System.import('app/main.js')</script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Extending Spring Social's Service Provider Framework">
<meta name="twitter:description" content="<p><a href=" http:="" ="" blog.springsource.com="" 2011="" 03="" 02="" introducing-spring-socials-service-provider-framework="" ="="></meta>Last week, I introduced you to Spring Social's Service Provider " Connect" Framework and showed you how it simplifies creating connections between a user's local application account their accounts on Software-as-a-Service (SaaS) providers. Today I want to show extend the service provider framework handle providers that aren't directly supported by Spring Social. <h3></head><body dir="ltr">Extending Spring Social for Netflix
<p>Suppose that you're developing a movie review website where users can go to read and post short movie reviews. Normally, the movie reviews are displayed with the most recent entries appearing first on the home page. But if a user has connected their account to their Netflix account, then you can show them reviews for the movies in their Netflix disc queue. To pull this off, you'd like to take advantage of Spring Social's Service Provider Framework for connecting your user's accounts with their Netflix accounts. Spring Social 1.0.0.M2 doesn't include a Netflix service provider or API binding, but can be easily extended to work with providers that aren't directly supported.</p>
">
<meta name="twitter:creator" content="@habuma">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/52fd524c733cc1098c2eeeae38ea8a20?s=200">

<meta property="og:title" content="Extending Spring Social's Service Provider Framework">
<meta property="og:image" content="https://gravatar.com/avatar/52fd524c733cc1098c2eeeae38ea8a20?s=200">
<meta property="og:description" content="<p><a href=" http:="" ="" blog.springsource.com="" 2011="" 03="" 02="" introducing-spring-socials-service-provider-framework="" ="="></meta>Last week, I introduced you to Spring Social's Service Provider " Connect" Framework and showed you how it simplifies creating connections between a user's local application account their accounts on Software-as-a-Service (SaaS) providers. Today I want to show extend the service provider framework handle providers that aren't directly supported by Spring Social. <h3>Extending Spring Social for Netflix
<p>Suppose that you're developing a movie review website where users can go to read and post short movie reviews. Normally, the movie reviews are displayed with the most recent entries appearing first on the home page. But if a user has connected their account to their Netflix account, then you can show them reviews for the movies in their Netflix disc queue. To pull this off, you'd like to take advantage of Spring Social's Service Provider Framework for connecting your user's accounts with their Netflix accounts. Spring Social 1.0.0.M2 doesn't include a Netflix service provider or API binding, but can be easily extended to work with providers that aren't directly supported.</p>
">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2011-03-10 21:41:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">// Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }</script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">扩展Spring Social的服务提供商框架</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/52fd524c733cc1098c2eeeae38ea8a20?s=20&d=mm"> <a class="author" rel="author" href="/team/cwalls">克雷格·沃尔斯</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2011-03-10 21:41:00.0">2011年3月10日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2011/03/10/extending-spring-social-s-service-provider-framework#disqus_thread" data-disqus-identifier="400">
</a></div>
</div>
</header>
<div class="blog--post"><p><a href="http://blog.springsource.com/2011/03/02/introducing-spring-socials-service-provider-framework/">上周</a> ，我向您介绍了Spring Social的服务提供商“连接”框架，并向您展示了它如何简化用户本地应用程序帐户与他们在软件即服务（SaaS）提供商上的帐户之间的连接。今天，我想向您展示如何扩展服务提供者框架以处理与Spring Social不直接支持的提供者的连接。</p>
<h3>为Netflix扩展Spring Social</h3>
<p>假设您正在开发一个电影评论网站，用户可以在其中阅读和发表简短的电影评论。通常，电影评论显示时，最新条目首先出现在主页上。但是，如果用户已将其帐户连接到其Netflix帐户，则可以向他们显示其Netflix光盘队列中电影的评论。为了实现这一点，您想利用Spring Social的服务提供商框架将用户的帐户与其Netflix帐户关联起来。春季社交1.0.0。M2不包含Netflix服务提供商或API绑定，但可以轻松扩展以与不直接支持的提供商一起使用。</p>
<p>在本文中，我将向您展示如何基于Spring Social的服务提供商框架来实现与Netflix的连接。我们将从开发Netflix服务提供商实现开始，然后构建一个简单的API绑定来满足我们应用程序的需求。用于开发Netflix服务提供商的技术可以应用于扩展Spring Social以支持几乎所有服务提供商。您可以通过<a href="https://github.com/SpringSource/spring-social-samples/tree/master/spring-social-extending-new-api">在GitHub上</a>查看<a href="https://github.com/SpringSource/spring-social-samples/tree/master/spring-social-extending-new-api">示例代码</a>来进行后续操作。</p>
<h3>了解Netflix的授权API</h3>
<p>在开始开发Netflix服务提供商实现之前，我们需要做一些前期研究，以了解有关Netflix Authorization API如何工作的一些基本细节。</p>
<p>我们需要确定的第一件事是Netflix使用什么授权协议。Netflix API文档的“ <a href="http://developer.netflix.com/docs/read/Security" target="_blank">身份验证概述”</a>部分告诉我们它们使用OAuth，但没有明确告诉我们正在使用哪个版本的OAuth规范。因此，将需要一些侦探工作。</p>
<p>在页面的下方（在“那些讨厌的OAuth参数”标题下），我们看到了消费者密钥，随机数和时间戳的提及。这些都不适用于OAuth 2，因此Netflix必须是OAuth 1提供程序。此外，将<code>oauth_version</code>参数设置为“ 1.0”的描述用于确认Netflix实现了OAuth 1。</p>
<p>现在我们知道Netflix使用OAuth 1。但是了解它们是实现规范的1.0版还是1.0a版也很重要。服务提供商通常不会在其文档中对此进行拼写，在两种情况下， <code>oauth_version</code>值均应为“ 1.0”。但是，有一些迹象表明，这是OAuth规范的特定版本。以下是表明OAuth 1.0正在运行的一些线索：</p>
<ul>
<li><code>oauth_callback</code>参数在授权URL上发送，而不在请求令牌请求上发送。</li>
<li>没有验证程序的概念，也不需要将<code>oauth_verifier</code>参数发送到访问令牌URL。</li>
</ul>
<p>对于OAuth 1.0a，请注意以下迹象：</p>
<ul>
<li><code>oauth_callback</code>参数在请求令牌请求中发送，而不是在授权URL中发送。</li>
<li>在回调中从提供程序接收到验证程序，并且必须将<code>oauth_verifier</code>参数发送到访问令牌URL。</li>
</ul>
<p>在Netflix文档中寻找这些线索时，我们确定Netflix使用OAuth 1.0（而不是1.0a）。此信息非常重要，在我们定义服务提供商实现时将很有用。</p>
<p>最后，我们需要知道请求令牌，授权和访问令牌的URL。在页面的更下方（在“进行受保护的呼叫”标题下），您会找到详细信息，这些信息告诉我们所需的URL如下：</p>
<ul>
<li><b>请求令牌URL：</b> http <b>:</b> //api.netflix.com/oauth/request_token</li>
<li><b>验证网址：https://api-user.netflix.com/oauth/login</b></li>
<li><b>访问令牌URL：</b> http <b>:</b> //api.netflix.com/oauth/access_token</li>
</ul>
<p>请特别注意请求和访问令牌URL中使用的协议。大多数提供商在这方面都比较灵活，建议您使用https。但是，根据我在Netflix上的经验，我发现如果您通过https请求请求或访问令牌，则Netflix将抱怨请求签名无效。不过，授权URL可以在https上正常运行。</p>
<h3>开发Netflix服务提供商实施</h3>
<p>要创建新的服务提供者实现，我们需要扩展<code>AbstractOAuth1ServiceProvider</code>或<code>AbstractOAuth2ServiceProvider</code> 。这两个类分别为OAuth 1.0 / 1.0a和OAuth 2提供了特定于OAuth版本的基本功能。由于Netflix是OAuth 1.0提供程序，因此我们的<code>NetFlixServiceProvider</code>将需要扩展<code>AbstractOAuth1ServiceProvider</code> ：</p>
<pre><code class="prettyprint java"><br>package org.springframework.social.movies.netflix;
import org.springframework.social.connect.oauth1.AbstractOAuth1ServiceProvider;
import org.springframework.social.connect.support.ConnectionRepository;
import org.springframework.social.oauth1.OAuth1Template;

public final class NetFlixServiceProvider extends AbstractOAuth1ServiceProvider<NetFlixApi> {

    public NetFlixServiceProvider(String consumerKey, String consumerSecret, ConnectionRepository connectionRepository) {
        super("netflix", connectionRepository, consumerKey, consumerSecret, 
            new OAuth1Template(consumerKey, consumerSecret, 
                "http://api.netflix.com/oauth/request_token",
                "https://api-user.netflix.com/oauth/login?oauth_token={requestToken}" +
                    "&oauth_callback={redirectUri}&oauth_consumer_key=" + consumerKey,
                "http://api.netflix.com/oauth/access_token", 
                 OAuth1Version.CORE_10));
    }

    @Override
    protected NetFlixApi getApi(String consumerKey, String consumerSecret, String accessToken, String secret) {
        return new NetFlixTemplate(consumerKey, consumerSecret, accessToken, secret);
    }
	
}
</code></pre>
<p>扩展Spring Social的抽象服务提供程序类之一时，必须做两件事：在构造函数中设置提供程序的详细信息，并实现<code>getApi()</code>方法。</p>
<p>抽象基类包含与服务提供者连接的所有机制。但是您必须通过将提供程序的详细信息传递给<code>super()</code>构造函数来进行设置。在此， <code>NetFlixServiceProvider</code>构造函数调用<code>super()</code>构造函数，并传入“ netflix”作为提供者ID，给定的连接存储库，使用者密钥和使用者秘密，以及<code>OAuth1Template</code>的实例，该实例应用于与提供者进行身份验证。</p>
<p><code>OAuth1Template</code>给出的<code>OAuth1Template</code>是使用使用者密钥和秘密构造的，还提供了我们在初步研究期间收集的三个URL（请求令牌，授权和访问令牌）。请注意，已将授权URL参数化为采用请求令牌和重定向URI。 <code>ConnectController</code>将在执行授权流程的过程中提供这些详细信息。还要注意，授权URL也带有<code>oauth_consumer_key</code>参数。这似乎是特定于Netflix的需求； OAuth 1.0规范没有这样的要求，并且我还没有遇到其他任何需要它的提供商。</p>
<p>大多数OAuth 1服务提供商都实施OAuth 1.0a规范。因此， <code>OAuth1Template</code>假定默认情况下将处理OAuth 1.0a。Netflix是基于OAuth 1.0的提供商。赋予<code>OAuth1Template</code>构造函数的最终参数指定其不应采用1.0a，而应根据OAuth 1.0条款与提供商进行协商。如果Netflix是OAuth 1.0a提供者，则可以将此参数设置为<code>OAuth1Version.CORE_10_REVISION_A</code>或完全CORE_10_REVISION_A 。</p>
<p>服务提供者实现所需要的另一件事是实现<code>getApi()</code>方法。对于OAuth 1提供程序，此方法采用四个<code>String</code>参数，其中包含应用程序的使用者密钥/秘密对和访问令牌/秘密对。在这里，这些值用于创建和返回<code>NetFlixTemplate</code>的新实例（ <code>NetFlixTemplate</code>在此类上提供更多信息）。</p>
<p>尽管<code>NetFlixServiceProvider</code>仅演示了如何为OAuth 1开发服务提供程序实现，但是在扩展<code>AbstractOAuth2ServiceProvider</code>以创建OAuth 2服务提供程序时，模型并没有太大不同。关键区别在于：</p>
<ul>
<li>客户端ID和密码不会通过<code>super()</code>构造函数传递。</li>
<li>的一个实例<code>OAuth2Template</code>创建代替<code>OAuth1Template</code> （且需要令牌的URL的请求）。</li>
<li><code>getApi()</code>方法提供了用于构造API绑定的访问令牌值。</li>
</ul>
<p>请查看<a href="https://github.com/SpringSource/spring-social/blob/master/spring-social-facebook/src/main/java/org/springframework/social/facebook/connect/FacebookServiceProvider.java"><code>FacebookServiceProvider</code></a> ， <a href="https://github.com/SpringSource/spring-social/blob/master/spring-social-github/src/main/java/org/springframework/social/github/connect/GitHubServiceProvider.java"><code>GitHubServiceProvider</code></a>或<a href="https://github.com/SpringSource/spring-social/blob/master/spring-social-gowalla/src/main/java/org/springframework/social/gowalla/connect/GowallaServiceProvider.java"><code>GowallaServiceProvider</code></a>以获取有关如何创建基于OAuth 2的服务提供程序实现的示例。有关更多示例OAuth 1服务提供商，您可能还需要查看<a href="https://github.com/SpringSource/spring-social/blob/master/spring-social-twitter/src/main/java/org/springframework/social/twitter/connect/TwitterServiceProvider.java"><code>TwitterServiceProvider</code></a> ， <a href="https://github.com/SpringSource/spring-social/blob/master/spring-social-linkedin/src/main/java/org/springframework/social/linkedin/connect/LinkedInServiceProvider.java"><code>LinkedInServiceProvider</code></a>和<a href="https://github.com/SpringSource/spring-social/blob/master/spring-social-tripit/src/main/java/org/springframework/social/tripit/connect/TripItServiceProvider.java"><code>TripItServiceProvider</code></a> 。</p>
<h3>创建Netflix API绑定</h3>
<p>服务提供商实施完成后，我们现在将注意力转向创建与Netflix REST API的绑定。为了满足我们的迫切需求，我们需要一种读取用户光盘队列的方法。为了定义该操作，我们创建了<code>NetFlixApi</code>接口，该接口定义了服务API：</p>
<pre><code class="prettyprint java"><br>public interface NetFlixApi {

    List<CatalogTitle> searchForTitles(String searchTerms);

    List<QueueItem> getDiscQueue();

}
</code></pre>
<p>这很难完全绑定到Netflix的REST API。但这足以满足我们的目的。<code>searchForTitles()</code>方法可用于帮助用户选择他们想要为其撰写评论的电影。<code>getDiscQueue()</code>方法将用于检索用户光盘队列中的项目。现在我们需要创建一个实现类。<code>NetFlixTemplate</code>使用Spring的<code>RestTemplate</code>来调用Netflix的REST API：</p>
<pre><code class="prettyprint java"><br>package org.springframework.social.netflix;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import org.springframework.social.oauth1.ProtectedResourceClientFactory;
import org.springframework.web.client.RestTemplate;

public class NetFlixTemplate implements NetFlixApi {

    private final RestTemplate restTemplate;

    private final String userBaseUrl;

    public NetFlixTemplate(String apiKey, String apiSecret, String accessToken, 
            String accessTokenSecret) {
        this.restTemplate = 
                ProtectedResourceClientFactory.create(apiKey, apiSecret, accessToken, accessTokenSecret);
        this.userBaseUrl = getUserBaseUrl();
    }

    public List<CatalogTitle> searchForTitles(String searchTerm) {
        Map<String, Object> resultMap = restTemplate.getForObject(SEARCH_TITLES_URL, Map.class, searchTerm);
        List<CatalogTitle> titles = new ArrayList<CatalogTitle>();

        // extract CatalogTitle objects from resultMap

        return titles;
    }

    public List<QueueItem> getDiscQueue() {
        Map<String, Object> resultMap = restTemplate.getForObject(userBaseUrl + QUEUE_PATH, Map.class);
        List<QueueItem> queueItems = new ArrayList<QueueItem>();

        // extract QueueItem objects from resultMap

        return queueItems;
    }

    private String getUserBaseUrl() {
        Map<String, Map<String, Map<String, String>>> result = 
                restTemplate.getForObject(CURRENT_USER_URL, Map.class);
        return result.get("resource").get("link").get("href");
    }

    private static final String SEARCH_TITLES_URL = 
            "http://api.netflix.com/catalog/titles?term={term}&max_results=5&output=json";
    
    private static final String CURRENT_USER_URL = 
            "http://api.netflix.com/users/current?output=json";
    
    private static final String QUEUE_PATH = "/queues/disc?output=json";
}
</code></pre>
<p>请注意，尽管<code>NetFlixTemplate</code>使用<code>RestTemplate</code> ，但它不会为其自身创建<code>RestTemplate</code>实例。而是使用<code>ProtectedResourceClientFactory</code>创建一个OAuth就绪的<code>RestTemplate</code>实例。将设置<code>ProtectedResourceClientFactory</code>创建的<code>RestTemplate</code> ，以使用OAuth凭据对带有“ Authorization”标头的每个请求进行签名。</p>
<p><code>getDiscQueue()</code> <code>searchForTitles()</code>和<code>getDiscQueue()</code>使用可用于OAuth的<code>RestTemplate</code>对Netflix REST API进行各自的操作。 URL中的<code>output</code>参数告诉Netflix API，我们希望接收JSON响应而不是XML。在每种情况下，对<code>getForObject()</code>的调用<code>getForObject()</code>返回一个<code>Map</code> ，该映射镜像JSON响应的结构。然后从<code>Map</code>提取相关信息，以产生返回给呼叫者的列表。（为简便起见，我在上面的清单中省略了如何细分<code>Map</code>的详细信息。在GitHub中查找<a href="https://github.com/SpringSource/spring-social-samples/blob/master/spring-social-extending-new-api/src/main/java/org/springframework/social/movies/netflix/NetFlixTemplate.java"><code>NetFlixTemplate</code></a>的完整实现。）</p>
<p>Netflix REST API中的所有面向用户的操作，包括用于检索用户的光盘队列的调用，都具有以“ http://api.netflix.com/users/{user ID}”开头的URL。尽管<code>NetFlixTemplate</code>无法立即获得用户的Netflix ID，但是可以通过“ / users / current” API调用来检索用户的基本URL（包括其Netflix ID）。<code>getUserBaseUrl()</code>方法调用“ / users / current”以检索用户的基本URL。为了避免在每次调用前都必须检索基本URL，构造函数将调用一次<code>getUserBaseUrl()</code>方法，并将基本URL存储在成员变量中，以供以后为面向用户的操作构造URL时使用。</p>
<p>现在我们有了Netflix服务提供商和API绑定，我们可以围绕它们构建其余的电影评论应用程序。为了说明如何使用<code>getDiscQueue()</code>方法，请看以下屏幕快照的右列：</p><p><a href="http://blog.springsource.com/wp-content/uploads/2011/03/movie_app.png"><img src="http://blog.springsource.com/wp-content/uploads/2011/03/movie_app.png" alt="" title="movie_app" width="822" height="636" class="alignnone size-full wp-image-8251"></a></p>
<p>在此，将显示用户光盘队列中的电影列表以及这些电影的最近评论。在这一点上，不难想象对该应用程序进行了进一步的增强，也许使用户可以在考虑其他用户的评论时修改其队列。</p>
<h3>使用现有的API绑定</h3>
<p>在Netflix示例中，我选择创建自己的API绑定。但是，如果已经有一些绑定到您喜欢使用的服务提供者的现有库，那么就没有理由不能使用它与Spring Social的服务提供者框架以及提供者的API进行交互来进行连接处理。</p>
<p>例如，尽管Spring Social附带了与Twitter的REST API的Java绑定，但是您可能更喜欢使用其他绑定实现，例如Twitter4J。 Twitter4J提供了与Twitter服务API的全面Java绑定，但未解决授权流程或连接管理。如果您想将Twitter4J的API与Spring Social的连接管理功能一起使用，则可以通过创建一个使用Twitter4J作为API绑定的服务提供商来实现。</p>
<p>为此，您需要创建一个服务提供者实现，该服务提供者的<code>getApi()</code>方法使用<code>TwitterFactory</code>构造一个Twitter4J实例而不是<code>TwitterTemplate</code> 。这是基于Twitter4J的服务提供商实现的样子：</p>
<pre><code class="prettyprint java"><br>package org.springframework.social.showcase.twitter;
import java.util.Properties;
import org.springframework.social.connect.oauth1.AbstractOAuth1ServiceProvider;
import org.springframework.social.connect.support.ConnectionRepository;
import org.springframework.social.oauth1.OAuth1Template;
import twitter4j.Twitter;
import twitter4j.TwitterFactory;
import twitter4j.conf.Configuration;
import twitter4j.conf.PropertyConfiguration;

public final class Twitter4JServiceProvider extends AbstractOAuth1ServiceProvider<Twitter> {

    public Twitter4JServiceProvider(String consumerKey, String consumerSecret, ConnectionRepository connectionRepository) {
        super("twitter", connectionRepository, consumerKey, consumerSecret, new OAuth1Template(consumerKey, consumerSecret,
            "https://twitter.com/oauth/request_token",
            "https://twitter.com/oauth/authorize?oauth_token={requestToken}",
            "https://twitter.com/oauth/access_token"));
    }

    @Override
    protected Twitter getApi(String consumerKey, String consumerSecret, String accessToken, String secret) {
        Properties props = new Properties();
        props.setProperty(PropertyConfiguration.OAUTH_CONSUMER_KEY, consumerKey);
        props.setProperty(PropertyConfiguration.OAUTH_CONSUMER_SECRET, consumerSecret);
        props.setProperty(PropertyConfiguration.OAUTH_ACCESS_TOKEN, accessToken);
        props.setProperty(PropertyConfiguration.OAUTH_ACCESS_TOKEN_SECRET, secret);
        Configuration conf = new PropertyConfiguration(props);
        return new TwitterFactory(conf).getInstance();
    }

}
</code></pre>
<p>如您所见， <code>Twitter4JServiceProvider</code>看起来与Spring Social的<a href="https://github.com/SpringSource/spring-social/blob/master/spring-social-twitter/src/main/java/org/springframework/social/twitter/connect/TwitterServiceProvider.java"><code>TwitterServiceProvider</code></a>非常相似，也非常类似于<code>NetFlixServiceProvider</code>创建的<code>NetFlixServiceProvider</code> 。关键区别在于，将<code>Twitter4JServiceProvider</code>参数化为<code>Twitter</code>服务提供商，而<code>getApi()</code>方法构造一个Twitter4J <code>Twitter</code>实例。</p>
<p><code>Twitter4JServiceProvider</code>的代码以及使用它的示例可以在GitHub的<a href="https://github.com/SpringSource/spring-social-samples/tree/master/spring-social-extending-new-api">Spring Social Samples存储库中找到</a> 。</p>
<h3>摘要</h3>
<p>即使Spring Social 1.0.0。M2专注于少数几个SaaS提供商，该服务提供商框架易于扩展，使您能够在Spring Social之上为其他提供商建立支持。此外，该框架不仅限于为Spring Social特定的API绑定开发服务提供商实现-您可以使用它为现有的API绑定创建连接。</p>
<p>在扩展Spring Social的主题时，您可能要探索的另一个领域是创建<a href="https://github.com/SpringSource/spring-social/blob/master/spring-social-core/src/main/java/org/springframework/social/connect/support/ConnectionRepository.java" target="_blank"><code>ConnectionRepository</code></a>接口的新实现。春季社交1.0.0。M2带有JDBC支持的实现，但是持久连接还有其他可能性。例如， <a href="http://www.springsource.org/spring-android" target="_blank">Spring Android</a>项目定义了一个<a href="http://git.springsource.org/spring-mobile/spring-android/blobs/master/spring-android-auth/src/main/java/org/springframework/social/connect/sqlite/SqliteConnectionRepository.java"><code>SqliteConnectionRepository</code></a> ，它使连接能够写入到Android设备本地存储的SQLite数据库中。另外，看到NoSQL连接存储库的外观也会很有趣。</p>
<p>我们期待看到您如何扩展Spring Social。如果您为Spring Social创建有用或有趣的扩展，请在<a href="http://forum.springsource.org/forumdisplay.php?f=82" target="_blank">论坛中</a>向我们介绍或在GitHub中向我们发送请求请求。我们已经收到了来自社区的少量请求请求，并且正在努力将其合并到Spring Social中。非常感谢您的贡献！</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">var disqus_shortname = 'spring-io';
      var disqus_identifier = 400;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));</script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
 <form id="mktoForm_4723"></form>
<script>MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });</script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>