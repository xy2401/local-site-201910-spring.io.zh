<html  data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>Spring Roo 1.2中新的应用程序分层和持久性选择</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="New application layering and persistence choices in Spring Roo 1.2">
<meta name="twitter:description" >
<meta property="og:title" content="New application layering and persistence choices in Spring Roo 1.2">
<meta property="og:description" >
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2011-09-14 17:18:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Spring Roo 1.2中新的应用程序分层和持久性选择</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="null?s=20&d=mm"> <span class="author">斯蒂芬·施密特（Stefan Schmidt）</span>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2011-09-14 17:18:00.0">2011年9月14日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2011/09/14/new-application-layering-and-persistence-choices-in-spring-roo-1-2#disqus_thread" data-disqus-identifier="440">
</a></div>
</div>
</header>
<div class="blog--post"><p>Java企业应用程序可以采用多种形状和形式。根据他们的要求，开发人员需要确定他们的应用程序需要哪些特定的体系结构层。到目前为止， <a href="http://www.springsource.org/roo">Spring Roo</a>采取了<a href="http://static.springsource.org/spring-roo/reference/html-single/index.html#architecture">务实的方法</a>来减少服务外观，存储库或DAO层引入的通常不必要的复杂性。新发布的Spring Roo 1.2.0。M1（ <a href="http://blog.springsource.com/2011/09/14/spring-roo-1-2-0-m1-released/">请参阅公告</a> ）包括<a href="https://jira.springsource.org/browse/ROO-340">经常</a> <a href="https://jira.springsource.org/browse/ROO-301">请求的</a>对体系结构层的支持，可以根据应用程序的需求进行定制。本文概述了Roo的新服务和存储库层功能。</p>
<center><img src="http://blog.springsource.com/wp-content/uploads/2011/09/roo-layering1.png" alt="Spring Roo应用程序分层支持"></center><p>尽管有许多新的分层和持久性选项可用，但默认情况下，Roo将继续默认支持JPA Active Record实体。但是，您可以通过添加其他服务或存储库层来轻松更改现有应用程序（以下详细信息）。如果添加新层，Roo将分别自动在消费者层或服务层更改其ITD。例如，Roo将自动更改您的应用程序，以便在给定域类型的现有MVC控制器，GWT定位器，集成测试或按需数据中注入并调用新的服务层。</p>
<h3>持久层</h3><p>与Roo 1.2.0。M1版本现在在Roo核心中提供了三个选项来支持数据持久性，JPA实体（Active Record样式），JPA存储库和MongoDB存储库。对<a href="http://www.springsource.org/spring-data/neo4j">Spring Data Neo4J的</a>支持目前正在开发中，应该作为<a href="http://static.springsource.org/spring-roo/reference/html-single/index.html#usage-add-ons">Roo附加组件</a>尽快提供。</p>
<h4>JPA实体（活动记录样式）</h4><p>自Spring Roo的第一个发行版以来，活动记录风格的JPA实体已成为默认设置，并将保持不变。为了为JPA持久性配置项目，可以运行jpa setup命令：</p>
<pre><code class="prettyprint xml">roo&gt; jpa setup --provider HIBERNATE --database HYPERSONIC_PERSISTENT
</code></pre><p>这会将您的项目配置为使用Hibernate对象关系映射器以及内存数据库（HSQLDB）。Roo支持的活动记录样式JPA实体带有注释<code><strong>@RooEntity</strong></code>它负责提供持久性标识符字段及其访问器和更改器。另外，该注释创建典型的CRUD方法以支持数据访问。</p>
<pre><code class="prettyprint xml">roo&gt; entity --class ~.domain.Pizza
</code></pre><p>此命令将创建一个Pizza域类型以及有效的记录样式方法，以保留，更新，读取和删除您的实体。以下示例还包含许多字段，可以将这些字段直接添加到Java源中，也可以通过Roo shell通过field命令添加。</p>
<pre><code class="prettyprint java">@RooJavaBean
@RooToString
@RooEntity
public class Pizza {

    @NotNull
    @Size(min = 2)
    private String name;

    private BigDecimal price;

    @ManyToMany(cascade = CascadeType.ALL)
    private Set&lt;Topping&gt; toppings = new HashSet&lt;Topping&gt;();

    @ManyToOne
    private Base base;
}
</code></pre>
<h4>JPA资料库</h4><p>需要存储库/ DAO层而不是默认的基于Roo JPA基于“活动记录”的持久性方法的开发人员可以通过为给定的JPA域类型创建<a href="http://www.springsource.org/spring-data/jpa">Spring Data JPA</a>支持的存储库来做到这一点。通过以下方式为JPA持久性配置项目后<code>jpa setup</code>命令，通过用Roo注释域类型自动提供此功能<code><strong>@RooJpaEntity</strong></code>注解。</p>
<pre><code class="prettyprint xml">roo&gt; entity --class ~.domain.Pizza --activeRecord false
</code></pre><p>通过定义<code>–activeRecord false</code>您可以选择不使用默认的“ Active Record”样式。以下示例还包含许多字段，可以通过Roo Shell通过field命令添加这些字段。</p>
<pre><code class="prettyprint java">@RooJavaBean
@RooToString
@RooJpaEntity
public class Pizza {

    @NotNull
    @Size(min = 2)
    private String name;

    private BigDecimal price;

    @ManyToMany(cascade = CascadeType.ALL)
    private Set&lt;Topping&gt; toppings = new HashSet&lt;Topping&gt;();

    @ManyToOne
    private Base base;
}
</code></pre><p>有了域类型后，您现在可以使用<code>repository jpa</code>命令：</p>
<pre><code class="prettyprint xml">roo&gt; repository jpa --interface ~.repository.PizzaRepository --entity ~.domain.Pizza
</code></pre><p>这将创建一个利用Spring Data JPA的简单接口定义：</p>
<pre><code class="prettyprint java">@RooRepositoryJpa(domainType = Pizza.class)
public interface PizzaRepository {
}
</code></pre><p>当然，您只需添加<code><strong>@RooRepositoryJpa</strong></code>可以手动在任何接口上进行注释，而不是在Roo Shell中发出repository jpa命令。</p><p>的加法<code><strong>@RooRepositoryJpa</strong></code>批注将触发一个相当琐碎的AspectJ ITD的创建，它会向PizzaRepository接口添加extend语句，从而导致等效于此接口定义：</p>
<pre><code class="prettyprint java">public interface PizzaRepository extends JpaRepository&lt;Pizza, Long&gt; {}
</code></pre><p><a href="http://static.springsource.org/spring-data/data-jpa/docs/current/api/org/springframework/data/jpa/repository/JpaRepository.html">JpaRepository</a>接口是<a href="http://www.springsource.org/spring-data/jpa">Spring Data JPA</a> API的一部分，提供了所有开箱即用的CRUD功能。</p>
<h4>MongoDB持久性</h4><p>作为JPA持久性的替代方法，Spring Roo 1.2现在通过利用<a href="http://www.springsource.org/spring-data/mongodb">Spring Data MongoDB</a>项目提供<a href="https://www.mongodb.org/">MongoDB</a>支持。MongoDB得到Cloud Foundry的支持，Cloud Foundry是自由开发和托管Spring Roo应用程序的好地方。除MongoDB外，您还可以将MySQL和PostgreSQL与Cloud Foundry结合使用。要为MongoDB持久性配置项目，可以使用mongo setup命令：</p>
<pre><code class="prettyprint xml">roo&gt; mongo setup
</code></pre><p>这将配置您的Spring Application上下文以使用在localhost和默认端口上运行的MongoDB安装。可选的命令属性允许您定义主机，端口，数据库名称，用户名和密码。如果您在Cloud Foundry上使用MongoDB，只需弹出<code>–cloudFoundry</code>在“ mongo setup”之后，Roo可以为您自动配置所有内容</p><p>将应用程序配置为支持MongoDB后， <code>entity mongo</code>和<code>repository mongo</code>命令可用：</p>
<pre><code class="prettyprint xml">roo&gt; entity mongo --class ~.domain.Pizza
</code></pre><p>此命令将创建一个批注为Pizza的比萨类型<strong><code>@RooMongoEntity</code></strong> 。该注释负责触发创建提供Spring数据的ITD。 <code>@Id</code>带注释的字段及其访问器和更改器。以下示例还包含许多字段，可以通过Roo Shell通过field命令添加这些字段。</p>
<pre><code class="prettyprint java">@RooJavaBean
@RooToString
@RooMongoEntity
public class Pizza {

    @NotNull
    @Size(min = 2)
    private String name;

    private BigDecimal price;

    @ManyToMany(cascade = CascadeType.ALL)
    private Set&lt;Topping&gt; toppings = new HashSet&lt;Topping&gt;();

    @ManyToOne
    private Base base;
}
</code></pre><p>使用域类型后，您现在可以使用repository mongo命令（或通过应用<code><strong>@RooRepositoryMongo</strong></code>对任意接口的注释）：</p>
<pre><code class="prettyprint xml">roo&gt; repository mongo --interface ~.repository.PizzaRepository --entity ~.domain.Pizza
</code></pre><p>这将创建一个利用<a href="http://www.springsource.org/spring-data/mongodb">Spring Data MongoDB</a>的简单接口定义：</p>
<pre><code class="prettyprint java">@RooRepositoryMongo(domainType = Pizza.class)
public interface PizzaRepository {

    List&lt;Pizza&gt; findAll();
}
</code></pre><p>与上面看到的Spring Data JPA驱动的存储库类似，此接口通过ITD进行了增强，该ITD引入了Spring Data API提供的<a href="http://static.springsource.org/spring-data/data-commons/docs/1.1.0.RELEASE/api/org/springframework/data/repository/PagingAndSortingRepository.html">PagingAndSortingRepository</a> ，并负责提供所有必要的CRUD功能。另外，此接口定义了“自定义”查找器，而PagingAndSortingRepository实现未提供该查找器： <code>List findAll();</code> 。此方法是Spring Roo的UI支架所必需的，并且由Spring Data MongoDB提供的<a href="http://static.springsource.org/spring-data/data-document/docs/1.0.0.M4/reference/html/#repositories.definition-tuning">查询构建器机制</a>自动实现。</p><p>与使用JPA持久性的应用程序类似（有关将JPA与Postgres结合使用的详细信息，请参阅<a href="http://blog.springsource.com/2011/08/30/using-postgres-on-cloud-foundry/">此博客文章</a> ），可以将MongoDB应用程序轻松部署到<a href="http://cloudfoundry.com/">VMware Cloud Foundry</a> 。以下脚本提供了Pizza Shop示例应用程序的示例（请参阅/sample/pizzashop.roo），该示例应用程序已进行了调整，以与MongoDB支持的存储库层一起使用：</p>
<pre><code class="prettyprint xml">// Create a new project.
project com.springsource.pizzashop

// Create configuration for MongoDB peristence 
mongo setup --cloudFoundry true

// Define domain model.
entity mongo --class ~.domain.Base --testAutomatically
field string --fieldName name --sizeMin 2 --notNull --class ~.domain.Base
entity mongo --class ~.domain.Topping --testAutomatically
field string --fieldName name --sizeMin 2 --notNull --class ~.domain.Topping
entity mongo --class ~.domain.Pizza --testAutomatically
field string --fieldName name --notNull --sizeMin 2 --class ~.domain.Pizza
field number --fieldName price --type java.lang.Float
field set --fieldName toppings --type ~.domain.Topping
field reference --fieldName base --type ~.domain.Base
entity mongo --class ~.domain.PizzaOrder --testAutomatically
field string --fieldName name --notNull --sizeMin 2 --class ~.domain.PizzaOrder
field string --fieldName address --sizeMax 30
field number --fieldName total --type java.lang.Float
field date --fieldName deliveryDate --type java.util.Date
field set --fieldName pizzas --type ~.domain.Pizza

// Add layer support.
repository mongo --interface ~.repository.ToppingRepository --entity ~.domain.Topping
repository mongo --interface ~.repository.BaseRepository --entity ~.domain.Base
repository mongo --interface ~.repository.PizzaRepository --entity ~.domain.Pizza
repository mongo --interface ~.repository.PizzaOrderRepository --entity ~.domain.PizzaOrder
service --interface ~.service.ToppingService --entity ~.domain.Topping
service --interface ~.service.BaseService --entity ~.domain.Base
service --interface ~.service.PizzaService --entity ~.domain.Pizza
service --interface ~.service.PizzaOrderService --entity ~.domain.PizzaOrder

// Create a Web UI.
web mvc setup
web mvc all --package ~.web

// Package the application into a war file.
perform package

// Deploy and start the application in Cloud Foundry
cloud foundry login 
cloud foundry deploy --appName roo-pizzashop --path /target/pizzashop-0.1.0.BUILD-SNAPSHOT.war --memory 512
cloud foundry create service --serviceName pizzashop-mongo --serviceType mongodb
cloud foundry bind service --serviceName pizzashop-mongo --appName roo-pizzashop
cloud foundry start app --appName roo-pizzashop
</code></pre><p>当前，“实时”示例应用程序已部署在Cloud Foundry上： <a href="http://roo-pizzashop.cloudfoundry.com/"></a> <a href="http://roo-pizzashop.cloudfoundry.com/">http://roo-pizzashop.cloudfoundry.com/</a><br></p><h3>服务层</h3><br>开发人员还可以选择在其应用程序中创建服务层。默认情况下，Roo将为一个或多个域实体创建服务接口（和实现）。如果给定域实体存在诸如Roo的默认实体层或存储库层之类的提供持久性的层，则服务层将通过其持久性层的接口和实现公开此持久性层提供的CRUD功能。<p></p><p>根据Roo的约定，所有功能都将通过AspectJ ITD引入，因此为开发人员提供了一个干净的画布，用于实现自然不适合域实体的自定义业务逻辑。服务层的其他常见用例是安全性或远程集成，例如Web服务。有关更详细的讨论，请参阅Spring Roo参考指南中的<a href="http://static.springsource.org/spring-roo/reference/html-single/index.html#architecture-services">体系结构章节</a> 。</p><p>通过直接使用@RooService批注或Roo shell中的service命令，将服务层集成到Roo项目中类似于存储库层：</p>
<pre><code class="prettyprint xml">roo&gt; service --interface ~.service.PizzaService --entity ~.domain.Pizza
</code></pre><p>此命令将创建<code>PizzaService</code>接口在已定义的包中，另外还有一个<code>PizzaServiceImpl</code>在同一个包装中（包装的名称和包装<code>PizzaServiceImpl</code>可以通过可选的自定义<code>–class</code>属性）。</p>
<pre><code class="prettyprint java">@RooService(domainTypes = { Pizza.class })
public interface PizzaService {
}
</code></pre><p>遵循Roo约定，可以在AspectJ ITD中找到默认的CRUD方法定义：</p>
<pre><code class="prettyprint java">void savePizza(Pizza pizza);
Pizza findPizza(Long id);    
List&lt;Pizza&gt; findAllPizzas();    
List&lt;Pizza&gt; findPizzaEntries(int firstResult, int maxResults);   
long countAllPizzas();    
Pizza updatePizza(pizza pizza);
void deletePizza(Pizza pizza);
</code></pre><p>同样，PizzaServiceImpl非常简单：</p>
<pre><code class="prettyprint java">public class PizzaServiceImpl implements PizzaService {}
</code></pre><p>通过AspectJ ITD， <code>PizzaServiceImpl</code>类型以<code><strong>@Service</strong></code>和<code><strong>@Transactional</strong></code>默认情况下为注释。此外，ITD将在目标类型中引入以下方法和字段：</p>
<pre><code class="prettyprint java">@Autowired PizzaRepository pizzaRepository;
    
public void savePizza(Pizza pizza) {
    pizzaRepository.save(pizza);
}

public Pizza findPizza(Long id) {
    return pizzaRepository.findOne(id);
}

public List&lt;Pizza&gt; findAllPizzas() {
    return pizzaRepository.findAll();
}

public List&lt;Pizza&gt; findPizzaEntries(int firstResult, int maxResults) {
    return pizzaRepository.findAll(new PageRequest(firstResult / maxResults, maxResults)).getContent();
}

public long countAllPizzas() {
    return pizzaRepository.count();
}

public Pizza updatePizza(Pizza pizza) {
    return pizzaRepository.save(pizza);
}
    
public void deletePizza(Pizza pizza) {
    pizzaRepository.delete(pizza);
}
</code></pre><p>如您所见，Roo将检测给定域类型是否存在持久性提供程序层，并自动注入该组件以将所有服务层调用委派给该层。如果不存在持久性（或其他“较低级别”）层，则服务层ITD将仅提供方法存根。</p>
<h3>总结思想</h3><p>使用Spring Roo 1.2，向新的或现有的Spring Roo托管的应用程序中添加体系结构层或持久性选项几乎变得微不足道。无需考虑为新的持久性提供程序配置应用程序，或将对新层的引用注入到Spring MVC控制器，GWT UI或集成测试中-Roo会为您完成所有工作！</p><p>借助Spring Roo 1.2中可用的分层支持，我们希望将来会看到更多的持久性提供程序。<a href="http://www.springsource.org/spring-data/neo4j">Spring Data Neo4J的</a>存储库分层集成目前正在开发中，应作为<a href="http://static.springsource.org/spring-roo/reference/html-single/index.html#usage-add-ons">Roo附加组件</a>尽快提供。</p><p>如果您想轻松地尝试这些新功能，为什么不构建自己的由MongoDB支持的<a href="http://roo-pizzashop.cloudfoundry.com/">Pizza Shop应用程序版本</a>并将其<a href="http://support.cloudfoundry.com/home">部署</a>到<a href="http://www.cloudfoundry.com/">Cloud Foundry</a> ？这些新的Roo 1.2.0只需几分钟。M1功能。</p><p>鉴于<a href="http://blog.springsource.com/2011/09/14/spring-roo-1-2-0-m1-released/">Spring Roo 1.2.0。M1</a>是一个里程碑版本，您应该继续将Roo 1.1.5用于生产项目。但是，我们相信Roo 1.2 M1非常适合探索新功能或快速项目。</p><p>Roo团队始终欢迎<a href="http://forum.springsource.org/forumdisplay.php?67-Roo">社区的</a>反馈。</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 440;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>