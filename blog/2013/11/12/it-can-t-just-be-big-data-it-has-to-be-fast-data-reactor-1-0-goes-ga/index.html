<html  data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>它不能只是大数据，而必须是快速数据：Reactor 1.0进入了GA</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="It can't just be Big Data, it has to be Fast Data: Reactor 1.0 goes GA">
<meta name="twitter:description" >
<meta name="twitter:creator" content="@j_brisbin">
<meta name="twitter:image:src" content="http://gravatar.com/avatar/5500b5cf634f9a3921e4619778a1425f?s=200">

<meta property="og:title" content="It can't just be Big Data, it has to be Fast Data: Reactor 1.0 goes GA">
<meta property="og:image" content="http://gravatar.com/avatar/5500b5cf634f9a3921e4619778a1425f?s=200">
<meta class="anchor" name="what-is-reactor-and-why-should-i-care" property="og:description" content="<p>I’m happy to announce that Reactor, a powerful foundational library for building reactive, fast data applications on the JVM has reached GA! </p>
<h3><a href=" #what-is-reactor-and-why-should-i-car="=">What is Reactor and why should I care?
<p>Reactor provides the necessary abstractions to build high-throughput, low-latency–what we now call “fast data”–applications that absolutely <em>must</em> work with thousands, tens of thousands, or even millions of concurrent requests per second.</p>
<p>You should care about Reactor because modern applications with non-human consumers–like mobile phones and the apps that run on them–generate more data than traditional thread-per-connection servers are capable of supporting so Reactor provides you with the tools and abstractions you need to build these kinds of high-scale applications without getting bogged down in the logistics of managing state and passing around events in an asynchronous application. Modern JVM applications must be built on a solid foundation of asynchronous and reactive components that efficiently manage the execution of a very large number of tasks on a very small number of system threads. Reactor is specifically designed to help you build these kinds of applications without getting in your way or forcing you to work within an opinionated pattern. </p>
">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2013-11-12 07:00:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category content--title">
<div>工程</div>
</div>
<div class="blog-category active content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">它不能只是大数据，而必须是快速数据：Reactor 1.0进入了GA</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon releases"></div>
<a class="category">发布</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/5500b5cf634f9a3921e4619778a1425f?s=20&d=mm"> <span class="author">乔恩·布里斯宾</span>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2013-11-12 07:00:00.0">2013年11月12日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2013/11/12/it-can-t-just-be-big-data-it-has-to-be-fast-data-reactor-1-0-goes-ga#disqus_thread" data-disqus-identifier="1242">
</a></div>
</div>
</header>
<div class="blog--post"><p>我很高兴地宣布，Reactor是一个功能强大的基础库，用于在JVM上构建响应式，快速数据应用程序。</p><h3><a href="#what-is-reactor-and-why-should-i-care" class="anchor" name="what-is-reactor-and-why-should-i-care"></a>什么是反应堆，我为什么要关心？</h3><p>Reactor提供了必要的抽象来构建高吞吐量，低延迟（我们现在称为“快速数据”）应用程序，这些应用程序绝对<em>必须</em>每秒处理数千，数万甚至数百万个并发请求。</p><p>您应该关心Reactor，因为具有非人类消费者的现代应用程序（例如手机和在其上运行的应用程序）所生成的数据比传统的每线程连接服务器能够支持的数据多，因此Reactor为您提供了工具和抽象需要构建此类大型应用程序，而又不会陷入异步应用程序中状态管理和事件传递的麻烦中。现代JVM应用程序必须建立在异步和反应性组件的坚实基础上，这些组件可以有效地管理非常少量的系统线程上大量任务的执行。Reactor是专门为帮助您构建此类应用程序而设计的，而不会妨碍您或强迫您按照自觉的方式工作。</p><h3><a href="#reactor-is-foundational" class="anchor" name="reactor-is-foundational"></a>反应堆是基础</h3><p>Reactor本身受<a href="https://en.wikipedia.org/wiki/Reactor_pattern">同名的知名设计模式的</a>严重影响-但它并不<em>仅从</em>该模式中汲取灵感。<a href="https://en.wikipedia.org/wiki/Actor_model">Actor模型的</a>元素也包括传统的基于事件的回调编程。</p><p>尽管它是<a href="https://spring.io/platform">Spring IO Platform</a>基础的一部分， <strong>但核心Reactor库并不依赖于Spring</strong> 。Reactor核心是一个自包含的库，它的唯一外部依赖关系是<a href="http://www.slf4j.org/">SLF4J</a>和出色的<a href="https://lmax-exchange.github.io/disruptor/">LMAX Disruptor RingBuffer库</a> 。</p><p>其他的可选组件构建在Reactor的核心上，以方便根据通用模式开发应用程序。Reactor的内置一流支持包括：</p>
<ul>
<li>通过高速<a href="https://reactor.github.io/docs/api/index.html?reactor/core/processor/Processor.html">处理器</a>抽象对LMAX Disruptor的支持，该抽象在RingBuffer上提供了Reactor API。</li>
<li>通过灵活的<a href="https://reactor.github.io/docs/api/index.html?reactor/queue/PersistentQueue.html">PersistentQueue</a>抽象支持高性能<a href="https://github.com/OpenHFT/Java-Chronicle">JavaChronicle持久消息传递库</a> 。</li>
<li>支持Groovy闭包和<code>@CompileStatic</code>并提供全面的环境构建和事件接线DSL。</li>
<li>基于Netty 4.0的高性能TCP客户端和服务器支持。</li>
<li>强大的基于注释的Spring支持。</li>
<li>靴子里有几桶东西……</li>
</ul><h3><a href="#reactor-is-fast" class="anchor" name="reactor-is-fast"></a>反应堆快</h3><p>从根本上设计Reactor的目的是要灵活，高效地执行操作，这样它就可以摆脱您的干扰，并帮助您尽快通过应用程序处理数据。以其最快的配置，标准的支持RingBuffer的Reactor可以在标准的开发者笔记本电脑上每秒发布10-15百万个事件。高性能<code>Processor</code>抽象每秒可以将超过1亿个事件泵入您的应用程序。您的应用程序如何处理数据以减慢Reactor的速度可能会因任务而异。但是在最佳的无操作模式下，由于具有如此高的吞吐量，因此应用程序将不会等待Reactor来完成其工作！</p><h3><a href="#reactor-is-functional" class="anchor" name="reactor-is-functional"></a>反应堆功能正常</h3><p>Reactor核心包含一些基本的抽象，这些抽象是受JDK 8的新功能抽象（在某些情况下直接基于）启发的， <code>Function<T,V></code> ， <code>Consumer<T></code> ， <code>Supplier<T></code>和<code>Predicate<T></code> 。Reactor本身不仅建立在这些抽象的基础上，而且您的应用程序也可以利用它们。在将来的某个时候，采用JDK 8的程度将非常普遍，以至于Reactor可以简单地从Reactor中删除这些抽象并依赖JDK 8中的抽象。在此之前，您的JDK 6和7应用程序现在可以从这些功能抽象中受益。</p><h3><a href="#reactor-is-reactive" class="anchor" name="reactor-is-reactive"></a>反应堆是反应性的</h3><p>受诸如<a href="https://rx.codeplex.com/">.NET</a>的<a href="https://rx.codeplex.com/">Reactive Extensions</a> ， <a href="https://github.com/Netflix/RxJava">Netflix的RxJava</a> ，JDK 8 <a href="http://download.java.net/jdk8/docs/api/index.html?java/util/stream/Stream.html">Stream</a>抽象以及许多其他库（更不用说20年的事件驱动计算机科学）之类的库的启发，Reactor提供了一种“反应式”编程模型来协调异步任务容易得多。像这样的抽象<code>Stream<T></code>和<code>Promise<T></code>使链接非阻塞操作变得简单明了-无需回调意大利面！</p>
<pre><code class="prettyprint java">@Inject
AsyncDataLoader loader;

Promise&lt;Buffer&gt; p = loader.get(&quot;U-U-I-D&quot;)
    .map(new Function&lt;Buffer, Data&gt;() {
      public Data apply(Buffer buff) {
        // transform data
        Data data = parser.parse(buff);
        return data;
      }
    })
    .filter(new Predicate&lt;Data&gt;() {
      public boolean test(Data data) {
        // check Data for certain conditions being true
        return null != data.getName();
      }
    })
    .consume(new Consumer&lt;Data&gt;() {
      public void accept(Data data) {
        // only Data that passes the Predicate test makes it here...
      }
    });
    
// Promises can also block like a Future
Buffer buff = p.await();
</code></pre><p>每个操作（ <code>map</code> ， <code>filter</code> ， <code>consume</code> ）是（可能）异步执行的不同操作。在传统的多线程环境中，必须添加一些关于期货阻塞和等待完成的嘈杂代码。但是，使用Reactor，您可以简单地以反应方式将动作链接在一起，以便在上一个动作完成后，动作将对数据“做出反应”。</p><h3><a href="#reactor-is-groovy" class="anchor" name="reactor-is-groovy"></a>反应堆是普通的</h3><p>Reactor包括对Groovy语言的一流支持。它支持使用Closures作为回调，并具有用于配置Reactor Environment的强大DSL，并为编写简洁的代码提供了一些非常酷的运算符重载。</p><h3><a href="#reactor-is-extensible" class="anchor" name="reactor-is-extensible"></a>反应堆是可扩展的</h3><p>Clojurewerkz有一个基于Reactor的名为<a href="https://github.com/clojurewerkz/meltdown">Meltdown</a>的库。无需付出很多努力即可添加其他JVM语言支持。Reactor的API设计为可扩展的，因此非Java语言可以从Reactor中的工具中受益。</p><h3><a href="#but-what-does-the-code-look-like" class="anchor" name="but-what-does-the-code-look-like"></a>但是代码是什么样的？</h3><p>Reactor已支持Java 8，因此，让我们首先使用JDK 8的Lambda出色功能查看一些Reactor代码：</p>
<pre><code class="prettyprint java">import static reactor.event.selector.Selectors.*;

// Only create one of these per JVM
static Environment env = new Environment();

// Create a Reactor and listen to a topic using a Selector
Reactor r = Reactors.reactor(env)
  .&lt;String&gt;on($(&quot;topic&quot;), ev -&gt; System.out.prinltn(&quot;greeting: &quot; + ev.getData()));

r.notify(&quot;topic&quot;, Event.wrap(&quot;Hello World!&quot;));
</code></pre><p>Reactor希望完成的任务之一是减少您必须编写的代码量。以上非常简洁。但是即使在Java 6和7中，它也非常简洁：</p>
<pre><code class="prettyprint java">import static reactor.event.selector.Selectors.*;

// Only create one of these per JVM
static Environment env = new Environment();

// Create a Reactor and listen to a topic using a Selector
Reactor r = Reactors.reactor(env)
  .on($(&quot;topic&quot;), new Consumer&lt;Event&lt;String&gt;&gt;() {
    public void accept(Event&lt;String&gt; ev) {
      System.out.prinltn(&quot;greeting: &quot; + ev.getData());
    }
  });

r.notify(&quot;topic&quot;, Event.wrap(&quot;Hello World!&quot;));
</code></pre><p>在Groovy中，它更加简洁（如您期望的那样），因为语言支持负责将某些对象转换为正确的类型并允许使用Closures：</p>
<pre><code class="prettyprint java">def env = new Environment()

def r = Reactors.reactor(env).on(&quot;topic&quot;) { String greeting -&gt;
  println &quot;greeting: $greeting&quot;
}

r.notify &quot;topic&quot;, &quot;Hello World!&quot;
</code></pre><h3><a href="#dispatchers" class="anchor" name="dispatchers"></a>调度员</h3><p>一种<code>Dispatcher</code>负责在给定的任务上执行任务<code>Thread</code> 。有各种内置的实现<code>Dispatcher</code>使用单线程事件循环样式分派或最快的分派器在调用线程中，池中的线程上执行任务的方法： <code>RingBufferDispatcher</code>它使用<a href="https://lmax-exchange.github.io/disruptor/">LMAX Disruptor RingBuffer</a>调度任务。</p><p>每当您在Reactor中创建组件时，通常都会指定<code>Dispatcher</code>在调度事件时使用。事件分配到RingBuffer的效率非常高，而不是使用线程池（对于大容量应用程序，这对于CPU和GC而言可能变得非常昂贵）。使用以下命令可以每秒分发10亿个事件<code>RingBufferDispatcher</code> 。</p><h3><a href="#selectors" class="anchor" name="selectors"></a>选择器</h3><p>一种<code>Selector</code>是动作到事件键的动态映射。当您将动作分配给<code>Reactor</code> ，您可以通过注册一个来告诉它要响应的事件键<code>Selector</code> 。有几种内置的实现可与类似的东西匹配<code>Object.equals()</code> ，执行基于字符串的正则表达式匹配，URI模板匹配，因此您可以使用熟悉的大括号分隔的占位符表示法来与URI进行匹配， <code>Class.isAssignableFrom()</code>匹配以仅选择那些来自通用抽象的键， <code>Predicate</code>匹配以允许您创建任意<code>Predicate<T></code>基于范围谓词的选择器，甚至还有一个可选<code>JsonPathSelector</code>使用<a href="https://code.google.com/p/json-path/">JsonPath</a>通过JsonPath表达式从键查询数据。</p><p>您会在示例中注意到使用某些东西，作为Java开发人员，您可能会对以下内容感到困惑： <code>$</code>创建一个快捷方式<code>Selector</code> [1]。如果您使用jQuery进行Web开发，那么您会感到宾至如归，因为<code>$</code>方法只是创建一个<code>Selector</code>就像jQuery在编写类似的东西时创建CSS查询一样<code>$(".css-class")</code> 。如果美元符号对您来说太不寻常了，Reactor总是尝试提供多种方法来完成某件事。您可以使用<code>Selectors.object(T)</code>要么<code>ObjectSelector.objectSelector()</code>而是使用静态创建方法（或只是新建一个实例） <code>ObjectSelector</code>使用构造函数）。</p><p>[1]： <em>此外<code>$(T)</code> ，还有其他用于创建选择器的快捷方式帮助器方法。有<code>R(String)</code>用于创建RegexSelector， <code>T(Class<?>)</code>用于创建ClassSelector，以及<code>U(String)</code>用于创建UriTemplateSelectors。</em></p><h3><a href="#promise-and-stream" class="anchor" name="promise-and-stream"></a>承诺和流</h3><p>反应堆<code>Promise</code>和<code>Stream</code>提供一种反应式，组合式的方式来协调多个异步任务，而不会产生过多的回调意大利面条。一种<code>Promise</code>是一个有状态的组件，可以在您的应用程序周围传递，并表示将从另一个线程填充的值。像传统<code>Future</code> ， 一种<code>Promise</code>可以阻止调用线程。但更重要的是<code>Promise</code>使转换值和执行整个处理链变得容易。</p><p>一种<code>Stream</code>类似于<code>Promise</code>它提供了一个复合API来对未来的价值做出反应。但是一个<code>Stream</code>不同于<code>Promise</code>它旨在处理传递的多个值。</p><p>在任一位置填充值<code>Promise</code>或<code>Stream</code> ，您创建了一个<code>Deferred</code> ，这是一个<code>Consumer<T></code> 。你可以通过<code>Deferred</code>进入您的服务层，以将最终的价值传达给呼叫者。</p>
<pre><code class="prettyprint java">// Only create one of these per JVM
static Environment env = new Environment();

public class DataLoader {

  public Promise&lt;Buffer&gt; load(String key) {  
    Deferred&lt;Buffer, Promise&lt;Buffer&gt;&gt; deferred = Promises.defer(env);

    // submit work to be done in another thread
    // like reading data from a datastore
    datastore.load(key, deferred);
    
    return deferred.compose();
  }
  
}

// Your service layer uses this API
@Inject
DataLoader loader;

loader.load(&quot;obj-key&quot;)
  .onSuccess(new Consumer&lt;Buffer&gt;() {
    public void accept(Buffer b) {
      // handle eventual data
    }
  })
  .onError(new Consumer&lt;Throwable&gt;() {
    public void accept(Throwable t) {
      // handle errors
    }
  });
</code></pre><h3><a href="#tuples" class="anchor" name="tuples"></a>元组</h3><p>Scala的Tuple类是一种类型安全的方法，用于传递封装其他值的单个对象，而无需创建特定于应用程序的一次性使用的“持有人” bean。Reactor将此功能整合到自己对<code>Tuple</code>类。</p><p>元组非常易于使用。您使用创建一个<code>Tuple.from(T1, T2, …)</code>方法，您可以使用<code>Tuple.getT1()</code>至<code>Tuple.getTN()</code>方法。</p>
<pre><code class="prettyprint java">reactor.on($(&quot;topic&quot;), new Consumer&lt;Event&lt;Tuple2&lt;URI, Buffer&gt;&gt;&gt;() {
  public void accept(Event&lt;Tuple2&lt;URI, Buffer&gt;&gt; ev) {
    URI uri = tup.getT1();
    Buffer buff = tup.getT2();  
    
    // deal with request from uri.getPath()
  }
});

// notify consumers of new request
reactor.notify(&quot;topic&quot;, Event.wrap(Tuple.from(requestUri, request)));
</code></pre><p>有关所有可能性，请查阅<a href="https://reactor.github.io/docs/api/index.html?reactor/tuple/Tuple.html">Tuple API文档</a> 。</p><h3><a href="#tcpclient-and-tcpserver" class="anchor" name="tcpclient-and-tcpserver"></a> TcpClient和TcpServer</h3><p>Reactor带有功能齐全的TCP客户端和服务器抽象。它们提供了一种简便的方法来构建可支持大量客户端的基于TCP的应用程序。Reactor TCP支持中的基本抽象是通用的，可以创建多种实现以利用不同的TCP技术。但是，内置实现利用出色的<a href="http://netty.io/">Netty库</a>来执行异步IO。</p><h3><a href="#apache-licensed-with-a-friendly-community" class="anchor" name="apache-licensed-with-a-friendly-community"></a> Apache许可，具有友好的社区</h3><p>Reactor是开源的，并获得Apache许可。开发人员和用户社区只是一群普通的人，他们希望共同努力，为在JVM上构建响应式FastData应用程序奠定坚实的基础。成为我们社区的一部分，以了解有关Reactor的更多信息或通过您希望看到的任何改进做出贡献。</p><p>要快速开始使用Reactor并在各种情况下查看一些代码，请查看快速入门：</p><p><a href="https://github.com/reactor/reactor-quickstart">https://github.com/reactor/reactor-quickstart</a></p><p>或样品：</p><p><a href="https://github.com/reactor/reactor-samples">https://github.com/reactor/reactor-samples</a></p><p>要派生源代码，阅读Wiki或提出问题，请在GitHub上访问我们：</p><p><a href="https://github.com/reactor/reactor">https://github.com/reactor/reactor</a></p><p>您可以加入一个Google网上论坛来提问或以其他方式参与Reactor的讨论：</p><p><a href="https://groups.google.com/forum/#!forum/reactor-framework">https://groups.google.com/forum/#!forum/reactor-framework</a></p><p>访问要包含在项目中的Maven工件：</p>
<pre><code class="prettyprint xml">&lt;dependencies&gt;

	&lt;!-- core components --&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;org.projectreactor&lt;/groupId&gt;
		&lt;artifactId&gt;reactor-core&lt;/artifactId&gt;
		&lt;version&gt;1.0.0.RELEASE&lt;/version&gt;
	&lt;/dependency&gt;
	
	&lt;!-- groovy support --&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;org.projectreactor&lt;/groupId&gt;
		&lt;artifactId&gt;reactor-groovy&lt;/artifactId&gt;
		&lt;version&gt;1.0.0.RELEASE&lt;/version&gt;
	&lt;/dependency&gt;

	&lt;!-- tcp client/server --&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;org.projectreactor&lt;/groupId&gt;
		&lt;artifactId&gt;reactor-tcp&lt;/artifactId&gt;
		&lt;version&gt;1.0.0.RELEASE&lt;/version&gt;
	&lt;/dependency&gt;

	&lt;!-- spring support --&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;org.projectreactor&lt;/groupId&gt;
		&lt;artifactId&gt;reactor-spring&lt;/artifactId&gt;
		&lt;version&gt;1.0.0.RELEASE&lt;/version&gt;
	&lt;/dependency&gt;

&lt;/dependencies&gt;
</code></pre></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 1242;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>