<html  data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>Spring Framework 4.0 M1：WebSocket支持</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Spring Framework 4.0 M1: WebSocket Support">
<meta name="twitter:creator" content="@rstoya05" http:="" ="" blog.springsource.org="" 2013="" 05="" 21="" spring-framework-4-0-m1-3-2-3-available="" ="=">already announced and with it we’ve released early WebSocket support. Why WebSocket matters? It enables efficient, two-way communication over the web that is essential in applications where messages need to be exchanged between client (typically browser) and server at high frequency and with low latency. Common examples include trading, games, collaboration, data visualization, and others but the range of scenarios and use cases will grow over time.
" > <meta>
<meta name="twitter:image:src" content="https://gravatar.com/avatar/4b12b9c0c665bc0345467c1a218ed0f7?s=200">

<meta property="og:title" content="Spring Framework 4.0 M1: WebSocket Support">
<meta property="og:image" content="https://gravatar.com/avatar/4b12b9c0c665bc0345467c1a218ed0f7?s=200">
<meta property="og:type" content="article" http:="" ="" blog.springsource.org="" 2013="" 05="" 21="" spring-framework-4-0-m1-3-2-3-available="" ="=">already announced and with it we’ve released early WebSocket support. Why WebSocket matters? It enables efficient, two-way communication over the web that is essential in applications where messages need to be exchanged between client (typically browser) and server at high frequency and with low latency. Common examples include trading, games, collaboration, data visualization, and others but the range of scenarios and use cases will grow over time.
" > <meta>
<meta property="og:article:published_time" content="2013-05-23 02:38:00.0">
</head>
<body >

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Spring Framework 4.0 M1：WebSocket支持</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/4b12b9c0c665bc0345467c1a218ed0f7?s=20&d=mm"> <a class="author" rel="author" href="/team/rstoyanchev">罗森·斯托扬切夫（Rossen Stoyanchev）</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2013-05-23 02:38:00.0">2013年5月23日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2013/05/23/spring-framework-4-0-m1-websocket-support#disqus_thread" data-disqus-identifier="521">
</a></div>
</div>
</header>
<div class="blog--post"><p>如您所见，Spring Framework 4.0的第一个里程碑<a href="http://blog.springsource.org/2013/05/21/spring-framework-4-0-m1-3-2-3-available/">已经宣布</a> ，并且我们已经发布了早期的WebSocket支持。为什么WebSocket很重要？它支持通过Web进行高效的双向通信，这对于需要在客户端（通常是浏览器）和服务器之间以高频率且低延迟地交换消息的应用程序至关重要。常见的示例包括交易，游戏，协作，数据可视化等，但是场景和用例的范围会随着时间而增长。</p><p>WebSocket是一个非常广泛的主题！您可以观看SpringOne 2012上InfoQ上的<a href="http://www.infoq.com/presentations/Introduction-WebSocket">“ WebSocket简介”</a> ，以获取更全面的介绍。简单地说，就是能够使用WebSocket只是一个开始。对于尚不支持它的浏览器（例如IE <10）以及阻止其使用的网络代理，您将需要一个后备策略。此外，对套接字进行编程非常低级。大多数应用程序将从更高级别的编程模型中受益。WebSocket协议也通过一种机制来确认这一点，该机制支持使用“子协议”（即更高级别的协议），就像今天我们都使用HTTP而不是原始TCP套接字一样。子协议示例包括<a href="https://stomp.github.io/">STOMP</a> ， <a href="http://wamp.ws/">WAMP</a>和许多其他子协议。</p><p>请记住，这是一个早期版本。它侧重于基础知识，包括JSR-356支持和供浏览器使用的后备选项。尚无子协议支持。这是下一个里程碑版本的目标。</p><p><strong>WebSocket的Java API（JSR-356）</strong></p><p>用于WebSocket的Java API最近完成，并且是Java EE 7的一部分。它定义了两种端点–的子类<code>Endpoint</code>以及带注释的端点，即<code>@ClientEndpoint</code>和<code>@ServerEndpoint</code> 。适当的介绍超出了本文的范围。我只会提到了解如何在Spring应用程序中配置和使用端点所需的最低要求。</p><p>在JSR-356中有两种部署服务器端点的方法-通过Servlet容器扫描（Servlet 3.0功能）和在启动时以编程方式进行。对于Servlet容器扫描，该规范要求带注释的端点具有默认构造函数。但是，端点子类无法自动部署。相反，Servlet容器扫描会检测到<code>ServerApplicationConfig</code>预计将提供的类型<code>Server/ClientEndpointConfig</code>每一个<code>Endpoint</code> 。</p><p>在尝试理解所有这些之前，您可能想知道的是它与Spring应用程序的关系。M1版本提供了对通过Spring初始化这两种端点的全面支持，包括适当的构造函数依赖项注入以及每个连接和单例端点生命周期。此外，您应该能够关闭Servlet容器扫描，该扫描相当重，可以扫描所有类，包括第三方依赖性。</p><p><em>给我看看代码！</em></p><p>要使用Spring初始化带注释的端点，只需配置一个<code>SpringConfigurator</code>在类型级别的注释中：</p>
<pre><code class="prettyprint java"><br />import javax.websocket.server.ServerEndpoint;
import org.springframework.web.socket.server.endpoint.SpringConfigurator;


@ServerEndpoint(value = &quot;/echo&quot;, configurator = SpringConfigurator.class)
public class EchoEndpoint {

  private final EchoService echoService;

  @Autowired
  public EchoEndpoint(EchoService echoService) {
    this.echoService = echoService;
  }

  @OnMessage
  public void handleMessage(Session session, String message) {
    // ...
  }

}
</code></pre><p>上面的代码确实假设<code>SpringContextLoaderListener</code>用于加载Spring配置，但在Web应用程序中通常是这种情况。除此之外，不需要任何其他操作。Servlet容器扫描找到带注释的端点，然后<code>SpringConfigurator</code>在每个WebSocket会话中初始化一个新实例，这也是规范中定义的默认生命周期。</p><p>如果要使用单个实例或要关闭Servlet容器扫描，请声明<code>EchoEndpoint</code>作为Spring bean，并添加一个（一次！）的Bean声明<code>ServerEndpointExporter</code> 。下面的示例使用<a href="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html">Spring的Java配置，</a>但是您也可以在基于XML的配置中添加等效的声明：</p>
<pre><code class="prettyprint java"><br />import org.springframework.web.socket.server.endpoint.ServerEndpointExporter;


@Configuration
public class EndpointConfig {

  @Bean
  public EchoEndpoint echoEndpoint() {
    return new EchoEndpoint(echoService());
  }

  @Bean
  public EchoService echoService() {
    // ...
  }

  @Bean
  public ServerEndpointExporter endpointExporter() {
    return new ServerEndpointExporter();
  }

}
</code></pre><p>端点子类可以通过以下方式部署<code>EndpointRegistration</code> （一次！）声明<code>ServerEndpointExporter</code> ：</p>
<pre><code class="prettyprint java"><br />import org.springframework.web.socket.server.endpoint.ServerEndpointExporter;
import org.springframework.web.socket.server.endpoint.ServerEndpointRegistration;


@Configuration
public class EndpointConfig {

  @Bean
  public EndpointRegistration echoEndpoint() {
    return new EndpointRegistration(&quot;/echo&quot;, EchoEndpoint.class);
  }

  @Bean
  public ServerEndpointExporter endpointExporter() {
    return new ServerEndpointExporter();
  }

  // ..

}
</code></pre><p><code>EndpointRegistration</code>还有一个接受端点实例的构造函数。这使您可以选择在每个WebSocket会话有一个新实例还是为所有会话提供一个实例。</p><p><em>客户端呢？</em></p><p>JSR-356提供以下用于连接服务器的API：</p>
<pre><code class="prettyprint java"><br />WebSocketContainer container = ContainerProvider.getWebSocketContainer();
container.connectToServer(EchoEndpoint.class, new URI(&quot;ws:localhost:8080/webapp/echo&quot;));
</code></pre><p>这很简单，但是如果我们也可以声明的话，那就太好了。一个常见的用例是–每当Web应用程序启动时，它应自动连接到远程端点，开始处理消息并在应用程序关闭时停止。</p><p>您可以使用如下所示的连接管理器来执行此操作，如下所示，分别在刷新或关闭Spring ApplicationContext时建立和关闭WebSocket连接：</p>
<pre><code class="prettyprint java"><br />import org.springframework.web.socket.client.endpoint.AnnotatedEndpointConnectionManager;


@Configuration
public class EndpointConfig {

  // For Endpoint sub-classes use EndpointConnectionManager instead

  @Bean
  public AnnotatedEndpointConnectionManager connectionManager() {
    return new AnnotatedEndpointConnectionManager(echoEndpoint(), &quot;ws://localhost:8080/webapp/echo&quot;);
  }

  @Bean
  public EchoEndpoint echoEndpoint() {
    // ...
  }

}
</code></pre><p>您也可以使用<code>autoStartup</code>属性以启用/禁用自动连接。如果禁用，则可以手动调用<code>start()</code>和<code>stop()</code> 。</p><p>总结了JSR-356支持概述。</p><p><strong>Spring WebSocket API</strong></p><p>除了对JSR-356的支持之外，该版本还提供了Spring WebSocket API的开始，这引发了一些明显的问题。</p><p>为什么要使用我们自己的API？我们在内部将其用作更高级别服务（例如SockJS）的基础。它允许我们插入其他Java WebSocket实现，并在可能的地方添加其他功能。例如，JSR-356没有提供从现有Servlet启动WebSocket握手的方法，我们发现在添加SockJS支持时这非常有用。此外，尽管Jetty尚未提供JSR-356支持，但我们能够插入（所有新的）Jetty 9 WebSocket API，并在此发行版中包含Jetty 9支持。我们可能会继续坚持直接使用Jetty 9 API，因为它提供了更丰富的WebSocket配置和处理选项集，并且与Java WebSocket API相比，更新频率可能更高。</p><p>为什么仅基于类型（即没有注释）？Spring WebSocket API主要针对框架使用。应用程序当然可以使用它，但是我们认为对套接字进行编程对于大多数应用程序来说太低了，无法组织其逻辑并提供可靠的消息处理。为了更好地理解这一点，请考虑：如果应用程序公开单个WebSocket连接（在大多数情况下应该如此），则它必须处理单个类中的所有应用程序消息类型。即使注释无法适应实际应用的复杂性。想象一下，REST没有名词（URL）和动词（HTTP方法），只是一个原始套接字。这就是为什么子协议支持和更高级别的编程模型非常重要的原因，而这正是我们更可能带有注释的地方。</p><p>希望能解决“为什么”的问题。现在，让我们看一些代码。</p><p>Spring WebSocket API的中央接口是<code>WebSocketHandler</code> 。下面是它的一种处理文本消息的实现，其中基类具有空方法，除了通过关闭协议中定义的状态为1003（不可接受）的会话拒绝二进制消息外：</p>
<pre><code class="prettyprint java"><br />import org.springframework.web.socket.adapter.TextWebSocketHandlerAdapter;


public class EchoHandler extends TextWebSocketHandlerAdapter {

  @Override
  public void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
    session.sendMessage(message);
  }

}
</code></pre><p>注意<code>handleTextMessage</code>允许异常传播。这与JSR-356有所不同。如果Exception（或Throwable）对方法进行转义，则会话将自动关闭，状态为1011（服务器错误）。这意味着，如果有任何有意义的事情可以处理，您可以选择处理该异常，否则可以采用默认方式对其进行处理。默认异常处理是通过<code>WebSocketHandlerDecorator</code>机制。可以扩展和/或替换。这些只是拥有自己的API使我们能够执行的操作的几个示例。</p><p>一种<code>WebSocketHandler</code>处理程序可以通过以下方式插入Spring MVC <code>WebSocketHttpRequestHandler</code> ：</p>
<pre><code class="prettyprint java"><br />import org.springframework.web.socket.server.support.WebSocketHttpRequestHandler;


@Configuration
public class WebConfig {

  @Bean
  public SimpleUrlHandlerMapping handlerMapping() {

    Map&lt;String, Object&gt; urlMap = new HashMap&lt;String, Object&gt;();
    urlMap.put(&quot;/echo&quot;, new WebSocketHttpRequestHandler(new EchoHandler()));

    SimpleUrlHandlerMapping hm = new SimpleUrlHandlerMapping();
    hm.setUrlMap(urlMap);
    return hm;
  }

}
</code></pre><p><strong>SockJS后备选项</strong></p><p>SockJS是一个浏览器JavaScript库，提供了类似WebSocket的编程模型和一系列特定于浏览器的传输方式，如果浏览器不支持WebSocket或<a href="http://www.infoq.com/articles/Web-Sockets-Proxy-Servers">网络问题</a>阻止了其使用，则可以使用这些传输方式。我们很高兴在此版本中宣布SockJS支持。有关SockJS和各种传输选项的更多详细信息，请访问<a href="https://github.com/sockjs/sockjs-client">sockjs-client</a>项目页面。</p><p>要启用SockJS支持，只需声明一个<code>SockJsService</code> ，将其映射到某个网址，并提供<code>WebSocketHandler</code>用于处理传入的消息。请注意<code>WebSocketHandler</code>与上面讨论的处理程序相同。换句话说，当使用SockJS时，编程模型保持不变，但是基础传输可能会更改为HTTP流，长轮询或其他必要的东西。</p>
<pre><code class="prettyprint java"><br />import org.springframework.web.socket.sockjs.SockJsService;
// ...


@Configuration
public class WebConfig {

  @Bean
  public SimpleUrlHandlerMapping handlerMapping() {

    SockJsService sockJsService = new DefaultSockJsService(taskScheduler());

    Map&lt;String, Object&gt; urlMap = new HashMap&lt;String, Object&gt;();
    urlMap.put(&quot;/echo/**&quot;, new SockJsHttpRequestHandler(sockJsService, new EchoHandler()));

    SimpleUrlHandlerMapping hm = new SimpleUrlHandlerMapping();
    hm.setUrlMap(urlMap);
    return hm;
  }

  @Bean
  public ThreadPoolTaskScheduler taskScheduler() {
    ThreadPoolTaskScheduler taskScheduler = new ThreadPoolTaskScheduler();
    taskScheduler.setThreadNamePrefix(&quot;SockJS-&quot;);
    return taskScheduler;
  }

}
</code></pre><p>如果您想知道上面的任务计划程序用于各种与SockJS相关的任务，例如在HTTP流请求上发送定期心跳消息（以防止代理认为连接过时），删除过期的SockJS会话等。</p><p><strong>收盘时</strong></p><p><a href="https://github.com/rstoyanchev/spring-websocket-test">在Github上</a>可以<a href="https://github.com/rstoyanchev/spring-websocket-test">找到</a>一个包含示例和说明的项目。它包括配置JSR-356端点，Spring WebSocketHandler以及SockJS服务的示例。对于所有示例，我建议使用Google Chrome开发人员工具的“网络”标签，以观察WebSocket和HTTP流量，观察错误等。</p><p>如果您有反馈或意见，我们很乐意听到！</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 521;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>