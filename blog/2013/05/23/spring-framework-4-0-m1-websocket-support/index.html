<!DOCTYPE html>
<html data-code-prettify="" data-mobile-support="" data-search="">
<head>
<title>Spring Framework 4.0 M1: WebSocket Support</title>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no" id="Viewport" name="viewport" />
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png" />
<link href="https://fonts.googleapis.com/css?family=Varela+Round|Montserrat:400,700" rel="stylesheet" type="text/css" />
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css" />
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M" name="google-site-verification" />

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css" />

<meta content="summary" name="twitter:card" />
<meta content="@springcentral" name="twitter:site" />
<meta name="twitter:title" content="Spring Framework 4.0 M1: WebSocket Support" />
<meta name="twitter:description" content="&lt;p&gt;As you may have seen, the first milestone of Spring Framework 4.0 was &lt;a href=&quot;http://blog.springsource.org/2013/05/21/spring-framework-4-0-m1-3-2-3-available/&quot;&gt;already announced&lt;/a&gt; and with it we’ve released early WebSocket support. Why WebSocket matters? It enables efficient, two-way communication over the web that is essential in applications where messages need to be exchanged between client (typically browser) and server at high frequency and with low latency. Common examples include trading, games, collaboration, data visualization, and others but the range of scenarios and use cases will grow over time.&lt;/p&gt;
" />
<meta name="twitter:creator" content="@rstoya05" />
<meta name="twitter:image:src" content="https://gravatar.com/avatar/4b12b9c0c665bc0345467c1a218ed0f7?s=200" />

<meta property="og:title" content="Spring Framework 4.0 M1: WebSocket Support" />
<meta property="og:image" content="https://gravatar.com/avatar/4b12b9c0c665bc0345467c1a218ed0f7?s=200" />
<meta property="og:description" content="&lt;p&gt;As you may have seen, the first milestone of Spring Framework 4.0 was &lt;a href=&quot;http://blog.springsource.org/2013/05/21/spring-framework-4-0-m1-3-2-3-available/&quot;&gt;already announced&lt;/a&gt; and with it we’ve released early WebSocket support. Why WebSocket matters? It enables efficient, two-way communication over the web that is essential in applications where messages need to be exchanged between client (typically browser) and server at high frequency and with low latency. Common examples include trading, games, collaboration, data visualization, and others but the range of scenarios and use cases will grow over time.&lt;/p&gt;
" />
<meta content="article" property="og:type" />
<meta property="og:article:published_time" content="2013-05-23 02:38:00.0" />
</head>
<body>

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" style="display:none;visibility:hidden" width="0"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">Projects</a>
</li>
<li class="navbar-link">
<a href="/guides">Guides</a>
</li>
<li class="navbar-link active">
<a href="/blog">Blog</a>
</li>
<li class="navbar-link">
<a href="/services">Training & Certification</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form action="/search" class="form-inline form-search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search for documentation, guides, and posts..." type="text" value="" />
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form action="/search" class="form-inline form-search" method="get">
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search..." type="text" value="" />
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">
Home
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">
Projects
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">
Guides
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">
Blog
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">
Training & Certification
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>Engineering</div>
</div>
<div class="blog-category content--title">
<div>Releases</div>
</div>
<div class="blog-category content--title">
<div>News and Events</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Spring Framework 4.0 M1: WebSocket Support</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">Engineering</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/4b12b9c0c665bc0345467c1a218ed0f7?s=20&amp;d=mm" />
<a class="author" rel="author" href="/team/rstoyanchev">Rossen Stoyanchev</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2013-05-23 02:38:00.0">May 23, 2013</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" data-disqus-identifier="521" href="/blog/2013/05/23/spring-framework-4-0-m1-websocket-support#disqus_thread">
</a></div>
</div>
</header>
<div class="blog--post"><p>As you may have seen, the first milestone of Spring Framework 4.0 was <a href="http://blog.springsource.org/2013/05/21/spring-framework-4-0-m1-3-2-3-available/">already announced</a> and with it we&rsquo;ve released early WebSocket support. Why WebSocket matters? It enables efficient, two-way communication over the web that is essential in applications where messages need to be exchanged between client (typically browser) and server at high frequency and with low latency. Common examples include trading, games, collaboration, data visualization, and others but the range of scenarios and use cases will grow over time.</p><p>WebSocket is a very broad subject! You can watch our <a href="http://www.infoq.com/presentations/Introduction-WebSocket">“Intro to WebSocket”</a> on InfoQ from SpringOne 2012 for a more thorough introduction. To put it simply being able to use a WebSocket is only the start. You&rsquo;ll need a fallback strategy for browsers that don&rsquo;t support it yet (e.g. IE &lt; 10) and for network proxies that preclude its use. Furthermore, programming to a socket is very, very low level. Most applications will benefit from a higher level programming model. This is also acknowledged in the WebSocket protocol through a mechanism that enables the use of a “sub-protocol” (i.e. a higher level protocol) much like today we all use HTTP, not a raw TCP socket. Example sub-protocols include <a href="https://stomp.github.io/">STOMP</a>, <a href="http://wamp.ws/">WAMP</a>, and many others.</p><p>Keep in mind that this is an early release. It focuses on fundamentals including JSR-356 support and fallback options for use within browsers. There is no sub-protocol support yet. That is the goal of the next milestone release.</p><p><strong>Java API for WebSocket (JSR-356)</strong></p><p>The Java API for WebSocket was recently finalized and is part of Java EE 7. It defines two kinds of endpoints &ndash; sub-classes of <code>Endpoint</code> as well as annotated endpoints, i.e. <code>@ClientEndpoint</code> and <code>@ServerEndpoint</code>. A proper introduction is beyond the scope of this post. I will only mention the minimum needed to understand how to configure and use endpoints in a Spring application.</p><p>There are two ways to deploy server endpoints in JSR-356 &ndash; through a Servlet container scan (Servlet 3.0 feature) and programmatically at startup. For the Servlet container scan, the spec requires annotated endpoints to have a default constructor. Endpoint sub-classes however cannot be deployed automatically. Instead the Servlet container scan detects <code>ServerApplicationConfig</code> types that in turn are expected to supply <code>Server/ClientEndpointConfig</code> for every <code>Endpoint</code>.</p><p>Before you try to make sense of all this, what you probably want to know is how it relates to your Spring application. The M1 release provides full support for initializing both kinds of endpoints through Spring including proper constructor dependency injection as well as per-connection and singleton endpoint lifecycle. Furthermore, you should be able to turn off the Servlet container scan, which is rather heavyweight and scans all classes including 3rd party dependencies.</p><p><em>Show me the code!</em></p><p>To initialize an annotated endpoint with Spring, simply configure a <code>SpringConfigurator</code> in the type-level annotation:</p>
<pre><code class="prettyprint java"><br />import javax.websocket.server.ServerEndpoint;
import org.springframework.web.socket.server.endpoint.SpringConfigurator;


@ServerEndpoint(value = &quot;/echo&quot;, configurator = SpringConfigurator.class)
public class EchoEndpoint {

  private final EchoService echoService;

  @Autowired
  public EchoEndpoint(EchoService echoService) {
    this.echoService = echoService;
  }

  @OnMessage
  public void handleMessage(Session session, String message) {
    // ...
  }

}
</code></pre><p>The above code does assume that <code>SpringContextLoaderListener</code> is used to load Spring configuration but that is typically the case in web applications. Apart from that nothing further is required. The Servlet container scan finds the annotated endpoint and <code>SpringConfigurator</code> initializes a new instance per WebSocket session, which is also the default lifecycle defined in the spec.</p><p>If you want to use a single instance or want to turn off the Servlet container scan, declare <code>EchoEndpoint</code> as a Spring bean and also add a (one time!) bean declaration for <code>ServerEndpointExporter</code>. The example below uses <a href="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html">Spring’s Java Configuration</a> but you could also add equivalent declarations to XML-based configuration:</p>
<pre><code class="prettyprint java"><br />import org.springframework.web.socket.server.endpoint.ServerEndpointExporter;


@Configuration
public class EndpointConfig {

  @Bean
  public EchoEndpoint echoEndpoint() {
    return new EchoEndpoint(echoService());
  }

  @Bean
  public EchoService echoService() {
    // ...
  }

  @Bean
  public ServerEndpointExporter endpointExporter() {
    return new ServerEndpointExporter();
  }

}
</code></pre><p>Endpoint sub-classes can be deployed via <code>EndpointRegistration</code> along with a (one time!) declaration of <code>ServerEndpointExporter</code>:</p>
<pre><code class="prettyprint java"><br />import org.springframework.web.socket.server.endpoint.ServerEndpointExporter;
import org.springframework.web.socket.server.endpoint.ServerEndpointRegistration;


@Configuration
public class EndpointConfig {

  @Bean
  public EndpointRegistration echoEndpoint() {
    return new EndpointRegistration(&quot;/echo&quot;, EchoEndpoint.class);
  }

  @Bean
  public ServerEndpointExporter endpointExporter() {
    return new ServerEndpointExporter();
  }

  // ..

}
</code></pre><p><code>EndpointRegistration</code> also has a constructor accepting an endpoint instance. This allows you to choose between having a new instance per WebSocket session or a single instance serving all sessions.</p><p><em>What about the client side?</em></p><p>JSR-356 provides the following API for connecting to servers:</p>
<pre><code class="prettyprint java"><br />WebSocketContainer container = ContainerProvider.getWebSocketContainer();
container.connectToServer(EchoEndpoint.class, new URI(&quot;ws:localhost:8080/webapp/echo&quot;));
</code></pre><p>This is simple enough but it would be nice if we could also make it declarative. A common use case is &ndash; whenever the web application starts, it should automatically connect to a remote endpoint, start processing messages and stop when the application shuts down.</p><p>You can do that with a connection manager as shown below where the WebSocket connection is established and closed when the Spring ApplicationContext is refreshed or closed respectively:</p>
<pre><code class="prettyprint java"><br />import org.springframework.web.socket.client.endpoint.AnnotatedEndpointConnectionManager;


@Configuration
public class EndpointConfig {

  // For Endpoint sub-classes use EndpointConnectionManager instead

  @Bean
  public AnnotatedEndpointConnectionManager connectionManager() {
    return new AnnotatedEndpointConnectionManager(echoEndpoint(), &quot;ws://localhost:8080/webapp/echo&quot;);
  }

  @Bean
  public EchoEndpoint echoEndpoint() {
    // ...
  }

}
</code></pre><p>You can also use the <code>autoStartup</code> property to enable/disable automatic connection. If disabled, you can manually invoke <code>start()</code> and <code>stop()</code>.</p><p>This concludes the JSR-356 support overview.</p><p><strong>Spring WebSocket API</strong></p><p>In addition to JSR-356 support, this release provides the beginnings of a Spring WebSocket API which leads to some obvious questions.</p><p>Why our own API? We use it internally as the basis for higher-level services such as SockJS. It allows us to plug additional Java WebSocket implementations and add additional features where possible. JSR-356 for example does not provide a way to initiate a WebSocket handshake from an existing Servlet, which we found very useful when adding SockJS support. Furthermore although Jetty does not yet provide JSR-356 support, we were able to plug the (all new) Jetty 9 WebSocket API and include Jetty 9 support in this release. We may stick to using the Jetty 9 API directly going forward since it provides a richer set of WebSocket configuration and processing options and is likely to be updated much more often than the Java API for WebSocket.</p><p>Why type-based only (i.e. no annotations)? The Spring WebSocket API targets framework use primarily. Applications can use it of course but we believe programming to a socket is too low level for most applications to organize their logic and provide robust message handling. To better appreciate this point, consider that if an application exposes a single WebSocket connection (as it should in most cases) it would have to deal with all application message types from a single class. Even with annotations that doesn&rsquo;t scale to the complexity of real-world applications. Imagine REST without the nouns (URLs) and the verbs (HTTP methods), just a raw socket. This is why sub-protocol support and a higher level programming model are pretty essential and that&rsquo;s where we&rsquo;re more likely to have annotations.</p><p>Hopefully that takes care of the “why” questions. Now let’s see some code.</p><p>The central interface in the Spring WebSocket API is <code>WebSocketHandler</code>. Below is an implementation of it for processing text messages where the base class has empty methods except for rejecting binary messages by closing the session with status 1003 (not acceptable) as defined in the protocol:</p>
<pre><code class="prettyprint java"><br />import org.springframework.web.socket.adapter.TextWebSocketHandlerAdapter;


public class EchoHandler extends TextWebSocketHandlerAdapter {

  @Override
  public void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
    session.sendMessage(message);
  }

}
</code></pre><p>Note that <code>handleTextMessage</code> allows Exception propagation. This is different from JSR-356, which doesn&rsquo;t. If an Exception (or Throwable) escapes the method, the session is automatically closed with status 1011 (server error). That means you can choose to deal with the exception, if there is anything meaningful to do about it, or otherwise let it be dealt with in a default manner. Default exception handling is provided through a <code>WebSocketHandlerDecorator</code> mechanism. It can be extended and/or replaced. These are just a couple of examples of what having our own API enables us to do.</p><p>A <code>WebSocketHandler</code> handler can be plugged into Spring MVC via <code>WebSocketHttpRequestHandler</code>:</p>
<pre><code class="prettyprint java"><br />import org.springframework.web.socket.server.support.WebSocketHttpRequestHandler;


@Configuration
public class WebConfig {

  @Bean
  public SimpleUrlHandlerMapping handlerMapping() {

    Map&lt;String, Object&gt; urlMap = new HashMap&lt;String, Object&gt;();
    urlMap.put(&quot;/echo&quot;, new WebSocketHttpRequestHandler(new EchoHandler()));

    SimpleUrlHandlerMapping hm = new SimpleUrlHandlerMapping();
    hm.setUrlMap(urlMap);
    return hm;
  }

}
</code></pre><p><strong>SockJS Fallback Options</strong></p><p>SockJS is a browser JavaScript library that provides a WebSocket-like programming model and a range of browser-specific transports that can be used if WebSocket is not supported in the browser, or <a href="http://www.infoq.com/articles/Web-Sockets-Proxy-Servers">network issues</a> preclude its use. We are pleased to announce SockJS support in this release. For more details on SockJS and the various transport options, visit the <a href="https://github.com/sockjs/sockjs-client">sockjs-client</a> project page.</p><p>To enable SockJS support, simply declare a <code>SockJsService</code>, map it to some URL, and provide a <code>WebSocketHandler</code> for handling incoming messages. Note that the <code>WebSocketHandler</code> is the same handler discussed above. In other words when using SockJS, the programming model remains the same but the underlying transport may change to HTTP streaming, long polling, or something else as necessary.</p>
<pre><code class="prettyprint java"><br />import org.springframework.web.socket.sockjs.SockJsService;
// ...


@Configuration
public class WebConfig {

  @Bean
  public SimpleUrlHandlerMapping handlerMapping() {

    SockJsService sockJsService = new DefaultSockJsService(taskScheduler());

    Map&lt;String, Object&gt; urlMap = new HashMap&lt;String, Object&gt;();
    urlMap.put(&quot;/echo/**&quot;, new SockJsHttpRequestHandler(sockJsService, new EchoHandler()));

    SimpleUrlHandlerMapping hm = new SimpleUrlHandlerMapping();
    hm.setUrlMap(urlMap);
    return hm;
  }

  @Bean
  public ThreadPoolTaskScheduler taskScheduler() {
    ThreadPoolTaskScheduler taskScheduler = new ThreadPoolTaskScheduler();
    taskScheduler.setThreadNamePrefix(&quot;SockJS-&quot;);
    return taskScheduler;
  }

}
</code></pre><p>In case you&rsquo;re wondering the task scheduler above is used for various SockJS-related tasks such as sending periodic heartbeat messages on HTTP streaming requests (to prevent proxies from thinking the connection is stale), removing expired SockJS sessions, etc.</p><p><strong>In Closing</strong></p><p>A project with samples and instructions can be <a href="https://github.com/rstoyanchev/spring-websocket-test">found on Github</a>. It includes examples of configuring JSR-356 endpoints, Spring WebSocketHandler, as well as a SockJS service. For all examples I recommend using the Network tab of Google Chrome&rsquo;s developer tools in order to watch WebSocket and HTTP traffic, observe errors, etc.</p><p>If you have feedback or comments we&rsquo;d love to hear it!</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 521;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>
Back
</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">All Posts</a>
<a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">Engineering</a>
<a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">Releases</a>
<a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">News and Events</a>
<a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>Get updates from The Spring Team delivered to your inbox</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">Tools</a></li>
<li><a href="https://store.pivotal.io/">Store</a></li>
<li><a href="/blog">Newsletter</a></li>
</ul>
</div>
</div>
&copy; <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a>, Inc. All Rights Reserved.
<a href="https://pivotal.io/terms-of-use">Terms of Use</a> &bullet;
<a href="https://pivotal.io/privacy-policy">Privacy</a> &bullet;
<a href="/trademarks">Trademark Guidelines</a>
<div id="teconsent" style="display:inline-block;"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>