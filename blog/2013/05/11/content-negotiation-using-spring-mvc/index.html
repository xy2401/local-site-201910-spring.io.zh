<html dir="ltr" data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>使用Spring MVC进行内容协商</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>System.config({baseURL: "/b92013b"});</script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>System.import('app/main.js')</script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Content Negotiation using Spring MVC">
<meta name="twitter:description" content="<p>There are two ways to generate output using Spring MVC:</p>
<ul> 
 <li> You can use the RESTful <code style=" font-size:="" 100%;="" color:="" black="="></head><body dir="ltr">@ResponseBody approach and HTTP message converters, typically to return data-formats like JSON or XML. Programmatic clients, mobile apps and AJAX enabled browsers are the usual clients. 
 <li>Alternatively you may use <em>view resolution</em>. Although views are perfectly capable of generating JSON and XML if you wish (more on that in my next post), views are normally used to generate presentation formats like HTML for a traditional web-application. </li>
 <li>Actually there is a third possibility - some applications require both, and Spring MVC supports such combinations easily. We will come back to that right at the end. </li>

">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/0b0bedf6c0dab07b13a322eed9350873?s=200">

<meta property="og:title" content="Content Negotiation using Spring MVC">
<meta property="og:image" content="https://gravatar.com/avatar/0b0bedf6c0dab07b13a322eed9350873?s=200">
<meta property="og:description" content="<p>There are two ways to generate output using Spring MVC:</p>
<ul> 
 <li> You can use the RESTful <code style=" font-size:="" 100%;="" color:="" black="=">@ResponseBody approach and HTTP message converters, typically to return data-formats like JSON or XML. Programmatic clients, mobile apps and AJAX enabled browsers are the usual clients. 
 <li>Alternatively you may use <em>view resolution</em>. Although views are perfectly capable of generating JSON and XML if you wish (more on that in my next post), views are normally used to generate presentation formats like HTML for a traditional web-application. </li>
 <li>Actually there is a third possibility - some applications require both, and Spring MVC supports such combinations easily. We will come back to that right at the end. </li>

">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2013-05-11 12:54:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">// Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }</script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">使用Spring MVC进行内容协商</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/0b0bedf6c0dab07b13a322eed9350873?s=20&d=mm"> <span class="author">保罗·查普曼</span>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2013-05-11 12:54:00.0">2013年5月11日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2013/05/11/content-negotiation-using-spring-mvc#disqus_thread" data-disqus-identifier="517">
</a></div>
</div>
</header>
<div class="blog--post"><p>有两种使用Spring MVC生成输出的方法：</p>
<ul>
<li>您可以使用RESTful <code style="font-size:100%;color:black">@ResponseBody</code>方法和HTTP消息转换器，通常返回JSON或XML之类的数据格式。程序客户端，移动应用程序和支持AJAX的浏览器是常见的客户端。
</li><li>或者，您可以使用<em>视图分辨率</em> 。尽管如果您愿意，视图完全可以生成JSON和XML（在我的下一篇文章中有更多介绍），但是视图通常用于生成表示形式的格式，例如用于传统Web应用程序的HTML。
</li><li>实际上，存在第三种可能性-有些应用程序同时需要这两者，并且Spring MVC轻松支持这种组合。最后我们将回到正确的位置。
</li></ul><p>无论哪种情况，您都需要处理控制器返回的相同数据的多种表示形式（或视图）。计算出要返回的数据格式称为“ <em>内容协商”</em> 。</p><p>在三种情况下，我们需要知道在HTTP响应中发送哪种类型的数据格式：</p>
<ul>
<li><strong>HttpMessageConverters：</strong>确定要使用的正确转换器。</li>
<li><strong>请求映射：</strong>将传入的HTTP请求<strong>映射</strong>到返回不同格式的不同方法。</li>
<li><strong>视图分辨率：</strong>选择要使用的正确视图。</li>
</ul><p>确定用户请求的格式取决于<code style="font-size:100%;color:black">ContentNegotationStrategy</code> 。开箱即用有默认实现，但是您也可以根据需要实现自己的实现。</p><p>在这篇文章中，我想讨论如何使用Spring配置和使用内容协商，主要是关于使用HTTP消息转换器的RESTful控制器。在以后的<a href="http://blog.springsource.org/2013/06/03/content-negotiation-using-views/">文章中，</a>我将展示如何使用Spring的<code style="font-size:100%;color:black">ContentNegotiatingViewResolver</code>专门设置与视图一起使用的内容协商。</p>
<h2>内容协商如何工作？</h2><p><strong>[标题ID =“ attachment_13288” align =“ alignleft” width =“ 200” caption =“获取正确的内容”] <img src="http://blog.springsource.org/wp-content/uploads/2013/05/Handshake_03.png" alt="谈判" title="内容协商" width="200" class="size-full wp-image-13288"> [/字幕]</strong></p><p>通过HTTP发出请求时，可以通过设置<code style="font-size:100%;color:black">Accept</code>标头属性来指定所需的响应类型。Web浏览器具有此预设以请求HTML（除其他外）。实际上，如果您看一下，就会发现浏览器实际上发送了非常混乱的Accept标头，这使得依赖它们变得不切实际。看到<a href="http://www.gethifi.com/blog/browser-rest-http-accept-headers"></a> <a href="http://www.gethifi.com/blog/browser-rest-http-accept-headers">http://www.gethifi.com/blog/browser-rest-http-accept-headers</a>对该问题进行了很好的讨论。底线： <code style="font-size:100%;color:black">Accept</code>标头被弄乱了，您通常也不能更改它们（除非您使用JavaScript和AJAX）。</p><p>因此，对于那些不希望使用<code style="font-size:100%;color:black">Accept</code>标头属性的情况，Spring提供了一些约定来代替。（这是Spring 3.2的一项不错的更改，它使灵活的内容选择策略不仅可以在使用视图时在所有Spring MVC上使用）。您可以集中配置一次内容协商策略，该策略将在需要确定不同格式（媒体类型）的任何地方应用。</p>
<h2>在Spring MVC中启用内容协商</h2><p>Spring支持几种用于选择所需格式的约定：URL后缀和/或URL参数。这些与使用<code style="font-size:100%;color:black">Accept</code>标头一起工作。结果，可以以三种方式中的任何一种来请求内容类型。默认情况下，将按以下顺序检查它们：</p>
<ul>
<li>在URL中添加路径扩展名（后缀）。因此，如果传入的URL是<code style="font-size:100%;color:navy">http://myserver/myapp/accounts/list.html</code>则需要HTML。对于电子表格，URL应该为<code style="font-size:100%;color:navy">http://myserver/myapp/accounts/list.xls</code> 。后缀到媒体类型的映射是通过<em>JavaBeans Activation Framework</em>或JAF自动定义的（因此， <code style="font-size:100%;color:black">activation.jar</code>必须在类路径上）。</li>
<li>像这样的URL参数： <code style="font-size:100%;color:navy">http://myserver/myapp/accounts/list?format=xls</code> 。参数的名称默认为<code style="font-size:100%;color:black">format</code> ，但是可以更改。默认情况下，禁用参数使用，但启用后将对其进行第二次检查。</li>
<li>最后，检查“ <code style="font-size:100%;color:black">Accept</code> HTTP标头”属性。这实际上是定义HTTP工作的方式，但是，如前所述，使用它可能会出现问题。</li>
</ul><p>进行此设置的Java配置如下所示。只需通过其配置器自定义预定义的内容协商管理器即可。请注意， <code style="font-size:100%;color:black">MediaType</code>帮助程序类具有用于大多数知名媒体类型的预定义常量。</p>
<pre><code class="prettyprint java"><br>@Configuration
@EnableWebMvc
public class WebConfig extends WebMvcConfigurerAdapter {

  /**
    * Setup a simple strategy: use all the defaults and return XML by default when not sure. 
    */
  @Override
  public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
    configurer.defaultContentType(MediaType.APPLICATION_XML);
  }
}
</code></pre><p>使用XML配置时，最容易通过<code style="font-size:100%;color:black">ContentNegotiationManagerFactoryBean</code>设置内容协商策略：</p>
<pre><code class="prettyprint xml"><br>   <!--
        Setup a simple strategy: 
           1. Take all the defaults.
           2. Return XML by default when not sure. 
       -->
  <bean id="contentNegotiationManager"
             class="org.springframework.web.accept.ContentNegotiationManagerFactoryBean">
       <property name="defaultContentType" value="application/xml" />
  </bean>

 <!-- Make this available across all of Spring MVC -->
 <mvc:annotation-driven content-negotiation-manager="contentNegotiationManager" />
</code></pre><p>通过任一设置创建的<code style="font-size:100%;color:black">ContentNegotiationManager</code>是<code style="font-size:100%;color:black">ContentNegotationStrategy</code>的实现，该实现实现了上述的<em>PPA策略</em> （路径扩展，然后是参数，然后是接受标头）。</p>
<h2>其他配置选项</h2><p>在Java配置中，可以使用配置器上的方法对策略进行完全自定义：</p>
<pre><code class="prettyprint java"><br>@Configuration
@EnableWebMvc
public class WebConfig extends WebMvcConfigurerAdapter {

  /**
    *  Total customization - see below for explanation.
    */
  @Override
  public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
    configurer.favorPathExtension(false).
            favorParameter(true).
            parameterName("mediaType").
            ignoreAcceptHeader(true).
            useJaf(false).
            defaultContentType(MediaType.APPLICATION_JSON).
            mediaType("xml", MediaType.APPLICATION_XML).
            mediaType("json", MediaType.APPLICATION_JSON);
  }
}
</code></pre><p>在XML中，可以使用工厂bean上的方法配置策略：</p>
<pre><code class="prettyprint xml"><br><br>  <!-- Total customization - see below for explanation. -->
  <bean id="contentNegotiationManager"
             class="org.springframework.web.accept.ContentNegotiationManagerFactoryBean">
    <property name="favorPathExtension" value="false" />
    <property name="favorParameter" value="true" />
    <property name="parameterName" value="mediaType" />
    <property name="ignoreAcceptHeader" value="true"/>
    <property name="useJaf" value="false"/>
    <property name="defaultContentType" value="application/json" />
 
    <property name="mediaTypes">
        <map>
            <entry key="json" value="application/json" />
            <entry key="xml" value="application/xml" />
       </map>
    </property>
</bean>
</code></pre><p>在两种情况下，我们所做的工作：</p>
<ul>
<li>禁用路径扩展。请注意，偏爱并不意味着优先使用一种方法而不是另一种方法，它只是启用或禁用了它。检查的顺序始终是路径扩展，参数，Accept标头。</li>
<li>启用URL参数的使用，但是我们将使用<code style="font-size:100%;color:black">mediaType</code>而不是默认参数<code style="font-size:100%;color:black">format</code> 。
</li>
<li>完全忽略<code style="font-size:100%;color:black">Accept</code>标头。如果大多数客户实际上是网络浏览器（通常是通过AJAX进行REST调用），则这通常是最佳方法。
</li><li>不要使用JAF，而是手动指定媒体类型映射-我们只希望支持JSON和XML。</li></ul><p><br></p>
<h2>列出用户帐户示例</h2><p><a href="http://blog.springsource.org/wp-content/uploads/2013/05/account-list-1.png"><img class="alignright size-full wp-image-13159" title="帐户列表为HTML" src="http://blog.springsource.org/wp-content/uploads/2013/05/account-list-1.png" alt="" width="380"></a></p><p>为了进行演示，我将一个简单的帐户列表应用程序作为我们的工作示例-屏幕截图显示了HTML中的典型帐户列表。完整的代码可以在Github上找到： <a href="https://github.com/paulc4/mvc-content-neg"></a> <a href="https://github.com/paulc4/mvc-content-neg">https://github.com/paulc4/mvc-content-neg</a> 。</p><p>要以JSON或XML返回帐户列表，我需要一个类似Controller的控制器。现在，我们将忽略HTML生成方法。</p>
<p> </p>
<pre><code class="prettyprint java"><br>@Controller
class AccountController {
    @RequestMapping(value="/accounts", method=RequestMethod.GET)
    @ResponseStatus(HttpStatus.OK)
    public @ResponseBody List<Account> list(Model model, Principal principal) {
        return accountManager.getAccounts(principal) );
    }

    // Other methods ...
}
</code></pre><p>这是内容协商策略的设置：</p>
<pre><code class="prettyprint xml"><br>	<!-- Simple strategy: only path extension is taken into account -->
	<bean id="cnManager"
		class="org.springframework.web.accept.ContentNegotiationManagerFactoryBean">
		<property name="favorPathExtension" value="true"/>
		<property name="ignoreAcceptHeader" value="true" />
		<property name="defaultContentType" value="text/html" />
		<property name="useJaf" value="false"/>

		<property name="mediaTypes">
			<map>
				<entry key="html" value="text/html" />
				<entry key="json" value="application/json" />
				<entry key="xml" value="application/xml" />
			</map>
		</property>
	</bean>
</code></pre><p>或者，使用Java配置，代码如下所示：</p>
<pre><code class="prettyprint java"><br>	@Override
	public void configureContentNegotiation(
			ContentNegotiationConfigurer configurer) {
		// Simple strategy: only path extension is taken into account
		configurer.favorPathExtension(true).
			ignoreAcceptHeader(true).
			useJaf(false).
			defaultContentType(MediaType.TEXT_HTML).
			mediaType("html", MediaType.TEXT_HTML).
			mediaType("xml", MediaType.APPLICATION_XML).
			mediaType("json", MediaType.APPLICATION_JSON);
	}
</code></pre><p>如果我的类路径上有JAXB2和Jackson，Spring MVC将自动设置必要的<code style="font-size:100%;color:black">HttpMessageConverters</code> 。我的域类也必须使用JAXB2和Jacksonannotation进行标记才能启用转换（否则消息转换器不知道该怎么做）。为了回应评论（如下），带注释的<code style="font-size:100%;color:black">Account</code>类如下<a href="#annotated-account-class">所示</a> 。</p><p>这是我们的“帐户”应用程序的JSON输出（请注意URL中的path-extension）。</p><p><a href="http://blog.springsource.org/wp-content/uploads/2013/04/account-list-json.png"><img class="alignright size-full wp-image-13160" title="account-list-json" src="http://blog.springsource.org/wp-content/uploads/2013/04/account-list-json.png" alt="" width="580"></a></p><p>系统如何知道要转换为XML还是JSON？由于进行了内容协商，因此将根据<code style="font-size:100%;color:black">ContentNegotiationManager</code>的配置方式使用上面讨论的三个（ <em>PPA策略</em> ）选项中的任何一个。在这种情况下，URL结尾于<code style="font-size:100%;color:navy">accounts.json</code>因为路径扩展是唯一启用的策略。</p><p>在示例代码中，可以通过在<code style="font-size:100%;color:black">web.xml</code>设置活动配置文件在XML或MVC的Java配置之间切换。配置文件分别是“ xml”和“ javaconfig”。</p>
<h2 id="combined-controller">结合数据和演示格式</h2><p>Spring MVC的REST支持基于现有的MVC Controller框架。因此，可以使相同的Web应用程序既以原始数据（如JSON）作为返回信息，又以表示形式（如HTML）作为返回信息。</p><p>两种技术都可以在同一控制器中轻松并排使用，如下所示：</p>
<pre><code class="prettyprint java"><br>@Controller
class AccountController {
    // RESTful method
    @RequestMapping(value="/accounts", produces={"application/xml", "application/json"})
    @ResponseStatus(HttpStatus.OK)
    public @ResponseBody List<Account> listWithMarshalling(Principal principal) {
        return accountManager.getAccounts(principal);
    }

    // View-based method
    @RequestMapping("/accounts")
    public String listWithView(Model model, Principal principal) {
        // Call RESTful method to avoid repeating account lookup logic
        model.addAttribute( listWithMarshalling(principal) );

        // Return the view to use for rendering the response
        return ¨accounts/list¨;
    }
}
</code></pre><p>这里有一个简单的模式： <code style="font-size:100%;color:black">@ResponseBody</code>方法处理所有数据访问以及与基础服务层（ <code style="font-size:100%;color:black">AccountManager</code> ）的集成。第二种方法调用第一种方法，并在Model中设置响应以供View使用。这避免了重复的逻辑。</p><p>为了确定选择两种<code style="font-size:100%;color:black">@RequestMapping</code>方法中的哪一种，我们再次使用我们的PPA内容协商策略。它允许<code style="font-size:100%;color:black">produces</code>选项起作用。以<code style="font-size:100%;color:navy">accounts.xml</code>或<code style="font-size:100%;color:navy">accounts.json</code>结尾的URL映射到第一种方法，以<code style="font-size:100%;color:navy">accounts.anything</code>结尾的任何其他URL映射到第二种方法。</p>
<h2>另一种方法</h2><p>另外，如果我们使用视图来生成所有可能的内容类型，则仅用一种方法就可以完成全部操作。这是<code style="font-size:100%;color:black">ContentNegotiatingViewResolver</code>出现的地方，这将是我下一篇<a href="http://blog.springsource.org/2013/06/03/content-negotiation-using-views/">文章</a>的主题。</p>
<h2>致谢</h2><p>我要感谢<a href="/author/rstoyanchev/">Rossen Stoyanchev</a>在撰写本文中所提供的帮助。任何错误都是我自己的。</p>
<h2 id="annotated-account-class">附录：带注释的帐户类</h2><p><b>添加2013年6月2日</b> 。</p><p>由于存在一些有关如何为JAXB注释类的问题，因此这是Account类的一部分。为简洁起见，我省略了数据成员以及除带注释的getter之外的所有方法。如果愿意，我可以直接为数据成员添加注释（实际上就像JPA注释一样）。请记住，Jackson可以使用这些相同的注释将对象编组为JSON。</p>
<pre><code class="prettyprint java"><br>/**
 * Represents an account for a member of a financial institution. An account has
 * zero or more {@link Transaction}s and belongs to a {@link Customer}. An aggregate entity.
 */
@Entity
@Table(name = "T_ACCOUNT")
@XmlRootElement
public class Account {

	// data-members omitted ...

	public Account(Customer owner, String number, String type) {
		this.owner = owner;
		this.number = number;
		this.type = type;
	}

	/**
	 * Returns the number used to uniquely identify this account.
	 */
	@XmlAttribute
	public String getNumber() {
		return number;
	}

	/**
	 * Get the account type.
	 * 
	 * @return One of "CREDIT", "SAVINGS", "CHECK".
	 */
	@XmlAttribute
	public String getType() {
		return type;
	}

	/**
	 * Get the credit-card, if any, associated with this account.
	 * 
	 * @return The credit-card number or null if there isn't one.
	 */
	@XmlAttribute
	public String getCreditCardNumber() {
		return StringUtils.hasText(creditCardNumber) ? creditCardNumber : null;
	}

	/**
	 * Get the balance of this account in local currency.
	 * 
	 * @return Current account balance.
	 */
	@XmlAttribute
	public MonetaryAmount getBalance() {
		return balance;
	}


	/**
	 * Returns a single account transaction. Callers should not attempt to hold
	 * on or modify the returned object. This method should only be used
	 * transitively; for example, called to facilitate reporting or testing.
	 * 
	 * @param name
	 *            the name of the transaction account e.g "Fred Smith"
	 * @return the beneficiary object
	 */
	@XmlElement   // Make these a nested <transactions> element
	public Set<Transaction> getTransactions() {
		return transactions;
	}

    // Setters and other methods ...

}
</code></pre></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">var disqus_shortname = 'spring-io';
      var disqus_identifier = 517;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));</script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
 <div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });</script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>