<!DOCTYPE html>
<html data-code-prettify="" data-mobile-support="" data-search="">
<head>
<title>Content Negotiation using Views</title>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no" id="Viewport" name="viewport" />
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png" />
<link href="https://fonts.googleapis.com/css?family=Varela+Round|Montserrat:400,700" rel="stylesheet" type="text/css" />
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css" />
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M" name="google-site-verification" />

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css" />

<meta content="summary" name="twitter:card" />
<meta content="@springcentral" name="twitter:site" />
<meta name="twitter:title" content="Content Negotiation using Views" />
<meta name="twitter:description" content="&lt;p&gt;In my previous &lt;a href=&quot;http://blog.springsource.org/2013/05/11/content-negotiation-using-spring-mvc/&quot;&gt;post&lt;/a&gt; I introduced the concept of content negotiation and the three strategies Spring MVC uses to determine the content requested.&lt;/p&gt;
&lt;p&gt;In this post I want to extend the concept specifically to supporting multiple views for different content-types using the &lt;code style=&quot;font-size:100%; color:black&quot;&gt;ContentNegotiatingViewResolver&lt;/code&gt; (or CNVR).&lt;/p&gt;
&lt;h2&gt;Quick Overview&lt;/h2&gt;
&lt;p&gt;Since we already know how to setup content-negotiation from the previous &lt;a href=&quot;http://blog.springsource.org/2013/05/11/content-negotiation-using-spring-mvc/&quot;&gt;post&lt;/a&gt;, using it to select between multiple views is very straightforward. Simply define a CNVR like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint xml&quot;&gt;&lt;br&gt;    &amp;lt;!--
      // View resolver that delegates to other view resolvers based on the
      // content type
      --&amp;gt;
    &amp;lt;bean class=&quot;org.springframework.web.servlet.view.
                                           ContentNegotiatingViewResolver&quot;&amp;gt;
       &amp;lt;!-- All configuration now done by manager - since Spring V3.2 --&amp;gt;
       &amp;lt;property name=&quot;contentNegotiationManager&quot; ref=&quot;cnManager&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    
    &amp;lt;!--
      // Setup a simple strategy:
      //  1. Only path extension is taken into account, Accept headers
      //      are ignored.
      //  2. Return HTML by default when not sure.
      --&amp;gt;
    &amp;lt;bean id=&quot;cnManager&quot; class=&quot;org.springframework.web.accept.
                                   ContentNegotiationManagerFactoryBean&quot;&amp;gt;
        &amp;lt;property name=&quot;ignoreAcceptHeader&quot; value=&quot;true&quot;/&amp;gt;        
        &amp;lt;property name=&quot;defaultContentType&quot; value=&quot;text/html&quot; /&amp;gt;
    &amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
" />
<meta name="twitter:image:src" content="https://gravatar.com/avatar/0b0bedf6c0dab07b13a322eed9350873?s=200" />

<meta property="og:title" content="Content Negotiation using Views" />
<meta property="og:image" content="https://gravatar.com/avatar/0b0bedf6c0dab07b13a322eed9350873?s=200" />
<meta property="og:description" content="&lt;p&gt;In my previous &lt;a href=&quot;http://blog.springsource.org/2013/05/11/content-negotiation-using-spring-mvc/&quot;&gt;post&lt;/a&gt; I introduced the concept of content negotiation and the three strategies Spring MVC uses to determine the content requested.&lt;/p&gt;
&lt;p&gt;In this post I want to extend the concept specifically to supporting multiple views for different content-types using the &lt;code style=&quot;font-size:100%; color:black&quot;&gt;ContentNegotiatingViewResolver&lt;/code&gt; (or CNVR).&lt;/p&gt;
&lt;h2&gt;Quick Overview&lt;/h2&gt;
&lt;p&gt;Since we already know how to setup content-negotiation from the previous &lt;a href=&quot;http://blog.springsource.org/2013/05/11/content-negotiation-using-spring-mvc/&quot;&gt;post&lt;/a&gt;, using it to select between multiple views is very straightforward. Simply define a CNVR like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;prettyprint xml&quot;&gt;&lt;br&gt;    &amp;lt;!--
      // View resolver that delegates to other view resolvers based on the
      // content type
      --&amp;gt;
    &amp;lt;bean class=&quot;org.springframework.web.servlet.view.
                                           ContentNegotiatingViewResolver&quot;&amp;gt;
       &amp;lt;!-- All configuration now done by manager - since Spring V3.2 --&amp;gt;
       &amp;lt;property name=&quot;contentNegotiationManager&quot; ref=&quot;cnManager&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    
    &amp;lt;!--
      // Setup a simple strategy:
      //  1. Only path extension is taken into account, Accept headers
      //      are ignored.
      //  2. Return HTML by default when not sure.
      --&amp;gt;
    &amp;lt;bean id=&quot;cnManager&quot; class=&quot;org.springframework.web.accept.
                                   ContentNegotiationManagerFactoryBean&quot;&amp;gt;
        &amp;lt;property name=&quot;ignoreAcceptHeader&quot; value=&quot;true&quot;/&amp;gt;        
        &amp;lt;property name=&quot;defaultContentType&quot; value=&quot;text/html&quot; /&amp;gt;
    &amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
" />
<meta content="article" property="og:type" />
<meta property="og:article:published_time" content="2013-06-03 18:26:00.0" />
</head>
<body>

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" style="display:none;visibility:hidden" width="0"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">Projects</a>
</li>
<li class="navbar-link">
<a href="/guides">Guides</a>
</li>
<li class="navbar-link active">
<a href="/blog">Blog</a>
</li>
<li class="navbar-link">
<a href="/services">Training & Certification</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form action="/search" class="form-inline form-search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search for documentation, guides, and posts..." type="text" value="" />
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form action="/search" class="form-inline form-search" method="get">
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search..." type="text" value="" />
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">
Home
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">
Projects
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">
Guides
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">
Blog
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">
Training & Certification
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>Engineering</div>
</div>
<div class="blog-category content--title">
<div>Releases</div>
</div>
<div class="blog-category content--title">
<div>News and Events</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Content Negotiation using Views</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">Engineering</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/0b0bedf6c0dab07b13a322eed9350873?s=20&amp;d=mm" />
<span class="author">Paul Chapman</span>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2013-06-03 18:26:00.0">June 03, 2013</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" data-disqus-identifier="515" href="/blog/2013/06/03/content-negotiation-using-views#disqus_thread">
</a></div>
</div>
</header>
<div class="blog--post"><p>In my previous <a href="http://blog.springsource.org/2013/05/11/content-negotiation-using-spring-mvc/">post</a> I introduced the concept of content negotiation and the three strategies Spring MVC uses to determine the content requested.</p>
<p>In this post I want to extend the concept specifically to supporting multiple views for different content-types using the <code style="font-size:100%; color:black">ContentNegotiatingViewResolver</code> (or CNVR).</p>
<h2>Quick Overview</h2>
<p>Since we already know how to setup content-negotiation from the previous <a href="http://blog.springsource.org/2013/05/11/content-negotiation-using-spring-mvc/">post</a>, using it to select between multiple views is very straightforward. Simply define a CNVR like this:</p>
<pre><code class="prettyprint xml"><br />    &lt;!--
      // View resolver that delegates to other view resolvers based on the
      // content type
      --&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.
                                           ContentNegotiatingViewResolver&quot;&gt;
       &lt;!-- All configuration now done by manager - since Spring V3.2 --&gt;
       &lt;property name=&quot;contentNegotiationManager&quot; ref=&quot;cnManager&quot;/&gt;
    &lt;/bean&gt;
    
    &lt;!--
      // Setup a simple strategy:
      //  1. Only path extension is taken into account, Accept headers
      //      are ignored.
      //  2. Return HTML by default when not sure.
      --&gt;
    &lt;bean id=&quot;cnManager&quot; class=&quot;org.springframework.web.accept.
                                   ContentNegotiationManagerFactoryBean&quot;&gt;
        &lt;property name=&quot;ignoreAcceptHeader&quot; value=&quot;true&quot;/&gt;        
        &lt;property name=&quot;defaultContentType&quot; value=&quot;text/html&quot; /&gt;
    &lt;/bean&gt;
</code></pre>
<p>For every request, a <code style="font-size:100%; color:black">@Controller</code> would typically return a <em>logical view name</em> (or Spring MVC will determine one, by convention from the incoming URL). The CNVR will consult all the other view-resolvers defined in the configuration to see 1) if it has a view with the right name and 2) if it has a view that it also generates the right content - all Views &lsquo;know&rsquo; what content-type they return. The desired content-type is determined in the exact same way discussed in the previous post.</p>
<p>For the equivalent Java configuration see <a href="#javaconfig1">here</a>. And for an extended configuration see <a href="#config2">here</a>. There is a demo application at Github: <a href="https://github.com/paulc4/mvc-content-neg-views"><a href="https://github.com/paulc4/mvc-content-neg-views">https://github.com/paulc4/mvc-content-neg-views</a></a>. </p>
<p>For those of you in a hurry, that&rsquo;s it in a nutshell.</p>
<p>For the rest of you, this post shows how we got to it. It discusses the concept of multiple-views in Spring MVC and builds upon that idea to define what the CNVR is, how to use it and how it works. It takes the same Accounts application from the previous <a href="http://blog.springsource.org/2013/05/11/content-negotiation-using-spring-mvc/">post</a> and builds it up to return account information in HTML, as a Spreadsheet, as JSON and in XML. All using <em>just</em> views.</p>
<h2>Why Multiple Views?</h2>
<p>One of the strengths of the MVC pattern is the ability to have multiple views for the same data.  In Spring MVC we achieve this using &rsquo;&rsquo;<em>Content Negotiation&ldquo;</em>&rdquo;. My previous <a href="http://blog.springsource.org/2013/05/11/content-negotiation-using-spring-mvc/">post</a> discussed content-negotiation in general and showed examples of RESTful controllers using HTTP Message Converters. But content-negotiation can also be used with Views as well.</p>
<p>For example, suppose I wish to display account information not just as a web-page, but also make it available as a spreadsheet too.  I could use a different URL for each, put two methods on my Spring controller and have each return the correct View type.  (BTW, if you aren´t sure how Spring can create a spreadsheet, I´ll show you that later).</p>
<pre><code class="prettyprint java"><br />@Controller
class AccountController {
    @RequestMapping(&quot;/accounts.htm&quot;)
    public String listAsHtml(Model model, Principal principal) {
        // Duplicated logic
        model.addAttribute( accountManager.getAccounts(principal) );
        return ¨accounts/list¨;         // View determined by view-resolution
    }

    @RequestMapping(&quot;/accounts.xls&quot;)
    public AccountsExcelView listAsXls(Model model, Principal principal) {
        // Duplicated logic
        model.addAttribute( accountManager.getAccounts(principal) );
        return new AccountsExcelView();  // Return view explicitly
    }
}
</code></pre>
<p>Using multiple methods is inelegant, defeats the MVC pattern and gets even uglier if I want to support other data formats too - such as PDF, CSV &hellip;  If you recall in the previous <a href="http://blog.springsource.org/2013/05/11/content-negotiation-using-spring-mvc/">post</a> we had a similar problem wanting a single method to return JSON or XML (which we solved by returning a single <code style="font-size:100%; color:black">@RequestBody</code> object and picking the right HTTP Message Converter).</p>
<p>[caption id=&ldquo;attachment_13458&rdquo; align=&ldquo;alignleft&rdquo; width=&ldquo;380&rdquo; caption=&ldquo;Picking the right view via Content-Negotiation.&rdquo;]<a href="http://blog.springsource.org/wp-content/uploads/2013/06/cnvr-flow.png"><img src="http://blog.springsource.org/wp-content/uploads/2013/06/cnvr-flow.png" alt="" title="View Resolution using CNVR" width="380" class="size-full wp-image-13458" /></a>[/caption]</p>
<p>Now we need a &ldquo;smart&rdquo; view resolver that picks the <em>right</em> View from <em>multiple</em> possible views.</p>
<p>Spring MVC has long supported multiple view resolvers, and goes to each in turn to find a view. Although the order that view resolvers are consulted can be specified, Spring MVC always picks the <em>first</em> view offered.  The &rsquo;&lsquo;<em>Content Negotiating View Resolver</em>&rsquo;&rsquo; (CNVR) negotiates between <em>all</em> the view resolvers to find the <em>best</em> match for the format desired - this <em>is</em> our &ldquo;smart&rdquo; view resolver.</p>
<h2>Listing User Accounts Example</h2>
<a href="http://blog.springsource.org/wp-content/uploads/2013/05/acounts-html.png"><img src="http://blog.springsource.org/wp-content/uploads/2013/05/acounts-html.png" alt="" title="Accounts Page as HTML" width="370" class="size-full wp-image-13352" /></a>
<p>Here is a simple account listing application which we will use as our worked example to list accounts in HTML, in a spreadsheet and (later) in JSON and XML formats - just using views.</p>
<p>The complete code can be found at Github: <a href="https://github.com/paulc4/mvc-content-neg-views"><a href="https://github.com/paulc4/mvc-content-neg-views">https://github.com/paulc4/mvc-content-neg-views</a></a>. It is a variation on the application I showed you last time that <em>only</em> uses views to generate output. <strong>Note</strong>: to keep the examples below simple I have used JSPs directly and an <code style="font-size:100%; color:black">InternalResourceViewResolver</code>. The Github project uses Tiles and JSPs because it&rsquo;s easier than raw JSPs.</p>
<p>The screenshot of the accounts list HTML page shows all the accounts for the currently logged in user. You will see screenshots of the spreadsheet and JSON output later.</p>
<p>The Spring MVC controller that generated our page is below. Note that the HTML output is generated by the logical view <code style="font-size:100%; color:navy">accounts/list</code>.</p>
<pre><code class="prettyprint java"><br />@Controller
class AccountController {
    @RequestMapping(&quot;/accounts&quot;)
    public String list(Model model, Principal principal) {
        model.addAttribute( accountManager.getAccounts(principal) );
        return ¨accounts/list¨;
    }
}
</code></pre>
<p>To show two types of views we need two types of view resolver - one for HTML and one for the spreadsheet (to keep it simple, I will use a JSP for the HTML view). Here is the Java Configuration:</p>
<pre><code class="prettyprint java"><br />@Configuration
@EnableWebMvc
public class MvcConfiguration extends WebMvcConfigurerAdapter {

    @Autowired
    ServletContext servletContext;

    // Will map to bean called &quot;accounts/list&quot; in &quot;spreadsheet-views.xml&quot;
    @Bean(name=&quot;excelViewResolver&quot;)
    public ViewResolver getXmlViewResolver() {
        XmlViewResolver resolver = new XmlViewResolver();
        resolver.setLocation(new ServletContextResource(servletContext,
                    &quot;/WEB-INF/spring/spreadsheet-views.xml&quot;));
        resolver.setOrder(1);
        return resolver;
    }

    // Will map to the JSP page: &quot;WEB-INF/views/accounts/list.jsp&quot;
    @Bean(name=&quot;jspViewResolver&quot;)
    public ViewResolver getJspViewResolver() {
        InternalResourceViewResolver resolver =
                            new InternalResourceViewResolver();
        resolver.setPrefix(&quot;WEB-INF/views&quot;);
        resolver.setSuffix(&quot;.jsp&quot;);
        resolver.setOrder(2);
        return resolver;
    }
}
</code></pre>
<p>Or in XML:</p>
<pre><code class="prettyprint xml"><br />  &lt;!-- Maps to a bean called &quot;accounts/list&quot; in &quot;spreadsheet-views.xml&quot; --&gt;
  &lt;bean class=&quot;org.springframework.web.servlet.view.XmlViewResolver&quot;&gt;
    &lt;property name=&quot;order&quot; value=&quot;1&quot;/&gt;
    &lt;property name=&quot;location&quot; value=&quot;WEB-INF/spring/spreadsheet-views.xml&quot;/&gt;
  &lt;/bean&gt;

  &lt;!-- Maps to &quot;WEB-INF/views/accounts/list.jsp&quot; --&gt;
  &lt;bean class=&quot;org.springframework.web.servlet.view.
                                        InternalResourceViewResolver&quot;&gt;
    &lt;property name=&quot;order&quot; value=&quot;2&quot;/&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;WEB-INF/views&quot;/&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
  &lt;/bean&gt;
</code></pre>
<p>And in <code style="font-size:100%; color:navy">WEB-INF/spring/spreadsheet-beans.xml</code> you will find</p>
<pre><code class="prettyprint xml">  &lt;bean id=&quot;accounts/list&quot; class=&quot;rewardsonline.accounts.AccountExcelView&quot;/&gt;
</code></pre>
<p>The generated spreadsheet looks like this:</p>
<a href="http://blog.springsource.org/wp-content/uploads/2013/04/account-list-xls.png"><img src="http://blog.springsource.org/wp-content/uploads/2013/04/account-list-xls.png" alt="" title="account-list-xls" width="580" class="alignnone size-full wp-image-13161" /></a>
<p>Here is how to create a spreadsheet using a view (this is a simplified version, the full implementation is much longer, but you get the idea):</p>
<pre><code class="prettyprint java">class AccountExcelView extends AbstractExcelView {
    @Override
    protected void buildExcelDocument(Map&lt;String, Object&gt; model,
            HSSFWorkbook workbook, HttpServletRequest request,
            HttpServletResponse response) throws Exception {
        List&lt;Account&gt; accounts = (List&lt;Account&gt;) model.get(&quot;accountList&quot;);
        HSSFCellStyle dateStyle = workbook.createCellStyle();
        dateStyle.setDataFormat(HSSFDataFormat.getBuiltinFormat(&quot;m/d/yy&quot;));
        HSSFSheet sheet = workbook.createSheet();
    
        for (short i = 0; i &lt; accounts.size(); i++) {
            Account account = accounts.get(i);
            HSSFRow row = sheet.createRow(i);
            addStringCell(row, 0, account.getName());
            addStringCell(row, 1, account.getNumber());
            addDateCell(row, 2, account.getDateOfBirth(), dateStyle);
        }   
    }   
    
    private HSSFCell addStringCell(HSSFRow row, int index, String value) {
        HSSFCell cell = row.createCell((short) index);
        cell.setCellValue(new HSSFRichTextString(value));
        return cell;
    }   
    
    private HSSFCell addDateCell(HSSFRow row, int index, Date date,
        HSSFCellStyle dateStyle) {
        HSSFCell cell = row.createCell((short) index);
        cell.setCellValue(date);
        cell.setCellStyle(dateStyle);
        return cell;
    }   
} 
</code></pre>
<h2>Adding Content Negotiation</h2>
<p>As it currently stands this setup will always return the spreadsheet because the <code style="font-size:100%; color:black">XmlViewResolver</code> is consulted first (its <code style="font-size:100%; color:black">order</code> property is 1) and it always returns the <code style="font-size:100%; color:black">AccountExcelView</code>.  The <code style="font-size:100%; color:black">InternalResourceViewResolver</code> is never consulted (its <code style="font-size:100%; color:black">order</code> is 2 and we never get that far).</p>
<p>This is where the CNVR comes in. Let&rsquo;s quickly review what we know about the content selection strategy discussed in the previous <a href="http://blog.springsource.org/2013/05/11/content-negotiation-using-spring-mvc/">post</a>. The requested content-type is determined by checking, in this order:</p>
<ul>
<li>A URL suffix (path extension) - for example <code style="font-size:100%; color:navy">http://...accounts.json</code> to indicate JSON format.</li>
<li>Or a URL parameter can be used. By default it is named <code style="font-size:100%; color:black">format</code>, for example <code style="font-size:100%; color:navy">http://...accounts?format=json</code>.</li>
<li>Or the HTTP <code style="font-size:100%; color:black">Accept</code> header property will be used (which is actually how HTTP is defined to work, but is not always convenient to use - especially when the client is a browser).</li>
</ul>
<p>In the first two cases the suffix or parameter value (<code style="font-size:100%; color:black">xml</code>, <code style="font-size:100%; color:black">json</code> &hellip;) must be mapped to the correct mime-type. Either the <em>JavaBeans Activation Framework</em> can be used or the mappings can be specified explicitly. With the <code style="font-size:100%; color:black">Accept</code> header property, its value <em>is</em> the mine-type.</p>
<h2>The Content Negotiating View Resolver</h2>
<p>This is a special view resolver that has our strategy plugged into it. Here is the <a name="javaconfig1">Java Configuration</a>:</p>
<pre><code class="prettyprint java"><br />@Configuration
@EnableWebMvc
public class MvcConfiguration extends WebMvcConfigurerAdapter {
 
  /**
    * Setup a simple strategy:
    *  1. Only path extension taken into account, Accept headers ignored.
    *  2. Return HTML by default when not sure.
    */
  @Override
  public void configureContentNegotiation
                          (ContentNegotiationConfigurer configurer) {
      configurer.ignoreAcceptHeader(true)
                .defaultContentType(MediaType.TEXT_HTML);
  }

  /**
    * Create the CNVR. Get Spring to inject the ContentNegotiationManager
    * created by the configurer (see previous method).
    */
  @Bean
  public ViewResolver contentNegotiatingViewResolver(
                             ContentNegotiationManager manager) {
    ContentNegotiatingViewResolver resolver =
                            new ContentNegotiatingViewResolver();
    resolver.setContentNegotiationManager(manager);
    return resolver;
  }
}
</code></pre>
<p>Or in XML:</p>
<pre><code class="prettyprint xml"><br />    &lt;!--
      // View resolver that delegates to other view resolvers based on the
      // content type
      --&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.
                                      ContentNegotiatingViewResolver&quot;&gt;
       &lt;!-- All configuration now done by manager - since Spring V3.2 --&gt;
       &lt;property name=&quot;contentNegotiationManager&quot; ref=&quot;cnManager&quot;/&gt;
    &lt;/bean&gt;
    
    &lt;!--
      // Setup a simple strategy:
      //  1. Only path extension taken into account, Accept headers ignored.
      //  2. Return HTML by default when not sure.
      --&gt;
    &lt;bean id=&quot;cnManager&quot; class=&quot;org.springframework.web.accept.
                                  ContentNegotiationManagerFactoryBean&quot;&gt;
        &lt;property name=&quot;ignoreAcceptHeader&quot; value=&quot;true&quot;/&gt;        
        &lt;property name=&quot;defaultContentType&quot; value=&quot;text/html&quot; /&gt;
    &lt;/bean&gt;
</code></pre>
<p>The <code style="font-size:100%; color:black">ContentNegotiationManager</code> is exactly the same bean I discussed in the previous <a href="http://blog.springsource.org/2013/05/11/content-negotiation-using-spring-mvc/">post</a>.</p>
<p>The CNVR automatically goes to <em>every</em> other view resolver bean defined to Spring and asks it for a <code style="font-size:100%; color:black">View</code> instance corresponding to the view-name returned by the controller - in this case <code style="font-size:100%; color:navy">accounts/list</code>.  Each <code style="font-size:100%; color:black">View</code> &lsquo;knows&rsquo; what sort of content it can generate because there is a <code style="font-size:100%; color:black">getContentType()</code> method on it (inherited from the <code style="font-size:100%; color:black">View</code> interface).  The JSP page is rendered by a <code style="font-size:100%; color:black">JstlView</code> (returned by the <code style="font-size:100%; color:black">InternalResourceViewResolver</code>) and its content-type is <code style="font-size:100%; color:navy">text/html</code>, whilst the <code style="font-size:100%; color:black">AccountExcelView</code> generates <code style="font-size:100%; color:navy">application/vnd.ms-excel</code>.</p>
<p>How the CNVR is actually configured is delegated to the <code style="font-size:100%; color:black">ContentNegotiationManager</code> which is created in turn via the configurer (Java Configuration) or one of Spring&rsquo;s many factory beans (XML).</p>
<p>The last piece of the puzzle is: <em>how does the CNVR know what content-type was requested</em>? Because the content-negotiation strategy tells it what to do: either a URL suffix is recognized, or a URL parameter or an Accept header. Exactly the same strategy setup described in the previous <a href="http://blog.springsource.org/2013/05/11/content-negotiation-using-spring-mvc/">post</a>, reused by the CNVR.</p>
<p><blockquote>Note that when content-negotiation strategies were introduced by Spring 3.0 they only applied to selecting Views. Since 3.2 this facility is available across the board (as per my previous <a href="http://blog.springsource.org/2013/05/11/content-negotiation-using-spring-mvc/">post</a>). The examples in this post use Spring 3.2 and may be different to older examples you have seen before. In particular most of the properties for configuring the content-negotiation strategy are now on the <code style="font-size:100%; color:black">ContentNegotiationManagerFactoryBean</code> and not on the <code style="font-size:100%; color:black">ContentNegotiatingViewResolver</code>. The properties on the CNVR are now deprecated in favor of those on the manager but the CNVR itself works exactly the same way that it always did.</blockquote></p>
<h2 id="config2">Configuring the Content Negotiating View Resolver</h2>
<p>By default the CNVR automatically detects all <code style="font-size:100%; color:black">ViewResolvers</code> defined to Spring and negotiates between them. If you prefer, the CNVR itself has a <code style="font-size:100%; color:black">viewResolvers</code> property so you can tell it <em>explicitly</em> which view resolvers to use. This makes it obvious that the CNVR is the master resolver and the others are subordinate to it. Note that the <code style="font-size:100%; color:black">order</code> property is no longer needed.</p>
<pre><code class="prettyprint java"><br />@Configuration
@EnableWebMvc
public class MvcConfiguration extends WebMvcConfigurerAdapter {
 
  // .. Other methods/declarations

  /**
    * Create the CNVR.  Specify the view resolvers to use explicitly.
    * Get Spring to inject the ContentNegotiationManager created by the
    * configurer (see previous method).
    */
  @Bean
  public ViewResolver contentNegotiatingViewResolver(
                        ContentNegotiationManager manager) {
    // Define the view resolvers
    List&lt;ViewResolver&gt; resolvers = new ArrayList&lt;ViewResolver&gt;();

    XmlViewResolver r1 = new XmlViewResolver();
    resolver.setLocation(new ServletContextResource(servletContext,
            &quot;/WEB-INF/spring/spreadsheet-views.xml&quot;));
    resolvers.add(r1);

    InternalResourceViewResolver r2 = new InternalResourceViewResolver();
    r2.setPrefix(&quot;WEB-INF/views&quot;);
    r2.setSuffix(&quot;.jsp&quot;);
    resolvers.add(r2);

    // Create CNVR plugging in the resolvers &amp; content-negotiation manager
    ContentNegotiatingViewResolver resolver =
                        new ContentNegotiatingViewResolver();
    resolver.setViewResolvers(resolvers);
    resolver.setContentNegotiationManager(manager);
    return resolver;
  }
}
</code></pre>
<p>Or in XML:</p>
<pre><code class="prettyprint xml"><br />  &lt;bean class=&quot;org.springframework.web.servlet.view.
                                ContentNegotiatingViewResolver&quot;&gt;
    &lt;property name=&quot;contentNegotiationManager&quot; ref=&quot;cnManager&quot;/&gt;

    &lt;!-- Define the view resolvers explicitly --&gt;
    &lt;property name=&quot;viewResolvers&quot;&gt;
      &lt;list&gt;
        &lt;bean class=&quot;org.springframework.web.servlet.view.XmlViewResolver&quot;&gt;
          &lt;property name=&quot;location&quot; value=&quot;spreadsheet-views.xml&quot;/&gt;
        &lt;/bean&gt;
    
        &lt;bean class=&quot;org.springframework.web.servlet.view.
                                InternalResourceViewResolver&quot;&gt;
          &lt;property name=&quot;prefix&quot; value=&quot;WEB-INF/views&quot;/&gt;
          &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
        &lt;/bean&gt;
      &lt;/list&gt;
    &lt;/property&gt;
  &lt;/bean&gt;
</code></pre>
<p>The Github demo project uses 2 sets of Spring profiles. In the <code style="font-size:100%; color:black">web.xml</code>, you can specify <code style="font-size:100%; color:black">xml</code> or <code style="font-size:100%; color:black">javaconfig</code> for XML or Java configuration respectively. And for either of them, specify either <code style="font-size:100%; color:black">separate</code> or <code style="font-size:100%; color:black">combined</code>. The <code style="font-size:100%; color:black">separate</code> profile defines all view resolvers as top-level beans and lets the CNVR scan the context to find them (as discussed in the previous section). In the <code style="font-size:100%; color:black">combined</code> profile the view resolvers are defined explicitly, not as Spring beans and passed to the CNVR via its <code style="font-size:100%; color:black">viewResolvers</code> property (as shown in this section). </p>
<h2>JSON Support</h2>
<p>Spring provides a <code style="font-size:100%; color:black">MappingJacksonJsonView</code> that supports the generation of JSON data from Java objects using the Jackson Object to JSON mapping library.  The <code style="font-size:100%; color:black">MappingJacksonJsonView</code> automatically converts all attributes found in the Model to JSON.  The only exception is that it ignores <code style="font-size:100%; color:black">BindingResult</code> objects since these are internal to Spring MVC form-handling and not needed.</p>
<p>A suitable view resolver is needed and Spring doesn&rsquo;t provide one.  Fortunately it is very simple to write your own:</p>
<pre><code class="prettyprint java"><br />public class JsonViewResolver implements ViewResolver {
    /**
     * Get the view to use.
     *
     * @return Always returns an instance of {@link MappingJacksonJsonView}.
     */
    @Override
    public View resolveViewName(String viewName, Locale locale)
                                                 throws Exception {
        MappingJacksonJsonView view = new MappingJacksonJsonView();
        view.setPrettyPrint(true);   // Lay JSON out to be nicely readable 
        return view;
    }
}
</code></pre>
<p>Simply declaring this view resolver as a Spring bean means JSON format data can be returned. The JAF already maps <code style="font-size:100%; color:black">json</code> to <code style="font-size:100%; color:navy">application/json</code> so we are done. A URL like <code style="font-size:100%; color:navy"><a href="http://myserver/myapp/accounts/list.json">http://myserver/myapp/accounts/list.json</a></code> can now return the account information in JSON. Here is the output from our Accounts application:</p>
<a href="http://blog.springsource.org/wp-content/uploads/2013/04/account-list-json.png"><img src="http://blog.springsource.org/wp-content/uploads/2013/04/account-list-json.png" alt="" title="account-list-json" width="580" class="alignright size-full wp-image-13160" /></a>
<p>For more on this View, see the <a href="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/web/servlet/view/json/MappingJacksonJsonView.html">Spring Javadoc</a>.</p>
<h2>XML Support</h2>
<p>There is a similar class for generating XML output - the <a href="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/web/servlet/view/xml/MarshallingView.html">MarshallingView</a>. It takes the first object in the model that can be marshalled and processes it. You can optionally configure the view by telling it which Model attribute (key) to pick - see <code style="font-size:100%; color:black">setModelKey()</code>.</p>
<p>Again we need a view resolver for it. Spring supports several marshalling technologies via Spring&rsquo;s <a href="http://static.springsource.org/spring/docs/current/spring-framework-reference/html/oxm.html">Object to XML Marshalling (OXM)</a> abstraction. Let&rsquo;s just use JAXB2 since it is built into the JDK (since JDK 6). Here is the resolver:</p>
<pre><code class="prettyprint java"><br />/**
 * View resolver for returning XML in a view-based system.
 */
public class MarshallingXmlViewResolver implements ViewResolver {

    private Marshaller marshaller;

    @Autowired
    public MarshallingXmlViewResolver(Marshaller marshaller) {
        this.marshaller = marshaller;
    }

    /**
     * Get the view to use.
     * 
     * @return Always returns an instance of {@link MappingJacksonJsonView}.
     */
    @Override
    public View resolveViewName(String viewName, Locale locale)
                                                 throws Exception {
        MarshallingView view = new MarshallingView();
        view.setMarshaller(marshaller);
        return view;
    }
}
</code></pre>
<p>Again my classes need annotating to work with JAXB (in response to comments, I have added an example of this to the end of my previous <a href="http://blog.springsource.org/2013/05/11/content-negotiation-using-spring-mvc/#annotated-account-class">post</a>). </p>
<p>Configure the new resolver as a Spring bean using Java Configuration:</p>
<pre><code class="prettyprint java"><br />  @Bean(name = &quot;marshallingXmlViewResolver&quot;)
  public ViewResolver getMarshallingXmlViewResolver() {
      Jaxb2Marshaller marshaller = new Jaxb2Marshaller();

      // Define the classes to be marshalled - these must have
      // @Xml... annotations on them
      marshaller.setClassesToBeBound(Account.class,
                               Transaction.class, Customer.class);
      return new MarshallingXmlViewResolver(marshaller);
  }
</code></pre>
<p>Or we can do the same thing in XML - note the use of the oxm namespace:</p>
<pre><code class="prettyprint xml">&lt;oxm:jaxb2-marshaller id=&quot;marshaller&quot; &gt;
    &lt;oxm:class-to-be-bound name=&quot;rewardsonline.accounts.Account&quot;/&gt;
    &lt;oxm:class-to-be-bound name=&quot;rewardsonline.accounts.Customer&quot;/&gt;
    &lt;oxm:class-to-be-bound name=&quot;rewardsonline.accounts.Transaction&quot;/&gt;
&lt;/oxm:jaxb2-marshaller&gt;

&lt;!-- View resolver that returns an XML Marshalling view. --&gt;
&lt;bean class=&quot;rewardsonline.accounts.MarshallingXmlViewResolver&quot; &gt;
    &lt;constructor-arg ref=&quot;marshaller&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>This is our finished system:</p>
<a href="http://blog.springsource.org/wp-content/uploads/2013/06/cnvr-all-flow.png"><img src="http://blog.springsource.org/wp-content/uploads/2013/06/cnvr-all-flow.png" alt="Full system with CNVR and 4 view-resolvers" title="cnvr-all-flow" width="480" class="size-full wp-image-13471" /></a>
<h2>Comparing RESTful Approaches</h2>
<p>Full support for a RESTful approach with MVC is available using <code style="font-size:100%; color:black">@ResponseBody</code>, <code style="font-size:100%; color:black">@ResponseStatus</code> and other REST related MVC annotations.  Something like this:</p>
<pre><code class="prettyprint java"><br />@RequestMapping(value=&quot;/accounts&quot;,
                produces={&quot;application/json&quot;, &quot;application/xml&quot;})
@ResponseStatus(HttpStatus.OK)
public @ResponseBody List&lt;Account&gt; list(Principal principal) {
    return accountManager.getAccounts(principal);
}
</code></pre>
<p>To enable the same content-negotiation for our <code style="font-size:100%; color:black">@RequestMapping</code> methods, we must reuse our content-negotiation manager (this allows the <code style="font-size:100%; color:black">produces</code> option to work).</p>
<pre><code class="prettyprint java"><br />&lt;mvc:annotation-driven
          content-negotiation-manager=&quot;contentNegotiationManager&quot; /&gt;
</code></pre>
<p>However this produces a different style of Controller method, the advantage being it is also more powerful. So which way to go: Views or <code style="font-size:100%; color:black">@ResponseBody</code>?</p>
<p>For an existing web-site already using Spring MVC and views, the <code style="font-size:100%; color:black">MappingJacksonJsonView</code> and <code style="font-size:100%; color:black">MarshallingView</code> provide an easy way to extend the web-application to return JSON and/or XML as well.  In many cases, these are the only data-formats you need and is an easy way to support read-only mobile apps and/or AJAX enabled web-pages where RESTful requests are only used to <em>GET</em> data.</p>
<p>Full support for REST, including the ability to modify data, involves the use of annotated controller methods in conjunction with HTTP Message Converters. Using views in this case doesn&rsquo;t make sense, just return a <code style="font-size:100%; color:black">@ResponseBody</code> object and let the converter do the work.</p>
<p>However, as shown &lt;a href=&quot;<a href="http://blog.springsource.org/2013/05/11/content-negotiation-using-spring-mvc/#combined-controller" "">http://blog.springsource.org/2013/05/11/content-negotiation-using-spring-mvc/#combined-controller""</a>here</a> in my previous post, it is perfectly possible for a controller to use both approaches at the same time. Now the same controller can support both traditional web-applications and implement a full RESTful interface, enhancing web-applications that may have been built-up and developed over many years.</p>
<p>Spring has always been strong on offering developers flexibility and choice. This is no exception.</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 515;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>
Back
</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">All Posts</a>
<a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">Engineering</a>
<a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">Releases</a>
<a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">News and Events</a>
<a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>Get updates from The Spring Team delivered to your inbox</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">Tools</a></li>
<li><a href="https://store.pivotal.io/">Store</a></li>
<li><a href="/blog">Newsletter</a></li>
</ul>
</div>
</div>
&copy; <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a>, Inc. All Rights Reserved.
<a href="https://pivotal.io/terms-of-use">Terms of Use</a> &bullet;
<a href="https://pivotal.io/privacy-policy">Privacy</a> &bullet;
<a href="/trademarks">Trademark Guidelines</a>
<div id="teconsent" style="display:inline-block;"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>