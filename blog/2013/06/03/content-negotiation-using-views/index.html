<html dir="ltr" data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>使用视图进行内容协商</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>System.config({baseURL: "/b92013b"});</script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>System.import('app/main.js')</script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Content Negotiation using Views">
<meta name="twitter:description" content="<p>In my previous <a href=" http:="" ="" blog.springsource.org="" 2013="" 05="" 11="" content-negotiation-using-spring-mvc="" ="="></meta>post I introduced the concept of content negotiation and the three strategies Spring MVC uses to determine the content requested.
<p>In this post I want to extend the concept specifically to supporting multiple views for different content-types using the <code style=" font-size:100%;color:black"></head><body dir="ltr">ContentNegotiatingViewResolver (or CNVR).<p></p>
<h2>Quick Overview</h2>
<p>Since we already know how to setup content-negotiation from the previous <a href="http://blog.springsource.org/2013/05/11/content-negotiation-using-spring-mvc/">post</a>, using it to select between multiple views is very straightforward. Simply define a CNVR like this:</p>
<pre><code class="prettyprint xml"><br>    <!--
      // View resolver that delegates to other view resolvers based on the
      // content type
      -->
    <bean class="org.springframework.web.servlet.view.
                                           ContentNegotiatingViewResolver">
       <!-- All configuration now done by manager - since Spring V3.2 -->
       <property name="contentNegotiationManager" ref="cnManager"/>
    </bean>
    
    <!--
      // Setup a simple strategy:
      //  1. Only path extension is taken into account, Accept headers
      //      are ignored.
      //  2. Return HTML by default when not sure.
      -->
    <bean id="cnManager" class="org.springframework.web.accept.
                                   ContentNegotiationManagerFactoryBean">
        <property name="ignoreAcceptHeader" value="true"/>        
        <property name="defaultContentType" value="text/html" />
    </bean>
</code></pre>
">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/0b0bedf6c0dab07b13a322eed9350873?s=200">

<meta property="og:title" content="Content Negotiation using Views">
<meta property="og:image" content="https://gravatar.com/avatar/0b0bedf6c0dab07b13a322eed9350873?s=200">
<meta property="og:description" content="<p>In my previous <a href=" http:="" ="" blog.springsource.org="" 2013="" 05="" 11="" content-negotiation-using-spring-mvc="" ="="></meta>post I introduced the concept of content negotiation and the three strategies Spring MVC uses to determine the content requested.
<p>In this post I want to extend the concept specifically to supporting multiple views for different content-types using the <code style=" font-size:100%;color:black">ContentNegotiatingViewResolver (or CNVR).<p></p>
<h2>Quick Overview</h2>
<p>Since we already know how to setup content-negotiation from the previous <a href="http://blog.springsource.org/2013/05/11/content-negotiation-using-spring-mvc/">post</a>, using it to select between multiple views is very straightforward. Simply define a CNVR like this:</p>
<pre><code class="prettyprint xml"><br>    <!--
      // View resolver that delegates to other view resolvers based on the
      // content type
      -->
    <bean class="org.springframework.web.servlet.view.
                                           ContentNegotiatingViewResolver">
       <!-- All configuration now done by manager - since Spring V3.2 -->
       <property name="contentNegotiationManager" ref="cnManager"/>
    </bean>
    
    <!--
      // Setup a simple strategy:
      //  1. Only path extension is taken into account, Accept headers
      //      are ignored.
      //  2. Return HTML by default when not sure.
      -->
    <bean id="cnManager" class="org.springframework.web.accept.
                                   ContentNegotiationManagerFactoryBean">
        <property name="ignoreAcceptHeader" value="true"/>        
        <property name="defaultContentType" value="text/html" />
    </bean>
</code></pre>
">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2013-06-03 18:26:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">// Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }</script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">使用视图进行内容协商</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/0b0bedf6c0dab07b13a322eed9350873?s=20&d=mm"> <span class="author">保罗·查普曼</span>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2013-06-03 18:26:00.0">2013年6月3日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2013/06/03/content-negotiation-using-views#disqus_thread" data-disqus-identifier="515">
</a></div>
</div>
</header>
<div class="blog--post"><p>在我以前的<a href="http://blog.springsource.org/2013/05/11/content-negotiation-using-spring-mvc/">文章中，</a>我介绍了内容协商的概念以及Spring MVC用于确定请求的内容的三种策略。</p>
<p>在本文中，我想将概念专门扩展为使用<code style="font-size:100%;color:black">ContentNegotiatingViewResolver</code> （或CNVR）支持不同内容类型的多个视图。</p>
<h2>快速概述</h2>
<p>由于我们已经从上一篇<a href="http://blog.springsource.org/2013/05/11/content-negotiation-using-spring-mvc/">文章中</a>了解了如何设置内容协商，因此使用它在多个视图之间进行选择非常简单。只需这样定义CNVR：</p>
<pre><code class="prettyprint xml"><br>    <!--
      // View resolver that delegates to other view resolvers based on the
      // content type
      -->
    <bean class="org.springframework.web.servlet.view.
                                           ContentNegotiatingViewResolver">
       <!-- All configuration now done by manager - since Spring V3.2 -->
       <property name="contentNegotiationManager" ref="cnManager"/>
    </bean>
    
    <!--
      // Setup a simple strategy:
      //  1. Only path extension is taken into account, Accept headers
      //      are ignored.
      //  2. Return HTML by default when not sure.
      -->
    <bean id="cnManager" class="org.springframework.web.accept.
                                   ContentNegotiationManagerFactoryBean">
        <property name="ignoreAcceptHeader" value="true"/>        
        <property name="defaultContentType" value="text/html" />
    </bean>
</code></pre>
<p>对于每个请求， <code style="font-size:100%;color:black">@Controller</code>通常会返回一个<em>逻辑视图名称</em> （或者，按照惯例，Spring MVC将根据传入的URL确定一个<em>名称</em> ）。CNVR将参考配置中定义的所有其他视图解析器，以查看1）如果它具有名称正确的视图，以及2）如果它具有还生成正确内容的视图-所有视图“知道”什么内容-他们返回。所需的内容类型以与上一篇文章中讨论的完全相同的方式确定。</p>
<p>有关等效的Java配置，请参见<a href="#javaconfig1">此处</a> 。有关扩展配置，请参见<a href="#config2">此处</a> 。Github上有一个演示应用程序： <a href="https://github.com/paulc4/mvc-content-neg-views"></a> <a href="https://github.com/paulc4/mvc-content-neg-views">https://github.com/paulc4/mvc-content-neg-views</a> 。</p>
<p>对于匆忙的你们，简而言之就是这样。</p>
<p>对于其余的人，这篇文章展示了我们是如何做到的。它讨论了Spring MVC中的多视图的概念，并基于该思想来定义CNVR是什么，如何使用它以及如何工作。它采用与上一篇<a href="http://blog.springsource.org/2013/05/11/content-negotiation-using-spring-mvc/">文章</a>相同的Accounts应用程序，并将其构建为以HTML，电子表格，JSON和XML的形式返回帐户信息。全部<em>只</em>使用视图。</p>
<h2>为什么要有多个视图？</h2>
<p>MVC模式的优势之一是能够为同一数据提供多个视图。在Spring MVC中，我们使用“ <em>内容协商”</em>来实现这一点。我以前的<a href="http://blog.springsource.org/2013/05/11/content-negotiation-using-spring-mvc/">文章</a>一般讨论了内容协商，并展示了使用HTTP消息转换器的RESTful控制器的示例。但是内容协商也可以与Views一起使用。</p>
<p>例如，假设我希望不仅将帐户信息显示为网页，还希望将其显示为电子表格。我可以为每个URL使用不同的URL，在Spring控制器上放置两个方法，并让每个方法返回正确的视图类型。（顺便说一句，如果您不确定Spring如何创建电子表格，我稍后将向您展示）。</p>
<pre><code class="prettyprint java"><br>@Controller
class AccountController {
    @RequestMapping("/accounts.htm")
    public String listAsHtml(Model model, Principal principal) {
        // Duplicated logic
        model.addAttribute( accountManager.getAccounts(principal) );
        return ¨accounts/list¨;         // View determined by view-resolution
    }

    @RequestMapping("/accounts.xls")
    public AccountsExcelView listAsXls(Model model, Principal principal) {
        // Duplicated logic
        model.addAttribute( accountManager.getAccounts(principal) );
        return new AccountsExcelView();  // Return view explicitly
    }
}
</code></pre>
<p>如果我也想支持其他数据格式（例如PDF，CSV），则使用多种方法是不雅的，失败了MVC模式，并且变得更加难看。如果您回想起上一篇<a href="http://blog.springsource.org/2013/05/11/content-negotiation-using-spring-mvc/">文章，</a>我们也遇到了类似的问题，我们想要一个方法来返回JSON或XML（我们通过返回单个<code style="font-size:100%;color:black">@RequestBody</code>对象并选择正确的HTTP消息转换器来解决）。</p>
<p>[caption id =” attachment_13458” align =” alignleft” width =“ 380” caption =”通过内容协商选择右视图。”] <a href="http://blog.springsource.org/wp-content/uploads/2013/06/cnvr-flow.png"><img src="http://blog.springsource.org/wp-content/uploads/2013/06/cnvr-flow.png" alt="" title="使用CNVR查看分辨率" width="380" class="size-full wp-image-13458"></a> [/字幕]</p>
<p>现在，我们需要一个“智能”视图解析器，从<em>多个</em>可能的视图中选择<em>正确的</em>视图。</p>
<p>Spring MVC长期以来一直支持多个视图解析器，并且依次转到每个视图解析器来查找视图。尽管可以指定协商视图解析器的顺序，但是Spring MVC始终会选择提供的<em>第一个</em>视图。<em>内容协商视图解析器</em> （CNVR）在<em>所有</em>视图解析器之间进行协商，以找到所需格式的<em>最佳</em>匹配-这<em>是</em>我们的“智能”视图解析器。</p>
<h2>列出用户帐户示例</h2>
<a href="http://blog.springsource.org/wp-content/uploads/2013/05/acounts-html.png"><img src="http://blog.springsource.org/wp-content/uploads/2013/05/acounts-html.png" alt="" title="帐户页面为HTML" width="370" class="size-full wp-image-13352"></a>
<p>这是一个简单的帐户列表应用程序，我们将使用该示例作为示例，以HTML，电子表格以及（后来）JSON和XML格式（仅使用视图）列出帐户。</p>
<p>完整的代码可以在Github上找到： <a href="https://github.com/paulc4/mvc-content-neg-views"></a> <a href="https://github.com/paulc4/mvc-content-neg-views">https://github.com/paulc4/mvc-content-neg-views</a> 。这是我上次向您展示的应用程序的一种变体，该应用程序<em>仅</em>使用视图来生成输出。<strong>注意</strong> ：为了使下面的示例简单易行，我直接使用了JSP和<code style="font-size:100%;color:black">InternalResourceViewResolver</code> 。Github项目使用Tiles和JSP，因为它比原始JSP容易。</p>
<p>帐户列表HTML页面的屏幕快照显示了当前登录用户的所有帐户。稍后，您将看到电子表格的屏幕截图和JSON输出。</p>
<p>生成我们页面的Spring MVC控制器如下。请注意，HTML输出是由逻辑视图<code style="font-size:100%;color:navy">accounts/list</code>生成的。</p>
<pre><code class="prettyprint java"><br>@Controller
class AccountController {
    @RequestMapping("/accounts")
    public String list(Model model, Principal principal) {
        model.addAttribute( accountManager.getAccounts(principal) );
        return ¨accounts/list¨;
    }
}
</code></pre>
<p>要显示两种类型的视图，我们需要两种类型的视图解析器-一种用于HTML，另一种用于电子表格（为简单起见，我将在HTML视图中使用JSP）。这是Java配置：</p>
<pre><code class="prettyprint java"><br>@Configuration
@EnableWebMvc
public class MvcConfiguration extends WebMvcConfigurerAdapter {

    @Autowired
    ServletContext servletContext;

    // Will map to bean called "accounts/list" in "spreadsheet-views.xml"
    @Bean(name="excelViewResolver")
    public ViewResolver getXmlViewResolver() {
        XmlViewResolver resolver = new XmlViewResolver();
        resolver.setLocation(new ServletContextResource(servletContext,
                    "/WEB-INF/spring/spreadsheet-views.xml"));
        resolver.setOrder(1);
        return resolver;
    }

    // Will map to the JSP page: "WEB-INF/views/accounts/list.jsp"
    @Bean(name="jspViewResolver")
    public ViewResolver getJspViewResolver() {
        InternalResourceViewResolver resolver =
                            new InternalResourceViewResolver();
        resolver.setPrefix("WEB-INF/views");
        resolver.setSuffix(".jsp");
        resolver.setOrder(2);
        return resolver;
    }
}
</code></pre>
<p>或使用XML：</p>
<pre><code class="prettyprint xml"><br>  <!-- Maps to a bean called "accounts/list" in "spreadsheet-views.xml" -->
  <bean class="org.springframework.web.servlet.view.XmlViewResolver">
    <property name="order" value="1"/>
    <property name="location" value="WEB-INF/spring/spreadsheet-views.xml"/>
  </bean>

  <!-- Maps to "WEB-INF/views/accounts/list.jsp" -->
  <bean class="org.springframework.web.servlet.view.
                                        InternalResourceViewResolver">
    <property name="order" value="2"/>
    <property name="prefix" value="WEB-INF/views"/>
    <property name="suffix" value=".jsp"/>
  </bean>
</code></pre>
<p>在<code style="font-size:100%;color:navy">WEB-INF/spring/spreadsheet-beans.xml</code>您会找到</p>
<pre><code class="prettyprint xml">  <bean id="accounts/list" class="rewardsonline.accounts.AccountExcelView"/>
</code></pre>
<p>生成的电子表格如下所示：</p>
<a href="http://blog.springsource.org/wp-content/uploads/2013/04/account-list-xls.png"><img src="http://blog.springsource.org/wp-content/uploads/2013/04/account-list-xls.png" alt="" title="帐户清单xls" width="580" class="alignnone size-full wp-image-13161"></a>
<p>这是使用视图创建电子表格的方法（这是简化版本，完整实现要花更长的时间，但您会明白的）：</p>
<pre><code class="prettyprint java">class AccountExcelView extends AbstractExcelView {
    @Override
    protected void buildExcelDocument(Map<String, Object> model,
            HSSFWorkbook workbook, HttpServletRequest request,
            HttpServletResponse response) throws Exception {
        List<Account> accounts = (List<Account>) model.get("accountList");
        HSSFCellStyle dateStyle = workbook.createCellStyle();
        dateStyle.setDataFormat(HSSFDataFormat.getBuiltinFormat("m/d/yy"));
        HSSFSheet sheet = workbook.createSheet();
    
        for (short i = 0; i < accounts.size(); i++) {
            Account account = accounts.get(i);
            HSSFRow row = sheet.createRow(i);
            addStringCell(row, 0, account.getName());
            addStringCell(row, 1, account.getNumber());
            addDateCell(row, 2, account.getDateOfBirth(), dateStyle);
        }   
    }   
    
    private HSSFCell addStringCell(HSSFRow row, int index, String value) {
        HSSFCell cell = row.createCell((short) index);
        cell.setCellValue(new HSSFRichTextString(value));
        return cell;
    }   
    
    private HSSFCell addDateCell(HSSFRow row, int index, Date date,
        HSSFCellStyle dateStyle) {
        HSSFCell cell = row.createCell((short) index);
        cell.setCellValue(date);
        cell.setCellStyle(dateStyle);
        return cell;
    }   
} 
</code></pre>
<h2>添加内容协商</h2>
<p>就目前情况而言，此设置将始终返回电子表格，因为首先会查询<code style="font-size:100%;color:black">XmlViewResolver</code> （其<code style="font-size:100%;color:black">order</code>属性为1），并且始终返回<code style="font-size:100%;color:black">AccountExcelView</code> 。永远不会查询<code style="font-size:100%;color:black">InternalResourceViewResolver</code> （它的<code style="font-size:100%;color:black">order</code>是2，所以我们永远不会走那么远）。</p>
<p>这就是CNVR的来历。让我们快速回顾一下我们对上一篇<a href="http://blog.springsource.org/2013/05/11/content-negotiation-using-spring-mvc/">文章中</a>讨论的内容选择策略的了解。通过按以下顺序检查来确定请求的内容类型：</p>
<ul>
<li>URL后缀（路径扩展名）-例如用于表示JSON格式的<code style="font-size:100%;color:navy">http://...accounts.json</code> 。</li>
<li>或者可以使用URL参数。默认情况下，其名称为<code style="font-size:100%;color:black">format</code> ，例如<code style="font-size:100%;color:navy">http://...accounts?format=json</code> 。</li>
<li>或将使用HTTP <code style="font-size:100%;color:black">Accept</code>标头属性（实际上是HTTP定义的工作方式，但使用起来并不总是很方便-尤其是当客户端是浏览器时）。</li>
</ul>
<p>在前两种情况下，必须将后缀或参数值（ <code style="font-size:100%;color:black">xml</code> ， <code style="font-size:100%;color:black">json</code> …）映射到正确的mime类型。可以使用<em>JavaBeans激活框架，</em>也可以显式指定映射。随着<code style="font-size:100%;color:black">Accept</code>标头属性，其价值<em>是</em>矿山型。</p>
<h2>内容协商视图解析器</h2>
<p>这是一个特殊的视图解析器，已将我们的策略插入其中。这是<a name="javaconfig1">Java配置</a> ：</p>
<pre><code class="prettyprint java"><br>@Configuration
@EnableWebMvc
public class MvcConfiguration extends WebMvcConfigurerAdapter {
 
  /**
    * Setup a simple strategy:
    *  1. Only path extension taken into account, Accept headers ignored.
    *  2. Return HTML by default when not sure.
    */
  @Override
  public void configureContentNegotiation
                          (ContentNegotiationConfigurer configurer) {
      configurer.ignoreAcceptHeader(true)
                .defaultContentType(MediaType.TEXT_HTML);
  }

  /**
    * Create the CNVR. Get Spring to inject the ContentNegotiationManager
    * created by the configurer (see previous method).
    */
  @Bean
  public ViewResolver contentNegotiatingViewResolver(
                             ContentNegotiationManager manager) {
    ContentNegotiatingViewResolver resolver =
                            new ContentNegotiatingViewResolver();
    resolver.setContentNegotiationManager(manager);
    return resolver;
  }
}
</code></pre>
<p>或使用XML：</p>
<pre><code class="prettyprint xml"><br>    <!--
      // View resolver that delegates to other view resolvers based on the
      // content type
      -->
    <bean class="org.springframework.web.servlet.view.
                                      ContentNegotiatingViewResolver">
       <!-- All configuration now done by manager - since Spring V3.2 -->
       <property name="contentNegotiationManager" ref="cnManager"/>
    </bean>
    
    <!--
      // Setup a simple strategy:
      //  1. Only path extension taken into account, Accept headers ignored.
      //  2. Return HTML by default when not sure.
      -->
    <bean id="cnManager" class="org.springframework.web.accept.
                                  ContentNegotiationManagerFactoryBean">
        <property name="ignoreAcceptHeader" value="true"/>        
        <property name="defaultContentType" value="text/html" />
    </bean>
</code></pre>
<p><code style="font-size:100%;color:black">ContentNegotiationManager</code>与我在上<code style="font-size:100%;color:black">ContentNegotiationManager</code> <a href="http://blog.springsource.org/2013/05/11/content-negotiation-using-spring-mvc/">文章中</a>讨论的bean完全相同。</p>
<p>CNVR自动转到定义给Spring的<em>每个</em>其他视图解析器bean，并向其请求与控制器返回的视图名称相对应的<code style="font-size:100%;color:black">View</code>实例-在这种情况下为<code style="font-size:100%;color:navy">accounts/list</code> 。每个<code style="font-size:100%;color:black">View</code> “知道”它可以生成什么样的内容，因为它上面有一个<code style="font-size:100%;color:black">getContentType()</code>方法（从<code style="font-size:100%;color:black">View</code>接口继承）。JSP页面由<code style="font-size:100%;color:black">JstlView</code>呈现（由<code style="font-size:100%;color:black">InternalResourceViewResolver</code>返回），其内容类型为<code style="font-size:100%;color:navy">text/html</code> ，而<code style="font-size:100%;color:black">AccountExcelView</code>生成<code style="font-size:100%;color:navy">application/vnd.ms-excel</code> 。</p>
<p>CNVR的实际配置方式委托给<code style="font-size:100%;color:black">ContentNegotiationManager</code> ，后者通过配置程序（Java配置）或Spring的许多工厂bean（XML）之一依次创建。</p>
<p>最后一个难题是： <em>CNVR如何知道请求的内容类型</em> ？因为内容协商策略告诉它要做什么：识别URL后缀，或者URL参数或Accept标头。与上一篇<a href="http://blog.springsource.org/2013/05/11/content-negotiation-using-spring-mvc/">文章中</a>描述的策略设置完全相同，由CNVR重用。</p>
<p></p><blockquote>请注意，当Spring 3.0引入内容协商策略时，它们仅适用于选择视图。从3.2开始，这个功能就可以使用了（根据我以前的<a href="http://blog.springsource.org/2013/05/11/content-negotiation-using-spring-mvc/">文章</a> ）。本文中的示例使用Spring 3.2，并且可能与您之前看到的旧示例有所不同。特别是，大多数用于配置内容协商策略的属性现在位于<code style="font-size:100%;color:black">ContentNegotiationManagerFactoryBean</code> ，而不位于<code style="font-size:100%;color:black">ContentNegotiatingViewResolver</code> 。现在不推荐使用CNVR上的属性，而推荐使用管理器上的属性，但是CNVR本身的工作方式与以前一样。</blockquote><p></p>
<h2 id="config2">配置内容协商视图解析器</h2>
<p>默认情况下，CNVR自动检测所有定义为Spring的<code style="font-size:100%;color:black">ViewResolvers</code>并在它们之间进行协商。如果愿意，CNVR本身也具有<code style="font-size:100%;color:black">viewResolvers</code>属性，因此您可以<em>明确</em>告知要使用的视图解析器。显然，CNVR是主解析器，其他解析器从属于它。请注意，不再需要<code style="font-size:100%;color:black">order</code>属性。</p>
<pre><code class="prettyprint java"><br>@Configuration
@EnableWebMvc
public class MvcConfiguration extends WebMvcConfigurerAdapter {
 
  // .. Other methods/declarations

  /**
    * Create the CNVR.  Specify the view resolvers to use explicitly.
    * Get Spring to inject the ContentNegotiationManager created by the
    * configurer (see previous method).
    */
  @Bean
  public ViewResolver contentNegotiatingViewResolver(
                        ContentNegotiationManager manager) {
    // Define the view resolvers
    List<ViewResolver> resolvers = new ArrayList<ViewResolver>();

    XmlViewResolver r1 = new XmlViewResolver();
    resolver.setLocation(new ServletContextResource(servletContext,
            "/WEB-INF/spring/spreadsheet-views.xml"));
    resolvers.add(r1);

    InternalResourceViewResolver r2 = new InternalResourceViewResolver();
    r2.setPrefix("WEB-INF/views");
    r2.setSuffix(".jsp");
    resolvers.add(r2);

    // Create CNVR plugging in the resolvers & content-negotiation manager
    ContentNegotiatingViewResolver resolver =
                        new ContentNegotiatingViewResolver();
    resolver.setViewResolvers(resolvers);
    resolver.setContentNegotiationManager(manager);
    return resolver;
  }
}
</code></pre>
<p>或使用XML：</p>
<pre><code class="prettyprint xml"><br>  <bean class="org.springframework.web.servlet.view.
                                ContentNegotiatingViewResolver">
    <property name="contentNegotiationManager" ref="cnManager"/>

    <!-- Define the view resolvers explicitly -->
    <property name="viewResolvers">
      <list>
        <bean class="org.springframework.web.servlet.view.XmlViewResolver">
          <property name="location" value="spreadsheet-views.xml"/>
        </bean>
    
        <bean class="org.springframework.web.servlet.view.
                                InternalResourceViewResolver">
          <property name="prefix" value="WEB-INF/views"/>
          <property name="suffix" value=".jsp"/>
        </bean>
      </list>
    </property>
  </bean>
</code></pre>
<p>Github演示项目使用2套Spring配置文件。在<code style="font-size:100%;color:black">web.xml</code> ，可以分别为XML或Java配置指定<code style="font-size:100%;color:black">xml</code>或<code style="font-size:100%;color:black">javaconfig</code> 。并为它们中的任何一个指定<code style="font-size:100%;color:black">separate</code>或<code style="font-size:100%;color:black">combined</code> 。<code style="font-size:100%;color:black">separate</code>配置文件将所有视图解析器定义为顶级Bean，并允许CNVR扫描上下文以找到它们（如上一节所述）。在<code style="font-size:100%;color:black">combined</code>配置文件中，视图解析器不是显式定义为Spring Bean，而是通过其<code style="font-size:100%;color:black">viewResolvers</code>属性传递给<code style="font-size:100%;color:black">viewResolvers</code> （如本节所示）。</p>
<h2>JSON支持</h2>
<p>Spring提供了一个<code style="font-size:100%;color:black">MappingJacksonJsonView</code> ，它支持使用Jackson对象到JSON映射库从Java对象生成JSON数据。<code style="font-size:100%;color:black">MappingJacksonJsonView</code>会将模型中找到的所有属性自动转换为JSON。唯一的例外是它会忽略<code style="font-size:100%;color:black">BindingResult</code>对象，因为它们是Spring MVC表单处理的内部对象，因此不需要。</p>
<p>需要一个合适的视图解析器，而Spring没有提供。幸运的是，编写自己的代码非常简单：</p>
<pre><code class="prettyprint java"><br>public class JsonViewResolver implements ViewResolver {
    /**
     * Get the view to use.
     *
     * @return Always returns an instance of {@link MappingJacksonJsonView}.
     */
    @Override
    public View resolveViewName(String viewName, Locale locale)
                                                 throws Exception {
        MappingJacksonJsonView view = new MappingJacksonJsonView();
        view.setPrettyPrint(true);   // Lay JSON out to be nicely readable 
        return view;
    }
}
</code></pre>
<p>只需将此视图解析器声明为Spring bean，即可返回JSON格式的数据。JAF已经将<code style="font-size:100%;color:black">json</code>映射到<code style="font-size:100%;color:navy">application/json</code>所以我们完成了。像<code style="font-size:100%;color:navy"><a href="http://myserver/myapp/accounts/list.json">http://myserver/myapp/accounts/list.json</a></code>这样的URL现在可以使用JSON返回帐户信息。这是“帐户”应用程序的输出：</p>
<a href="http://blog.springsource.org/wp-content/uploads/2013/04/account-list-json.png"><img src="http://blog.springsource.org/wp-content/uploads/2013/04/account-list-json.png" alt="" title="account-list-json" width="580" class="alignright size-full wp-image-13160"></a>
<p>有关此视图的更多信息，请参见<a href="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/web/servlet/view/json/MappingJacksonJsonView.html">Spring Javadoc</a> 。</p>
<h2>XML支持</h2>
<p>有一个类似的类用于生成XML输出<a href="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/web/servlet/view/xml/MarshallingView.html">-MarshallingView</a> 。它采用模型中可以编组的第一个对象并对其进行处理。您可以通过告诉视图选择哪个Model属性（键）来选择配置视图，请参见<code style="font-size:100%;color:black">setModelKey()</code> 。</p>
<p>同样，我们需要一个视图解析器。Spring通过Spring的<a href="http://static.springsource.org/spring/docs/current/spring-framework-reference/html/oxm.html">Object to XML Marshalling（OXM）</a>抽象支持多种封送技术。让我们只使用JAXB2，因为它内置在JDK中（自JDK 6起）。这是解析器：</p>
<pre><code class="prettyprint java"><br>/**
 * View resolver for returning XML in a view-based system.
 */
public class MarshallingXmlViewResolver implements ViewResolver {

    private Marshaller marshaller;

    @Autowired
    public MarshallingXmlViewResolver(Marshaller marshaller) {
        this.marshaller = marshaller;
    }

    /**
     * Get the view to use.
     * 
     * @return Always returns an instance of {@link MappingJacksonJsonView}.
     */
    @Override
    public View resolveViewName(String viewName, Locale locale)
                                                 throws Exception {
        MarshallingView view = new MarshallingView();
        view.setMarshaller(marshaller);
        return view;
    }
}
</code></pre>
<p>同样，我的班级需要注释才能与JAXB一起使用（为回应评论，我在上一篇<a href="http://blog.springsource.org/2013/05/11/content-negotiation-using-spring-mvc/#annotated-account-class">文章</a>的末尾添加了一个示例）。</p>
<p>使用Java配置将新的解析器配置为Spring bean：</p>
<pre><code class="prettyprint java"><br>  @Bean(name = "marshallingXmlViewResolver")
  public ViewResolver getMarshallingXmlViewResolver() {
      Jaxb2Marshaller marshaller = new Jaxb2Marshaller();

      // Define the classes to be marshalled - these must have
      // @Xml... annotations on them
      marshaller.setClassesToBeBound(Account.class,
                               Transaction.class, Customer.class);
      return new MarshallingXmlViewResolver(marshaller);
  }
</code></pre>
<p>或者我们可以在XML中做同样的事情-注意oxm名称空间的使用：</p>
<pre><code class="prettyprint xml"><oxm:jaxb2-marshaller id="marshaller" >
    <oxm:class-to-be-bound name="rewardsonline.accounts.Account"/>
    <oxm:class-to-be-bound name="rewardsonline.accounts.Customer"/>
    <oxm:class-to-be-bound name="rewardsonline.accounts.Transaction"/>
</oxm:jaxb2-marshaller>

<!-- View resolver that returns an XML Marshalling view. -->
<bean class="rewardsonline.accounts.MarshallingXmlViewResolver" >
    <constructor-arg ref="marshaller"/>
</bean>
</code></pre>
<p>这是我们完成的系统：</p>
<a href="http://blog.springsource.org/wp-content/uploads/2013/06/cnvr-all-flow.png"><img src="http://blog.springsource.org/wp-content/uploads/2013/06/cnvr-all-flow.png" alt="带有CNVR和4个视图解析器的完整系统" title="cnvr全流" width="480" class="size-full wp-image-13471"></a>
<h2>比较RESTful方法</h2>
<p>使用<code style="font-size:100%;color:black">@ResponseBody</code> ， <code style="font-size:100%;color:black">@ResponseStatus</code>和其他与REST相关的MVC注释，可以完全支持MVC的RESTful方法。像这样：</p>
<pre><code class="prettyprint java"><br>@RequestMapping(value="/accounts",
                produces={"application/json", "application/xml"})
@ResponseStatus(HttpStatus.OK)
public @ResponseBody List<Account> list(Principal principal) {
    return accountManager.getAccounts(principal);
}
</code></pre>
<p>要为我们的<code style="font-size:100%;color:black">@RequestMapping</code>方法启用相同的内容协商，我们必须重用我们的内容协商管理器（这可以使<code style="font-size:100%;color:black">produces</code>选项起作用）。</p>
<pre><code class="prettyprint java"><br><mvc:annotation-driven
          content-negotiation-manager="contentNegotiationManager" />
</code></pre>
<p>但是，这会产生不同样式的Controller方法，优点是它也更强大。那么<code style="font-size:100%;color:black">@ResponseBody</code> ：Views或<code style="font-size:100%;color:black">@ResponseBody</code>呢？</p>
<p>对于已经使用Spring MVC和视图的现有网站， <code style="font-size:100%;color:black">MappingJacksonJsonView</code>和<code style="font-size:100%;color:black">MarshallingView</code>提供了一种简便的方法来扩展Web应用程序以返回JSON和/或XML。在许多情况下，这些是您唯一需要的数据格式，并且是一种支持只读移动应用程序和/或启用AJAX的网页的简便方法，其中RESTful请求仅用于<em>获取</em>数据。</p>
<p>对REST的完全支持（包括修改数据的能力）涉及将带注释的控制器方法与HTTP消息转换器一起使用。在这种情况下，使用视图没有意义，只需返回一个<code style="font-size:100%;color:black">@ResponseBody</code>对象，然后让转换器完成工作即可。</p>
<p>但是，如我之前的文章中所示<a href="javascript:void(0);" http:="" ="" blog.springsource.org="" 2013="" 05="" 11="" content-negotiation-using-spring-mvc="" #combined-controlle="=">http://blog.springsource.org/2013/05/11/content-negotiation-using-spring-mvc/#combined-controller“”</a>所示，控制器完全有可能同时使用两种方法。现在，同一控制器既可以支持传统的Web应用程序，又可以实现完整的RESTful接口，从而增强了可能已经建立和开发多年的Web应用程序。</p>
<p>Spring一直在为开发人员提供灵活性和选择力。也不例外。</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">var disqus_shortname = 'spring-io';
      var disqus_identifier = 515;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));</script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });</script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>