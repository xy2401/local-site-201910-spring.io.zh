<html  data-code-prettify="" data-mobile-support="" data-search=""><head></head><body >﻿
<title>React.js和Spring Data REST：第5部分-安全</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="React.js and Spring Data REST: Part 5 - Security">
<meta name="twitter:description" >
<meta name="twitter:creator" content="@gregturn">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/43e9a9d63f7f4f9891c9fcd592b89cfa?s=200">

<meta property="og:title" content="React.js and Spring Data REST: Part 5 - Security">
<meta property="og:image" content="https://gravatar.com/avatar/43e9a9d63f7f4f9891c9fcd592b89cfa?s=200">
<meta property="og:description" >
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2015-10-28 14:04:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">React.js和Spring Data REST：第5部分-安全</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/43e9a9d63f7f4f9891c9fcd592b89cfa?s=20&d=mm"> <a class="author" rel="author" href="/team/gturnquist">格雷格·特恩奎斯特</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2015-10-28 14:04:00.0">2015年10月28日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2015/10/28/react-js-and-spring-data-rest-part-5-security#disqus_thread" data-disqus-identifier="2288">
</a></div>
</div>
</header>
<div class="blog--post"><div id="preamble">
<div class="sectionbody">
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">要查看此代码的更新，请访问我们的<a href="https://spring.io/guides/tutorials/react-and-spring-data-rest/">React.js和Spring Data REST教程</a> 。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>在上<a href="https://spring.io/blog/2015/10/13/react-js-and-spring-data-rest-part-4-events">一个会话中</a> ，您通过Spring Data REST的内置事件处理程序和Spring Framework的WebSocket支持使应用程序动态响应其他用户的更新。但是，如果没有完整的应用程序，那么任何应用程序都是不完整的，因此只有适当的用户才能访问UI及其背后的资源。</p>
</div>
<div class="paragraph">
<p>随时从该存储库中<a href="https://github.com/gregturn/react-and-spring-data-rest/tree/master/security">获取代码</a>并继续。该会话基于上一会话的应用程序，并添加了其他内容。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_adding_spring_security_to_the_project">将Spring Security添加到项目</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在进行之前，您需要向项目的pom.xml文件中添加几个依赖项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;
    &lt;artifactId&gt;thymeleaf-extras-springsecurity4&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这引入了Spring Boot的Spring Security入门程序以及一些额外的Thymeleaf标签，以在网页中进行安全性查找。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_defining_the_security_model">定义安全模型</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在上一届会议上，您使用了不错的薪资系统。在后端声明内容并让Spring Data REST承担繁重的工作很方便。下一步是对需要建立安全控制的系统进行建模。</p>
</div>
<div class="paragraph">
<p>如果这是一个薪资系统，那么只有经理才能访问它。因此，通过建模<code>Manager</code>宾语：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Data
@ToString(exclude = "password")
@Entity
public class Manager {

	public static final PasswordEncoder PASSWORD_ENCODER = new BCryptPasswordEncoder();

	private @Id @GeneratedValue Long id;

	private String name;

	private @JsonIgnore String password;

	private String[] roles;

	public void setPassword(String password) {
		this.password = PASSWORD_ENCODER.encode(password);
	}

	protected Manager() {}

	public Manager(String name, String password, String... roles) {

		this.name = name;
		this.setPassword(password);
		this.roles = roles;
	}

}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<code>PASSWORD_ENCODER</code>是在比较之前对新密码进行加密或获取密码输入并对其进行加密的方法。
</li>
<li>
<code>id</code> ， <code>name</code> ， <code>password</code>和<code>roles</code>定义限制访问所需的参数。
</li>
<li>
<p>定制的<code>setPassword()</code>确保密码永远不会以明文形式存储。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>设计安全层时，要记住一件事。保护正确的数据位（例如密码），不要让它们被打印到控制台，日志中或通过JSON序列化导出。</p>
</div>
<div class="ulist">
<ul>
<li>
<code>@ToString(exclude = "password")</code>确保Lombok生成的toString（）方法不会打印出密码。
</li>
<li>
<code>@JsonIgnore</code>应用于密码字段可防止Jackson对该字段进行序列化。
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_creating_a_manager_s_repository">创建经理的资料库</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Data非常擅长管理实体。为什么不创建一个存储库来处理这些经理？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@RepositoryRestResource(exported = false)
public interface ManagerRepository extends Repository&lt;Manager, Long&gt; {

	Manager save(Manager manager);

	Manager findByName(String name);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>而不是扩展通常的<code>CrudRepository</code> ，则不需要太多方法。相反，您需要保存数据（也用于更新），并且需要查找现有用户。因此，您可以使用Spring Data Common的<code>Repository</code>标记界面。它没有预定义的操作。</p>
</div>
<div class="paragraph">
<p>默认情况下，Spring Data REST将导出其找到的任何存储库。您不希望此存储库公开以进行REST操作！应用<code>@RepositoryRestResource(exported = false)</code>注释以阻止其导出。这样可以防止存储库以及任何元数据被提供。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_linking_employees_with_their_managers">将员工与其经理联系起来</h2>
<div class="sectionbody">
<div class="paragraph">
<p>安全性建模的最后一点是使员工与经理相关联。在此域中，一个雇员可以有一个经理，而一个经理可以有多个雇员：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Data
@Entity
public class Employee {

	private @Id @GeneratedValue Long id;
	private String firstName;
	private String lastName;
	private String description;

	private @Version @JsonIgnore Long version;

	private @ManyToOne Manager manager;

	private Employee() {}

	public Employee(String firstName, String lastName, String description, Manager manager) {
		this.firstName = firstName;
		this.lastName = lastName;
		this.description = description;
		this.manager = manager;
	}
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>通过JPA链接到manager属性<code>@ManyToOne</code> 。经理不需要<code>@OneToMany</code>因为您还没有定义查找的必要。
</li>
<li>实用程序构造函数调用已更新以支持初始化。
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_securing_employees_to_their_managers">确保员工与经理的关系</h2>
<div class="sectionbody">
<div class="paragraph">
<p>当定义安全策略时，Spring Security支持多种选择。在此会话中，您希望限制某些事情，以便仅经理可以查看员工工资数据，并且保存，更新和删除操作仅限于员工的经理。换句话说，任何经理都可以登录并查看数据，但是只有给定员工的经理才能进行任何更改。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@PreAuthorize("hasRole('ROLE_MANAGER')")
public interface EmployeeRepository extends PagingAndSortingRepository&lt;Employee, Long&gt; {

	@Override
	@PreAuthorize("#employee?.manager == null or #employee?.manager?.name == authentication?.name")
	Employee save(@Param("employee") Employee employee);

	@Override
	@PreAuthorize("@employeeRepository.findOne(#id)?.manager?.name == authentication?.name")
	void delete(@Param("id") Long id);

	@Override
	@PreAuthorize("#employee?.manager?.name == authentication?.name")
	void delete(@Param("employee") Employee employee);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@PreAuthorize</code>界面顶部的，禁止访问具有<strong>ROLE_MANAGER的人员</strong> 。</p>
</div>
<div class="paragraph">
<p>上<code>save()</code> ，或者员工的经理为空（在未分配经理的情况下初始创建新员工），或者员工的经理名称与当前经过身份验证的用户名匹配。在这里，您使用<a href="https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#el-access">Spring Security的SpEL表达式</a>来定义访问。它带有方便的“？”。属性导航器来处理空检查。注意使用<code>@Param(…​)</code>在参数上链接HTTP操作与方法。</p>
</div>
<div class="paragraph">
<p>上<code>delete()</code> ，则该方法可以访问雇员，或者如果该方法仅具有ID，则它必须在应用程序上下文中找到<strong>employeeRepository</strong> ，然后执行<code>findOne(id)</code> ，然后针对当前经过身份验证的用户检查管理员。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_writing_a_code_userdetails_code_service">写一个<code>UserDetails</code>服务</h2>
<div class="sectionbody">
<div class="paragraph">
<p>与安全性集成的一个共同点是定义一个<code>UserDetailsService</code> 。这是将用户的数据存储连接到Spring Security界面的方法。Spring Security需要一种方法来查找用户以进行安全检查，这就是桥梁。幸运的是，对于Spring Data，所做的工作非常少：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Component
public class SpringDataJpaUserDetailsService implements UserDetailsService {

	private final ManagerRepository repository;

	@Autowired
	public SpringDataJpaUserDetailsService(ManagerRepository repository) {
		this.repository = repository;
	}

	@Override
	public UserDetails loadUserByUsername(String name) throws UsernameNotFoundException {
		Manager manager = this.repository.findByName(name);
		return new User(manager.getName(), manager.getPassword(),
				AuthorityUtils.createAuthorityList(manager.getRoles()));
	}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>SpringDataJpaUserDetailsService</code>实现Spring Security的<code>UserDetailsService</code> 。该接口有一种方法： <code>loadByUsername()</code> 。此方法旨在返回一个<code>UserDetails</code>对象，以便Spring Security可以询问用户的信息。</p>
</div>
<div class="paragraph">
<p>因为你有一个<code>ManagerRepository</code> ，则无需编写任何SQL或JPA表达式即可获取此所需数据。在此类中，它是通过构造函数注入自动装配的。</p>
</div>
<div class="paragraph">
<p><code>loadByUsername()</code>进入您刚才编写的自定义查找器， <code>findByName()</code> 。然后填充Spring Security <code>User</code>实例，它实现了<code>UserDetails</code>接口。您还在使用Spring Securiy的<code>AuthorityUtils</code>从一系列基于字符串的角色过渡到Java <code>List</code>的<code>GrantedAuthority</code> 。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_wiring_up_your_security_policy">连接您的安全策略</h2>
<div class="sectionbody">
<div class="paragraph">
<p>的<code>@PreAuthorize</code>应用于存储库的表达式是<strong>访问规则</strong> 。没有安全策略，这些规则是徒劳的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {

	@Autowired
	private SpringDataJpaUserDetailsService userDetailsService;

	@Override
	protected void configure(AuthenticationManagerBuilder auth) throws Exception {
		auth
			.userDetailsService(this.userDetailsService)
				.passwordEncoder(Manager.PASSWORD_ENCODER);
	}

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.authorizeRequests()
				.antMatchers("/bower_components/**", "/*.js",
						"/*.jsx", "/main.css").permitAll()
				.anyRequest().authenticated()
				.and()
			.formLogin()
				.defaultSuccessUrl("/", true)
				.permitAll()
				.and()
			.httpBasic()
				.and()
			.csrf().disable()
			.logout()
				.logoutSuccessUrl("/");
	}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这段代码有很多复杂性，因此让我们逐步了解一下，首先讨论注释和API。然后，我们将讨论它定义的安全策略。</p>
</div>
<div class="ulist">
<ul>
<li>
<code>@EnableWebSecurity</code>告诉Spring Boot放弃其自动配置的安全策略，而改用该策略。对于快速演示，可以自动配置安全性。但是对于任何真实的事情，您都应该自己编写策略。
</li>
<li>
<code>@EnableGlobalMethodSecurity</code>通过Spring Security复杂的<a href="https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#el-pre-post-annotations">@Pre和@Post注释</a>打开方法级安全性。
</li>
<li>它延伸<code>WebSecsurityConfigurerAdapter</code> ，方便编写策略的基类。
</li>
<li>它自动接线<code>SpringDataJpaUserDetailsService</code>通过现场注入，然后通过<code>configure(AuthenticationManagerBuilder)</code>方法。的<code>PASSWORD_ENCODER</code>从<code>Manager</code>也已设置。
</li>
<li>关键的安全策略是用纯Java编写的， <code>configure(HttpSecurity)</code> 。
</li>
</ul>
</div>
<div class="paragraph">
<p>安全策略说使用先前定义的访问规则授权所有请求。</p>
</div>
<div class="ulist">
<ul>
<li>列出的路径<code>antMatchers()</code>被授予无条件访问权限，因为没有理由阻止静态Web资源。
</li>
<li>任何不匹配的东西都会落入<code>anyRequest().authenticated()</code>表示需要验证。
</li>
<li>设置了这些访问规则后，系统将告知Spring Security使用基于表单的身份验证，成功时默认为“ /”，并授予对登录页面的访问权限。
</li>
<li>BASIC登录也配置为禁用CSRF。这主要是用于演示，不建议对生产系统进行仔细分析。
</li>
<li>注销配置为将用户带到“ /”。
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title">警告</div>
</td>
<td class="content">在尝试curl时，BASIC身份验证非常方便。使用curl访问基于表单的系统令人生畏。重要的是要认识到，通过HTTP（不是HTTPS）上的任何机制进行身份验证都会使您面临通过网络嗅探凭据的风险。CSRF是一个完整的好协议。只需禁用它即可使与BASIC的交互和卷曲更加容易。在生产中，最好将其保留。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_adding_security_details_automatically">自动添加安全详细信息</h2>
<div class="sectionbody">
<div class="paragraph">
<p>良好的用户体验是应用程序可以自动应用上下文时。在此示例中，如果已登录的经理创建了新员工记录，则该经理拥有该记录是有意义的。使用Spring Data REST的事件处理程序，用户无需显式链接它。它还可以确保用户不会意外记录到错误的管理员。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Component
@RepositoryEventHandler(Employee.class)
public class SpringDataRestEventHandler {

	private final ManagerRepository managerRepository;

	@Autowired
	public SpringDataRestEventHandler(ManagerRepository managerRepository) {
		this.managerRepository = managerRepository;
	}

	@HandleBeforeCreate
	public void applyUserInformationUsingSecurityContext(Employee employee) {

		String name = SecurityContextHolder.getContext().getAuthentication().getName();
		Manager manager = this.managerRepository.findByName(name);
		if (manager == null) {
			Manager newManager = new Manager();
			newManager.setName(name);
			newManager.setRoles(new String[]{"ROLE_MANAGER"});
			manager = this.managerRepository.save(newManager);
		}
		employee.setManager(manager);
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@RepositoryEventHandler(Employee.class)</code>将此事件处理程序标记为仅应用于<code>Employee</code>对象。的<code>@HandleBeforeCreate</code>注释使您有机会更改传入的<code>Employee</code>在将其写入数据库之前进行记录。</p>
</div>
<div class="paragraph">
<p>在此情况下，您将查找当前用户的安全上下文以获取用户名。然后使用<code>findByName()</code>并将其应用于经理。如果系统中尚不存在新的管理员，则可以使用一些额外的胶水代码来创建新的管理员。但这主要是为了支持数据库的初始化。在实际的生产系统中，应删除该代码，而应依赖DBA或Security Ops团队来正确维护用户数据存储。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_pre_loading_manager_data">预加载经理数据</h2>
<div class="sectionbody">
<div class="paragraph">
<p>加载经理并将员工与这些经理联系起来很简单：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Component
public class DatabaseLoader implements CommandLineRunner {

	private final EmployeeRepository employees;
	private final ManagerRepository managers;

	@Autowired
	public DatabaseLoader(EmployeeRepository employeeRepository,
						  ManagerRepository managerRepository) {

		this.employees = employeeRepository;
		this.managers = managerRepository;
	}

	@Override
	public void run(String... strings) throws Exception {

		Manager greg = this.managers.save(new Manager("greg", "turnquist",
							"ROLE_MANAGER"));
		Manager oliver = this.managers.save(new Manager("oliver", "gierke",
							"ROLE_MANAGER"));

		SecurityContextHolder.getContext().setAuthentication(
			new UsernamePasswordAuthenticationToken("greg", "doesn't matter",
				AuthorityUtils.createAuthorityList("ROLE_MANAGER")));

		this.employees.save(new Employee("Frodo", "Baggins", "ring bearer", greg));
		this.employees.save(new Employee("Bilbo", "Baggins", "burglar", greg));
		this.employees.save(new Employee("Gandalf", "the Grey", "wizard", greg));

		SecurityContextHolder.getContext().setAuthentication(
			new UsernamePasswordAuthenticationToken("oliver", "doesn't matter",
				AuthorityUtils.createAuthorityList("ROLE_MANAGER")));

		this.employees.save(new Employee("Samwise", "Gamgee", "gardener", oliver));
		this.employees.save(new Employee("Merry", "Brandybuck", "pony rider", oliver));
		this.employees.save(new Employee("Peregrin", "Took", "pipe smoker", oliver));

		SecurityContextHolder.clearContext();
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>一个麻烦是，当此加载程序运行时，Spring Security在启用访问规则的情况下将处于活动状态。因此，要保存员工数据，您必须使用Spring Security的<code>setAuthentication()</code>用于使用正确的名称和角色对该加载程序进行身份验证的API。最后，清除安全上下文。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_touring_your_secured_rest_service">游览您的安全REST服务</h2>
<div class="sectionbody">
<div class="paragraph">
<p>放置所有这些模块后，您可以启动应用程序（ <code>./mvnw spring-boot:run</code> ），并使用cURL检出mod。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl -v -u greg:turnquist localhost:8080/api/employees/1
*   Trying ::1...
* Connected to localhost (::1) port 8080 (#0)
* Server auth using Basic with user 'greg'
&gt; GET /api/employees/1 HTTP/1.1
&gt; Host: localhost:8080
&gt; Authorization: Basic Z3JlZzp0dXJucXVpc3Q=
&gt; User-Agent: curl/7.43.0
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 200 OK
&lt; Server: Apache-Coyote/1.1
&lt; X-Content-Type-Options: nosniff
&lt; X-XSS-Protection: 1; mode=block
&lt; Cache-Control: no-cache, no-store, max-age=0, must-revalidate
&lt; Pragma: no-cache
&lt; Expires: 0
&lt; X-Frame-Options: DENY
&lt; Set-Cookie: JSESSIONID=E27F929C1836CC5BABBEAB78A548DF8C; Path=/; HttpOnly
&lt; ETag: "0"
&lt; Content-Type: application/hal+json;charset=UTF-8
&lt; Transfer-Encoding: chunked
&lt; Date: Tue, 25 Aug 2015 15:57:34 GMT
&lt;
{
  "firstName" : "Frodo",
  "lastName" : "Baggins",
  "description" : "ring bearer",
  "manager" : {
    "name" : "greg",
    "roles" : [ "ROLE_MANAGER" ]
  },
  "_links" : {
    "self" : {
      "href" : "http://localhost:8080/api/employees/1"
    }
  }
}</pre>
</div>
</div>
<div class="paragraph">
<p>与第一个会话相比，这显示了更多细节。首先，Spring Security启用了几种HTTP协议来防御各种攻击媒介（编译指示，过期，X-Frame-Options等）。您还将通过以下方式发行BASIC凭证： <code>-u greg:turnquist</code>呈现Authorization标头。</p>
</div>
<div class="paragraph">
<p>在所有标题中，您可以从版本化资源中看到<strong>ETag</strong>标题。</p>
</div>
<div class="paragraph">
<p>最后，在数据本身内部，您可以看到一个新属性： <strong>manager</strong> 。您可以看到它包含名称和角色，但不包含密码。那是由于使用<code>@JsonIgnore</code>在那个领域。由于Spring Data REST并未导出该存储库，因此在该资源中内联了它的值。在下一节中更新UI时，将充分利用它。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_displaying_manager_info_on_the_ui">在界面上显示经理信息</h2>
<div class="sectionbody">
<div class="paragraph">
<p>有了所有这些mod的后端，您现在就可以转移到更新前端中的内容。首先，在`里面显示一个员工的经理<employee></employee> `React组件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">var Employee = React.createClass({
    handleDelete: function () {
        this.props.onDelete(this.props.employee);
    },
    render: function () {
        return (
            &lt;tr&gt;
                &lt;td&gt;{this.props.employee.entity.firstName}&lt;/td&gt;
                &lt;td&gt;{this.props.employee.entity.lastName}&lt;/td&gt;
                &lt;td&gt;{this.props.employee.entity.description}&lt;/td&gt;
                &lt;td&gt;{this.props.employee.entity.manager.name}&lt;/td&gt;
                &lt;td&gt;
                    &lt;UpdateDialog employee={this.props.employee}
                                  attributes={this.props.attributes}
                                  onUpdate={this.props.onUpdate}/&gt;
                &lt;/td&gt;
                &lt;td&gt;
                    &lt;button onClick={this.handleDelete}&gt;Delete&lt;/button&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
        )
    }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>这只是为<code>this.props.employee.entity.manager.name</code> 。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_filtering_out_json_schema_metadata">过滤出JSON模式元数据</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果数据输出中显示了一个字段，则可以假定它在JSON模式元数据中有一个条目。您可以在以下摘录中看到它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>{
	...
    "manager" : {
      "readOnly" : false,
      "$ref" : "#/descriptors/manager"
    },
    ...
  },
  ...
  "$schema" : "http://json-schema.org/draft-04/schema#"
}</pre>
</div>
</div>
<div class="paragraph">
<p>管理员字段不是您希望人们直接编辑的内容。由于是内联的，因此应将其视为只读属性。要从中过滤掉内联条目<code>CreateDialog</code>和<code>UpdatDialog</code> ，只需在获取JSON Schema元数据后删除此类条目即可。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">/**
 * Filter unneeded JSON Schema properties, like uri references and
 * subtypes ($ref).
 */
Object.keys(schema.entity.properties).forEach(function (property) {
    if (schema.entity.properties[property].hasOwnProperty('format') &amp;&amp;
        schema.entity.properties[property].format === 'uri') {
        delete schema.entity.properties[property];
    }
    if (schema.entity.properties[property].hasOwnProperty('$ref')) {
        delete schema.entity.properties[property];
    }
});

this.schema = schema.entity;
this.links = employeeCollection.entity._links;
return employeeCollection;</code></pre>
</div>
</div>
<div class="paragraph">
<p>此代码修剪掉URI关系以及$ ref条目。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_trapping_for_unauthorized_access">诱捕未经授权的访问</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在后端配置了安全检查之后，添加一个处理程序，以防有人尝试未经授权而更新记录：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">onUpdate: function (employee, updatedEmployee) {
    client({
        method: 'PUT',
        path: employee.entity._links.self.href,
        entity: updatedEmployee,
        headers: {
            'Content-Type': 'application/json',
            'If-Match': employee.headers.Etag
        }
    }).done(response =&gt; {
        /* Let the websocket handler update the state */
    }, response =&gt; {
        if (response.status.code === 403) {
            alert('ACCESS DENIED: You are not authorized to update ' +
                employee.entity._links.self.href);
        }
        if (response.status.code === 412) {
            alert('DENIED: Unable to update ' + employee.entity._links.self.href +
                '. Your copy is stale.');
        }
    });
},</code></pre>
</div>
</div>
<div class="paragraph">
<p>您有捕获HTTP 412错误的代码。这将捕获HTTP 403状态代码并提供适当的警报。</p>
</div>
<div class="paragraph">
<p>对删除操作执行相同的操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">onDelete: function (employee) {
    client({method: 'DELETE', path: employee.entity._links.self.href}
    ).done(response =&gt; {/* let the websocket handle updating the UI */},
    response =&gt; {
        if (response.status.code === 403) {
            alert('ACCESS DENIED: You are not authorized to delete ' +
                employee.entity._links.self.href);
        }
    });
},</code></pre>
</div>
</div>
<div class="paragraph">
<p>这与定制的错误消息类似地编码。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_add_some_security_details_to_the_ui">向用户界面添加一些安全细节</h2>
<div class="sectionbody">
<div class="paragraph">
<p>冠上该版本应用程序的最后一件事是显示谁登录以及提供注销按钮。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;div&gt;
    Hello, &lt;span th:text="${#authentication.name}"&gt;user&lt;/span&gt;.
    &lt;form th:action="@{/logout}" method="post"&gt;
        &lt;input type="submit" value="Log Out"/&gt;
    &lt;/form&gt;
&lt;/div&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_putting_it_all_together">放在一起</h2>
<div class="sectionbody">
<div class="paragraph">
<p>通过前端中的这些更改，重新启动应用程序并导航到<a href="http://localhost:8080" class="bare">http：// localhost：8080</a> 。</p>
</div>
<div class="paragraph">
<p>您将立即重定向到登录表单。该表格由Spring Security提供，不过您可以根据需要<a href="https://spring.io/guides/gs/securing-web/">创建自己的</a>表格。以greg / turnquist登录。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://github.com/gregturn/react-and-spring-data-rest/raw/master/security/images/security-1.png" alt="安全1">
</div>
</div>
<div class="paragraph">
<p>您可以看到新添加的管理员列。浏览几页，直到找到由<strong>Oliver</strong>拥有的雇员。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://github.com/gregturn/react-and-spring-data-rest/raw/master/security/images/security-2.png" alt="安全2">
</div>
</div>
<div class="paragraph">
<p>单击<strong>更新</strong> ，进行一些更改，然后单击<strong>更新</strong> 。它应该失败，并显示以下弹出窗口：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://github.com/gregturn/react-and-spring-data-rest/raw/master/security/images/security-3.png" alt="安全3">
</div>
</div>
<div class="paragraph">
<p>如果尝试<strong>Delete</strong> ，它将失败并显示类似消息。创建一个新员工，应将其分配给您。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_review">评论</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在此会话中：</p>
</div>
<div class="ulist">
<ul>
<li>您定义了经理模型，并通过一对多关系将其链接到员工。
</li>
<li>您为经理创建了一个存储库，并告诉Spring Data REST不要导出。
</li>
<li>您为empoyee存储库编写了一组访问规则，还编写了安全策略。
</li>
<li>您编写了另一个Spring Data REST事件处理程序，以在创建事件发生之前捕获它们，以便可以将当前用户分配为员工的经理。
</li>
<li>您更新了UI，以显示员工的经理，并且在采取未经授权的操作时还显示错误弹出窗口。
</li>
</ul>
</div>
<div class="paragraph">
<p>有问题吗？</p>
</div>
<div class="paragraph">
<p>该网页已变得非常复杂。但是，如何管理关系和内联数据呢？创建/更新对话框并不十分适合。它可能需要一些自定义的书面形式。</p>
</div>
<div class="paragraph">
<p>经理有权访问员工数据。员工应该有访问权限吗？如果要添加更多详细信息，例如电话号码和地址，您将如何建模？您将如何授予员工访问系统的权限，以便他们可以更新那些特定字段？是否还有其他易于在页面上放置的超媒体控件？我希望你喜欢这个系列。</p>
</div>
</div>
</div></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 2288;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>