<!doctype html><html data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>Spring XD Benchmarks Part 1</title>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no" id="Viewport" name="viewport">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="https://fonts.googleapis.com/css?family=Varela+Round|Montserrat:400,700" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>System.config({baseURL: "/b92013b"});</script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>System.import('app/main.js')</script>
<meta content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M" name="google-site-verification">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta content="summary" name="twitter:card">
<meta content="@springcentral" name="twitter:site">
<meta name="twitter:title" content="Spring XD Benchmarks Part 1">
<meta name="introduction" content="<h1><a href=" #introduction" class="anchor"></head><body>Introduction
<p>A common question when developing streaming applications is, “How many events per second can you process?”. The primary purpose of this blog post is to answer that question without falling into the classic benchmarking <a href="https://twitter.com/mipsytipsy/status/605861025200472064">conundrum</a> of benchmarking versus “benchmarketing”. The common approach with ‘native’ benchmarking applications provide by messaging middleware vendors is to focus on raw data transport speed, without serialization or deserialization of the message data and without any data processing. In Part 1 of the series, we will follow this approach.</p>
">
<meta name="twitter:creator" content="@cppwfs">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/7881b619a0163626e6d7fefc7c43597d?s=200">

<meta property="og:title" content="Spring XD Benchmarks Part 1">
<meta property="og:image" content="https://gravatar.com/avatar/7881b619a0163626e6d7fefc7c43597d?s=200">
<meta property="og:description" content="<h1><a href=" #introduction" class="anchor" name="introduction">Introduction
<p>A common question when developing streaming applications is, “How many events per second can you process?”. The primary purpose of this blog post is to answer that question without falling into the classic benchmarking <a href="https://twitter.com/mipsytipsy/status/605861025200472064">conundrum</a> of benchmarking versus “benchmarketing”. The common approach with ‘native’ benchmarking applications provide by messaging middleware vendors is to focus on raw data transport speed, without serialization or deserialization of the message data and without any data processing. In Part 1 of the series, we will follow this approach.</p>
">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2015-06-17 00:40:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" style="display:none;visibility:hidden" width="0"></iframe></noscript>

<script type="text/javascript">// Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }</script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">Projects</a>
</li>
<li class="navbar-link">
<a href="/guides">Guides</a>
</li>
<li class="navbar-link active">
<a href="/blog">Blog</a>
</li>
<li class="navbar-link">
<a href="/services">Training & Certification</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form action="/search" class="form-inline form-search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search for documentation, guides, and posts..." type="text" value="">
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form action="/search" class="form-inline form-search" method="get">
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">
Home
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">
Projects
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">
Guides
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">
Blog
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">
Training & Certification
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>Engineering</div>
</div>
<div class="blog-category content--title">
<div>Releases</div>
</div>
<div class="blog-category content--title">
<div>News and Events</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Spring XD Benchmarks Part 1</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">Engineering</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/7881b619a0163626e6d7fefc7c43597d?s=20&d=mm">
<a class="author" rel="author" href="/team/grenfro">Glenn Renfro</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2015-06-17 00:40:00.0">June 17, 2015</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" data-disqus-identifier="2166" href="/blog/2015/06/17/spring-xd-benchmarks-part-1#disqus_thread">
</a></div>
</div>
</header>
<div class="blog--post"><h1><a href="#introduction" class="anchor" name="introduction"></a>Introduction</h1><p>A common question when developing streaming applications is, “How many events per second can you process?”. The primary purpose of this blog post is to answer that question without falling into the classic benchmarking <a href="https://twitter.com/mipsytipsy/status/605861025200472064">conundrum</a> of benchmarking versus “benchmarketing”. The common approach with ‘native’ benchmarking applications provide by messaging middleware vendors is to focus on raw data transport speed, without serialization or deserialization of the message data and without any data processing. In Part 1 of the series, we will follow this approach.</p><p>Our tests used direct binding (in-memory) and Apache KafkaⓇ transports in Spring XD in the scenario where the producer and consumer are running simultaneously. This test scenario simulates real-time stream processing versus having a producer only or consumer only suite of tests. The test scenarios use a single container for direct binding and multiple containers when using the Kafka transport. Each test varied the event (message) size and the results are shown in total messages and MB’s consumed per second. In the case of the Kafka transport tests, we used Kafka’s provided performance tools to provide to us a baseline benchmark for the infrastructure that was provisioned.</p><h2><a href="#what-is-spring-xd" class="anchor" name="what-is-spring-xd"></a>What is Spring XD?</h2><p>Spring XD is a unified, distributed, and extensible system for data ingestion, real time analytics, batch processing, and data export. The project’s goal is to simplify the development of big data or Enterprise streaming/batch applications. More information on XD can be found <a href="https://projects.spring.io/spring-xd/">here</a>.</p><h2><a href="#architecture" class="anchor" name="architecture"></a>Architecture</h2><p>All tests were run using RackSpace OnMetal servers to guarantee network speed for all services and provide appropriate disk write speed for our Kafka based tests. See below for additional details on this choice. The specs for the servers used are as follows:</p><h3><a href="#server-instance-types" class="anchor" name="server-instance-types"></a>Server Instance Types</h3>
<ul>
<li>OnMetal Compute Instances for Spring XD
<ul>
<li>Intel® Xeon® E5-2680 v2 2.8Ghz</li>
<li>1x10 Core</li>
<li>32GB RAM</li>
<li>Boot device (32GB SATADOM)</li>
</ul></li>
<li>OnMetal IO instances for Kafka
<ul>
<li>Intel® Xeon® E5-2680 v2 2.8Ghz</li>
<li>1x10 Core</li>
<li>128 GB RAM</li>
<li>Boot device (32GB SATADOM)</li>
<li>Dual 1.6 TB PCIe flash cards (Data Disks)</li>
</ul></li>
<li>Rackspace Compute V1 for Zookeeper (a smaller instance type was used, because Zookeeper does not have a large footprint)
<ul>
<li>2vCPUs</li>
<li>3.75GB RAM</li>
<li>Boot Device (50 GB High Performance SSD)</li>
</ul></li>
</ul><h3><a href="#network" class="anchor" name="network"></a>Network:</h3><p>All of the tests ran Spring XD on a 10 Gigabit Network with an average speed of 1117 MB/s or 8.936 Gbps. We used iperf to determine network performance using the following command for the client <code>iperf -c 
<ip of the iperf server>
  -f Mbytes
</ip></code> and <code>iperf -s</code> for the server.</p><h3><a href="#disk" class="anchor" name="disk"></a>Disk:</h3><p>All tests that required high performance disk writes were implemented on the OnMetal IO data disks. The average disk write speed for these devices was approx. ~934 MB/s. The command used to verify the disk write speed was <code>dd if=/dev/zero of=/data1/largefile bs=1M count=10000 conv=fdatasync</code>. The fdatasync on the dd command requires a complete “sync” right before it exits, thus verifying data is written completely on the disk versus the cache.</p><h2><a href="#tools" class="anchor" name="tools"></a>Tools</h2><p>The two primary tools used to test transports were the <a href="https://github.com/spring-projects/spring-xd-modules/tree/master/load-generator-source">load-generator</a> source and <a href="https://github.com/spring-projects/spring-xd-modules/tree/master/throughput">throughput</a> sink modules that can be found on github in the <a href="https://github.com/spring-projects/spring-xd-modules">spring-xd-modules</a> project. The load-generator source module generates data in-memory and can be configured to send a specific number of messages of a certain size. The throughput module is a sink that counts received messages and periodically reports the witnessed throughput to the log.</p><h1><a href="#transport-tests" class="anchor" name="transport-tests"></a>Transport Tests</h1><h2><a href="#direct-binding-transport" class="anchor" name="direct-binding-transport"></a>Direct Binding Transport</h2><p>To eliminate network latency, it is sometimes desirable to allow co-located, contiguous modules to communicate directly, rather than by using the configured remote transport. Spring XD creates direct bindings by default only in cases where every “pair” of producers and consumers (modules bound on either side of a pipe) are guaranteed to be co-located in the same JVM. The purpose of this benchmark is to show message throughput of a single XD-Container using direct binding. In this scenario we sent and consumed 500 million messages in a single container. The following stream definition was used to capture the results results for the 1000 byte message test:<br><code>stream create directBindingTest –definition “load-generator –messageCount=500000000 –messageSize=1000 | throughput”</code><br><code>stream deploy directBindingTest –properties module.*.count=0</code><br>The diagrams below show the Messages/MB per second with message sizes of 100, 1000, 10000 and 100000 bytes:</p><h3><a href="#messages-per-second" class="anchor" name="messages-per-second"></a>Messages Per Second</h3><p><img src="https://github.com/markpollack/spring-xd-images/blob/master/directbindingmsgspersec.png?raw=true" alt="Direct Binding Msgs Per Second"></p><h3><a href="#megabytes-per-second" class="anchor" name="megabytes-per-second"></a>Megabytes Per Second</h3><p><img src="https://github.com/markpollack/spring-xd-images/blob/master/directbindingmbspersecond.png?raw=true" alt="Direct Binding Mb Per Second"></p>
<table>
<thead>
<tr>
<th>Message Size </th>
<th>Messages Per Second XD </th>
<th>MB Per Second XD </th>
</tr>
</thead>
<tbody>
<tr>
<td>100 </td>
<td>12,919,560 </td>
<td>1,232 </td>
</tr>
<tr>
<td>1,000 </td>
<td>5,126,920 </td>
<td>4,893 </td>
</tr>
<tr>
<td>10,000 </td>
<td>1,121,921 </td>
<td>10,699 </td>
</tr>
<tr>
<td>100,000 </td>
<td>152,364 </td>
<td>14,530 </td>
</tr>
</tbody>
</table><p>The graphs show that rates decrease as message size increases, but overall data throughput increases. For typical size payloads in the range of 100 to 1,000 bytes we are able to push 5-12 million events second using a single thread. The cost of doing small operations at this scale, such as accessing data in a hashtable, means that any data processing will bring the rates down significantly.</p><h2><a href="#kafka-transport" class="anchor" name="kafka-transport"></a>Kafka Transport</h2><h3><a href="#testing-topology" class="anchor" name="testing-topology"></a>Testing Topology</h3><p>For testing with Kafka we created the following topology:<br></p><figure><br><img src="https://github.com/markpollack/spring-xd-images/blob/master/xdkafkadeployment.jpg?raw=true" alt="Topology"><br><figcaption>Test Topology with Spring XD and Kafka</figcaption><br></figure><p></p><p>A three broker Kafka cluster was set up on the three OnMetal I/O instances. Each Kafka instance has two SSDs with no RAID. One Zookeeper instance was shared between the Kafka brokers and XD and was deployed on an Compute v1 Rackspace instance. The XD Cluster was deployed on 2 OnMetal Compute instances. RS(RackSpace) Instance One hosted, one XD-Admin, one HSQLDB and one xd-container. RS(RackSpace) Instance Two hosted one xd-container. </p><h4><a href="#instance-type-selection" class="anchor" name="instance-type-selection"></a>Instance Type Selection</h4><p>Instance types were selected based on processor speed, disk write speed, and a network that could handle the volume of data. Originally the tests were slated for EC2 but we found that the ephemeral disk write speeds were too slow (approx. ~75 MB/s) for Kafka to perform at its peak. We plan to re-run tests on the newly released D2 instance types. We decided to use Rackspace OnMetal I/O to take advantage of the high performance SSD’s (approx. ~934 MB/s). </p><h4><a href="#tests" class="anchor" name="tests"></a>Tests</h4><p>The purpose of this benchmark is to show message throughput of a source (publisher) and sink (consumer) running on two different XD containers on different machines using Kafka as a transport.<br>The goal for this benchmark was to capture the native statistics from Kafka’s own testing tools and compare them to Spring XD’s results for the same set of tests. This comparison is important in that XD does not use the standard Kafka Consumer API but rather the <a href="https://github.com/spring-projects/spring-integration-kafka">Spring Integration Kafka Adapter</a> that adds additional capabilities such as control over what offset to consume from and which partitions to consume from a topic.<br>In each case a topic would be created with six partitions with a replication factor of three. The producer would be placed on RS Instance One and the consumer would be on RS Instance Two. All payloads for these tests operate only with byte array data. Thus for these tests Spring XD has the Kafka transport mode set to raw. Raw mode indicates Spring XD will not embed headers and will leave the handling of serialization to the user. </p><h4><a href="#kafka-native-tests" class="anchor" name="kafka-native-tests"></a>Kafka Native Tests</h4><p>Using Kafka’s performance tools in the same manner as demonstrated in <a href="https://engineering.linkedin.com/kafka/benchmarking-apache-kafka-2-million-writes-second-three-cheap-machines">Benchmarking Apache Kafka: 2 Million Writes Per Second</a> we wished to identify the base speed of the Kafka cluster. In the example below the following producer/consumer commands were used for these results for the 1000 byte message test:</p><p>Producer:<br><code>./bin/kafka-topics.sh –zookeeper 
<ip>
 :2181 –create –topic $1 –partitions 6 –replication-factor 3 
</ip></code><br><code>./bin/kafka-run-class.sh org.apache.kafka.clients.tools.ProducerPerformance $1 300000000 1000 -1 acks=1 bootstrap.servers=
<ip>
 :9092,
 <ip>
  :9092,
  <ip>
   1:9092 batch.size=128000 
  </ip>
 </ip>
</ip></code><br>Consumer:<br><code>./bin/kafka-run-class.sh ./bin/kafka-consumer-perf-test.sh –zookeeper 
<ip>
 :2181 –messages 300000000 –topic $1 –threads 1 
</ip></code></p><h4><a href="#xd-tests-using-kafka-as-transport" class="anchor" name="xd-tests-using-kafka-as-transport"></a>XD Tests using Kafka as transport</h4><p>Spring XD 1.2 uses the new <a href="https://github.com/spring-projects/spring-integration-kafka">Spring Integration Kafka adapter</a>, which offers a richer set of features than that of the standard Kafka client library. The configuration for XD was out of the box except we set the following configurations in the servers.yml to match those used in the native tests:</p>
<ol>
<li>xd.transport to kafka</li>
<li>xd.messagebus.kafka.zkAddress to the shared ZooKeeper URL</li>
<li>xd.messagebus.kafka.brokers to the kafka broker URLs</li>
<li>xd.messagebus.kafka.mode to raw, since we were transferring raw data</li>
<li>xd.messagebus.kafka.batchSize to 128000</li>
<li>xd.messagebus.kafka.default.minPartitionCount to 6</li>
<li>xd.messagebus.kafka.default.replicationFactor to 3</li>
<li>zk.client.connect to the shared ZooKeeper URL</li>
</ol><p>To read more about these configurations please review our documentation located <a href="https://docs.spring.io/spring-xd/docs/1.2.0.RELEASE/reference/html/#_server_configuration">here</a>.</p><p>The following stream was used for these results for the 1000 byte message test:<br><code>stream create myTest –definition “load-generator –messageCount=300000000 –messageSize=1000 | throughput”</code><br><code>stream deploy myTest</code></p><h4><a href="#throughput" class="anchor" name="throughput"></a>Throughput</h4><h5><a href="#messages-per-second" class="anchor" name="messages-per-second"></a>Messages Per Second</h5><p><img src="https://github.com/markpollack/spring-xd-images/blob/master/xdkafkamsgs.png?raw=true" alt="KafkaMsgsPerSecond"></p>
<table>
<thead>
<tr>
<th>Message Size </th>
<th>Messages Per Second Kafka Client </th>
<th>Messages Per Second XD </th>
</tr>
</thead>
<tbody>
<tr>
<td>100 </td>
<td>2,567,657 </td>
<td>2,348,289 </td>
</tr>
<tr>
<td>1,000 </td>
<td>592,881 </td>
<td>562,113 </td>
</tr>
<tr>
<td>10,000 </td>
<td>64,806 </td>
<td>61,985 </td>
</tr>
<tr>
<td>100,000 </td>
<td>6,505 </td>
<td>6,341 </td>
</tr>
</tbody>
</table><h5><a href="#messages-per-second" class="anchor" name="messages-per-second"></a>Messages Per Second</h5><p><img src="https://github.com/markpollack/spring-xd-images/blob/master/xdkafkambs.png?raw=true" alt="KafkaMbPerSecond"></p>
<table>
<thead>
<tr>
<th>Message Size </th>
<th>Mb Per Second Kafka Client </th>
<th>Mb Per Second XD </th>
</tr>
</thead>
<tbody>
<tr>
<td>100 </td>
<td>245 </td>
<td>224 </td>
</tr>
<tr>
<td>1,000 </td>
<td>565 </td>
<td>536 </td>
</tr>
<tr>
<td>10,000 </td>
<td>618 </td>
<td>591 </td>
</tr>
<tr>
<td>100,000 </td>
<td>611 </td>
<td>605 </td>
</tr>
</tbody>
</table><p>As in the direct binding benchmark, the graphs show that as message size increases, rates decrease but overall data throughput increases. For typical size payloads in the range of 100 to 1,000 bytes we are able to push 600K to ~2 million events per second using a single thread. It is important to note that Spring XD’s benchmarks - based on a more feature rich consumer library - were within 8% of the Kafka native client API’s benchmarks. Also note that between 1000 and 10,000 byte message sizes a single producer can reach about half of the 10Gb network capacity. In future tests we will show benchmarks of multiple producers and consumers to show how XD scales up and how other tuning parameters such as batch size impact performance.</p><h1><a href="#conclusion" class="anchor" name="conclusion"></a>Conclusion</h1><p>The benchmarks above show that Spring XD can meet high performance streaming use-case requirements. They also show that Spring XD which uses the <a href="https://docs.spring.io/spring-xd/docs/current-SNAPSHOT/reference/html/#_server_configuration">Spring Integration Kafka</a> (SIK) client library introduces very little overhead as compared to the native Kafka high level consumer library, while providing added functionality such as control over offsets and partitions. Thus you can take advantage of using the Spring XD programming model as well as functionality in the SIK consumer API with minimal impact to performance. </p><h1><a href="#next-steps" class="anchor" name="next-steps"></a>Next steps</h1><p>While there are some use-cases that are mostly data passthrough-centric, most use cases will involve some processing of the payload. Also, we only used a single processing thread. In future blog posts we will show how XD scales up with more container instances, how message rates are impacted while deserializing/serializing objects using popular libraries and how multiple threads and reactive programming can also help to increase rates per JVM process. Stay tuned!</p><p><em>Editor’s Note: ©2015 Pivotal Software, Inc. All rights reserved. Apache and Apache Kafka, are either registered trademarks or trademarks of the Apache Software Foundation in the United States and/or other countries.</em></p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">var disqus_shortname = 'spring-io';
      var disqus_identifier = 2166;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>
Back
</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">All Posts</a>
<a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">Engineering</a>
<a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">Releases</a>
<a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">News and Events</a>
<a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>Get updates from The Spring Team delivered to your inbox</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });</script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">Tools</a></li>
<li><a href="https://store.pivotal.io/">Store</a></li>
<li><a href="/blog">Newsletter</a></li>
</ul>
</div>
</div>
© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a>, Inc. All Rights Reserved.
<a href="https://pivotal.io/terms-of-use">Terms of Use</a> •
<a href="https://pivotal.io/privacy-policy">Privacy</a> •
<a href="/trademarks">Trademark Guidelines</a>
<div id="teconsent" style="display:inline-block;"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>