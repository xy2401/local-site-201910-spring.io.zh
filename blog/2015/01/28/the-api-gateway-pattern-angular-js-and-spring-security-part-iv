<!DOCTYPE html>
<html data-code-prettify="" data-mobile-support="" data-search="">
<head>
<title>The API Gateway Pattern: Angular JS and Spring Security Part IV</title>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no" id="Viewport" name="viewport" />
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png" />
<link href="https://fonts.googleapis.com/css?family=Varela+Round|Montserrat:400,700" rel="stylesheet" type="text/css" />
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css" />
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M" name="google-site-verification" />

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css" />

<meta content="summary" name="twitter:card" />
<meta content="@springcentral" name="twitter:site" />
<meta name="twitter:title" content="The API Gateway Pattern: Angular JS and Spring Security Part IV" />
<meta name="twitter:description" content="&lt;blockquote&gt;
 &lt;p&gt;Note: the source code and test for this blog continue to evolve, but the changes to the text are not being maintained here. Please see &lt;a href=&quot;https://spring.io/guides/tutorials/spring-security-and-angular-js/&quot;&gt;the tutorial version&lt;/a&gt; for the most up to date content.&lt;/p&gt; 
&lt;/blockquote&gt;
&lt;p&gt;In this article we continue &lt;a href=&quot;http://spring.io/blog/2015/01/20/the-resource-server-angular-js-and-spring-security-part-iii&quot; title=&quot;Third Article in the Series&quot;&gt;our discussion&lt;/a&gt; of how to use &lt;a href=&quot;http://projects.spring.io/spring-security&quot;&gt;Spring Security&lt;/a&gt; with &lt;a href=&quot;http://angularjs.org&quot;&gt;Angular JS&lt;/a&gt; in a “single page application”. Here we show how to build an API Gateway to control the authentication and access to the backend resources using &lt;a href=&quot;http://projects.spring.io/spring-cloud/&quot;&gt;Spring Cloud&lt;/a&gt;. This is the fourth in a series of articles, and you can catch up on the basic building blocks of the application or build it from scratch by reading the &lt;a href=&quot;http://spring.io/blog/2015/01/12/spring-and-angular-js-a-secure-single-page-application&quot; title=&quot;First Article in the Series&quot;&gt;first article&lt;/a&gt;, or you can just go straight to the &lt;a href=&quot;https://github.com/dsyer/spring-security-angular/tree/master/proxy&quot;&gt;source code in Github&lt;/a&gt;. In the &lt;a href=&quot;http://spring.io/blog/2015/01/20/the-resource-server-angular-js-and-spring-security-part-iii&quot; title=&quot;Third Article in the Series&quot;&gt;last article&lt;/a&gt; we built a simple distributed application that used &lt;a href=&quot;https://github.com/spring-projects/spring-session/&quot;&gt;Spring Session&lt;/a&gt; to authenticate the backend resources. In this one we make the UI server into a reverse proxy to the backend resource server, fixing the issues with the last implementation (technical complexity introduced by custom token authentication), and giving us a lot of new options for controlling access from the browser client.&lt;/p&gt;
" />
<meta name="twitter:creator" content="@david_syer" />
<meta name="twitter:image:src" content="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=200" />

<meta property="og:title" content="The API Gateway Pattern: Angular JS and Spring Security Part IV" />
<meta property="og:image" content="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=200" />
<meta property="og:description" content="&lt;blockquote&gt;
 &lt;p&gt;Note: the source code and test for this blog continue to evolve, but the changes to the text are not being maintained here. Please see &lt;a href=&quot;https://spring.io/guides/tutorials/spring-security-and-angular-js/&quot;&gt;the tutorial version&lt;/a&gt; for the most up to date content.&lt;/p&gt; 
&lt;/blockquote&gt;
&lt;p&gt;In this article we continue &lt;a href=&quot;http://spring.io/blog/2015/01/20/the-resource-server-angular-js-and-spring-security-part-iii&quot; title=&quot;Third Article in the Series&quot;&gt;our discussion&lt;/a&gt; of how to use &lt;a href=&quot;http://projects.spring.io/spring-security&quot;&gt;Spring Security&lt;/a&gt; with &lt;a href=&quot;http://angularjs.org&quot;&gt;Angular JS&lt;/a&gt; in a “single page application”. Here we show how to build an API Gateway to control the authentication and access to the backend resources using &lt;a href=&quot;http://projects.spring.io/spring-cloud/&quot;&gt;Spring Cloud&lt;/a&gt;. This is the fourth in a series of articles, and you can catch up on the basic building blocks of the application or build it from scratch by reading the &lt;a href=&quot;http://spring.io/blog/2015/01/12/spring-and-angular-js-a-secure-single-page-application&quot; title=&quot;First Article in the Series&quot;&gt;first article&lt;/a&gt;, or you can just go straight to the &lt;a href=&quot;https://github.com/dsyer/spring-security-angular/tree/master/proxy&quot;&gt;source code in Github&lt;/a&gt;. In the &lt;a href=&quot;http://spring.io/blog/2015/01/20/the-resource-server-angular-js-and-spring-security-part-iii&quot; title=&quot;Third Article in the Series&quot;&gt;last article&lt;/a&gt; we built a simple distributed application that used &lt;a href=&quot;https://github.com/spring-projects/spring-session/&quot;&gt;Spring Session&lt;/a&gt; to authenticate the backend resources. In this one we make the UI server into a reverse proxy to the backend resource server, fixing the issues with the last implementation (technical complexity introduced by custom token authentication), and giving us a lot of new options for controlling access from the browser client.&lt;/p&gt;
" />
<meta content="article" property="og:type" />
<meta property="og:article:published_time" content="2015-01-28 14:16:00.0" />
</head>
<body>

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" style="display:none;visibility:hidden" width="0"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">Projects</a>
</li>
<li class="navbar-link">
<a href="/guides">Guides</a>
</li>
<li class="navbar-link active">
<a href="/blog">Blog</a>
</li>
<li class="navbar-link">
<a href="/services">Training & Certification</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form action="/search" class="form-inline form-search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search for documentation, guides, and posts..." type="text" value="" />
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form action="/search" class="form-inline form-search" method="get">
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search..." type="text" value="" />
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">
Home
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">
Projects
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">
Guides
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">
Blog
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">
Training & Certification
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>Engineering</div>
</div>
<div class="blog-category content--title">
<div>Releases</div>
</div>
<div class="blog-category content--title">
<div>News and Events</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">The API Gateway Pattern: Angular JS and Spring Security Part IV</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">Engineering</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=20&amp;d=mm" />
<a class="author" rel="author" href="/team/dsyer">Dave Syer</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2015-01-28 14:16:00.0">January 28, 2015</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" data-disqus-identifier="1906" href="/blog/2015/01/28/the-api-gateway-pattern-angular-js-and-spring-security-part-iv#disqus_thread">
</a></div>
</div>
</header>
<div class="blog--post"><blockquote><p>Note: the source code and test for this blog continue to evolve, but the changes to the text are not being maintained here. Please see <a href="https://spring.io/guides/tutorials/spring-security-and-angular-js/">the tutorial version</a> for the most up to date content.</p>
</blockquote><p>In this article we continue <a href="https://spring.io/blog/2015/01/20/the-resource-server-angular-js-and-spring-security-part-iii" title="Third Article in the Series">our discussion</a> of how to use <a href="https://projects.spring.io/spring-security">Spring Security</a> with <a href="http://angularjs.org">Angular JS</a> in a &ldquo;single page application&rdquo;. Here we show how to build an API Gateway to control the authentication and access to the backend resources using <a href="https://projects.spring.io/spring-cloud/">Spring Cloud</a>. This is the fourth in a series of articles, and you can catch up on the basic building blocks of the application or build it from scratch by reading the <a href="https://spring.io/blog/2015/01/12/spring-and-angular-js-a-secure-single-page-application" title="First Article in the Series">first article</a>, or you can just go straight to the <a href="https://github.com/dsyer/spring-security-angular/tree/master/proxy">source code in Github</a>. In the <a href="https://spring.io/blog/2015/01/20/the-resource-server-angular-js-and-spring-security-part-iii" title="Third Article in the Series">last article</a> we built a simple distributed application that used <a href="https://github.com/spring-projects/spring-session/">Spring Session</a> to authenticate the backend resources. In this one we make the UI server into a reverse proxy to the backend resource server, fixing the issues with the last implementation (technical complexity introduced by custom token authentication), and giving us a lot of new options for controlling access from the browser client.</p>
<blockquote><p>Reminder: if you are working through this article with the sample application, be sure to clear your browser cache of cookies and HTTP Basic credentials. In Chrome the best way to do that for a single server is to open a new incognito window.</p>
</blockquote><h2><a href="#creating-an-api-gateway" class="anchor" name="creating-an-api-gateway"></a>Creating an API Gateway</h2><p>An API Gateway is a single point of entry (and control) for front end clients, which could be browser based (like the examples in this article) or mobile. The client only has to know the URL of one server, and the backend can be refactored at will with no change, which is a significant advantage. There are other advantages in terms of centralization and control: rate limiting, authentication, auditing and logging. And implementing a simple reverse proxy is really simple with <a href="https://projects.spring.io/spring-cloud/">Spring Cloud</a>.</p><p>If you were following along in the code, you will know that the application implementation at the end of the <a href="https://spring.io/blog/2015/01/20/the-resource-server-angular-js-and-spring-security-part-iii" title="Third Article in the Series">last article</a> was a bit complicated, so it&rsquo;s not a great place to iterate away from. There was, however, a halfway point which we could start from more easily, where the backend resource wasn&rsquo;t yet secured with Spring Security. The source code for this is a separate project <a href="https://github.com/dsyer/spring-security-angular/tree/master/vanilla">in Github</a> so we are going to start from there. It has a UI server and a resource server and they are talking to each other. The resource server doesn&rsquo;t have Spring Security yet so we can get the system working first and then add that layer.</p><h3><a href="#declarative-reverse-proxy-in-one-line" class="anchor" name="declarative-reverse-proxy-in-one-line"></a>Declarative Reverse Proxy in One Line</h3><p>To turn it into an API Gateawy, the UI server needs one small tweak. Somewhere in the Spring configuration we need to add an <code>@EnableZuulProxy</code> annotation, e.g. in the main (only) <a href="https://github.com/dsyer/spring-security-angular/blob/master/proxy/ui/src/main/java/demo/UiApplication.java">application class</a>:</p>
<pre><code class="prettyprint java">@SpringBootApplication
@RestController
@EnableZuulProxy
public class UiApplication {
  ...
}
</code></pre><p>and in an external configuration file we need to map a local resource in the UI server to a remote one in the <a href="https://github.com/dsyer/spring-security-angular/blob/master/proxy/ui/src/main/resources/application.yml">external configuration</a> (&ldquo;application.yml&rdquo;):</p>
<pre><code class="prettyprint yaml">security:
  ...
zuul:
  routes:
    resource:
      path: /resource/**
      url: http://localhost:9000
</code></pre><p>This says &ldquo;map paths with the pattern /resource/** in this server to the same paths in the remote server at localhost:9000&rdquo;. Simple and yet effective (OK so it&rsquo;s 6 lines including the YAML, but you don&rsquo;t always need that)!</p><p>All we need to make this work is the right stuff on the classpath. For that purpose we have a few new lines in our Maven POM:</p>
<pre><code class="prettyprint xml">&lt;dependencyManagement&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
      &lt;artifactId&gt;spring-cloud-starter-parent&lt;/artifactId&gt;
      &lt;version&gt;1.0.0.BUILD-SNAPSHOT&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
      &lt;scope&gt;import&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;

&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;
  &lt;/dependency&gt;
  ...
&lt;/dependencies&gt;
</code></pre><p>Note the use of the &ldquo;spring-cloud-starter-zuul&rdquo; - it&rsquo;s a starter POM just like the Spring Boot ones, but it governs the dependencies we need for this Zuul proxy. We are also using <code>&lt;dependencyManagement&gt;</code> because we want to be able to depend on all the versions of transitive dependencies being correct.</p><h3><a href="#consuming-the-proxy-in-the-client" class="anchor" name="consuming-the-proxy-in-the-client"></a>Consuming the Proxy in the Client</h3><p>With those changes in place our application still works, but we haven&rsquo;t actually used the new proxy yet until we modify the client. Fortunately that&rsquo;s trivial. We just need to go from this implementation of the &ldquo;home&rdquo; controller:</p>
<pre><code class="prettyprint javascript">angular.module(&#39;hello&#39;, [ &#39;ngRoute&#39; ])
...
.controller(&#39;home&#39;, function($scope, $http) {
	$http.get(&#39;http://localhost:9000/&#39;).success(function(data) {
		$scope.greeting = data;
	})
});
</code></pre><p>to a local resource:</p>
<pre><code class="prettyprint javascript">angular.module(&#39;hello&#39;, [ &#39;ngRoute&#39; ])
...
.controller(&#39;home&#39;, function($scope, $http) {
	$http.get(&#39;resource/&#39;).success(function(data) {
		$scope.greeting = data;
	})
});
</code></pre><p>Now when we fire up the servers everything is working and the requests are being proxied through the UI (API Gateway) to the resource server.</p><h3><a href="#further-simplifications" class="anchor" name="further-simplifications"></a>Further Simplifications</h3><p>Even better: we don&rsquo;t need the CORS filter any more in the resource server. We threw that one together pretty quickly anyway, and it should have been a red light that we had to do anything as technically focused by hand (especially where it concerns security). Fortunately it is now redundant, so we can just throw it away, and go back to sleeping at night!</p><h2><a href="#securing-the-resource-server" class="anchor" name="securing-the-resource-server"></a>Securing the Resource Server</h2><p>You might remember in the intermediate state that we started from there is no security in place for the resource server. </p>
<blockquote><p>Aside: Lack of software security might not even be a problem if your network architecture mirrors the application architecture (you can just make the resource server physically inaccessible to anyone but the UI server). As a simple demonstration of that we can make the resource server only accessible on localhost. Just add this to <code>application.properties</code> in the resource server:</p>
</blockquote>
<pre><code class="prettyprint">    server.address: 127.0.0.1
</code></pre>
<blockquote><p>Wow, that was easy! Do that with a network address that&rsquo;s only visible in your data center and you have a security solution that works for all resource servers and all user desktops.</p>
</blockquote><p>Suppose that we decide we do need security at the software level (quite likely for a number of reasons). That&rsquo;s not going to be a problem, because all we need to do is add Spring Security as a dependency (in the <a href="https://github.com/dsyer/spring-security-angular/blob/master/proxy/resource/pom.xml">resource server POM</a>):</p>
<pre><code class="prettyprint xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre><p>That&rsquo;s enough to get us a secure resource server, but it won&rsquo;t get us a working application yet, for the same reason that it didn&rsquo;t in <a href="https://spring.io/blog/2015/01/20/the-resource-server-angular-js-and-spring-security-part-iii" title="Third Article in the Series">Part III</a>: there is no shared authentication state between the two servers.</p><h2><a href="#sharing-authentication-state" class="anchor" name="sharing-authentication-state"></a>Sharing Authentication State</h2><p>We can use the same mechanism to share authentication (and CSRF) state as we did in the last, i.e. <a href="https://github.com/spring-projects/spring-session/">Spring Session</a>. We add the dependency to both servers as before:</p>
<pre><code class="prettyprint xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;
  &lt;artifactId&gt;spring-session&lt;/artifactId&gt;
  &lt;version&gt;1.0.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre><p>but this time the configuration is much simpler because we can just add the same <code>Filter</code> declaration to both. First the UI server (adding <code>@EnableRedisHttpSession</code>):</p>
<pre><code class="prettyprint java">@SpringBootApplication
@RestController
@EnableZuulProxy
@EnableRedisHttpSession
public class UiApplication {

  ...

}
</code></pre><p>and then the resource server. There are three small changes to make: one is adding <code>@EnableRedisHttpSession</code> to the <code>ResourceApplication</code>:</p>
<pre><code class="prettyprint java">@SpringBootApplication
@RestController
@EnableRedisHttpSession
class ResourceApplication {
  ...
}
</code></pre><p>another is to explicitly disable HTTP Basic in the resource server (to prevent the browser from popping up authentication dialogs):</p>
<pre><code class="prettyprint java">@SpringBootApplication
@RestController
@EnableRedisHttpSession
class ResourceApplication extends WebSecurityConfigurerAdapter {

  ...

  @Override
  protected void configure(HttpSecurity http) throws Exception {
    http.httpBasic().disable()
    http.authorizeRequests().anyRequest().authenticated()
  }

}

</code></pre>
<blockquote><p>Aside: an alternative, which would also prevent the authentication dialog, would be to keep HTTP Basic but change the 401 challenge to something other than &ldquo;Basic&rdquo;. You can do that with a one-line implementation of <code>AuthenticationEntryPoint</code> in the <code>HttpSecurity</code> configuration callback.</p>
</blockquote><p>and the last one is to explicitly ask for a non-stateless session creation policy in <code>application.properties</code>:</p>
<pre><code class="prettyprint properties">security.sessions: NEVER
</code></pre><p>As long as redis is still running in the background (use the <a href="https://github.com/dsyer/spring-security-angular/tree/master/proxy/fig.yml"><code>fig.yml</code></a> if you like to start it) then the system will work. Load the homepage for the UI at <a href="http://localhost:8080">http://localhost:8080</a> and login and you will see the message from the backend rendered on the homepage.</p><h2><a href="#how-does-it-work" class="anchor" name="how-does-it-work"></a>How Does it Work?</h2><p>What is going on behind the scenes now? First we can look at the HTTP requests in the UI server (and API Gateway):</p>
<table>
<thead>
<tr>
<th>Verb </th>
<th>Path </th>
<th>Status </th>
<th>Response</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET </td>
<td>/ </td>
<td>200 </td>
<td>index.html</td>
</tr>
<tr>
<td>GET </td>
<td>/css/angular-bootstrap.css </td>
<td>200 </td>
<td>Twitter bootstrap CSS</td>
</tr>
<tr>
<td>GET </td>
<td>/js/angular-bootstrap.js </td>
<td>200 </td>
<td>Bootstrap and Angular JS</td>
</tr>
<tr>
<td>GET </td>
<td>/js/hello.js </td>
<td>200 </td>
<td>Application logic</td>
</tr>
<tr>
<td>GET </td>
<td>/user </td>
<td>302 </td>
<td>Redirect to login page</td>
</tr>
<tr>
<td>GET </td>
<td>/login </td>
<td>200 </td>
<td>Whitelabel login page (ignored)</td>
</tr>
<tr>
<td>GET </td>
<td>/resource </td>
<td>302 </td>
<td>Redirect to login page</td>
</tr>
<tr>
<td>GET </td>
<td>/login </td>
<td>200 </td>
<td>Whitelabel login page (ignored)</td>
</tr>
<tr>
<td>GET </td>
<td>/login.html </td>
<td>200 </td>
<td>Angular login form partial</td>
</tr>
<tr>
<td>POST </td>
<td>/login </td>
<td>302 </td>
<td>Redirect to home page (ignored)</td>
</tr>
<tr>
<td>GET </td>
<td>/user </td>
<td>200 </td>
<td>JSON authenticated user</td>
</tr>
<tr>
<td>GET </td>
<td>/resource </td>
<td>200 </td>
<td>(Proxied) JSON greeting</td>
</tr>
</tbody>
</table><p>That&rsquo;s identical to the sequence at the end of <a href="https://spring.io/blog/2015/01/12/the-login-page-angular-js-and-spring-security-part-ii" title="Second Article in the Series">Part II</a> except for the fact that the cookie names are slightly different (&ldquo;SESSION&rdquo; instead of &ldquo;JSESSIONID&rdquo;) because we are using Spring Session. But the architecture is different and that last request to &ldquo;/resource&rdquo; is special because it was proxied to the resource server. </p><p>We can see the reverse proxy in action by looking at the &ldquo;/trace&rdquo; endpoint in the UI server (from Spring Boot Actuator, which we added with the Spring Cloud dependencies). Go to <a href="http://localhost:8080/trace">http://localhost:8080/trace</a> in a new browser and scroll to the end (if you don&rsquo;t have one already get a JSON plugin for your browser to make it nice and readable). You will need to authenticate with HTTP Basic (browser popup), but the same credentials are valid as for your login form. At or near the end you should see a pair of requests something like this:</p>
<blockquote><p>Note: Try to use a different browser so that there is no chance of authentication crossover (e.g. use Firefox if yoused Chrome for testing the UI) - it won&rsquo;t stop the app from working, but it will make the traces harder to read if they contain a mixture of authentication from the same browser. </p>
</blockquote>
<pre><code class="prettyprint javascript">{
  &quot;timestamp&quot;: 1420558194546,
  &quot;info&quot;: {
    &quot;method&quot;: &quot;GET&quot;,
    &quot;path&quot;: &quot;/&quot;,
    &quot;query&quot;: &quot;&quot;
    &quot;remote&quot;: true,
    &quot;proxy&quot;: &quot;resource&quot;,
    &quot;headers&quot;: {
      &quot;request&quot;: {
        &quot;accept&quot;: &quot;application/json, text/plain, */*&quot;,
        &quot;x-xsrf-token&quot;: &quot;542c7005-309c-4f50-8a1d-d6c74afe8260&quot;,
        &quot;cookie&quot;: &quot;SESSION=c18846b5-f805-4679-9820-cd13bd83be67; XSRF-TOKEN=542c7005-309c-4f50-8a1d-d6c74afe8260&quot;,
        &quot;x-forwarded-prefix&quot;: &quot;/resource&quot;,
        &quot;x-forwarded-host&quot;: &quot;localhost:8080&quot;
      },
      &quot;response&quot;: {
        &quot;Content-Type&quot;: &quot;application/json;charset=UTF-8&quot;,
        &quot;status&quot;: &quot;200&quot;
      }
    },
  }
},
{
  &quot;timestamp&quot;: 1420558200232,
  &quot;info&quot;: {
    &quot;method&quot;: &quot;GET&quot;,
    &quot;path&quot;: &quot;/resource/&quot;,
    &quot;headers&quot;: {
      &quot;request&quot;: {
        &quot;host&quot;: &quot;localhost:8080&quot;,
        &quot;accept&quot;: &quot;application/json, text/plain, */*&quot;,
        &quot;x-xsrf-token&quot;: &quot;542c7005-309c-4f50-8a1d-d6c74afe8260&quot;,
        &quot;cookie&quot;: &quot;SESSION=c18846b5-f805-4679-9820-cd13bd83be67; XSRF-TOKEN=542c7005-309c-4f50-8a1d-d6c74afe8260&quot;
      },
      &quot;response&quot;: {
        &quot;Content-Type&quot;: &quot;application/json;charset=UTF-8&quot;,
        &quot;status&quot;: &quot;200&quot;
      }
    }
  }
},
</code></pre><p>The second entry there is the request from the client to the gateway on &ldquo;/resource&rdquo; and you can see the cookies (added by the browser) and the CSRF header (added by Angular as discussed in <a href="second">Part II</a>). The first entry has <code>remote: true</code> and that means it&rsquo;s tracing the call to the resource server. You can see it went out to a uri path &ldquo;/&rdquo; and you can see that (crucially) the cookies and CSRF headers have been sent too. Without Spring Session these headers would be meaningless to the resource server, but the way we have set it up it can now use those headers to re-constitute a session with authentication and CSRF token data. So the request is permitted and we are in business!</p><h2><a href="#conclusion" class="anchor" name="conclusion"></a>Conclusion</h2><p>We covered quite a lot in this article but we got to a really nice place where there is a minimal amount of boilerplate code in our two servers, they are both nicely secure and the user experience isn&rsquo;t compromised. That alone would be a reason to use the API Gateway pattern, but really we have only scratched the surface of what that might be used for (Netflix uses it for <a href="https://github.com/Netflix/zuul/wiki/How-We-Use-Zuul-At-Netflix">a lot of things</a>). Read up on <a href="https://projects.spring.io/spring-cloud/">Spring Cloud</a> to find out more on how to make it easy to add more features to the gateway. The <a href="https://spring.io/blog/2015/02/03/sso-with-oauth2-angular-js-and-spring-security-part-v">next article</a> in this series will extend the application architecture a bit by extracting the authentication responsibilities to a separate server (the Single Sign On pattern).</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 1906;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>
Back
</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">All Posts</a>
<a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">Engineering</a>
<a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">Releases</a>
<a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">News and Events</a>
<a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>Get updates from The Spring Team delivered to your inbox</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">Tools</a></li>
<li><a href="https://store.pivotal.io/">Store</a></li>
<li><a href="/blog">Newsletter</a></li>
</ul>
</div>
</div>
&copy; <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a>, Inc. All Rights Reserved.
<a href="https://pivotal.io/terms-of-use">Terms of Use</a> &bullet;
<a href="https://pivotal.io/privacy-policy">Privacy</a> &bullet;
<a href="/trademarks">Trademark Guidelines</a>
<div id="teconsent" style="display:inline-block;"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>