<html  data-code-prettify="" data-mobile-support="" data-search=""><head></head><body >﻿
<title>资源服务器：Angular JS和Spring Security第三部分</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="The Resource Server: Angular JS and Spring Security Part III">
<meta name="twitter:description" >
<meta name="twitter:creator" content="@david_syer">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=200">

<meta property="og:title" content="The Resource Server: Angular JS and Spring Security Part III">
<meta property="og:image" content="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=200">
<meta property="og:description" >
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2015-01-20 09:54:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">资源服务器：Angular JS和Spring Security第三部分</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=20&d=mm"> <a class="author" rel="author" href="/team/dsyer">戴夫·瑟</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2015-01-20 09:54:00.0">2015年1月20日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2015/01/20/the-resource-server-angular-js-and-spring-security-part-iii#disqus_thread" data-disqus-identifier="1905">
</a></div>
</div>
</header>
<div class="blog--post"><blockquote><p>注意：此博客的源代码和测试在不断发展，但此处未保留对文本的更改。请参阅<a href="https://spring.io/guides/tutorials/spring-security-and-angular-js/">教程版本</a>以获取最新内容。</p>
</blockquote><p>在本文中，我们将继续<a href="https://spring.io/blog/2015/01/12/the-login-page-angular-js-and-spring-security-part-ii" title="系列第二篇">讨论</a>如何在“单页应用程序”中将<a href="https://projects.spring.io/spring-security">Spring Security</a>与<a href="http://angularjs.org">Angular JS</a>一起使用。在这里，我们首先将在应用程序中用作动态内容的“问候”资源分解到单独的服务器中，首先作为不受保护的资源，然后由不透明的令牌保护。这是系列文章中的第三篇，您可以了解应用程序的基本构建块，或者通过阅读<a href="https://spring.io/blog/2015/01/12/spring-and-angular-js-a-secure-single-page-application" title="系列文章的第一篇">第一篇文章</a>从头开始构建它，或者直接进入Github中的源代码，该文章位于分为两部分：一部分<a href="https://github.com/dsyer/spring-security-angular/tree/master/vanilla">不受资源保护</a> ，另一部分<a href="https://github.com/dsyer/spring-security-angular/tree/master/spring-session">由令牌保护</a> 。</p>
<blockquote><p>提醒：如果您正在使用示例应用程序浏览本文，请确保清除浏览器的cookie和HTTP Basic凭据缓存。在Chrome中，对单个服务器执行此操作的最佳方法是打开一个新的隐身窗口。</p>
</blockquote><h2><a href="#a-separate-resource-server" class="anchor" name="a-separate-resource-server"></a>单独的资源服务器</h2><h3><a href="#client-side-changes" class="anchor" name="client-side-changes"></a>客户端更改</h3><p>在客户端，没有太多要做的事情可以将资源移动到另一个后端。这是<a href="https://github.com/dsyer/spring-security-angular/blob/master/single/src/main/resources/static/js/hello.js">上一篇文章中</a>的“ home”控制器：</p>
<pre><code class="prettyprint javascript">angular.module(&#39;hello&#39;, [ &#39;ngRoute&#39; ])
...
.controller(&#39;home&#39;, function($scope, $http) {
	$http.get(&#39;/resource/&#39;).success(function(data) {
		$scope.greeting = data;
	})
})
...
</code></pre><p>我们要做的就是更改URL。例如，如果我们要在localhost上运行新资源，则它看起来可能像这样：</p>
<pre><code class="prettyprint javascript">angular.module(&#39;hello&#39;, [ &#39;ngRoute&#39; ])
...
.controller(&#39;home&#39;, function($scope, $http) {
	$http.get(&#39;http://localhost:9000/&#39;).success(function(data) {
		$scope.greeting = data;
	})
})
...
</code></pre><h3><a href="#server-side-changes" class="anchor" name="server-side-changes"></a>服务器端更改</h3><p><a href="https://github.com/dsyer/spring-security-angular/blob/master/vanilla/ui/src/main/java/demo/UiApplication.java">UI服务器的</a>更改很简单：我们只需要删除<code>@RequestMapping</code>用于问候资源（它是“ / resource”）。然后，我们需要创建一个新的资源服务器，我们可以像使用<a href="https://start.spring.io">Spring Boot Initializr</a>在<a href="https://spring.io/blog/2015/01/12/spring-and-angular-js-a-secure-single-page-application" title="系列文章的第一篇">第一篇文章中</a>所做的那样进行操作。例如在类似UN * X的系统上使用curl：</p>
<pre><code class="prettyprint">$ mkdir resource &amp;&amp; cd resource
$ curl https://start.spring.io/starter.tgz -d style=web \
-d name=resource -d language=groovy | tar -xzvf - 
</code></pre><p>然后，您可以将该项目（默认情况下是普通的Maven Java项目）导入到您喜欢的IDE中，或者仅在命令行上使用文件和“ mvn”。我们使用Groovy是因为我们可以这样做，但是如果您愿意，请随时使用Java。反正不会有太多的代码。</p><p>只需添加一个<code>@RequestMapping</code>到<a href="https://github.com/dsyer/spring-security-angular/blob/master/vanilla/resource/src/main/groovy/demo/ResourceApplication.groovy">主应用程序类</a> ，从<a href="https://github.com/dsyer/spring-security-angular/blob/master/single/src/main/java/demo/UiApplication.java">旧版UI</a>复制实现：</p>
<pre><code class="prettyprint java">@SpringBootApplication
@RestController
class ResourceApplication {
	
	@RequestMapping(&#39;/&#39;)
	def home() {
		[id: UUID.randomUUID().toString(), content: &#39;Hello World&#39;]
	}

    static void main(String[] args) {
        SpringApplication.run ResourceApplication, args
    }

}
</code></pre><p>完成后，您的应用程序将可以在浏览器中加载。在命令行上，您可以执行此操作</p>
<pre><code class="prettyprint">$ mvn spring-boot:run --server.port=9000
</code></pre><p>并转到位于<a href="http://localhost:9000">http：// localhost：9000</a>的浏览器，您应该看到带有问候语的JSON。您可以烘烤端口更改<code>application.properties</code> （在“ src / main / resources”中）：</p>
<pre><code class="prettyprint properties">server.port: 9000
</code></pre><p>如果尝试从浏览器中的UI（在端口8080上）加载该资源，则会发现该资源不起作用，因为浏览器不允许XHR请求。</p><h2><a href="#cors-negotiation" class="anchor" name="cors-negotiation"></a> CORS谈判</h2><p>浏览器尝试与我们的资源服务器进行协商，以根据<a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing">通用起源资源共享</a>协议来确定是否允许其访问它。这不是Angular JS的责任，因此就像cookie合同一样，它可以与浏览器中的所有JavaScript一起工作。这两个服务器没有声明它们具有相同的来源，因此浏览器拒绝发送请求，并且UI损坏。</p><p>为了解决此问题，我们需要支持CORS协议，该协议涉及“预检” OPTIONS请求和一些标头，以列出调用者的允许行为。Spring 4.2可能有一些不错<a href="https://jira.spring.io/browse/SPR-9278">的CORS细粒度支持</a> ，但是在发布之前，我们可以通过使用来向所有请求发送相同的CORS响应，从而为该应用程序的目的做适当的工作。 <code>Filter</code> 。我们可以在与资源服务器应用程序相同的目录中创建一个类，并确保它是一个<code>@Component</code> （因此将其扫描到Spring应用程序上下文中），例如：</p>
<pre><code class="prettyprint java">@Component
@Order(Ordered.HIGHEST_PRECEDENCE)
class CorsFilter implements Filter {

  void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) {
    HttpServletResponse response = (HttpServletResponse) res
    response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)
    response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, PUT, GET, OPTIONS, DELETE&quot;)
    response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;x-requested-with&quot;)
    response.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;)
    if (request.getMethod()!=&#39;OPTIONS&#39;) {
      chain.doFilter(req, res)
    } else {
    }
  }

  void init(FilterConfig filterConfig) {}

  void destroy() {}

}
</code></pre><p>的<code>Filter</code>用一个定义<code>@Order</code>因此绝对可以<em>在</em>主Spring Security过滤器<em>之前</em>应用它。通过对资源服务器的更改，我们应该能够重新启动它并在UI中获得问候。</p>
<blockquote><p>注意：善用<code>Access-Control-Allow-Origin=*</code>既快速又脏，并且可以使用，但是它并不安全，因此不建议以任何方式使用。</p>
</blockquote><h2><a href="#securing-the-resource-server" class="anchor" name="securing-the-resource-server"></a>保护资源服务器</h2><p>大！我们有一个具有新架构的可运行应用程序。唯一的问题是资源服务器没有安全性。</p><h3><a href="#adding-spring-security" class="anchor" name="adding-spring-security"></a>增加Spring安全性</h3><p>我们还可以研究如何像UI服务器一样，将安全性作为过滤器层添加到资源服务器。这也许是更常规的做法，并且无疑是大多数PaaS环境中的最佳选择（因为它们通常不会使专用网络可用于应用程序）。第一步非常简单：只需将Spring Security添加到Maven POM中的类路径即可：</p>
<pre><code class="prettyprint xml">&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
  &lt;/dependency&gt;
  ...
&lt;/dependencies&gt;
</code></pre><p>重新启动资源服务器，嘿！是安全的：</p>
<pre><code class="prettyprint">$ curl -v localhost:9000
&lt; HTTP/1.1 302 Found
&lt; Location: http://localhost:9000/login
...
</code></pre><p>我们正在重定向到（whitelabel）登录页面，因为curl没有发送与Angular客户端相同的标头。修改命令以发送更多类似的标头：</p>
<pre><code class="prettyprint">$ curl -v -H &quot;Accept: application/json&quot; \
    -H &quot;X-Requested-With: XMLHttpRequest&quot; localhost:9000
&lt; HTTP/1.1 401 Unauthorized
...
</code></pre><p>因此，我们需要做的就是教客户在每个请求中发送凭据。</p><h2><a href="#token-authentication" class="anchor" name="token-authentication"></a>令牌认证</h2><p>互联网和人们的Spring后端项目到处都是基于令牌的定制身份验证解决方案。Spring Security提供了准系统<code>Filter</code>实施以使您自己开始（请参阅示例<a href="https://github.com/spring-projects/spring-security/blob/master/web/src/main/java/org/springframework/security/web/authentication/preauth/AbstractPreAuthenticatedProcessingFilter.java"><code>AbstractPreAuthenticatedProcessingFilter</code></a>和<a href="https://github.com/spring-projects/spring-security/blob/master/core/src/main/java/org/springframework/security/core/token/TokenService.java"><code>TokenService</code></a> ）。但是，Spring Security中没有规范的实现，这可能是有一种更简单的方法的原因之一。</p><p>请记住，在本系列的<a href="https://spring.io/blog/2015/01/12/the-login-page-angular-js-and-spring-security-part-ii" title="系列第二篇">第二部分</a>中，Spring Security使用了<code>HttpSession</code>默认情况下存储身份验证数据。但是，它不会直接与会话互动：有一个抽象层（ <a href="https://github.com/spring-projects/spring-security/blob/master/web/src/main/java/org/springframework/security/web/context/SecurityContextRepository.java"><code>SecurityContextRepository</code></a> ）之间，您可以用来更改存储后端。如果我们可以将资源库中的该存储库指向经过UI验证的身份验证的商店，那么我们就可以在两个服务器之间共享身份验证。UI服务器已经有这样的商店（ <code>HttpSession</code> ），因此，如果我们可以分发该存储并将其打开到资源服务器，则可以使用大多数解决方案。</p><h3><a href="#spring-session" class="anchor" name="spring-session"></a>春季会议</h3><p>解决方案的这一部分对于<a href="https://github.com/spring-projects/spring-session/">Spring Session</a>来说非常容易。我们需要的是一个共享数据存储（开箱即用地支持Redis），以及服务器中的几行配置以设置一个<code>Filter</code> 。</p><p>在UI应用程序中，我们需要向<a href="https://github.com/dsyer/spring-security-angular/blob/master/spring-session/ui/pom.xml">POM</a>添加一些依赖项：</p>
<pre><code class="prettyprint xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;
  &lt;artifactId&gt;spring-session&lt;/artifactId&gt;
  &lt;version&gt;1.0.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre><p>然后添加<code>@EnableRedisHttpSession</code>到您的主要应用程序：</p>
<pre><code class="prettyprint java">@SpringBootApplication
@RestController
@EnableRedisHttpSession
public class UiApplication {

  public static void main(String[] args) {
    SpringApplication.run(UiApplication.class, args);
  }

  ...

}
</code></pre><p>的<code>@EnableRedisHttpSession</code>注解来自Spring Session，Spring Boot提供了Redis连接（可以使用环境变量或配置文件来配置URL和凭据）。</p><p>有了这行代码并在本地主机上运行Redis服务器，就可以运行UI应用程序，使用一些有效的用户凭据登录，并且会话数据（身份验证和CSRF令牌）将存储在redis中。</p>
<blockquote><p>提示：如果您没有本地运行的Redis服务器，则可以使用<a href="https://www.docker.com/">Docker</a>轻松启动它（在Windows或MacOS上，这需要一个VM）。有一个<a href="https://docs.docker.com/compose/"><code>docker-compose.yml</code></a> <a href="https://github.com/dsyer/spring-security-angular/tree/master/spring-session/docker-compose.yml">Github</a>中的<a href="https://github.com/dsyer/spring-security-angular/tree/master/spring-session/docker-compose.yml">源代码中的</a>文件，您可以使用以下命令在命令行中轻松地运行它<code>docker-compose up</code> 。</p>
</blockquote><h2><a href="#sending-a-custom-token-from-the-ui" class="anchor" name="sending-a-custom-token-from-the-ui"></a>从UI发送自定义令牌</h2><p>唯一缺少的部分是存储中数据密钥的传输机制。关键是<code>HttpSession</code> ID，因此如果我们可以在UI客户端中获取该键，则可以将其作为自定义标头发送到资源服务器。因此，“ home”控制器将需要进行更改，以使其将标头作为问候资源的HTTP请求的一部分发送。例如：</p>
<pre><code class="prettyprint javascript">angular.module(&#39;hello&#39;, [ &#39;ngRoute&#39; ])
...
.controller(&#39;home&#39;, function($scope, $http) {
  $http.get(&#39;token&#39;).success(function(token) {
    $http({
      url : &#39;http://localhost:9000&#39;,
      method : &#39;GET&#39;,
      headers : {
        &#39;X-Auth-Token&#39; : token.token
      }
    }).success(function(data) {
      $scope.greeting = data;
    });
  })
});
</code></pre><p>（一种更优雅的解决方案可能是根据需要获取令牌，并使用Angular <a href="https://docs.angularjs.org/api/ng/service/$http">拦截器</a>将标头添加到对资源服务器的每个请求中。然后可以对拦截器定义进行抽象化，而不是一味地做完所有事情并弄乱业务逻辑。）</p><p>我们没有直接转到“ <a href="http://localhost:9000">http：// localhost：9000</a> ”，而是将该调用包装在对“ / token”上的UI服务器上的新自定义终结点的调用的成功回调中。实现起来很简单：</p>
<pre><code class="prettyprint java">@SpringBootApplication
@RestController
@EnableRedisHttpSession
public class UiApplication {

  public static void main(String[] args) {
    SpringApplication.run(UiApplication.class, args);
  }

  ...

  @RequestMapping(&quot;/token&quot;)
  @ResponseBody
  public Map&lt;String,String&gt; token(HttpSession session) {
    return Collections.singletonMap(&quot;token&quot;, session.getId());
  }

}
</code></pre><p>因此，UI应用程序已准备就绪，并将在所有对后端的调用中将会话ID包含在名为“ X-Auth-Token”的标头中。</p><h2><a href="#authentication-in-the-resource-server" class="anchor" name="authentication-in-the-resource-server"></a>资源服务器中的身份验证</h2><p>资源服务器有一个微小的变化，使其能够接受自定义标头。CORS过滤器必须将该标头指定为来自远程客户端的允许标头，例如</p>
<pre><code class="prettyprint java">@Component
@Order(Ordered.HIGHEST_PRECEDENCE)
public class CorsFilter implements Filter {

  void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {
    ...
    response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;x-auth-token, x-requested-with&quot;)
    ...
  }

  ...
}
</code></pre><p>剩下的就是在资源服务器中获取自定义令牌，并使用它来验证我们的用户。事实证明这很简单，因为我们要做的就是告诉Spring Security会话存储库在哪里，以及在传入请求中在哪里寻找令牌（会话ID）。首先，我们需要添加Spring Session和Redis依赖项，然后我们可以设置<code>Filter</code> ：</p>
<pre><code class="prettyprint java">@SpringBootApplication
@RestController
@EnableRedisHttpSession
class ResourceApplication {

  ...
  
  @Bean
  HeaderHttpSessionStrategy sessionStrategy() {
    new HeaderHttpSessionStrategy();
  }

}
</code></pre><p>这个<code>Filter</code> created是UI服务器中的镜像，因此它将Redis建立为会话存储。唯一的区别是它使用了自定义<code>HttpSessionStrategy</code>在标题（默认为“ X-Auth-Token”）而不是默认名称（名为“ JSESSIONID”的cookie）中查找。我们还需要防止浏览器在未经身份验证的客户端中弹出对话框-该应用程序是安全的，但会发送401 <code>WWW-Authenticate: Basic</code>默认情况下，因此浏览器会以一个对话框提示用户名和密码。有多种方法可以实现此目的，但是我们已经使Angular发送了一个“ X-Requested-With”标头，因此Spring Security默认为我们处理它。</p><p>对资源服务器进行了最后的更改，以使其与我们的新身份验证方案一起使用。Spring Boot的默认安全性是无状态的，我们希望它在会话中存储身份验证，因此我们需要在<code>application.yml</code> （要么<code>application.properties</code> ）：</p>
<pre><code class="prettyprint yaml">security:
  sessions: NEVER
</code></pre><p>这对Spring Security说：“从不创建会话，但如果存在则使用一个会话”（由于UI中的身份验证，该会话已经存在）。</p><p>重新启动资源服务器，并在新的浏览器窗口中打开UI。</p><h2><a href="#why-doesn-rsquo-t-it-all-work-with-cookies" class="anchor" name="why-doesn-rsquo-t-it-all-work-with-cookies"></a>为什么不是全部都使用Cookie？</h2><p>我们必须使用自定义标头并在客户端中编写代码来填充标头，这并不十分复杂，但是似乎与<a href="https://spring.io/blog/2015/01/12/the-login-page-angular-js-and-spring-security-part-ii" title="系列第二篇">第二部分中</a>的建议尽可能使用cookie和会话相矛盾。有人争辩说，不这样做会带来额外的不必要的复杂性，并且可以肯定的是，我们现在所实现的实现是迄今为止我们所见过的最复杂的：解决方案的技术部分远远超过了业务逻辑（公认的很小）。这绝对是一种公平的批评（我们计划在本系列的下一篇文章中解决），但让我们简要地看一下为什么它不像对所有内容使用cookie和会话那样简单。</p><p>至少我们仍在使用会话，这是有道理的，因为Spring Security和Servlet容器知道如何做到这一点。但是我们不能继续使用cookie来传输身份验证令牌吗？本来不错，但是有一个原因它不起作用，那就是浏览器不允许我们这样做。您可以从JavaScript客户端浏览浏览器的cookie存储，但是有一些限制，这是有充分理由的。特别是，您无权访问服务器以“ HttpOnly”形式发送的cookie（默认情况下，您将看到会话cookie）。您也不能在传出请求中设置cookie，因此我们无法设置“ SESSION” cookie（这是Spring Session的默认cookie名称），我们必须使用自定义的“ X-Session”标头。这两个限制都是为了保护您自己，因此恶意脚本无法在未经适当授权的情况下访问您的资源。</p><p>TL; DR UI和资源服务器没有相同的来源，因此它们无法共享Cookie（即使我们可以使用Spring Session强制它们共享会话）。</p><h2><a href="#conclusion" class="anchor" name="conclusion"></a>结论</h2><p>我们在<a href="https://spring.io/blog/2015/01/12/the-login-page-angular-js-and-spring-security-part-ii" title="系列第二篇">本系列的第二部分中</a>重复了该应用程序的功能：从远程后端获取带有问候语的主页，并在导航栏中显示登录和注销链接。区别在于，问候语来自独立的资源服务器，而不是嵌入在UI服务器中。这给实现增加了相当大的复杂性，但是好消息是我们有一个主要基于配置的（实际上是100％声明式）解决方案。通过将所有新代码提取到库中（Spring配置和Angular自定义指令），我们甚至可以使解决方案具有100％声明性。在接下来的两期中，我们将推迟这项有趣的任务。<a href="https://spring.io/blog/2015/01/28/the-api-gateway-pattern-angular-js-and-spring-security-part-iv">在下一篇文章中，</a>我们将探讨降低当前实现中所有复杂性的另一种非常有效的方法：API网关模式（客户端将其所有请求发送到一个地方，然后在此处进行身份验证）。</p>
<blockquote><p>注意：我们在这里使用Spring Session在2个逻辑上不是同一应用程序的服务器之间共享会话。这是一个巧妙的技巧，使用“常规” JEE分布式会话是不可能的。</p>
</blockquote></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 1905;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>