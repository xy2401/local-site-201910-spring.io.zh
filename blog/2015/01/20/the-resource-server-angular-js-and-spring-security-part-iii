<!DOCTYPE html>
<html data-code-prettify="" data-mobile-support="" data-search="">
<head>
<title>The Resource Server: Angular JS and Spring Security Part III</title>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no" id="Viewport" name="viewport" />
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png" />
<link href="https://fonts.googleapis.com/css?family=Varela+Round|Montserrat:400,700" rel="stylesheet" type="text/css" />
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css" />
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M" name="google-site-verification" />

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css" />

<meta content="summary" name="twitter:card" />
<meta content="@springcentral" name="twitter:site" />
<meta name="twitter:title" content="The Resource Server: Angular JS and Spring Security Part III" />
<meta name="twitter:description" content="&lt;blockquote&gt;
 &lt;p&gt;Note: the source code and test for this blog continue to evolve, but the changes to the text are not being maintained here. Please see &lt;a href=&quot;https://spring.io/guides/tutorials/spring-security-and-angular-js/&quot;&gt;the tutorial version&lt;/a&gt; for the most up to date content.&lt;/p&gt; 
&lt;/blockquote&gt;
&lt;p&gt;In this article we continue &lt;a href=&quot;http://spring.io/blog/2015/01/12/the-login-page-angular-js-and-spring-security-part-ii&quot; title=&quot;Second Article in the Series&quot;&gt;our discussion&lt;/a&gt; of how to use &lt;a href=&quot;http://projects.spring.io/spring-security&quot;&gt;Spring Security&lt;/a&gt; with &lt;a href=&quot;http://angularjs.org&quot;&gt;Angular JS&lt;/a&gt; in a “single page application”. Here we start by breaking out the “greeting” resource that we are using as the dynamic content in our application into a separate server, first as an unprotected resource, and then protected by an opaque token. This is the third in a series of articles, and you can catch up on the basic building blocks of the application or build it from scratch by reading the &lt;a href=&quot;http://spring.io/blog/2015/01/12/spring-and-angular-js-a-secure-single-page-application&quot; title=&quot;First Article in the Series&quot;&gt;first article&lt;/a&gt;, or you can just go straight to the source code in Github, which is in two parts: one where the &lt;a href=&quot;https://github.com/dsyer/spring-security-angular/tree/master/vanilla&quot;&gt;resource is unprotected&lt;/a&gt;, and one where it is &lt;a href=&quot;https://github.com/dsyer/spring-security-angular/tree/master/spring-session&quot;&gt;protected by a token&lt;/a&gt;.&lt;/p&gt;
" />
<meta name="twitter:creator" content="@david_syer" />
<meta name="twitter:image:src" content="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=200" />

<meta property="og:title" content="The Resource Server: Angular JS and Spring Security Part III" />
<meta property="og:image" content="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=200" />
<meta property="og:description" content="&lt;blockquote&gt;
 &lt;p&gt;Note: the source code and test for this blog continue to evolve, but the changes to the text are not being maintained here. Please see &lt;a href=&quot;https://spring.io/guides/tutorials/spring-security-and-angular-js/&quot;&gt;the tutorial version&lt;/a&gt; for the most up to date content.&lt;/p&gt; 
&lt;/blockquote&gt;
&lt;p&gt;In this article we continue &lt;a href=&quot;http://spring.io/blog/2015/01/12/the-login-page-angular-js-and-spring-security-part-ii&quot; title=&quot;Second Article in the Series&quot;&gt;our discussion&lt;/a&gt; of how to use &lt;a href=&quot;http://projects.spring.io/spring-security&quot;&gt;Spring Security&lt;/a&gt; with &lt;a href=&quot;http://angularjs.org&quot;&gt;Angular JS&lt;/a&gt; in a “single page application”. Here we start by breaking out the “greeting” resource that we are using as the dynamic content in our application into a separate server, first as an unprotected resource, and then protected by an opaque token. This is the third in a series of articles, and you can catch up on the basic building blocks of the application or build it from scratch by reading the &lt;a href=&quot;http://spring.io/blog/2015/01/12/spring-and-angular-js-a-secure-single-page-application&quot; title=&quot;First Article in the Series&quot;&gt;first article&lt;/a&gt;, or you can just go straight to the source code in Github, which is in two parts: one where the &lt;a href=&quot;https://github.com/dsyer/spring-security-angular/tree/master/vanilla&quot;&gt;resource is unprotected&lt;/a&gt;, and one where it is &lt;a href=&quot;https://github.com/dsyer/spring-security-angular/tree/master/spring-session&quot;&gt;protected by a token&lt;/a&gt;.&lt;/p&gt;
" />
<meta content="article" property="og:type" />
<meta property="og:article:published_time" content="2015-01-20 09:54:00.0" />
</head>
<body>

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" style="display:none;visibility:hidden" width="0"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">Projects</a>
</li>
<li class="navbar-link">
<a href="/guides">Guides</a>
</li>
<li class="navbar-link active">
<a href="/blog">Blog</a>
</li>
<li class="navbar-link">
<a href="/services">Training & Certification</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form action="/search" class="form-inline form-search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search for documentation, guides, and posts..." type="text" value="" />
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form action="/search" class="form-inline form-search" method="get">
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search..." type="text" value="" />
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">
Home
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">
Projects
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">
Guides
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">
Blog
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">
Training & Certification
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>Engineering</div>
</div>
<div class="blog-category content--title">
<div>Releases</div>
</div>
<div class="blog-category content--title">
<div>News and Events</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">The Resource Server: Angular JS and Spring Security Part III</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">Engineering</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=20&amp;d=mm" />
<a class="author" rel="author" href="/team/dsyer">Dave Syer</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2015-01-20 09:54:00.0">January 20, 2015</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" data-disqus-identifier="1905" href="/blog/2015/01/20/the-resource-server-angular-js-and-spring-security-part-iii#disqus_thread">
</a></div>
</div>
</header>
<div class="blog--post"><blockquote><p>Note: the source code and test for this blog continue to evolve, but the changes to the text are not being maintained here. Please see <a href="https://spring.io/guides/tutorials/spring-security-and-angular-js/">the tutorial version</a> for the most up to date content.</p>
</blockquote><p>In this article we continue <a href="https://spring.io/blog/2015/01/12/the-login-page-angular-js-and-spring-security-part-ii" title="Second Article in the Series">our discussion</a> of how to use <a href="https://projects.spring.io/spring-security">Spring Security</a> with <a href="http://angularjs.org">Angular JS</a> in a &ldquo;single page application&rdquo;. Here we start by breaking out the &ldquo;greeting&rdquo; resource that we are using as the dynamic content in our application into a separate server, first as an unprotected resource, and then protected by an opaque token. This is the third in a series of articles, and you can catch up on the basic building blocks of the application or build it from scratch by reading the <a href="https://spring.io/blog/2015/01/12/spring-and-angular-js-a-secure-single-page-application" title="First Article in the Series">first article</a>, or you can just go straight to the source code in Github, which is in two parts: one where the <a href="https://github.com/dsyer/spring-security-angular/tree/master/vanilla">resource is unprotected</a>, and one where it is <a href="https://github.com/dsyer/spring-security-angular/tree/master/spring-session">protected by a token</a>.</p>
<blockquote><p>Reminder: if you are working through this article with the sample application, be sure to clear your browser cache of cookies and HTTP Basic credentials. In Chrome the best way to do that for a single server is to open a new incognito window.</p>
</blockquote><h2><a href="#a-separate-resource-server" class="anchor" name="a-separate-resource-server"></a>A Separate Resource Server</h2><h3><a href="#client-side-changes" class="anchor" name="client-side-changes"></a>Client Side Changes</h3><p>On the client side there isn&rsquo;t very much to do to move the resource to a different backend. Here&rsquo;s the &ldquo;home&rdquo; controller in the <a href="https://github.com/dsyer/spring-security-angular/blob/master/single/src/main/resources/static/js/hello.js">last article</a>:</p>
<pre><code class="prettyprint javascript">angular.module(&#39;hello&#39;, [ &#39;ngRoute&#39; ])
...
.controller(&#39;home&#39;, function($scope, $http) {
	$http.get(&#39;/resource/&#39;).success(function(data) {
		$scope.greeting = data;
	})
})
...
</code></pre><p>All we need to do to this is change the URL. For example, if we are going to run the new resource on localhost, it could look like this:</p>
<pre><code class="prettyprint javascript">angular.module(&#39;hello&#39;, [ &#39;ngRoute&#39; ])
...
.controller(&#39;home&#39;, function($scope, $http) {
	$http.get(&#39;http://localhost:9000/&#39;).success(function(data) {
		$scope.greeting = data;
	})
})
...
</code></pre><h3><a href="#server-side-changes" class="anchor" name="server-side-changes"></a>Server Side Changes</h3><p>The <a href="https://github.com/dsyer/spring-security-angular/blob/master/vanilla/ui/src/main/java/demo/UiApplication.java">UI server</a> is trivial to change: we just need to remove the <code>@RequestMapping</code> for the greeting resource (it was &ldquo;/resource&rdquo;). Then we need to create a new resource server, which we can do like we did in the <a href="https://spring.io/blog/2015/01/12/spring-and-angular-js-a-secure-single-page-application" title="First Article in the Series">first article</a> using the <a href="https://start.spring.io">Spring Boot Initializr</a>. E.g. using curl on a UN*X like system:</p>
<pre><code class="prettyprint">$ mkdir resource &amp;&amp; cd resource
$ curl https://start.spring.io/starter.tgz -d style=web \
-d name=resource -d language=groovy | tar -xzvf - 
</code></pre><p>You can then import that project (it&rsquo;s a normal Maven Java project by default) into your favourite IDE, or just work with the files and &ldquo;mvn&rdquo; on the command line. We are using Groovy because we can, but please feel free to use Java if you prefer. There isn&rsquo;t going to be much code anyway.</p><p>Just add a <code>@RequestMapping</code> to the <a href="https://github.com/dsyer/spring-security-angular/blob/master/vanilla/resource/src/main/groovy/demo/ResourceApplication.groovy">main application class</a>, copying the implementation from the <a href="https://github.com/dsyer/spring-security-angular/blob/master/single/src/main/java/demo/UiApplication.java">old UI</a>:</p>
<pre><code class="prettyprint java">@SpringBootApplication
@RestController
class ResourceApplication {
	
	@RequestMapping(&#39;/&#39;)
	def home() {
		[id: UUID.randomUUID().toString(), content: &#39;Hello World&#39;]
	}

    static void main(String[] args) {
        SpringApplication.run ResourceApplication, args
    }

}
</code></pre><p>Once that is done your application will be loadable in a browser. On the command line you can do this</p>
<pre><code class="prettyprint">$ mvn spring-boot:run --server.port=9000
</code></pre><p>and go to a browser at <a href="http://localhost:9000">http://localhost:9000</a> and you should see JSON with a greeting. You can bake in the port change in <code>application.properties</code> (in&ldquo;src/main/resources&rdquo;):</p>
<pre><code class="prettyprint properties">server.port: 9000
</code></pre><p>If you try loading that resource from the UI (on port 8080) in a browser, you will find that it doesn&rsquo;t work because the browser won&rsquo;t allow the XHR request.</p><h2><a href="#cors-negotiation" class="anchor" name="cors-negotiation"></a>CORS Negotiation</h2><p>The browser tries to negotiate with our resource server to find out if it is allowed to access it according to the <a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing">Common Origin Resource Sharing</a> protocol. It&rsquo;s not an Angular JS responsibility, so just like the cookie contract it will work like this with all JavaScript in the browser. The two servers do not declare that they have a common origin, so the browser declines to send the request and the UI is broken.</p><p>To fix that we need to support the CORS protocol which involves a &ldquo;pre-flight&rdquo; OPTIONS request and some headers to list the allowed behaviour of the caller. Spring 4.2 might have some nice <a href="https://jira.spring.io/browse/SPR-9278">fine-grained CORS support</a>, but until that is released we can do an adequate job for the purposes of this application by sending the same CORS responses to all requests using a <code>Filter</code>. We can just create a class in the same directory as the resource server application and make sure it is a <code>@Component</code> (so it gets scanned into the Spring application context), for example:</p>
<pre><code class="prettyprint java">@Component
@Order(Ordered.HIGHEST_PRECEDENCE)
class CorsFilter implements Filter {

  void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) {
    HttpServletResponse response = (HttpServletResponse) res
    response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)
    response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, PUT, GET, OPTIONS, DELETE&quot;)
    response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;x-requested-with&quot;)
    response.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;)
    if (request.getMethod()!=&#39;OPTIONS&#39;) {
      chain.doFilter(req, res)
    } else {
    }
  }

  void init(FilterConfig filterConfig) {}

  void destroy() {}

}
</code></pre><p>The <code>Filter</code> is defined with an <code>@Order</code> so that it is definitely applied <em>before</em> the main Spring Security filter. With that change to the resource server, we should be able to re-launch it and get our greeting in the UI.</p>
<blockquote><p>Note: blithely using <code>Access-Control-Allow-Origin=*</code> is quick and dirty, and it works, but it is not not secure and is not in any way recommended.</p>
</blockquote><h2><a href="#securing-the-resource-server" class="anchor" name="securing-the-resource-server"></a>Securing the Resource Server</h2><p>Great! We have a working application with a new architecture. The only problem is that the resource server has no security.</p><h3><a href="#adding-spring-security" class="anchor" name="adding-spring-security"></a>Adding Spring Security</h3><p>We can also look at how to add security to the resource server as a filter layer, like in the UI server. This is perhaps more conventional, and is certainly the best option in most PaaS environments (since they don&rsquo;t usually make private networks available to applications). The first step is really easy: just add Spring Security to the classpath in the Maven POM:</p>
<pre><code class="prettyprint xml">&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
  &lt;/dependency&gt;
  ...
&lt;/dependencies&gt;
</code></pre><p>Re-launch the resource server and, hey presto! It&rsquo;s secure:</p>
<pre><code class="prettyprint">$ curl -v localhost:9000
&lt; HTTP/1.1 302 Found
&lt; Location: http://localhost:9000/login
...
</code></pre><p>We are getting a redirect to a (whitelabel) login page because curl is not sending the same headers that our Angular client will. Modifying the command to send more similar headers:</p>
<pre><code class="prettyprint">$ curl -v -H &quot;Accept: application/json&quot; \
    -H &quot;X-Requested-With: XMLHttpRequest&quot; localhost:9000
&lt; HTTP/1.1 401 Unauthorized
...
</code></pre><p>So all we need to do is teach the client to send credentials with every request.</p><h2><a href="#token-authentication" class="anchor" name="token-authentication"></a>Token Authentication</h2><p>The internet, and people&rsquo;s Spring backend projects, are littered with custom token-based authentication solutions. Spring Security provides a barebones <code>Filter</code> implementation to get you started on your own (see for example <a href="https://github.com/spring-projects/spring-security/blob/master/web/src/main/java/org/springframework/security/web/authentication/preauth/AbstractPreAuthenticatedProcessingFilter.java"><code>AbstractPreAuthenticatedProcessingFilter</code></a> and <a href="https://github.com/spring-projects/spring-security/blob/master/core/src/main/java/org/springframework/security/core/token/TokenService.java"><code>TokenService</code></a>). There is no canonical implementation in Spring Security though, and one of the reasons why is probably that there&rsquo;s an easier way.</p><p>Remember from <a href="https://spring.io/blog/2015/01/12/the-login-page-angular-js-and-spring-security-part-ii" title="Second Article in the Series">Part II</a> of this series that Spring Security uses the <code>HttpSession</code> to store authentication data by default. It doesn&rsquo;t interact directly with the session though: there&rsquo;s an abstraction layer (<a href="https://github.com/spring-projects/spring-security/blob/master/web/src/main/java/org/springframework/security/web/context/SecurityContextRepository.java"><code>SecurityContextRepository</code></a>) in between that you can use to change the storage backend. If we can point that repository, in our resource server, to a store with an authentication verified by our UI, then we have a way to share authentication between the two servers. The UI server already has such a store (the <code>HttpSession</code>), so if we can distribute that store and open it up to the resource server, we have most of a solution.</p><h3><a href="#spring-session" class="anchor" name="spring-session"></a>Spring Session</h3><p>That part of the solution is pretty easy with <a href="https://github.com/spring-projects/spring-session/">Spring Session</a>. All we need is a shared data store (Redis is supported out of the box), and a few lines of configuration in the servers to set up a <code>Filter</code>.</p><p>In the UI application we need to add some dependencies to our <a href="https://github.com/dsyer/spring-security-angular/blob/master/spring-session/ui/pom.xml">POM</a>:</p>
<pre><code class="prettyprint xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;
  &lt;artifactId&gt;spring-session&lt;/artifactId&gt;
  &lt;version&gt;1.0.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre><p>and then add <code>@EnableRedisHttpSession</code> to your main application:</p>
<pre><code class="prettyprint java">@SpringBootApplication
@RestController
@EnableRedisHttpSession
public class UiApplication {

  public static void main(String[] args) {
    SpringApplication.run(UiApplication.class, args);
  }

  ...

}
</code></pre><p>The <code>@EnableRedisHttpSession</code> annotation comes from Spring Session, and Spring Boot supplies a redis connection (a URL and credentials can be configured using environment variables or configuration files).</p><p>With that 1 line of code in place and a Redis server running on localhost you can run the UI application, login with some valid user credentials, and the session data (the authentication and CSRF token) will be stored in redis.</p>
<blockquote><p>Tip: if you don&rsquo;t have a redis server running locally you can easily spin one up with <a href="https://www.docker.com/">Docker</a> (on Windows or MacOS this requires a VM). There is a <a href="https://docs.docker.com/compose/"><code>docker-compose.yml</code></a> file in the <a href="https://github.com/dsyer/spring-security-angular/tree/master/spring-session/docker-compose.yml">source code in Github</a> which you can run really easily on the command line with <code>docker-compose up</code>.</p>
</blockquote><h2><a href="#sending-a-custom-token-from-the-ui" class="anchor" name="sending-a-custom-token-from-the-ui"></a>Sending a Custom Token from the UI</h2><p>The only missing piece is the transport mechanism for the key to the data in the store. The key is the <code>HttpSession</code> ID, so if we can get hold of that key in the UI client, we can send it as a custom header to the resource server. So the &ldquo;home&rdquo; controller would need to change so that it sends the header as part of the HTTP request for the greeting resource. For example:</p>
<pre><code class="prettyprint javascript">angular.module(&#39;hello&#39;, [ &#39;ngRoute&#39; ])
...
.controller(&#39;home&#39;, function($scope, $http) {
  $http.get(&#39;token&#39;).success(function(token) {
    $http({
      url : &#39;http://localhost:9000&#39;,
      method : &#39;GET&#39;,
      headers : {
        &#39;X-Auth-Token&#39; : token.token
      }
    }).success(function(data) {
      $scope.greeting = data;
    });
  })
});
</code></pre><p>(A more elegant solution might be to grab the token as needed, and use an Angular <a href="https://docs.angularjs.org/api/ng/service/$http">interceptor</a> to add the header to every request to the resource server. The interceptor definition could then be abstracted instead of doing it all in one place and cluttering up the business logic.)</p><p>Instead of going directly to &ldquo;<a href="http://localhost:9000">http://localhost:9000</a>&rdquo; we have wrapped that call in the success callback of a call to a new custom endpoint on the UI server at &ldquo;/token&rdquo;. The implementation of that is trivial:</p>
<pre><code class="prettyprint java">@SpringBootApplication
@RestController
@EnableRedisHttpSession
public class UiApplication {

  public static void main(String[] args) {
    SpringApplication.run(UiApplication.class, args);
  }

  ...

  @RequestMapping(&quot;/token&quot;)
  @ResponseBody
  public Map&lt;String,String&gt; token(HttpSession session) {
    return Collections.singletonMap(&quot;token&quot;, session.getId());
  }

}
</code></pre><p>So the UI application is ready and will include the session ID in a header called &ldquo;X-Auth-Token&rdquo; for all calls to the backend.</p><h2><a href="#authentication-in-the-resource-server" class="anchor" name="authentication-in-the-resource-server"></a>Authentication in the Resource Server</h2><p>There is one tiny change to the resource server for it to be able to accept the custom header. The CORS filter has to nominate that header as an allowed one from remote clients, e.g.</p>
<pre><code class="prettyprint java">@Component
@Order(Ordered.HIGHEST_PRECEDENCE)
public class CorsFilter implements Filter {

  void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {
    ...
    response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;x-auth-token, x-requested-with&quot;)
    ...
  }

  ...
}
</code></pre><p>All that remains is to pick up the custom token in the resource server and use it to authenticate our user. This turns out to be pretty straightforward because all we need to do is tell Spring Security where the session repository is, and where to look for the token (session ID) in an incoming request. First we need to add the Spring Session and Redis dependencies, and then we can set up the <code>Filter</code>:</p>
<pre><code class="prettyprint java">@SpringBootApplication
@RestController
@EnableRedisHttpSession
class ResourceApplication {

  ...
  
  @Bean
  HeaderHttpSessionStrategy sessionStrategy() {
    new HeaderHttpSessionStrategy();
  }

}
</code></pre><p>This <code>Filter</code> created is the mirror image of the one in the UI server, so it establishes Redis as the session store. The only difference is that it uses a custom <code>HttpSessionStrategy</code> that looks in the header (&ldquo;X-Auth-Token&rdquo; by default) instead of the default (cookie named &ldquo;JSESSIONID&rdquo;). We also need to prevent the browser from popping up a dialog in an unauthenticated client - the app is secure but sends a 401 with <code>WWW-Authenticate: Basic</code> by default, so the browser responds with a dialog for username and password. There is more than one way to achieve this, but we already made Angular send an &ldquo;X-Requested-With&rdquo; header, so Spring Security handles it for us by default.</p><p>There is one final change to the resource server to make it work with our new authentication scheme. Spring Boot default security is stateless, and we want this to store authentication in the session, so we need to be explicit in <code>application.yml</code> (or <code>application.properties</code>):</p>
<pre><code class="prettyprint yaml">security:
  sessions: NEVER
</code></pre><p>This says to Spring Security &ldquo;never create a session, but use one if it is there&rdquo; (it will be already be there because of the authentication in the UI).</p><p>Re-launch the resource server and open the UI up in a new browser window.</p><h2><a href="#why-doesn-rsquo-t-it-all-work-with-cookies" class="anchor" name="why-doesn-rsquo-t-it-all-work-with-cookies"></a>Why Doesn&rsquo;t it All Work With Cookies?</h2><p>We had to use a custom header and write code in the client to populate the header, which isn&rsquo;t terribly complicated, but it seems to contradict the advice in <a href="https://spring.io/blog/2015/01/12/the-login-page-angular-js-and-spring-security-part-ii" title="Second Article in the Series">Part II</a> to use cookies and sessions wherever possible. The argument there was that not to do so introduces additional unecessary complexity, and for sure the implementation we have now is the most complex we have seen so far: the technical part of the solution far outweighs the business logic (which is admittedly tiny). This is definitely a fair criticism (and one we plan to address in the next article in this series), but let&rsquo;s just briefly look at why it&rsquo;s not as simple as just using cookies and sessions for everything.</p><p>At least we are still using the session, which makes sense because Spring Security and the Servlet container know how to do that with no effort on our part. But couldn&rsquo;t we have continued to use cookies to transport the authentication token? It would have been nice, but there is a reason it wouldn&rsquo;t work, and that is that the browser wouldn&rsquo;t let us. You can just go poking around in the browser&rsquo;s cookie store from a JavaScript client, but there are some restrictions, and for good reason. In particular you don&rsquo;t have access to the cookies that were sent by the server as &ldquo;HttpOnly&rdquo; (which you will see is the case by default for session cookies). You also can&rsquo;t set cookies in outgoing requests, so we couldn&rsquo;t set a &ldquo;SESSION&rdquo; cookie (which is the Spring Session default cookie name), we had to use a custom &ldquo;X-Session&rdquo; header. Both these restrictions are for your own protection so malicious scripts cannot access your resources without proper authorization.</p><p>TL;DR the UI and resource servers do not have a common origin, so they cannot share cookies (even though we can use Spring Session to force them to share sessions).</p><h2><a href="#conclusion" class="anchor" name="conclusion"></a>Conclusion</h2><p>We have duplicated the features of the application in <a href="https://spring.io/blog/2015/01/12/the-login-page-angular-js-and-spring-security-part-ii" title="Second Article in the Series">Part II of this series</a>: a home page with a greeting fetched from a remote backend, with login and logout links in a navigation bar. The difference is that the greeting comes from a resource server that is a standalone, instead of being embedded in the UI server. This added significant complexity to the implementation, but the good news is that we have a mostly configuration-based (and practically 100% declarative) solution. We could even make the solution 100% declarative by extracting all the new code into libraries (Spring configuration and Angular custom directives). We are going to defer that interesting task for after the next couple of installments. In the <a href="https://spring.io/blog/2015/01/28/the-api-gateway-pattern-angular-js-and-spring-security-part-iv">next article</a> we are going to look at a different really great way to reduce all the complexity in the current implementation: the API Gateway Pattern (the client sends all its requests to one place and authentication is handled there).</p>
<blockquote><p>Note: we used Spring Session here to share sessions between 2 servers that are not logically the same application. It&rsquo;s a neat trick, and it isn&rsquo;t possible with &ldquo;regular&rdquo; JEE distributed sessions.</p>
</blockquote></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 1905;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>
Back
</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">All Posts</a>
<a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">Engineering</a>
<a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">Releases</a>
<a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">News and Events</a>
<a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>Get updates from The Spring Team delivered to your inbox</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">Tools</a></li>
<li><a href="https://store.pivotal.io/">Store</a></li>
<li><a href="/blog">Newsletter</a></li>
</ul>
</div>
</div>
&copy; <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a>, Inc. All Rights Reserved.
<a href="https://pivotal.io/terms-of-use">Terms of Use</a> &bullet;
<a href="https://pivotal.io/privacy-policy">Privacy</a> &bullet;
<a href="/trademarks">Trademark Guidelines</a>
<div id="teconsent" style="display:inline-block;"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>