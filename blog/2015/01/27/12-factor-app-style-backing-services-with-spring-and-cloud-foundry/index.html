<html  data-code-prettify="" data-mobile-support="" data-search=""><head></head><body >﻿
<title>具有Spring和Cloud Foundry的12要素应用程序样式支持服务</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content=" 12-Factor App-Style Backing Services with Spring and Cloud Foundry">
<meta name="twitter:description" >
<meta name="twitter:creator" content="@starbuxman">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=200">

<meta property="og:title" content=" 12-Factor App-Style Backing Services with Spring and Cloud Foundry">
<meta property="og:image" content="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=200">
<meta property="og:description" >
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2015-01-27 23:00:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">具有Spring和Cloud Foundry的12要素应用程序样式支持服务</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=20&d=mm"> <a class="author" rel="author" href="/team/jlong">乔什·朗（Josh Long）</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2015-01-27 23:00:00.0">2015年1月27日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2015/01/27/12-factor-app-style-backing-services-with-spring-and-cloud-foundry#disqus_thread" data-disqus-identifier="1945">
</a></div>
</div>
</header>
<div class="blog--post"><p>《 <a href="http://12factor.net/">12因素应用宣言》详细</a>讨论了<a href="http://12factor.net/backing-services">支持服务</a> 。基本上，后备服务是您的应用程序用来完成其工作所消耗的任何网络附加服务。这可能是MongoDB实例，PostgreSQL数据库，像Amazon S3这样的二进制存储，像New Relic这样的指标收集服务，RabbitMQ或ActiveMQ消息队列，基于Memcached或Redis的缓存，FTP服务，电子邮件服务或其他任何东西其他。这种区别是没有这么多的服务是<em>什么</em>这么多，因为<em>它是如何暴露，并在应用程序使用</em> 。这两个应用程序都附有资源，可通过URL或配置中存储的其他定位符/凭证访问。</p><p>我们研究了如何使用<a href="https://spring.io/blog/2015/01/13/configuring-it-all-out-or-12-factor-app-style-configuration-with-spring"><em>配置</em></a>从应用程序代码中解脱诸如定位符和凭据之类的魔术字符串并将其外部化。我们还<a href="https://spring.io/blog/2015/01/20/microservice-registration-and-discovery-with-spring-cloud-and-netflix-s-eureka">研究了使用服务注册表</a>在动态（通常是云）环境中保留某种微服务的实时<em>电话簿</em> 。</p><p>在本文中，我们将研究<a href="http://cloudfoundry.org">Cloud Foundry</a>或Heroku等<a href="https://en.wikipedia.org/wiki/Platform_as_a_service">平台即服务（PaaS）环境</a>通常公开<em>支持服务的方式</em> ，并探讨在Spring应用程序内部使用这些服务的方式。对于我们的示例，我们将使用Cloud Foundry，因为它是开源的，并且易于在任何数据中心或托管中运行，尽管其中大多数都非常容易应用于Heroku。</p><p>我的朋友<a href="https://twitter.com/ab415">Abby Gregory Kearns</a>很好地概括<a href="https://blog.pivotal.io/cloud-foundry-pivotal/products/why-services-are-essential-to-your-platform-as-a-service">了Cloud Foundry支持服务组合</a>的<a href="https://blog.pivotal.io/cloud-foundry-pivotal/products/why-services-are-essential-to-your-platform-as-a-service">作用和价值</a> 。</p><p>像Cloud Foundry这样的PaaS将支持服务公开为操作系统进程本地环境变量。环境变量之所以方便，是因为它们适用于所有语言和运行时，并且很容易从一种环境更改为另一种环境。这比试图让JNDI起来和本地机器上运行，例如简单<em>的方式</em> ，促进建立便携。我打算在本文中专门通过当今Cloud Foundry的角度来查看支持服务。请记住，尽管该方法专门用于在云环境<em>之外</em>推广可移植构建。弹簧是量身定制的，便于携带；依赖注入促进了将Bean（例如，来自后勤服务的Bean）的耦合和初始化和获取逻辑从其使用地点解耦。我们可以使用Spring来编写思考<code>javax.sql.DataSources</code>然后将配置写入源<code>DataSource</code>当应用程序从一种环境迁移到另一种环境时，可以从正确的上下文和配置中进行选择。</p><p>下一版本的Cloud Foundry（在新闻中称为“ <em>迭戈</em> ”）下的运行时是Docker-first和Docker-native。当然，Docker使容器化应用程序变得容易，容器化应用程序与外部世界之间的接口也被故意最小化，以促进可移植应用程序的发展。您猜到，Docker映像中的关键输入之一就是环境变量！我们的朋友Chris Richardson在打包和构建<a href="http://plainoldobjects.com/2014/11/16/deploying-spring-boot-based-microservices-with-docker/?utm_content=bufferc3d35&utm_medium=social&utm_source=twitter.com&utm_campaign=buffer">基于Spring Boot的Docker映像</a>以及<a href="http://plainoldobjects.com/2015/01/14/need-to-install-mongodb-rabbitmq-or-mysql-use-docker-to-simplify-dev-and-test/">站起来的支持服务</a>方面做了很多不错的文章。我们不会在本文中介绍Docker（不过，请继续关注！），但是内部化很重要：环境变量是外部化支持服务连接信息的简单易行的方式。</p><h2><a href="#a-simple-spring-boot-application-that-talks-to-a-jdbc-code-datasource-code" class="anchor" name="a-simple-spring-boot-application-that-talks-to-a-jdbc-code-datasource-code"></a>与JDBC对话的简单Spring Boot应用程序<code>DataSource</code></h2><p>这是一个简单的Spring Boot应用程序，可从其中插入并公开一些记录。 <code>DataSource</code> Spring Boot会自动为我们创建的bean，因为CLASSPATH上有H2嵌入式数据库驱动程序。如果Spring Boot未检测到类型的Bean <code>javax.sql.DataSource</code>并且<em>确实</em>检测到嵌入式数据库驱动程序（H2，Derby，HSQL），它将自动创建嵌入式<code>javax.sql.DataSource</code>豆。本示例使用JPA将记录映射到数据库。这是Maven依赖项：</p>
<table>
<thead>
<tr>
<th>组号</th>
<th>伪影ID</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>com.h2database</code> </td>
<td><code>h2</code> </td>
</tr>
<tr>
<td><code>org.springframework.boot</code> </td>
<td><code>spring-boot-starter-data-jpa</code> </td>
</tr>
<tr>
<td><code>org.springframework.boot</code> </td>
<td><code>spring-boot-starter-data-rest</code> </td>
</tr>
<tr>
<td><code>org.springframework.boot</code> </td>
<td><code>spring-boot-starter-test</code> </td>
</tr>
<tr>
<td><code>org.springframework.boot</code> </td>
<td><code>spring-boot-starter-actuator</code> </td>
</tr>
</tbody>
</table><p>这是示例Java代码：</p>
<pre><code class="prettyprint java">package demo;

import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.rest.core.annotation.RepositoryRestResource;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import java.util.Arrays;

@SpringBootApplication
public class DemoApplication {

	public static void main(String[] args) {
		SpringApplication.run(DemoApplication.class, args);
	}

	@Bean
	CommandLineRunner seed(ReservationRepository rr) {
		return args -&gt; Arrays.asList(&quot;Phil,Webb&quot;, &quot;Josh,Long&quot;, &quot;Dave,Syer&quot;, &quot;Spencer,Gibb&quot;).stream()
			.map(s -&gt; s.split(&quot;,&quot;))
			.forEach(namePair -&gt; rr.save(new Reservation(namePair[0], namePair[1])));
	}
}

@RepositoryRestResource
interface ReservationRepository extends JpaRepository&lt;Reservation, Long&gt; {
}

@Entity
class Reservation {

	@Id
	@GeneratedValue
	private Long id;

	private String firstName, lastName;

	Reservation() {
	}

	public Reservation(String firstName, String lastName) {
		this.firstName = firstName;
		this.lastName = lastName;
	}

	public Long getId() {
		return id;
	}

	public String getFirstName() {
		return firstName;
	}

	public String getLastName() {
		return lastName;
	}
}
</code></pre><h2><a href="#creating-and-binding-backing-services-in-cloud-foundry" class="anchor" name="creating-and-binding-backing-services-in-cloud-foundry"></a>在Cloud Foundry中创建和绑定支持服务</h2><p>该应用程序可在本地运行，但现在让我们使其在Cloud Foundry上运行，需要在该应用程序上告诉它如何连接到为其公开的支持服务（PostgreSQL实例）。</p><p>Cloud Foundry有多种口味。像Heroku一样，您可以在基于AWS的风味上托管它， <a href="https://run.pivotal.io">并以Pivotal Web Services的形式运行</a> 。您可以获得一个免费试用帐户。您可以使用Pivotal的收缩包装变体<a href="https://www.pivotal.io/platform-as-a-service/pivotal-cf">Pivotal Cloud Foundry</a> ，并根据需要在数据中心中运行它。另外，您也可以<a href="http://cloudfoundry.org">使用开源代码</a>并运行它。或使用<a href="https://console.ng.bluemix.net/">IBM</a>和<a href="http://www8.hp.com/us/en/cloud/helion-devplatform-overview.html">HP</a>之类的众多其他实现中的任何一种。无论如何，您最终将获得一个PaaS，其行为在支持服务方面基本相同。</p><p>添加支持服务是声明性功能：只需<em>创建</em>一个服务，然后将其绑定即可。Cloud Foundry具有<em>市场</em>命令： <code>cf marketplace</code> 。对于80％的情况，您应该可以从以下选项中进行选择： <code>cf marketplace</code>输出。选择服务后，创建该服务的实例，如下所示：</p>
<pre><code class="prettyprint bash">cf create-service elephantsql turtle postgresql-db
</code></pre><p>请特别注意<code>postgresql-db</code>是后勤服务名称， <code>elephantsql</code>是服务提供商名称，并且<code>turtle</code>是（免费）分层<em>计划</em>名称。有了它，您就可以<em>将</em>服务<em>绑定</em>到已部署的应用程序。您可以使用<code>cf</code> CLI，或只是在应用程序的声明中声明后台服务依赖项<code>manifest.yml</code>文件。</p><p>这是基本的<code>manifest.yml</code>对于我们所有的样本。的<code>name</code>和<code>host</code>从一个清单更改为另一个清单，但本文的示例使用此新创建的清单<code>postgresql-db</code>服务。</p>
<pre><code class="prettyprint">---
applications:
- name: simple-backing-services
	memory: 512M
	instances: 1
	host: simple-backing-services-${random-word}
	domain: cfapps.io
	path: target/simple.jar
	services:
		- postgresql-db
	env:
		SPRING_PROFILES_ACTIVE: cloud
		DEBUG: &quot;true&quot;
		debug: &quot;true&quot;
</code></pre><p>现在，让我们看一下使用支持服务的几种不同方式，并了解它们的一些优点和缺点。</p><p>对于所有这些示例，我们将至少使用<a href="https://start.spring.io">Spring Boot</a> 。Spring Boot提供了Spring Boot执行器模块。它提供有关应用程序的非常有用的信息-指标，环境转储，所有已定义bean的列表等。我们将使用其中的一些端点来深入了解运行Spring应用程序时暴露的环境变量和系统属性，以及了解诸如运行Spring Boot的配置文件之类的内容。在您的Maven或Gradle构建中添加Spring Boot Actuator。的<code>groupId</code>是<code>org.springframework.boot</code>和<code>artifactId</code>是<code>spring-boot-starter-actuator</code> 。如果您使用的是从生成的Spring Boot，则无需指定版本<a href="https://start.spring.io"><code>start.spring.io</code></a>或者<code>spring init</code> CLI命令。</p><h2><a href="#cloud-foundry-rsquo-s-auto-reconfiguration" class="anchor" name="cloud-foundry-rsquo-s-auto-reconfiguration"></a> Cloud Foundry的自动重新配置</h2><p><a href="https://github.com/cloudfoundry/java-buildpack/blob/master/docs/framework-spring_auto_reconfiguration.md">Cloud Foundry Java buildpack</a>会为您<em>自动重新配置</em> 。<a href="https://github.com/cloudfoundry/java-buildpack-auto-reconfiguration">从文档</a> ：</p>
<blockquote><p>自动重新配置包括三个部分。首先，它添加了<code>cloud</code>配置文件到Spring的活动配置文件列表。其次，它将Cloud Foundry贡献的所有属性公开为<code>PropertySource</code>在里面<code>ApplicationContext</code> 。最后，它重写了各种类型的Bean定义，以自动与绑定到应用程序的服务连接。重写的类型如下：</p>
<table>
<thead>
<tr>
<th>豆类型</th>
<th>服务类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>javax.sql.DataSource</code> </td>
<td>关系数据服务（例如，ClearDB，ElephantSQL）</td>
</tr>
<tr>
<td><code>org.springframework.amqp.rabbit.connection.ConnectionFactory</code> </td>
<td>RabbitMQ服务（例如CloudAMQP）</td>
</tr>
<tr>
<td><code>org.springframework.data.mongodb.MongoDbFactory</code> </td>
<td>Mongo服务（例如MongoLab）</td>
</tr>
<tr>
<td><code>org.springframework.data.redis.connection.RedisConnectionFactory</code> </td>
<td>Redis服务（例如，Redis Cloud）</td>
</tr>
<tr>
<td><code>org.springframework.orm.hibernate3.AbstractSessionFactoryBean</code> </td>
<td>关系数据服务（例如，ClearDB，ElephantSQL）</td>
</tr>
<tr>
<td><code>org.springframework.orm.hibernate4.LocalSessionFactoryBean</code> </td>
<td>关系数据服务（例如，ClearDB，ElephantSQL）</td>
</tr>
<tr>
<td><code>org.springframework.orm.jpa.AbstractEntityManagerFactoryBean</code> </td>
<td>关系数据服务（例如，ClearDB，ElephantSQL）</td>
</tr>
</tbody>
</table>
</blockquote><p>效果是，假设您有一个支持服务，该服务指向创建并绑定到该应用程序的PostgreSQL实例，就像上面所做的那样，在本地H2上运行的应用程序将自动针对Cloud Foundry上的PostgreSQL运行。这很方便！如果您仅有两个目标目标是localhost和Cloud Foundry，则此方法非常有效。</p><h2><a href="#useful-code-environment-code-properties-for-your-spring-application" class="anchor" name="useful-code-environment-code-properties-for-your-spring-application"></a>有用<code>Environment</code> Spring应用程序的属性</h2><p>默认的Java buildpack（您可以在执行<code>cf push</code>或者通过在您的<code>manifest.yml</code> ）添加弹簧<code>Environment</code><code>PropertySource</code>注册了一系列以开头的属性<code>cloud.</code> 。如果您访问REST，则可以看到它们<code>/env</code>将应用程序推送到Cloud Foundry后，将其作为上述应用程序中的终结点。这是我的应用程序的<em>一些</em>输出：</p>
<pre><code class="prettyprint json"><br />{
	...
	cloud.services.postgresql-db.connection.jdbcurl: &quot;jdbc:postgresql://babar.elephantsql.com:5432/AUSER?user=AUSER&amp;password=WOULDNTYOULIKETOKNOW&quot;,
	...
	cloud.services.postgresql-db.connection.uri: &quot;postgres://AUSER:<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="0e59415b424a405a57415b4247454b5a41454041594e6c6f6c6f7c206b626b7e666f607a7d7f62206d6163">[email&#160;protected]</a>:5432/AUSER&quot;,
	cloud.services.postgresql-db.connection.scheme: &quot;postgres&quot;,
	cloud.services.postgresql.connection.jdbcurl: &quot;jdbc:postgresql://babar.elephantsql.com:5432/AUSER?user=AUSER&amp;password=WOULDNTYOULIKETOKNOW&quot;,
	cloud.services.postgresql.connection.port: 5432,
	cloud.services.postgresql.connection.path: &quot;AUSER&quot;,
	cloud.application.host: &quot;0.0.0.0&quot;,
	cloud.services.postgresql-db.connection.password: &quot;******&quot;,
	cloud.services.postgresql-db.connection.username: &quot;AUSER&quot;,
	...
	cloud.application.application_name: &quot;simple-backing-services&quot;,
	cloud.application.limits: {
		mem: 512,
		disk: 1024,
		fds: 16384
	},
	cloud.services.postgresql-db.id: &quot;postgresql-db&quot;,
	cloud.application.application_uris: [
	&quot;simple-backing-services-fattiest-teniafuge.cfapps.io&quot;,
	&quot;simple-backing-services-unmummifying-prehnite.cfapps.io&quot;
],
	cloud.application.instance_index: 0,
	...
}
</code></pre><p>您可以像其他任何属性一样在Spring中使用这些属性。它们也非常方便，因为它们不仅提供了相当标准的Heroku式连接URI（ <code>cloud.services.postgresql-db.connection.uri</code> ），也可以直接在JDBC上下文中使用， <code>cloud.services.postgresql.connection.jdbcurl</code> 。只要使用此（或其中的一个）buildpack，您就会从这些属性中受益。</p><p>Cloud Foundry将所有这些信息作为标准，语言和技术的网络环境变量公开（ <code>VCAP_SERVICES</code>和<code>VCAP_APPLICATION</code> ）。从理论上讲，您应该能够为任何Cloud Foundry实施编写应用程序，并将这些变量作为目标。Spring Boot还为这些变量提供了<em>自动配置</em> ，无论您是否使用上述Java buildpack，这种方法都有效。</p><p>Spring Boot将这些环境变量映射到Spring可以访问的一组属性中<code>Environment</code>抽象。这是来自<code>VCAP_*</code> Spring Boot公开的属性，也来自<code>/env</code> ：</p>
<pre><code class="prettyprint json">{
	...
	vcap.application.start: &quot;2015-01-27 09:58:13 +0000&quot;,
	vcap.application.application_version: &quot;9e6ba76e-039f-4585-9573-8efa9f7e9b7e&quot;,
	vcap.application.application_uris[2]: &quot;simple-backing-services-detersive-sterigma.cfapps.io&quot;,
	vcap.application.uris: &quot;simple-backing-services-fattiest-teniafuge.cfapps.io,simple-backing-services-grottoed-distillment.cfapps.io,...&quot;,
	vcap.application.space_name: &quot;joshlong&quot;,
	vcap.application.started_at: &quot;2015-01-27 09:58:13 +0000&quot;,
	vcap.services.postgresql-db.tags: &quot;Data Stores,Data Store,postgresql,relational,New Product&quot;,
	vcap.services.postgresql-db.credentials.uri: &quot;postgres://AUSER:<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="7c2b3329303832282533293035373928333732332b3c1e1d1e1d0e521910190c141d12080f0d10521f1311">[email&#160;protected]</a>:5432/hqsugvxo&quot;,
	vcap.services.postgresql-db.tags[1]: &quot;Data Store&quot;,
	vcap.services.postgresql-db.tags[4]: &quot;New Product&quot;,
	vcap.application.application_name: &quot;simple-backing-services&quot;,
	vcap.application.name: &quot;simple-backing-services&quot;,
	vcap.application.uris[2]: &quot;simple-backing-services-detersive-sterigma.cfapps.io&quot;,
	...
}
</code></pre><p>我倾向于稍微依赖每种方法。Spring Boot属性很方便，因为它们提供了索引属性。 <code>vcap.application.application_uris[2]</code>提供了一种方法来为此应用程序的可能路由数组建立索引。如果您想告诉正在运行的应用程序其外部可访问的URI是什么（例如，如果它需要在启动任何请求之前在启动时建立回调），则这是理想的选择。它还提供了与技术无关的等效URI，但不提供特定于JDBC的连接字符串。所以，我会同时使用。这种方法很方便，尤其是在Spring Boot中，因为我可以在我的配置和设置属性（例如<code>spring.datasource.*</code> ）指导Spring Boot如何进行设置。为了明确起见，或者如果我有多个相同类型的支持服务（例如JDBC），这很有用。 <code>javax.sql.DataSource</code> ）绑定到同一应用程序。在这种情况下，buildpack将不知道该怎么做，因此您需要明确并消除歧义应该注入哪个后备服务引用以及在哪里。</p><h2><a href="#using-spring-profiles" class="anchor" name="using-spring-profiles"></a>使用Spring配置文件</h2><p>默认情况下，Spring Boot加载<code>src/main/resources/application.(properties,yml)</code> 。它还将加载表单的特定于配置文件的属性文件， <code>src/main/resources/application-PROFILE.yml</code> ，在哪里<code>PROFILE</code>是<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-profiles.html">活动的Spring配置文件</a>的名称。之前，我们看到<code>manifest.yml</code>专门激活<code>cloud</code>通过设置环境变量来配置文件。因此，假设您想拥有一个仅在以下情况下激活的配置： <code>cloud</code>配置文件，另一个是在未激活特定配置文件时被激活的-称为<code>default</code>轮廓。您可以创建三个文件： <code>src/main/resources/application-cloud.(properties,yml)</code>每当<code>cloud</code>个人资料已激活， <code>src/main/resources/application-default.(properties,yml)</code>当没有其他特定的配置文件被特别激活时，它将被激活，并且<code>src/main/resources/application.(properties,yml)</code>无论在任何情况下都将激活该功能。</p><p>一个样品<code>src/main/resources/application.properties</code> ：</p>
<pre><code class="prettyprint properties">spring.jpa.generate-ddl=true
</code></pre><p>一个样品<code>src/main/resources/application-cloud.properties</code> ：</p>
<pre><code class="prettyprint properties">spring.datasource.url=${cloud.services.postgresql-db.connection.jdbcurl}
</code></pre><p>一个样品<code>src/main/resources/application-default.properties</code> ：</p>
<pre><code class="prettyprint properties"># empty in this case because I rely on the embedded H2 instance being created
# though you could point it to another, local,
# PostgresSQL instancefor dev workstation configuration
</code></pre><h2><a href="#using-spring-cloud-paas-connectors" class="anchor" name="using-spring-cloud-paas-connectors"></a>使用Spring Cloud PaaS连接器</h2><p>到目前为止，所有这些选项都利用了<code>Environment</code>抽象。毫无疑问，它们比手动分离JSON结构简单得多。 <code>VCAP_SERVICES</code>变量，但我们可以做得更好。正如<a href="https://github.com/spring-cloud/spring-cloud-connectors/blob/master/README.md">Spring Cloud Connectors</a>项目的文档所说：</p>
<blockquote><p>Spring Cloud为在云平台上运行的基于JVM的应用程序提供了一个简单的抽象，以在运行时发现绑定的服务和部署信息，并提供了将发现的服务注册为Spring bean的支持。它基于插件模型，因此相同的编译应用程序可以部署在本地或多个云上，并且通过Java SPI支持自定义服务定义。</p>
</blockquote><p>让我们看一下修改后的示例：</p>
<pre><code class="prettyprint java">package demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.config.java.AbstractCloudConfig;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.rest.core.annotation.RepositoryRestResource;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.sql.DataSource;

@SpringBootApplication
public class DemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }

    @Configuration
    @Profile(&quot;cloud&quot;)
    public static class DataSourceConfig extends AbstractCloudConfig {

        @Bean
        DataSource reservationsPostgreSqlDb() {
            return connectionFactory().dataSource(&quot;postgresql-db&quot;);
        }
    }

}

@RepositoryRestResource
interface ReservationRepository extends JpaRepository&lt;Reservation, Long&gt; {
}

@Entity
class Reservation {
    @Id
    @GeneratedValue
    private Long id;

    public Long getId() {
        return id;
    }

    private String firstName, lastName;

    Reservation() {
    }

    public Reservation(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

    public String getFirstName() {
        return firstName;
    }

    public String getLastName() {
        return lastName;
    }
}
</code></pre><p>而不是配置<code>javax.sql.DataSource</code>使用属性和Spring Boot，我们显式地创建了正确类型的对象。还有其他支持其他服务的方法，例如<a href="https://www.mongodb.org/">MongoDB</a> ， <a href="http://redis.io">Redis</a> ， <a href="https://sendgrid.com/">SendGrid</a>等，您可以轻松提供自己的方法。我们正在为Cloud Foundry使用Spring Cloud Connectors插件，尽管没有理由不能为Heroku使用Spring Cloud Connectors插件，也不能为本地应用程序使用基于属性的替代方案。这样，您的应用程序在各个环境中都是相同的，只有外部配置有所不同。</p><h2><a href="#using-java-configuration-code-bean-code-s" class="anchor" name="using-java-configuration-code-bean-code-s"></a>使用Java配置<code>@Bean</code> s</h2><p>到目前为止，我们已经依赖于平台或框架提供的常识性默认值，但是您无需放弃任何控制权。例如，您可以使用环境中的值以XML或Java配置显式定义一个bean。如果您的应用程序要使用自定义连接池，或者以其他方式自定义备份服务的配置，则可以执行此操作。如果平台和框架对要使用的支持服务没有<em>自动</em>支持，则也可以这样做。</p>
<pre><code class="prettyprint java"><br />	@Bean
	@Profile(&quot;cloud&quot;)
	DataSource dataSource(
			@Value(&quot;${cloud.services.postgresql-db.connection.jdbcurl}&quot;) String jdbcUrl) {
		try {
			return new SimpleDriverDataSource(
				org.postgresql.Driver.class.newInstance() , jdbcUrl);
		}
		catch (Exception e) {
			throw new RuntimeException(e) ;
		}
	}
</code></pre><h2><a href="#where-to-go-from-here" class="anchor" name="where-to-go-from-here"></a>然后去哪儿？</h2><p>到目前为止，我们仅研究了Cloud Foundry公开的服务。如果您想使用PaaS之外的服务，那么很容易使用<a href="http://docs.cloudfoundry.org/devguide/services/user-provided.html">Cloud Foundry的用户提供的服务</a>将其像其他支持服务一样对待。这种机制只是一种告诉Cloud Foundry有关您希望您的应用程序与之通信的自定义服务的定位器和凭据信息的好方法。完成此操作后，Cloud Foundry应用程序和服务可以将该服务绑定到其应用程序，并像往常一样使用它。用户提供的服务是理想的或您不想让Cloud Foundry管理的服务，例如固定的Oracle实例。Cloud Foundry不会添加新实例，不会删除它们，并且不控制授权。</p><p>如果要Cloud Foundry管理服务，则需要<a href="http://docs.cloudfoundry.org/services/api.html">使用Service Broker API</a>使其适应<a href="http://docs.cloudfoundry.org/services/api.html">Cloud Foundry</a> 。在您自己的环境中部署Cloud Foundry时，这尤为重要，并且需要<em>管理员</em>特权（例如，托管的Pivotal Cloud Foundry中不会具有）。服务代理API是Cloud Foundry需要注意的一组著名的REST回调。实施您自己的定制服务代理很容易，甚至还有这个方便<a href="https://github.com/cloudfoundry-community/spring-boot-cf-service-broker">的基于Spring Boot的项目</a>和<a href="https://github.com/spgreenberg/spring-boot-cf-service-broker-mongo">相应的示例</a> 。</p><p>也查看<a href="https://github.com/joshlong/12factor-backing-services">示例</a> ！</p></div>
</div>
<section id="disqus_thread"></section>
<script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 1945;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>