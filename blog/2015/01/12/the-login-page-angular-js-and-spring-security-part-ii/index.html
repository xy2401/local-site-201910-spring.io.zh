<html dir="ltr" data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>登录页面：Angular JS和Spring Security第二部分</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>System.config({baseURL: "/b92013b"});</script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>System.import('app/main.js')</script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="The Login Page: Angular JS and Spring Security Part II">
<meta name="twitter:description" content="<blockquote>
 <p>Note: the source code and test for this blog continue to evolve, but the changes to the text are not being maintained here. Please see <a href=" https:="" ="" spring.io guides="" tutorials="" spring-security-and-angular-js="" ="="></meta>the tutorial version for the most up to date content. 

<p>In this article we continue <a href=" http: blog 2015 01 12 spring-and-angular-js-a-secure-single-page-application" title="系列文章的第一篇"></head><body dir="ltr" class="ng-cloak" ng-app="hello" ng-cloak="">our discussion of how to use <a href="http://projects.spring.io/spring-security">Spring Security</a> with <a href="http://angularjs.org">Angular JS</a> in a “single page application”. Here we show how to use Angular JS to authenticate a user via a form and fetch a secure resource to render in the UI. This is the second in a series of articles, and you can catch up on the basic building blocks of the application or build it from scratch by reading the <a href="http://spring.io/blog/2015/01/12/spring-and-angular-js-a-secure-single-page-application" title="系列文章的第一篇">first article</a>, or you can just go straight to the <a href="https://github.com/dsyer/spring-security-angular/tree/master/single">source code in Github</a>. In the first article we built a simple application that used HTTP Basic authentication to protect the backend resources. In this one we add a login form, give the user some control over whether to authenticate or not, and fix the issues with the first iteration (principally lack of CSRF protection).<p></p>
">
<meta name="twitter:creator" content="@david_syer">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=200">

<meta property="og:title" content="The Login Page: Angular JS and Spring Security Part II">
<meta property="og:image" content="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=200">
<meta property="og:description" content="<blockquote>
 <p>Note: the source code and test for this blog continue to evolve, but the changes to the text are not being maintained here. Please see <a href=" https:="" ="" spring.io guides="" tutorials="" spring-security-and-angular-js="" ="="></meta>the tutorial version for the most up to date content. 

<p>In this article we continue <a href=" http: blog 2015 01 12 spring-and-angular-js-a-secure-single-page-application" title="系列文章的第一篇">our discussion of how to use <a href="http://projects.spring.io/spring-security">Spring Security</a> with <a href="http://angularjs.org">Angular JS</a> in a “single page application”. Here we show how to use Angular JS to authenticate a user via a form and fetch a secure resource to render in the UI. This is the second in a series of articles, and you can catch up on the basic building blocks of the application or build it from scratch by reading the <a href="http://spring.io/blog/2015/01/12/spring-and-angular-js-a-secure-single-page-application" title="系列文章的第一篇">first article</a>, or you can just go straight to the <a href="https://github.com/dsyer/spring-security-angular/tree/master/single">source code in Github</a>. In the first article we built a simple application that used HTTP Basic authentication to protect the backend resources. In this one we add a login form, give the user some control over whether to authenticate or not, and fix the issues with the first iteration (principally lack of CSRF protection).<p></p>
">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2015-01-12 12:20:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">// Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }</script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">登录页面：Angular JS和Spring Security第二部分</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=20&d=mm"> <a class="author" rel="author" href="/team/dsyer">戴夫·瑟</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2015-01-12 12:20:00.0">2015年1月12日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2015/01/12/the-login-page-angular-js-and-spring-security-part-ii#disqus_thread" data-disqus-identifier="1904">
</a></div>
</div>
</header>
<div class="blog--post"><blockquote><p>注意：此博客的源代码和测试在不断发展，但此处未保留对文本的更改。请参阅<a href="https://spring.io/guides/tutorials/spring-security-and-angular-js/">本教程的版本</a>为最最新的内容。</p>
</blockquote><p>在本文中，我们继续<a href="https://spring.io/blog/2015/01/12/spring-and-angular-js-a-secure-single-page-application" title="系列文章的第一篇">讨论</a>如何在“单页应用程序”中将<a href="https://projects.spring.io/spring-security">Spring Security</a>与<a href="http://angularjs.org">Angular JS</a>一起使用。在这里，我们展示了如何使用Angular JS通过表单对用户进行身份验证以及如何获取安全资源以在UI中呈现。这是系列文章中的第二篇，您可以了解应用程序的基本构建块，或者通过阅读<a href="https://spring.io/blog/2015/01/12/spring-and-angular-js-a-secure-single-page-application" title="系列文章的第一篇">第一篇文章</a>从头开始构建它，或者直接进入<a href="https://github.com/dsyer/spring-security-angular/tree/master/single">Github中</a>的<a href="https://github.com/dsyer/spring-security-angular/tree/master/single">源代码</a> 。在第一篇文章中，我们构建了一个简单的应用程序，该应用程序使用HTTP Basic身份验证来保护后端资源。在此表单中，我们添加了一个登录表单，使用户可以控制是否进行身份验证，并解决第一次迭代中的问题（主要是缺少CSRF保护）。</p>
<blockquote><p>提醒：如果您正在使用示例应用程序浏览本文，请确保清除浏览器的cookie和HTTP Basic凭据缓存。在Chrome中，对单个服务器执行此操作的最佳方法是打开一个新的隐身窗口。</p>
</blockquote><h2><a href="#add-navigation-to-the-home-page" class="anchor" name="add-navigation-to-the-home-page"></a>将导航添加到主页</h2><p>单页应用程序的核心是静态的“ index.html”。我们已经有了一个非常基础的功能，但是对于此应用程序，我们需要提供一些导航功能（登录，注销，主页），因此让我们对其进行修改（在“ src / main / resources / static”中）：</p>
<pre><code class="prettyprint html"><!doctype html>
<html>
<head>
<title>Hello AngularJS</title>
<link
	href="css/angular-bootstrap.css"
	rel="stylesheet">
<style type="text/css">
[ng\:cloak], [ng-cloak], .ng-cloak {
	display: none !important;
}
</style>
</head>

<body ng-app="hello" ng-cloak class="ng-cloak">
	<div ng-controller="navigation" class="container">
		<ul class="nav nav-pills" role="tablist">
			<li class="active"><a href="#/">home</a></li>
			<li><a href="#/login">login</a></li>
			<li ng-show="authenticated"><a href="" ng-click="logout()">logout</a></li>
		</ul>
	</div>
	<div ng-view class="container"></div>
	<script src="js/angular-bootstrap.js" type="text/javascript"></script>
	<script src="js/hello.js"></script>
</body>
</html>
</code></pre><p>实际上，它与原始版本没有太大区别。主要特点：</p>
<ul>
<li><p>有一个<code><ul></code></p><ul></ul>导航栏。所有链接都直接返回到主页，但是一旦我们为“ Angular”设置了“路线”，Angular就会识别出这种方式。<p></p></li>
<li><p>所有内容都将作为“部分”添加到<code><div></code></p><div></div>标记为“ ng-view”。<p></p></li>
<li><p>“ ng-cloak”已移至主体，因为我们要隐藏整个页面，直到Angular可以确定要渲染的位。否则，当页面加载时，菜单和内容在移动时会“闪烁”。</p></li>
<li><p>与<a href="https://spring.io/blog/2015/01/12/spring-and-angular-js-a-secure-single-page-application" title="系列文章的第一篇">第一篇文章一样</a> ，前端资产“ angular-bootstrap.css”和“ angular-bootstrap.js”是在构建时从JAR库生成的。</p></li>
</ul><h2><a href="#add-navigation-to-the-angular-application" class="anchor" name="add-navigation-to-the-angular-application"></a>将导航添加到Angular应用程序</h2><p>让我们修改“ hello”应用程序（在“ src / main / resources / public / js / hello.js”中）以添加一些导航功能。我们可以从为路由添加一些配置开始，以便主页中的链接实际上可以执行某些操作。例如</p>
<pre><code class="prettyprint javascript">angular.module('hello', [ 'ngRoute' ])
  .config(function($routeProvider, $httpProvider) {

	$routeProvider.when('/', {
		templateUrl : 'home.html',
		controller : 'home'
	}).when('/login', {
		templateUrl : 'login.html',
		controller : 'navigation'
	}).otherwise('/');

    $httpProvider.defaults.headers.common["X-Requested-With"] = 'XMLHttpRequest';

  })
  .controller('home', function($scope, $http) {
    $http.get('/resource/').success(function(data) {
      $scope.greeting = data;
    })
  })
  .controller('navigation', function() {});
</code></pre><p>我们在名为<a href="https://docs.angularjs.org/api/ngRoute">“ ngRoute”</a>的Angular模块上添加了一个依赖<a href="https://docs.angularjs.org/api/ngRoute">项</a> ，这使我们能够将神奇的<code>$routeProvider</code>注入到config函数中（Angular通过命名约定进行依赖项注入，并识别函数参数的名称）。然后，在函数内部使用<code>$routeProvider</code>来建立指向“ /”（“ home”控制器）和“ / login”（“ login”控制器）的链接。“ templateUrl”是从路径根（即“ /”）到“局部”视图的相对路径，这些路径将用于渲染每个控制器创建的模型。</p><p>定制的“ X-Requested-With”是浏览器客户端发送的常规标头，它曾经是Angular中的默认标头，但他们<a href="https://github.com/angular/angular.js/issues/1004">在1.3.0中将其取出</a> 。Spring Security通过不在401响应中发送“ WWW-Authenticate”标头来对此进行响应，因此浏览器将不会弹出身份验证对话框（这在我们的应用程序中是理想的，因为我们要控制身份验证）。</p><p>为了使用“ ngRoute”模块，我们需要在“ wro.xml”配置中添加一行以构建静态资产（在“ src / main / wro”中）：</p>
<pre><code class="prettyprint xml"><groups xmlns="http://www.isdc.ro/wro">
  <group name="angular-bootstrap">
    ...
    <js>webjar:angularjs/1.3.8/angular-route.min.js</js>
   </group>
</groups>
</code></pre><h3><a href="#the-greeting" class="anchor" name="the-greeting"></a>打招呼</h3><p>旧首页的问候语内容可以放在“ home.html”中（在“ src / main / resources / static”中“ index.html”的旁边）：</p>
<pre><code class="prettyprint html"><h1>Greeting</h1>
<div ng-show="authenticated">
	<p>The ID is {{greeting.id}}</p>
	<p>The content is {{greeting.content}}</p>
</div>
<div  ng-show="!authenticated">
	<p>Login to see your greeting</p>
</div>
</code></pre><p>由于用户现在可以选择是否登录（在全部由浏览器控制之前），因此我们需要在UI中区分安全内容和不安全内容。我们已经通过添加对（尚不存在）经过<code>authenticated</code>变量的引用来预料到这一点。</p><h3><a href="#the-login-form" class="anchor" name="the-login-form"></a>登录表格</h3><p>登录表单位于“ login.html”中：</p>
<pre><code class="prettyprint html"><div class="alert alert-danger" ng-show="error">
	There was a problem logging in. Please try again.
</div>
<form role="form" ng-submit="login()">
	<div class="form-group">
		<label for="username">Username:</label> <input type="text"
			class="form-control" id="username" name="username" ng-model="credentials.username"/>
	</div>
	<div class="form-group">
		<label for="password">Password:</label> <input type="password"
			class="form-control" id="password" name="password" ng-model="credentials.password"/>
	</div>
	<button type="submit" class="btn btn-primary">Submit</button>
</form>
</code></pre><p>这是一个非常标准的登录表单，有2个输入的用户名和密码以及一个通过<a href="https://docs.angularjs.org/api/ng/directive/ngSubmit"><code>ng-submit</code></a>表单的按钮。您不需要对form标记执行任何操作，因此最好不要完全放入其中。还有一个错误消息，仅当角度<code>$scope</code>包含<code>error</code> 。表单控件使用<a href="https://docs.angularjs.org/api/ng/directive/ngModel"><code>ng-model</code></a>在HTML和Angular控制器之间传递数据，在这种情况下，我们使用<code>credentials</code>对象保存用户名和密码。根据我们定义的路线，登录表单与“导航”控制器链接，该控制器到目前为止是空的，因此让我们继续以填补一些空白。</p><h2><a href="#the-authentication-process" class="anchor" name="the-authentication-process"></a>认证过程</h2><p>为了支持我们刚刚添加的登录表单，我们需要添加一些其他功能。在客户端，这些将在“导航”控制器中实现，而在服务器上将是Spring Security配置。</p><h3><a href="#submitting-the-login-form" class="anchor" name="submitting-the-login-form"></a>提交登录表格</h3><p>要提交表单，我们需要定义已经通过<code>ng-submit</code>在表单中引用的<code>login()</code>函数，以及通过<code>ng-model</code>引用的<code>credentials</code>对象。让我们在“ hello.js”中充实“导航”控制器（省略路由配置和“ home”控制器）：</p>
<pre><code class="prettyprint javascript">angular.module('hello', [ 'ngRoute' ]) // ... omitted code
.controller('navigation',

  function($rootScope, $scope, $http, $location) {

  var authenticate = function(credentials, callback) {

    var headers = credentials ? {authorization : "Basic "
        + btoa(credentials.username + ":" + credentials.password)
    } : {};

    $http.get('user', {headers : headers}).success(function(data) {
      if (data.name) {
        $rootScope.authenticated = true;
      } else {
        $rootScope.authenticated = false;
      }
      callback && callback();
    }).error(function() {
      $rootScope.authenticated = false;
      callback && callback();
    });

  }

  authenticate();
  $scope.credentials = {};
  $scope.login = function() {
      authenticate($scope.credentials, function() {
        if ($rootScope.authenticated) {
          $location.path("/");
          $scope.error = false;
        } else {
          $location.path("/login");
          $scope.error = true;
        }
      });
  };
});
</code></pre><p>页面加载时将执行“导航”控制器中的所有代码，因为<code><div></code></p><div></div>包含菜单栏的菜单可见，并用<code>ng-controller="navigation"</code>装饰。除了初始化<code>credentials</code>对象之外，它还定义了2个函数，即表单中需要的<code>login()</code>和试图从后端加载“用户”资源的本地帮助函数<code>authenticate()</code> 。加载控制器时，将调用<code>authenticate()</code>函数，以查看用户是否实际上已经过身份验证（例如，如果他在会话中间刷新了浏览器）。我们需要<code>authenticate()</code>函数进行远程调用，因为实际的身份验证是由服务器完成的，并且我们不想信任浏览器来跟踪它。<p></p><p><code>authenticate()</code>函数设置一个应用程序范围的标志，称为<code>authenticated</code> ，我们已经在“ home.html”中使用它来控制呈现页面的哪些部分。我们使用<a href="https://docs.angularjs.org/api/ng/service/$rootScope"><code>$rootScope</code></a>完成此操作，因为它很方便且易于遵循，并且我们需要在“导航”和“ home”控制器之间共享经过<code>authenticated</code>标志。Angular专家可能更喜欢通过共享的用户定义服务来共享数据（但是最终却是相同的机制）。</p><p><code>authenticate()</code>对相对资源（相对于应用程序的部署根目录）“ / user”进行GET。当从<code>login()</code>函数调用时，它将在标题中添加Base64编码的凭据，以便在服务器上进行身份验证并接受cookie作为回报。当我们获得身份验证结果时， <code>login()</code>函数还将相应地设置本地<code>$scope.error</code>标志，该标志用于控制登录表单上方错误消息的显示。</p><h3><a href="#the-currently-authenticated-user" class="anchor" name="the-currently-authenticated-user"></a>当前认证的用户</h3><p>为了服务<code>authenticate()</code>函数，我们需要向后端添加一个新的端点：</p>
<pre><code class="prettyprint java">@SpringBootApplication
@RestController
public class UiApplication {
  
  @RequestMapping("/user")
  public Principal user(Principal user) {
    return user;
  }

  ...

}
</code></pre><p>这是Spring Security应用程序中的一个有用技巧。如果“ / user”资源可访问，则它将返回当前已认证的用户（一个<a href="https://github.com/spring-projects/spring-security/blob/master/core/src/main/java/org/springframework/security/core/Authentication.java" title="认证方式"><code>Authentication</code></a> ），否则Spring Security将拦截该请求并通过<a href="https://github.com/spring-projects/spring-security/blob/master/web/src/main/java/org/springframework/security/web/AuthenticationEntryPoint.java" title="认证入口点"><code>AuthenticationEntryPoint</code></a>发送401响应。</p><h3><a href="#handling-the-login-request-on-the-server" class="anchor" name="handling-the-login-request-on-the-server"></a>在服务器上处理登录请求</h3><p>Spring Security使处理登录请求变得容易。我们只需要向我们的<a href="https://github.com/dsyer/spring-security-angular/blob/master/single/src/main/java/demo/UiApplication.java">主应用程序类中</a>添加一些配置（例如，作为一个内部类）：</p>
<pre><code class="prettyprint java">@SpringBootApplication
@RestController
public class UiApplication {

  ...

  @Configuration
  @Order(SecurityProperties.ACCESS_OVERRIDE_ORDER)
  protected static class SecurityConfiguration extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
      http
        .httpBasic()
      .and()
        .authorizeRequests()
          .antMatchers("/index.html", "/home.html", "/login.html", "/").permitAll()
          .anyRequest().authenticated();
    }
  }

}
</code></pre><p>这是具有Spring Security定制功能的标准Spring Boot应用程序，仅允许匿名访问静态（HTML）资源（默认情况下已可以访问CSS和JS资源）。HTML资源需要供匿名用户使用，而不仅仅是Spring Security会忽略的原因，原因将变得显而易见。</p><h2><a href="#csrf-protection" class="anchor" name="csrf-protection"></a> CSRF保护</h2><p>该应用程序几乎可以使用了，但是如果您尝试运行它，您会发现登录表单不起作用。在浏览器中查看响应，您将看到原因：</p>
<pre><code class="prettyprint">POST /login HTTP/1.1
...
Content-Type: application/x-www-form-urlencoded

username=user&password=password

HTTP/1.1 403 Forbidden
Set-Cookie: JSESSIONID=3941352C51ABB941781E1DF312DA474E; Path=/; HttpOnly
Content-Type: application/json;charset=UTF-8
Transfer-Encoding: chunked
...

{"timestamp":1420467113764,"status":403,"error":"Forbidden","message":"Expected CSRF token not found. Has your session expired?","path":"/login"}
</code></pre><p>很好，因为这意味着Spring Security内置的CSRF保护功能已开始发挥作用，以防止我们用脚射击。它想要的只是在名为“ X-CSRF”的标头中发送给它的令牌。CSRF令牌的值是服务器端在加载主页的初始请求中的<code>HttpRequest</code>属性中可用的值。为了将其提供给客户端，我们可以使用服务器上的动态HTML页面来呈现它，或者通过自定义端点公开它，否则我们可以将其作为cookie发送。最后一个选择是最好的，因为Angular已基于cookie <a href="https://docs.angularjs.org/api/ng/service/$http">内置了对CSRF</a> （称为“ XSRF”）的支持。</p><p>因此，我们在服务器上所需的是一个自定义过滤器，它将发送cookie。Angular希望cookie名称为“ XSRF-TOKEN”，Spring Security将其作为请求属性提供，因此我们只需要将值从请求属性转移到cookie：</p>
<pre><code class="prettyprint java">public class CsrfHeaderFilter extends OncePerRequestFilter {
  @Override
  protected void doFilterInternal(HttpServletRequest request,
      HttpServletResponse response, FilterChain filterChain)
      throws ServletException, IOException {
    CsrfToken csrf = (CsrfToken) request.getAttribute(CsrfToken.class
        .getName());
    if (csrf != null) {
      Cookie cookie = WebUtils.getCookie(request, "XSRF-TOKEN");
      String token = csrf.getToken();
      if (cookie==null || token!=null && !token.equals(cookie.getValue())) {
        cookie = new Cookie("XSRF-TOKEN", token);
        cookie.setPath("/");
        response.addCookie(cookie);
      }
    }
    filterChain.doFilter(request, response);
  }
}
</code></pre><p>为了完成这项工作并使它完全通用，我们应该小心地将cookie路径设置为应用程序的上下文路径（而不是硬编码为“ /”），但这对于我们正在处理的应用程序已经足够了。</p><p>我们需要将此过滤器安装在应用程序中的某个位置，并且需要在Spring Security <code>CsrfFilter</code>之后进行<code>CsrfFilter</code>以便请求属性可用。由于我们具有保护这些资源的Spring Security，因此没有比Spring Security过滤器链更好的地方了，例如，在上面扩展<code>SecurityConfiguration</code> ：</p>
<pre><code class="prettyprint java">@Configuration
@Order(SecurityProperties.ACCESS_OVERRIDE_ORDER)
protected static class SecurityConfiguration extends WebSecurityConfigurerAdapter {
  @Override
  protected void configure(HttpSecurity http) throws Exception {
    http
      .httpBasic().and()
      .authorizeRequests()
        .antMatchers("/index.html", "/home.html", "/login.html", "/").permitAll().anyRequest()
        .authenticated().and()
      .addFilterAfter(new CsrfHeaderFilter(), CsrfFilter.class);
  }
}
</code></pre><p>我们在服务器上要做的另一件事是让Spring Security期望CSRF令牌采用Angular希望发回的格式（一个名为“ X-XRSF-TOKEN”的标头，而不是默认的“ X-CSRF-TOKEN” ”）。我们通过定制CSRF过滤器来做到这一点：</p>
<pre><code class="prettyprint java">@Override
protected void configure(HttpSecurity http) throws Exception {
  http
    .httpBasic().and()
    ...
    .csrf().csrfTokenRepository(csrfTokenRepository());
}

private CsrfTokenRepository csrfTokenRepository() {
  HttpSessionCsrfTokenRepository repository = new HttpSessionCsrfTokenRepository();
  repository.setHeaderName("X-XSRF-TOKEN");
  return repository;
}
</code></pre><p>完成这些更改后，我们无需在客户端执行任何操作，并且登录表单现在可以使用了。</p><h2><a href="#logout" class="anchor" name="logout"></a>登出</h2><p>该应用程序几乎在功能上完成了。我们需要做的最后一件事就是实现我们在主页中绘制的注销功能。提醒一下导航栏的外观：</p>
<pre><code class="prettyprint html"><div ng-controller="navigation" class="container">
  <ul class="nav nav-pills" role="tablist">
    <li class="active"><a href="#/">home</a></li>
    <li><a href="#/login">login</a></li>
    <li ng-show="authenticated"><a href="" ng-click="logout()">logout</a></li>
  </ul>
</div>
</code></pre><p>如果用户通过了身份验证，那么我们将显示一个“注销”链接，并将其挂钩到“导航”控制器中的<code>logout()</code>函数。该函数的实现相对简单：</p>
<pre><code class="prettyprint javascript">angular.module('hello', [ 'ngRoute' ]). 
// ...
.controller('navigation', function(...) {

...

$scope.logout = function() {
  $http.post('logout', {}).success(function() {
    $rootScope.authenticated = false;
    $location.path("/");
  }).error(function(data) {
    $rootScope.authenticated = false;
  });
}

...

});
</code></pre><p>它将HTTP POST发送到“ / logout”，我们现在需要在服务器上实现。这很简单：</p>
<pre><code class="prettyprint java">@Override
protected void configure(HttpSecurity http) throws Exception {
  http
    ...
  .and()
    .logout()
    ...
  ;
}
</code></pre><p>（我们刚刚将<code>.logout()</code>添加到<code>HttpSecurity</code>配置构建器中）。</p><h2><a href="#how-does-it-work" class="anchor" name="how-does-it-work"></a>它是如何工作的？</h2><p>如果您使用某些开发人员工具，则可以在浏览器中看到浏览器与后端之间的交互（通常F12会打开它，默认情况下在Chrome中运行，并且需要Firefox中的插件）。总结如下：</p>
<table>
<thead>
<tr>
<th>动词</th>
<th>路径</th>
<th>状态</th>
<th>响应</th>
</tr>
</thead>
<tbody>
<tr>
<td>得到</td>
<td>/</td>
<td>200</td>
<td>index.html</td>
</tr>
<tr>
<td>得到</td>
<td>/css/angular-bootstrap.css</td>
<td>200</td>
<td>Twitter引导CSS</td>
</tr>
<tr>
<td>得到</td>
<td>/js/angular-bootstrap.js</td>
<td>200</td>
<td>Bootstrap和Angular JS</td>
</tr>
<tr>
<td>得到</td>
<td>/js/hello.js</td>
<td>200</td>
<td>应用逻辑</td>
</tr>
<tr>
<td>得到</td>
<td>/用户</td>
<td>401</td>
<td>未经授权</td>
</tr>
<tr>
<td>得到</td>
<td>/home.html</td>
<td>200</td>
<td>主页</td>
</tr>
<tr>
<td>得到</td>
<td>/资源</td>
<td>401</td>
<td>未经授权</td>
</tr>
<tr>
<td>得到</td>
<td>/login.html</td>
<td>200</td>
<td>角登录表单部分</td>
</tr>
<tr>
<td>得到</td>
<td>/用户</td>
<td>401</td>
<td>未经授权</td>
</tr>
<tr>
<td>得到</td>
<td>/用户</td>
<td>200</td>
<td>发送凭据并获取JSON</td>
</tr>
<tr>
<td>得到</td>
<td>/资源</td>
<td>200</td>
<td>JSON问候</td>
</tr>
</tbody>
</table><p>上面标记为“忽略”的响应是Angular在XHR调用中收到的HTML响应，并且由于我们没有处理该数据，因此HTML掉在了地板上。在“ / user”资源的情况下，我们确实会寻找经过身份验证的用户，但是由于在第一次调用中不存在经过身份验证的用户，因此该响应将被丢弃。</p><p>仔细查看请求，您将看到它们都有cookie。如果您使用的是干净的浏览器（例如Chrome中的隐身浏览器），则第一个请求不会向服务器发送任何Cookie，但是服务器会为“ JSESSIONID”（常规<code>HttpSession</code> ）和“ X- XSRF-TOKEN”（我们在上面设置的CRSF cookie）。后续请求都具有这些cookie，它们很重要：没有它们，应用程序将无法运行，并且它们提供了一些真正的基本安全功能（身份验证和CSRF保护）。当用户进行身份验证时（在POST之后），cookie的值会更改，这是另一个重要的安全功能（防止<a href="https://en.wikipedia.org/wiki/Session_fixation">会话固定攻击</a> ）。</p>
<blockquote><p>注意：CSRF保护仅依靠将cookie发送回服务器是不够的，因为即使您不在从应用程序加载的页面中，浏览器也会自动发送cookie（跨站点脚本攻击，也称为<a href="https://en.wikipedia.org/wiki/Cross-site_scripting">XSS）</a> ）。标头不会自动发送，因此源在控制之下。您可能会看到，在我们的应用程序中，CSRF令牌以cookie的形式发送到客户端，因此我们将看到浏览器将其自动发送回去，但是提供保护的是标头。</p>
</blockquote><h2><a href="#help-how-is-my-application-going-to-scale" class="anchor" name="help-how-is-my-application-going-to-scale"></a>帮助，我的应用程序如何扩展？</h2><p>“但是等等……”您说，“在单页应用程序中使用会话状态不是真的很糟糕吗？”这个问题的答案将必须是“大部分”，因为使用会话进行身份验证和CSRF保护绝对是一件好事。该状态必须存储在某个位置，如果您将其从会话中删除，则必须将其放置在其他位置，然后自己在服务器和客户端上手动对其进行管理。那只是更多的代码和可能更多的维护，并且通常会重新发明一个完美的轮子。</p><p>“但是，但是……”您将回答，“现在如何水平扩展应用程序？”这是您在上面提出的“真实”问题，但往往会简化为“会话状态不好，我必须是无状态的”。不要惊慌这里要考虑的主要点是安全性<em>是</em>有状态的。您不能拥有安全的无状态应用程序。那么，您将在哪里存储状态？这里的所有都是它的。<a href="https://spring.io/team/rwinch">Rob Winch</a>在<a href="https://skillsmatter.com/skillscasts/5398-the-state-of-securing-restful-apis-with-spring">Spring Exchange 2014上</a>进行了非常有用且有见地的演讲，解释了对状态的需求（以及它的普遍性-TCP和SSL是有状态的，因此无论您是否了解，系统都是有状态的），这可能值得一看。如果您想更深入地研究这个主题。</p><p>好消息是您可以选择。最简单的选择是将会话数据存储在内存中，并依靠负载均衡器中的粘性会话将请求从同一会话路由回同一JVM（它们都以某种方式支持）。这是个好足以让你掉在地上，将一个<em>真正</em>大量使用情况下工作。另一个选择是在应用程序实例之间共享会话数据。只要您严格并且仅存储安全性数据，它就很小并且很少更改（仅当用户登录和注销或他们的会话超时时），因此应该不会有任何主要的基础结构问题。使用<a href="https://github.com/spring-projects/spring-session/">Spring Session</a>也很容易。我们将在本系列的下一篇文章中使用Spring Session，因此无需在此处进行设置的任何细节，但这实际上是几行代码和一个Redis服务器，这是非常快的。</p>
<blockquote><p>提示：设置共享会话状态的另一种简便方法是将您的应用程序作为WAR文件部署到Cloud Foundry <a href="https://run.pivotal.io">Pivotal Web服务</a>并将其绑定到Redis服务。</p>
</blockquote><h2><a href="#but-what-about-my-custom-token-implementation-it-rsquo-s-stateless-look" class="anchor" name="but-what-about-my-custom-token-implementation-it-rsquo-s-stateless-look"></a>但是，我的自定义令牌实现又如何呢（看似无状态）？</h2><p>如果那是您对上一节的答复，请重新阅读，因为您可能是第一次没有得到它。如果将令牌存储在某个地方，这可能不是无状态的，但是即使您没有（例如，使用JWT编码的令牌），也将如何提供CSRF保护？这一点很重要。这是一条经验法则（归因于Rob Winch）：如果浏览器将访问您的应用程序或API，则需要CSRF保护。这并不是说如果没有会话就无法做到这一点，只是您必须自己编写所有代码，这很重要，因为它已经实现并且可以很好地在<code>HttpSession</code>之上运行（这反过来又是一部分）从一开始就使用了哪个容器并烘焙成规格）？即使您决定不需要CSRF，并且拥有完美的“无状态”（基于非会话）令牌实现，您仍然必须在客户端中编写额外的代码以使用和使用它，而您可能只是委托给浏览器和服务器自身的内置功能：浏览器始终发送cookie，并且服务器始终具有会话（除非您将其关闭）。该代码不是业务逻辑，它不会为您赚钱，只是开销，所以更糟的是，它会花费您金钱。</p><h2><a href="#conclusion" class="anchor" name="conclusion"></a>结论</h2><p>我们现在拥有的应用程序接近用户在实时环境中的“真实”应用程序中可能期望的应用程序，并且它可以用作构建具有该架构的功能更丰富的应用程序的模板（具有静态功能的单服务器）内容和JSON资源）。我们正在使用<code>HttpSession</code>来存储安全数据，依靠我们的客户来尊重和使用我们发送给他们的cookie，对此我们感到满意，因为它使我们能够专注于自己的业务领域。<a href="https://spring.io/blog/2015/01/20/the-resource-server-angular-js-and-spring-security-part-iii" title="系列文章中的第三篇">在下一篇文章中，</a>我们将体系结构扩展到单独的身份验证和UI服务器，以及用于JSON的独立资源服务器。显然，这很容易推广到多个资源服务器。我们还将把Spring Session引入堆栈，并展示如何将其用于共享身份验证数据。</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">var disqus_shortname = 'spring-io';
      var disqus_identifier = 1904;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));</script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });</script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>