<html  data-code-prettify="" data-mobile-support="" data-search=""><head></head><body >﻿
<title>Spring Data Fowler有什么新功能？</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="What's new in Spring Data Fowler?">
<meta name="twitter:description" >
<meta name="twitter:creator" content="@thomasdarimont">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/014bb231d48031c2974e4f723cc381b2?s=200">

<meta property="og:title" content="What's new in Spring Data Fowler?">
<meta property="og:image" content="https://gravatar.com/avatar/014bb231d48031c2974e4f723cc381b2?s=200">
<meta property="og:description" >
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2015-03-26 13:53:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Spring Data Fowler有什么新功能？</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/014bb231d48031c2974e4f723cc381b2?s=20&d=mm"> <span class="author">托马斯·达里蒙特</span>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2015-03-26 13:53:00.0">2015年3月26日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2015/03/26/what-s-new-in-spring-data-fowler#disqus_thread" data-disqus-identifier="2043">
</a></div>
</div>
</header>
<div class="blog--post"><p>Spring Data发布火车Fowler的GA发布标志着6个月开发的终点。现在是时候让您对该版本的内容有一个印象，并简要介绍各个功能。Fowler发行培训的主要主题是性能改进和Java 8支持的增强，这些主要体现在Spring Data JPA和MongoDB模块中，但许多其他模块也实现了显着改进。</p><p>升级到Spring Data Fowler发布系列最简单的方法是使用Spring Boot并配置<code>spring-data-releasetrain.version</code>财产<code>Fowler-RELEASE</code> 。如果您尚未使用Spring Boot，请将<a href="https://search.maven.org/#artifactdetails|org.springframework.data|spring-data-releasetrain|Fowler-RELEASE|pom">Spring Data BOM</a>添加到您的<code><dependencyManagement /></code> Maven POM部分。</p><h2><a href="#general-themes" class="anchor" name="general-themes"></a>一般主题</h2><h3><a href="#java-8-streams-in-repository-methods" class="anchor" name="java-8-streams-in-repository-methods"></a>存储库方法中的Java 8流</h3><p>Java 8的一项伟大的新功能是<code>Stream</code> API，它允许Java开发人员定义要在对象流上执行的操作流水线，但只有最终操作实际上会触发对象流中元素的消耗<code>Stream</code> 。</p><p>在数据访问的上下文中，提供查询执行的结果为<code>Stream</code>这是一个非常有用的用例，因为它可以防止在读取所有项目之前阻塞查询方法的调用者。这里甚至没有提到更有效的内存使用。</p><p>在Fowler版本中，我们引入了对Java 8 Streams的支持，作为存储库中finder方法的返回类型。现在，在MongoDB和JPA模块中，您都可以继续声明声明方法，如下所示：</p>
<pre><code class="prettyprint java">interface CustomerRepository extends Repository&lt;Customer, Long&gt; {

  Stream&lt;Customer&gt; findByLastname(String lastname);
}
</code></pre><p>调用此方法将执行支持存储库方法的查询，并在第一个结果可用时立即返回。要使用JPA实现此目的，我们使用持久性提供程序特定的API，因为JPA本身仅提供获取查询结果的方式， <code>List</code> s。现在，存储库客户端可以继续使用并在try-with-resources块中使用方法调用的结果。这将确保保持打开状态以便能够遍历流的资源最终将被关闭：</p>
<pre><code class="prettyprint java">try (Stream&lt;Customer&gt; customers = repository.findByLastname(&quot;Matthews&quot;)) {
  customers.filter(…).map(…).collect(…);
}
</code></pre><h3><a href="#jsr-310-and-threeten-backport-support" class="anchor" name="jsr-310-and-threeten-backport-support"></a> JSR-310和ThreeTen Backport支持</h3><p>为了轻松持久地保存<em>非时区的</em> JSR-310类型（JDK 8中新引入的日期/时间API），在域对象中，我们在MongoDB和JPA模块中添加了相关类型的转换器。对于还不能升级到Java 8的开发人员，我们为<a href="https://github.com/ThreeTen/threetenbp">ThreeTen Backport项目</a>添加了一组类似的转换器，以便即使您仍在使用Java 7，也可以开始使用代码中的类型。切换到Java 8将是以后程序包名称中的简单切换。</p><p>在MongoDB模块中， <code>Converter</code>实现是自动可用的。对于JPA，您可以简单地注册<code>Jsr310JpaConverters</code>要么<code>ThreeTenBackPortJpaConverters</code>与您的持续性提供商。如果您使用的是<code>LocalContainerEntityManagerFactoryBean</code>要在Spring中设置JPA环境，只需添加<code>org.springframework.data.jpa.convert.threeten</code>要么<code>….threetenbp</code>扫描软件包。使用Spring Boot，只需将上述类添加到<code>@EntityScan</code>宣言：</p>
<pre><code class="prettyprint java">@EntityScan(
  basePackageClasses = { Application.class, Jsr310JpaConverters.class }
)
@SpringBootApplication
class Application { … }
</code></pre><p>此设置将确保扫描您的应用程序包和用于JSR-310转换器的Spring Data JPA，并将其交给持久性提供程序。在我们的<a href="https://github.com/spring-projects/spring-data-examples/tree/master/jpa/java8">Spring Data Examples资源库中</a>找到一个完整的例子。注意，由于转换器只是将JSR-310类型转换为传统格式<code>Date</code>实例， <em>仅非时区</em> （例如<code>LocalDateTime</code>等）。</p><h2><a href="#mongodb" class="anchor" name="mongodb"></a> MongoDB</h2><h3><a href="#3-0-server-and-driver-support" class="anchor" name="3-0-server-and-driver-support"></a> 3.0服务器和驱动程序支持</h3><p>Spring Data Fowler提供了对最新，最强大的MongoDB 3.0服务器的支持。尽管该版本已经可以与2.13.0版的MongoDB Java驱动程序一起使用，但我们还确保了Spring Data MongoDB将与即将推出的3.0版Java驱动程序完美配合。因此，开发人员可以自由选择要使用的版本，也可以选择何时升级到新驱动程序。有关驱动程序和服务器版本之间兼容性的一般信息，请务必查看<a href="http://docs.mongodb.org/ecosystem/drivers/java/">MongoDB文档。</a>请注意，尽管后续开发显然将重点放在服务器和驱动程序的3.0行上。</p><p>总的来说，我们鼓励所有人都喜欢<code>MongoClient</code>过度<code>Mongo</code>在JavaConfig中使用，或将新引入的XML元素用于<code><mongo:mongo-client /></code>和<code><mongo:client-options /></code> 。有关更多信息，请参考<a href="https://docs.spring.io/spring-data/mongodb/docs/1.7.0.RELEASE/reference/html/#mongo.mongo-3">参考文档</a> 。</p><h3><a href="#geojson-support" class="anchor" name="geojson-support"></a> GeoJSON支持</h3><p>自MongoDB引入<a href="http://geosjon.org">GeoJSON</a>作为处理地理结构的格式以来，已经有一段时间了。这些数据结构在类似球形的地球上运行，因此无法与2D索引一起使用。话虽如此，由于我们提供了专用的类型来支持GeoJSON，因此用法非常简单。这些可以在您的域类型以及查询参数中使用。</p>
<pre><code class="prettyprint java">@Document
class Store {

  @Id String id;

  /**
   * The location is stored in GeoJSON format:
   * { &quot;type&quot; : &quot;Point&quot;, &quot;coordinates&quot; : [ x, y ] }
   */
  GeoJsonPoint location;
}

interface StoreRepository extends CrudRepository&lt;Store, String&gt; {

  List&lt;Store&gt; findByLocationWithin(Polygon polygon);
}

repo.findByLocationWithin(
  new GeoJsonPolygon(
    new Point(-73.992514, 40.758934),
    new Point(-73.961138, 40.760348),
    new Point(-73.991658, 40.730006),
    new Point(-73.992514, 40.758934)));
</code></pre><p>这将创建以下要在MongoDB中执行的查询：</p>
<pre><code class="prettyprint json">{
  &quot;location&quot;: {
    &quot;$geoWithin&quot;: {
      &quot;$geometry&quot;: {
        &quot;type&quot;: &quot;Polygon&quot;,
        &quot;coordinates&quot;: [[
           [-73.992514,40.758934],
           [-73.961138,40.760348],
           [-73.991658,40.730006],
           [-73.992514,40.758934]
        ]]
      }
    }
  }
}
</code></pre><p>请注意<code>StoreRepository.findByLocationWithin(…)</code>仍然需要一个<code>Polygon</code> 。使用<code>GeoJsonPolygon</code>与<code>findByLocationWithin(…)</code>将使用创建查询<code>$geometry</code>运算符和GeoJSON表示形式。有关用法和限制的更多详细信息，请参见<a href="http://docs.mongodb.org/manual/core/2dsphere/#geospatial-indexes-store-geojson/">MongoDB手册</a> 。</p><h3><a href="#execution-of-mongodb-stored-scripts" class="anchor" name="execution-of-mongodb-stored-scripts"></a>执行MongoDB存储的脚本</h3><p>MongoDB允许通过直接发送原始脚本或调用先前存储的脚本来在服务器上执行JavaScript函数。我们通过新引入的功能来展示此功能<code>ScriptOperations</code>可以从中获得的接口<code>MongoOperations</code> 。</p>
<pre><code class="prettyprint java">ScriptOperations ops = mongoOperations.scriptOps();
ExecutableMongoScript script = new ExecutableMongoScript(&quot;function(x) { return x; }&quot;);
Object r1 = ops.execute(script, &quot;Direct function execution.&quot;)

ops.register(new NamedMongoScript(&quot;echo&quot;, script));
Object r2 = ops.call(&quot;echo&quot;, &quot;Call stored function.&quot;);
</code></pre><p>服务器端脚本支持将在后续发行版中得到增强，在该发行版中，我们将添加返回类型转换，用于从存储库方法调用过程的注释以及对<code>$where</code>操作员。</p><h3><a href="#performance-improvements-in-object-to-store-conversion" class="anchor" name="performance-improvements-in-object-to-store-conversion"></a>对象到商店转换的性能改进</h3><p>从对象到商店的映射子系统在性能方面进行了重大改进。我们剖析了Commons和store模块，在这里和那里介绍了一些缓存，并且与Evans发布火车相比，实际上每秒可以实现相当可观的操作增长（尽管大部分改进也都移植到了Evans的服务版本中） 。</p><p><img src="https://gist.githubusercontent.com/olivergierke/1d4239b59c57e05760c3/raw/fowler-bar-chart-read-write.png" alt="Spring Data Fowler中的性能改进"></p><p>如您所见，我们进行读取访问的每秒操作数增加了一倍以上，也接近于写入操作。</p><p>当从数据存储中读取许多对象时，将花费大量时间通过反射来创建对象实例。在Fowler发布系列中，我们引入了新的默认值<code>EntityInstantiator</code>通过在运行时使用ASM为域对象创建工厂类来解决该瓶颈。这个工厂类直接调用域类的构造函数，这比通过反射进行构造要快得多。如果你有兴趣在漂亮的细节， <a href="https://github.com/spring-projects/spring-data-commons/blob/1.10.0.RELEASE/src/main/java/org/springframework/data/convert/BytecodeGeneratingEntityInstantiator.java#L54">在这里</a>的，做的伎俩为我们的类。</p><h2><a href="#redis" class="anchor" name="redis"></a>雷迪斯</h2><h3><a href="#hyperloglog" class="anchor" name="hyperloglog"></a>超级日志</h3><p>Redis <a href="http://redis.io/commands#hyperloglog">HyperLogLog命令</a>提供了一种有效的解决方案，可以计算独特的事物，而无需记住已经遇到的元素。例如，这适用于按IP计算唯一身份访问量。</p>
<pre><code class="prettyprint java">HyperLogLogOperations hll = redisTemplate.opsForHyperLogLog();

hll.add(today(), &quot;8.8.8.8&quot;, &quot;8.8.4.4&quot;);
hll.size(today()); // Unique page visits today = 2

hll.add(today(), &quot;198.153.192.40&quot;, &quot;8.8.8.8&quot;);
hll.size(today()); // Unique page visits today = 3
hll.size(today(), yesterday()); // Unique page visits today and yesterday
</code></pre><h2><a href="#gemfire" class="anchor" name="gemfire"></a>宝石火</h2><p>到目前为止，对GemFire模块的最重大更改是对GemFire 8的完全支持。自7.0.2起，GemFire 8引入<a href="http://gemfire80.docs.pivotal.io/8.0.0/userguide/index.html#relnotes/release_notes.html">了几项新更改</a> ，包括新<a href="http://gemfire80.docs.pivotal.io/8.0.0/userguide/index.html#relnotes/release_notes.html">的基于群集的配置服务</a> 。</p><p>启用该服务后，开发人员可以在执行操作（例如添加区域，创建索引，配置磁盘存储等）时在Gfsh中记录其操作和类似于模式的更改。当开发人员在集群中启动新的GemFire对等方时，将从定位器中托管的新的基于群集的配置服务中自动获取其配置。</p><p>尽管Spring Data GemFire的<a href="https://docs.spring.io/spring-data-gemfire/docs/current/reference/html/#bootstrap">基于XML命名空间的配置</a>仍然是一个流行的选择，尤其是在具有高度迭代且反馈周期短的开发过程中，但Spring Data GemFire却增加了对新<a href="https://docs.spring.io/spring-data-gemfire/docs/1.6.0.RC1/reference/html/#bootstrap:cache:cluster-configuration">的基于集群的配置</a>的支持，其行为类似于Spring Data Gemfire对GemFire的<a href="https://docs.spring.io/spring-data-gemfire/docs/1.6.0.RC1/reference/html/#bootstrap:cache">本机</a>支持。 <a href="https://docs.spring.io/spring-data-gemfire/docs/1.6.0.RC1/reference/html/#bootstrap:cache">`cache.xml</a>格式。</p><p>要在Spring配置的GemFire节点中启用基于集群的配置，开发人员只需设置<code>use-cluster-configuration</code>的属性<code><gfe:cache /></code>元素，如下所示：</p>
<pre><code class="prettyprint xml">&lt;gfe:cache id=&quot;gemfireCache&quot; use-cluster-configuration=&quot;true&quot; … /&gt;
</code></pre><p>在应用XML名称空间特定的配置之前，Spring Data GemFire将首先请求并应用集群范围的配置。您可以将XML配置元数据视为扩充了集群配置服务发送的集群配置。</p><p>有关GemFire的新群集配置服务的更多信息，请参阅<a href="http://gemfire80.docs.pivotal.io/8.0.0/userguide/index.html#deploying/gfsh/gfsh_persist.html">GemFire用户指南</a>和<a href="https://jira.spring.io/browse/SGF-226">SGF-226</a>了解更多详细信息。</p><h2><a href="#spring-data-rest" class="anchor" name="spring-data-rest"></a> Spring Data REST</h2><p>Spring Data REST在Fowler版本中也进行了许多改进。最显着的改进之一是检查了更多的实体元数据，并将其用于填充响应头。例如，商店通过<code>@Version</code>注释现在将获得用作的实体版本<code>ETag</code>标头，以便客户可以利用它们来触发条件<code>GET</code>要求。</p><p>相当相关的是，使用Spring Data审核支持的实体将自动获得其最后修改日期，并将其传播到<code>LastModified</code>项目资源响应的标头：</p>
<pre><code class="prettyprint java">class Customer {

  @Version Long version;
  @LastModifiedDate LocalDate lastModifiedDate;
}
</code></pre>
<pre><code class="prettyprint">curl -v http://…/customers/1

Etag: 1
Last-Modified: Tue, 24 Mar 2015 12:34:56 GMT
</code></pre><h3><a href="#json-schema" class="anchor" name="json-schema"></a> JSON模式</h3><p>Spring Data REST的Fowler版本还附带了对JSON Schema的改进支持。默认情况下，该架构由针对域类型公开的ALPS文档中的表示形式描述符指向。在<a href="https://github.com/spring-projects/spring-data-examples/tree/master/rest/starbucks">星巴克示例中，</a>您可以看到链接呈现如下：</p>
<pre><code class="prettyprint">curl http://…/alps/stores

{
  &quot;version&quot;: &quot;1.0&quot;,
  &quot;descriptors&quot;: [ {
    &quot;id&quot;: &quot;store-representation&quot;,
    &quot;href&quot;: &quot;http://localhost:8080/stores/schema&quot;,
    &quot;descriptors&quot;: [ … ]
  }],
  …
}
</code></pre><p>跟随链接将显示商店的JSON模式文档：</p>
<pre><code class="prettyprint">{
  &quot;title&quot;: &quot;example.stores.Store&quot;,
  &quot;properties&quot;: {
    &quot;address&quot;: {
      &quot;$ref&quot;: &quot;#/descriptors/address&quot;
    },
    &quot;name&quot;: {
      &quot;type&quot;: &quot;string&quot;
    }
  },
  &quot;descriptors&quot;: {
    &quot;address&quot;: {
      &quot;type&quot;: &quot;object&quot;,
      &quot;properties&quot;: {
        &quot;zip&quot;: {
          &quot;type&quot;: &quot;string&quot;
        },
        &quot;city&quot;: {
          &quot;type&quot;: &quot;string&quot;
        },
        &quot;street&quot;: {
          &quot;type&quot;: &quot;string&quot;
        },
        &quot;location&quot;: {
          &quot;$ref&quot;: &quot;#/descriptors/point&quot;
        }
      }
    },
    &quot;point&quot;: {
      &quot;type&quot;: &quot;object&quot;,
      &quot;properties&quot;: {
        &quot;x&quot;: {
          &quot;type&quot;: &quot;number&quot;
        },
        &quot;y&quot;: {
          &quot;type&quot;: &quot;number&quot;
        }
      }
    }
  },
  &quot;type&quot;: &quot;object&quot;,
  &quot;$schema&quot;: &quot;http://json-schema.org/draft-04/schema#&quot;
}
</code></pre><p>请注意，我们如何从域类型及其Jackson映射中得出模式的基本特征。可以通过使用确定所需的属性<code>@JsonProperty(required = true)</code> ，可以正确发现和发布日期/时间类型。您可以在上注册自定义JSON模式格式或模式<code>RepositoryRestConfiguration.metadataConfiguration()</code> ：</p>
<pre><code class="prettyprint java">@Configuration
static class SampleConfiguration extends RepositoryRestMvcConfiguration {

  @Override
  protected void configureRepositoryRestConfiguration(
    RepositoryRestConfiguration config) {
    config.metadataConfiguration().
      registerJsonSchemaFormat(JsonSchemaFormat.EMAIL, EmailAddress.class);
  }
}
</code></pre><p>假设<code>EmailAddress</code>是您已调整Jackson使其呈现为纯色的值对象<code>String</code> ，此配置将导致类型的所有属性<code>EmailAddress</code>与...一起出现<code>format</code>调成<code>email</code>在JSON模式文档中。</p><h2><a href="#solr" class="anchor" name="solr"></a>索尔</h2><h3><a href="#document-score-improvements" class="anchor" name="document-score-improvements"></a>文件分数改善</h3><p>Fowler版本增加了对实时获取的支持，允许从索引中读取未提交的更改。 <code>getById</code>可用于<code>SolrTemplate</code> 。还值得注意的是<code>@Score</code>灵感来自<code>@TextScore</code>适用于Spring Data MongoDB。该批注允许检索文档分数，并将隐式添加必需的参数，从而不再需要显式添加<code>@Query(fields={"*", "score"}</code>检索文档查询匹配分数时。</p><h2><a href="#miscellaneous" class="anchor" name="miscellaneous"></a>杂</h2><h3><a href="#elevating-projections" class="anchor" name="elevating-projections"></a>高架投影</h3><p>Spring Data REST在Evans发行版中附带了一项名为“投影”的功能。在Fowler中，我们将支持该基础结构的基础结构移入了Spring Data Commons，并对其进行了一些调整，以便其他项目可以使用它而无需进一步的依赖。该功能的核心是<code>ProjectionFactory</code>允许您为支持其他对象的接口创建对象实例，例如<code>Map</code> 。</p>
<pre><code class="prettyprint java">interface Customer {

  String getFirstname();

  String getLastname();

  @Value(&quot;#{target.firstname + &#39; &#39; + target.lastname}&quot;)
  String getFullName();
}
</code></pre><p>现在可以使用<code>ProjectionFactory</code> ：</p>
<pre><code class="prettyprint java">Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
map.put(&quot;firstname&quot;, &quot;Dave&quot;);
map.put(&quot;lastname&quot;, &quot;Matthews&quot;);

ProjectionFactory factory = new SpelAwareProjectionFactory();
Customer customer = factory.createProjection(Customer.class, map)

assertThat(customer.getFirstname(), is(&quot;Dave&quot;));
assertThat(customer.getLastname(), is(&quot;Matthews&quot;));
assertThat(customer.getFullName(), is(&quot;Dave Matthews&quot;));
</code></pre><p>如您所见，我们选择了<code>Map</code>支持创建的投影实例。在幕后创建了一个JDK代理，该代理配备了方法拦截器-如果是<code>Map</code>支持代理-将访问者的调用委派给内部的属性查询<code>Map</code> 。用注释的方法<code>@Value</code>将获得带注释的SpEL表达式求值。如果您配置了<code>BeanFactory</code>在<code>SpelAwareProjectionFactory</code>您甚至可以从这些表达式中引用Spring bean，从而触发更复杂的计算。</p><p>如果后备查询未返回可分配给声明的返回类型的值，则为标准<code>ConversionService</code>用于简单转换，然后进行递归投影步骤。</p><p>有关如何在Spring MVC控制器中使用投影的示例，请参见<a href="https://stackoverflow.com/a/29386907/18122">StackOverflow上的此答案</a> 。</p><h3><a href="#projections-in-spring-mvc" class="anchor" name="projections-in-spring-mvc"></a> Spring MVC中的投影</h3><p>现在，Spring MVC控制器实现可以使用投影机制来仅使用接口来创建表单支持对象。使用<code>@EnableSpringDataWebSupport</code>在您的Spring配置中（在Boot中自动激活） <code>ProxyingHandlerMethodArgumentResolver</code>已解决，它将自动为接口创建代理实例并将相应的请求参数绑定到该接口：</p>
<pre><code class="prettyprint java">interface Form {

  @NotBlank String getName();
  @NotBlank String getText();
}

@Controller
@RequestMapping(value = &quot;/guestbook&quot;)
class GuestbookController {

  @RequestMapping(method = RequestMethod.GET)
  String guestbook(Form form, Model model) { … }

  @RequestMapping(method = RequestMethod.POST)
  String guestbook(@Valid Form form, Errors errors, Model model) { … }
}
</code></pre><p>查看如何在接受<code>GET</code>请求向要呈现的视图提供一个空的表单支持对象。接收方法<code>POST</code>请求使用<code>Form</code>表示它想要获取绑定到代理实例的表单数据并应用验证。</p><h2><a href="#summary" class="anchor" name="summary"></a>摘要</h2><p>尽管篇幅冗长，但我们几乎没有涉及Spring Data Fowler附带的所有新功能的表面。您可能想浏览<a href="https://github.com/spring-projects/spring-data-commons/wiki/Release-Train-Fowler">发行火车Wiki</a>以获得更多的信息，并依次遍历票证和相关提交的链接，因为它们包含通常很好地展示单个功能的测试用例。</p><p>另外，已经提到的<a href="https://github.com/spring-projects/spring-data-examples">Spring Data示例库</a>有很多东西可以玩和探索。</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 2043;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>