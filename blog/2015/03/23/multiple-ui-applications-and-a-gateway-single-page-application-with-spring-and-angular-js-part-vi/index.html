<html dir="ltr" data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>多个UI应用程序和一个网关：具有Spring和Angular JS Part VI的单页应用程序</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>System.config({baseURL: "/b92013b"});</script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>System.import('app/main.js')</script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Multiple UI Applications and a Gateway: Single Page Application with Spring and Angular JS Part VI">
<meta name="twitter:description" content="<blockquote>
 <p>Note: the source code and test for this blog continue to evolve, but the changes to the text are not being maintained here. Please see <a href=" https: ="" spring.io guides="" tutorials="" spring-security-and-angular-js="" ="="></meta>the tutorial version for the most up to date content. 

<p>In this article we continue <a href=" blog 2015 02 03 sso-with-oauth2-angular-js-and-spring-security-part-v" title="系列文章中的第五篇"></head><body dir="ltr" class="ng-cloak" ng-app="hello" ng-controller="navigation" ng-cloak="">our discussion of how to use <a href="http://projects.spring.io/spring-security">Spring Security</a> with <a href="http://angularjs.org">Angular JS</a> in a “single page application”. Here we show how to use <a href="http://projects.spring.io/spring-security-oauth/">Spring Session</a> together with <a href="http://projects.spring.io/spring-cloud/">Spring Cloud</a> to combine the features of the systems we built in parts II and IV, and actually end up building 3 single page applications with quite different responsibilities. The aim is to build a Gateway (like in <a href="http://spring.io/blog/2015/01/28/the-api-gateway-pattern-angular-js-and-spring-security-part-iv" title="系列文章中的第四篇">part IV</a>) that is used not only for API resources but also to load the UI from a backend server. We simplify the token-wrangling bits of <a href="http://spring.io/blog/2015/01/12/the-login-page-angular-js-and-spring-security-part-ii" title="系列第二篇">part II</a> by using the Gateway to pass through the authentication to the backends. Then we extend the system to show how we can make local, granular access decisions in the backends, while still controlling identity and authentication at the Gateway. This is a very powerful model for building distributed systems in general, and has a number of benefits that we can explore as we introduce the features in the code we build.<p></p>
">
<meta name="twitter:creator" content="@david_syer">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=200">

<meta property="og:title" content="Multiple UI Applications and a Gateway: Single Page Application with Spring and Angular JS Part VI">
<meta property="og:image" content="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=200">
<meta property="og:description" content="<blockquote>
 <p>Note: the source code and test for this blog continue to evolve, but the changes to the text are not being maintained here. Please see <a href=" https: ="" spring.io guides="" tutorials="" spring-security-and-angular-js="" ="="></meta>the tutorial version for the most up to date content. 

<p>In this article we continue <a href=" blog 2015 02 03 sso-with-oauth2-angular-js-and-spring-security-part-v" title="系列文章中的第五篇">our discussion of how to use <a href="http://projects.spring.io/spring-security">Spring Security</a> with <a href="http://angularjs.org">Angular JS</a> in a “single page application”. Here we show how to use <a href="http://projects.spring.io/spring-security-oauth/">Spring Session</a> together with <a href="http://projects.spring.io/spring-cloud/">Spring Cloud</a> to combine the features of the systems we built in parts II and IV, and actually end up building 3 single page applications with quite different responsibilities. The aim is to build a Gateway (like in <a href="http://spring.io/blog/2015/01/28/the-api-gateway-pattern-angular-js-and-spring-security-part-iv" title="系列文章中的第四篇">part IV</a>) that is used not only for API resources but also to load the UI from a backend server. We simplify the token-wrangling bits of <a href="http://spring.io/blog/2015/01/12/the-login-page-angular-js-and-spring-security-part-ii" title="系列第二篇">part II</a> by using the Gateway to pass through the authentication to the backends. Then we extend the system to show how we can make local, granular access decisions in the backends, while still controlling identity and authentication at the Gateway. This is a very powerful model for building distributed systems in general, and has a number of benefits that we can explore as we introduce the features in the code we build.<p></p>
">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2015-03-23 14:50:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">// Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }</script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">多个UI应用程序和一个网关：具有Spring和Angular JS Part VI的单页应用程序</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=20&d=mm"> <a class="author" rel="author" href="/team/dsyer">戴夫·瑟</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2015-03-23 14:50:00.0">2015年3月23日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2015/03/23/multiple-ui-applications-and-a-gateway-single-page-application-with-spring-and-angular-js-part-vi#disqus_thread" data-disqus-identifier="2011">
</a></div>
</div>
</header>
<div class="blog--post"><blockquote><p>注意：此博客的源代码和测试在不断发展，但此处未保留对文本的更改。请参阅<a href="https://spring.io/guides/tutorials/spring-security-and-angular-js/">本教程的版本</a>为最最新的内容。</p>
</blockquote><p>在本文中，我们继续<a href="https://spring.io/blog/2015/02/03/sso-with-oauth2-angular-js-and-spring-security-part-v" title="系列文章中的第五篇">讨论</a>如何在“单页应用程序”中将<a href="https://projects.spring.io/spring-security">Spring Security</a>与<a href="http://angularjs.org">Angular JS</a>一起使用。在这里，我们展示了如何将<a href="https://projects.spring.io/spring-security-oauth/">Spring Session</a>与<a href="https://projects.spring.io/spring-cloud/">Spring Cloud</a>结合使用，以结合我们在第II部分和第IV部分中构建的系统的功能，并最终结束构建3个职责完全不同的单页应用程序。目的是构建一个网关（类似于<a href="https://spring.io/blog/2015/01/28/the-api-gateway-pattern-angular-js-and-spring-security-part-iv" title="系列文章中的第四篇">第IV部分</a> ），该网关不仅用于API资源，还可以从后端服务器加载UI。通过使用网关将身份验证传递到后端，我们简化了<a href="https://spring.io/blog/2015/01/12/the-login-page-angular-js-and-spring-security-part-ii" title="系列第二篇">第二部分</a>的令牌争用位。然后，我们扩展系统以显示如何在后端中做出本地的，细粒度的访问决策，同时仍在网关上控制身份和认证。通常，这是用于构建分布式系统的非常强大的模型，在引入所构建代码的功能时，我们可以探索许多好处。</p>
<blockquote><p>提醒：如果您正在使用示例应用程序浏览本文，请确保清除浏览器的cookie和HTTP Basic凭据缓存。在Chrome中，最好的方法是打开一个新的隐身窗口。</p>
</blockquote><h2><a href="#target-architecture" class="anchor" name="target-architecture"></a>目标架构</h2><p>这是我们将要开始构建的基本系统的图片：</p><p><img src="https://raw.githubusercontent.com/dsyer/spring-security-angular/master/double/double-simple.png" alt="系统组成"></p><p>像本系列中的其他示例应用程序一样，它具有一个UI（HTML和JavaScript）和一个资源服务器。像<a href="https://spring.io/blog/2015/01/28/the-api-gateway-pattern-angular-js-and-spring-security-part-iv" title="系列文章中的第四篇">第四部分中</a>的示例一样，它具有一个网关，但是在这里它是独立的，而不是UI的一部分。 UI有效地成为了后端的一部分，为我们提供了更多选择来重新配置和重新实现功能，并且还带来了我们将看到的其他好处。</p><p>浏览器可以访问网关的所有内容，而不必了解后端的体系结构（从根本上讲，它不知道有后端）。浏览器在此Gateway中要做的一件事就是身份验证，例如，它像<a href="https://spring.io/blog/2015/01/12/the-login-page-angular-js-and-spring-security-part-ii" title="系列第二篇">第II部分中</a>一样发送用户名和密码，并获得cookie。在随后的请求中，它会自动显示cookie，然后网关会将其传递到后端。无需在客户端上编写任何代码即可启用Cookie。后端使用cookie进行身份验证，并且由于所有组件共享一个会话，因此它们共享有关用户的相同信息。与<a href="https://spring.io/blog/2015/02/03/sso-with-oauth2-angular-js-and-spring-security-part-v" title="Fifth Article in the Series">第五部分</a>相反，在<a href="https://spring.io/blog/2015/02/03/sso-with-oauth2-angular-js-and-spring-security-part-v" title="系列文章中的第五篇">第五部分</a>中，必须将Cookie转换为网关中的访问令牌，然后所有后端组件都必须对访问令牌进行独立解码。</p><p>与<a href="https://spring.io/blog/2015/01/28/the-api-gateway-pattern-angular-js-and-spring-security-part-iv" title="系列文章中的第四篇">第IV部分中一样</a> ，网关简化了客户端和服务器之间的交互，并提供了一个很小的，定义明确的表面来处理安全性。例如，我们不必操心<a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing">共同的起源资源共享</a> ，这是一个可喜的解脱，因为它是很容易出错。</p><p>我们将要构建的完整项目的源代码在<a href="https://github.com/dsyer/spring-security-angular/tree/master/double">此处的Github中</a> ，因此您可以克隆项目并直接从那里进行工作。该系统的最终状态还有一个额外的组件（“ double-admin”），因此暂时将其忽略。</p><h2><a href="#building-the-backend" class="anchor" name="building-the-backend"></a>建立后端</h2><p>在这种体系结构中，后端与我们在<a href="https://spring.io/blog/2015/01/20/the-resource-server-angular-js-and-spring-security-part-iii" title="系列文章中的第三篇">第三部分中</a>构建的<a href="https://github.com/dsyer/spring-security-angular/tree/master/spring-session">“ spring-session”</a>示例非常相似，不同之处在于它实际上不需要登录页面。达到我们想要的目的的最简单方法可能是从第III部分复制“资源”服务器，并从<a href="https://spring.io/blog/2015/01/12/spring-and-angular-js-a-secure-single-page-application" title="系列文章的第一篇">第I部分</a>的<a href="https://github.com/dsyer/spring-security-angular/tree/master/basic">“基本”</a>示例中获取UI。为了从“基本” UI转到我们想要的UI，我们只需要添加几个依赖项（例如，当我们在第III部分中首次使用<a href="https://github.com/spring-projects/spring-session/">Spring Session</a>时）：</p>
<pre><code class="prettyprint xml"><dependency>
  <groupId>org.springframework.session</groupId>
  <artifactId>spring-session</artifactId>
  <version>1.0.0.RELEASE</version>
</dependency>
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-redis</artifactId>
</dependency>
</code></pre><p>并将<code>@EnableRedisHttpSession</code>annotation添加到主应用程序类：</p>
<pre><code class="prettyprint java">@SpringBootApplication
@EnableRedisHttpSession
public class UiApplication {

public static void main(String[] args) {
    SpringApplication.run(UiApplication.class, args);
  }

}
</code></pre><p>由于现在是UI，因此不需要“ / resource”端点。完成后，您将拥有一个非常简单的Angular应用程序（与“基本”示例中的应用程序相同），从而极大地简化了对其行为的测试和推理。</p><p>最后，我们希望该服务器作为后台运行，所以我们给它一个非默认端口上监听（在<code>application.properties</code> ）：</p>
<pre><code class="prettyprint properties">server.port: 8081
security.sessions: NEVER
</code></pre><p>如果这是<em>整个</em>内容<code>application.properties</code>的内容，则该应用程序将是安全的，并且名为“ user”的用户可以使用随机密码访问该应用程序，但该密码在启动时会打印在控制台上（日志级别为INFO）。“ security.sessions”设置意味着Spring Security将接受cookie作为身份验证令牌，但是除非它们已经存在，否则不会创建它们。</p><h2><a href="#the-resource-server" class="anchor" name="the-resource-server"></a>资源服务器</h2><p>资源服务器很容易从我们现有的样本之一中生成。这是一样的“春天会话”资源服务器在<a href="https://spring.io/blog/2015/01/20/the-resource-server-angular-js-and-spring-security-part-iii" title="系列文章中的第三篇">第三部分</a> ：只是一个“/资源”端点和<code>@EnableRedisHttpSession</code>得到分布式会话数据。我们希望该服务器具有一个非默认端口以进行侦听，并且希望能够在会话中查找身份验证，因此我们需要这样做（在<code>application.properties</code> ）：</p>
<pre><code class="prettyprint properties">server.port: 9000
security.sessions: NEVER
</code></pre><p>如果您想看一眼，完整的示例<a href="https://github.com/dsyer/spring-security-angular/tree/master/double/resource">在github中</a> 。</p><h2><a href="#the-gateway" class="anchor" name="the-gateway"></a>门户</h2><p>对于网关的初始实现（可能可行的最简单的事情），我们可以仅使用一个空的Spring Boot Web应用程序并添加<code>@EnableZuulProxy</code>annotation。正如我们在<a href="https://spring.io/blog/2015/01/12/spring-and-angular-js-a-secure-single-page-application" title="系列文章的第一篇">第一部分中</a>看到的那样，有几种方法可以做到这一点，一种方法是使用<a href="https://start.spring.io">Spring Initializr</a>生成框架项目。甚至更容易的是，使用<a href="https://cloud-start.spring.io">Spring Cloud Initializr</a>也是一样，只是用于<a href="https://cloud.spring.io">Spring Cloud</a>应用程序。使用与第一部分相同的命令行操作顺序：</p>
<pre><code class="prettyprint">$ mkdir gateway && cd gateway
$ curl https://cloud-start.spring.io/starter.tgz -d style=web \
  -d style=security -d style=cloud-zuul -d name=gateway \
  -d style=redis | tar -xzvf - 
</code></pre><p>然后，您可以将该项目（默认情况下是普通的Maven Java项目）导入您喜欢的IDE中，或者仅在命令行上使用文件和“ mvn”。如果您想从<a href="https://github.com/dsyer/spring-security-angular/tree/master/double/gateway">github中找到</a>一个版本<a href="https://github.com/dsyer/spring-security-angular/tree/master/double/gateway">，</a>那么它还有一些我们不需要的额外功能。</p><p>从空白的Initializr应用程序开始，我们添加Spring Session依赖项（如上面的UI），并添加<code>@EnableRedisHttpSession</code>annotation：</p>
<pre><code class="prettyprint java">@SpringBootApplication
@EnableRedisHttpSession
@EnableZuulProxy
public class GatewayApplication {

public static void main(String[] args) {
    SpringApplication.run(GatewayApplication.class, args);
  }

}
</code></pre><p>网关是准备好运行，但它还不知道我们的后端服务，所以我们只设置了在其<code>application.yml</code> （从改名<code>application.properties</code>如果你没有卷曲事上）：</p>
<pre><code class="prettyprint">zuul:
  routes:
    ui:
      url: http://localhost:8081
    resource:
      url: http://localhost:9000
security:
  user:
    password:
      password
  sessions: ALWAYS
</code></pre><p>代理中有2条路由，每条分别用于UI和资源服务器，并且我们已经设置了默认密码和会话持久性策略（告诉Spring Security始终在身份验证上创建会话）。最后一点很重要，因为我们希望进行身份验证，因此需要在网关中管理会话。</p><h2><a href="#up-and-running" class="anchor" name="up-and-running"></a>启动并运行</h2><p>现在，我们有三个组件，在三个端口上运行。如果你的浏览器指向在<a href="http://localhost:8080/ui/">HTTP：//本地主机：8080 / UI /</a>你应该得到一个HTTP基本挑战，您可以为“用户名/密码”（在网关凭据），身份验证，一旦你做，你应该看到通过代理服务器到资源服务器的后端调用在UI中打招呼。</p><p>如果您使用某些开发人员工具，则可以在浏览器中看到浏览器与后端之间的交互（通常F12会打开它，默认情况下在Chrome中运行，并且需要Firefox中的插件）。总结如下：</p>
<table>
<thead>
<tr>
<th>动词</th>
<th>路径</th>
<th>状态</th>
<th>响应</th>
</tr>
</thead>
<tbody>
<tr>
<td>得到</td>
<td>/ ui /</td>
<td>401</td>
<td>浏览器提示进行身份验证</td>
</tr>
<tr>
<td>得到</td>
<td>/ ui /</td>
<td>200</td>
<td>index.html</td>
</tr>
<tr>
<td>得到</td>
<td>/ui/css/angular-bootstrap.css</td>
<td>200</td>
<td>Twitter引导CSS</td>
</tr>
<tr>
<td>得到</td>
<td>/ui/js/angular-bootstrap.js</td>
<td>200</td>
<td>Bootstrap和Angular JS</td>
</tr>
<tr>
<td>得到</td>
<td>/ui/js/hello.js</td>
<td>200</td>
<td>应用逻辑</td>
</tr>
<tr>
<td>得到</td>
<td>/ ui /用户</td>
<td>200</td>
<td>认证方式</td>
</tr>
<tr>
<td>得到</td>
<td>/资源/</td>
<td>200</td>
<td>JSON问候</td>
</tr>
</tbody>
</table><p>您可能看不到401，因为浏览器将主页加载视为单个交互。所有请求都被代理（网关中没有内容，除了用于管理的Actuator端点之外）。</p><p>呼啦，行得通！您有两个后端服务器，其中一个是UI，每个服务器具有独立的功能并且可以隔离进行测试，并且它们与您控制并为其配置了身份验证的安全网关连接在一起。如果浏览器无法访问后端，则没关系（事实上，这可能是一个优势，因为它使您可以更好地控制物理安全性）。</p><h2><a href="#adding-a-login-form" class="anchor" name="adding-a-login-form"></a>添加登录表单</h2><p>就像在<a href="https://spring.io/blog/2015/01/12/spring-and-angular-js-a-secure-single-page-application" title="系列文章的第一篇">第一部分</a>中的“基本”示例中一样，我们现在可以向网关添加登录表单，例如，通过复制<a href="https://spring.io/blog/2015/01/12/the-login-page-angular-js-and-spring-security-part-ii" title="系列第二篇">第二部分中</a>的代码。当我们这样做时，我们还可以在网关中添加一些基本的导航元素，因此用户不必知道代理中UI后端的路径。因此，我们首先将静态资产从“单个” UI复制到网关，删除消息呈现并将登录表单插入我们的主页（在<code><body/></code>某处）：</p>
<pre><code class="prettyprint html"><body ng-app="hello" ng-controller="navigation" ng-cloak
	class="ng-cloak">
  ...
  <div class="container" ng-show="!authenticated">
    <form role="form" ng-submit="login()">
      <div class="form-group">
        <label for="username">Username:</label> <input type="text"
          class="form-control" id="username" name="username"
          ng-model="credentials.username" />
      </div>
      <div class="form-group">
        <label for="password">Password:</label> <input type="password"
          class="form-control" id="password" name="password"
          ng-model="credentials.password" />
      </div>
      <button type="submit" class="btn btn-primary">Submit</button>
    </form>
  </div>
</body>
</code></pre><p>代替消息呈现，我们将有一个不错的大导航按钮：</p>
<pre><code class="prettyprint html"><div class="container" ng-show="authenticated">
  <a class="btn btn-primary" href="/ui/">Go To User Interface</a>
</div>
</code></pre><p>如果您在github中查看示例，则它还有一个带有“注销”按钮的最小导航栏。这是屏幕截图中的登录表单：</p><p><img src="https://raw.githubusercontent.com/dsyer/spring-security-angular/master/double/login.png" alt="登录页面"></p><p>为了支持我们需要一些JavaScript和实施了“导航”控制器的登录表单<code>login()</code>我们在声明的函数<code><form/></code></p><form></form> ，我们需要设置<code>authenticated</code>标志，以便主页根据用户是否通过身份验证而呈现不同的外观。例如：<p></p>
<pre><code class="prettyprint javascript">angular.module('hello', []).controller('navigation',
function($scope, $http) {

  ...
  
  authenticate();
  
  $scope.credentials = {};

$scope.login = function() {
    authenticate($scope.credentials, function() {
      if ($scope.authenticated) {
        console.log("Login succeeded")
        $scope.error = false;
        $scope.authenticated = true;
      } else {
        console.log("Login failed")
        $scope.error = true;
        $scope.authenticated = false;
      }
    })
  };

}
</code></pre><p>在执行<code>authenticate()</code>函数是类似于<a href="https://spring.io/blog/2015/01/12/the-login-page-angular-js-and-spring-security-part-ii" title="系列第二篇">第二部分</a> ：</p>
<pre><code class="prettyprint javascript">var authenticate = function(credentials, callback) {

  var headers = credentials ? {
    authorization : "Basic "
        + btoa(credentials.username + ":"
            + credentials.password)
  } : {};

  $http.get('user', {
    headers : headers
  }).success(function(data) {
    if (data.name) {
      $scope.authenticated = true;
    } else {
      $scope.authenticated = false;
    }
    callback && callback();
  }).error(function() {
    $scope.authenticated = false;
    callback && callback();
  });

}
</code></pre><p>我们可以使用<code>$scope</code>来存储<code>authenticated</code>标志，因为在这个简单的应用程序中只有一个控制器。</p><p>如果我们运行此增强的网关，则不必记住UI的URL，只需加载主页并单击链接即可。这是经过身份验证的用户的主页：</p><p><img src="https://raw.githubusercontent.com/dsyer/spring-security-angular/master/double/home.png" alt="主页"></p><h2><a href="#granular-access-decisions-in-the-backend" class="anchor" name="granular-access-decisions-in-the-backend"></a>后端中的细粒度访问决策</h2><p>到目前为止，我们的应用程序在功能上与<a href="https://spring.io/blog/2015/01/20/the-resource-server-angular-js-and-spring-security-part-iii" title="系列文章中的第三篇">第三部分</a>或<a href="https://spring.io/blog/2015/01/28/the-api-gateway-pattern-angular-js-and-spring-security-part-iv" title="系列文章中的第四篇">第四部分中</a>的应用程序非常相似，但是具有一个额外的专用网关。额外层的优势可能尚不明显，但是我们可以通过扩展系统来强调它。假设我们要使用该网关公开另一个后端UI，以便用户“管理”主UI中的内容，并且我们希望将具有特定角色的用户的访问权限限制为该功能。因此，我们将在代理后面添加一个“ Admin”应用程序，系统将如下所示：</p><p><img src="https://raw.githubusercontent.com/dsyer/spring-security-angular/master/double/double-components.png" alt="系统组成"></p><p>在<code>application.yml</code>的网关中有一个新组件（管理员）和一条新路由：</p>
<pre><code class="prettyprint yaml">zuul:
  routes:
    ui:
      url: http://localhost:8081
    admin:
      url: http://localhost:8082
    resource:
      url: http://localhost:9000
</code></pre><p>上面的框图中的“网关”框中（绿色字母）指示了现有用户界面以“用户”角色提供给用户的事实，以及进入管理应用程序需要“管理员”角色的事实。“ ADMIN”角色的访问决定可以在网关中应用，在这种情况下，它可以显示在<code>WebSecurityConfigurerAdapter</code> ，也可以在Admin应用程序本身中应用（我们将在下面看到如何做）。</p><p>另外，假设在Admin应用程序中，我们想区分“ READER”和“ WRITER”角色，以便我们允许（例如）审核员用户查看主要admin用户所做的更改。这是一个精细的访问决策，其中该规则仅在后端应用程序中是已知的，并且应该仅在该应用程序中是已知的。在网关中，我们只需要确保我们的用户帐户具有所需的角色，并且此信息可用，但是网关不需要知道如何解释它。在网关中，我们创建用户帐户以使示例应用程序保持独立：</p>
<pre><code class="prettyprint javascript">@Configuration
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {

  @Autowired
  public void globalUserDetails(AuthenticationManagerBuilder auth) throws Exception {
    auth.inMemoryAuthentication()
      .withUser("user").password("password").roles("USER")
    .and()
      .withUser("admin").password("admin").roles("USER", "ADMIN", "READER", "WRITER")
    .and()
      .withUser("audit").password("audit").roles("USER", "ADMIN", "READER");
  }
  
}
</code></pre><p>其中，“管理员”用户已通过3个新角色（“ ADMIN”，“ READER”和“ WRITER”）得到了增强，并且我们还添加了具有“ ADMIN”访问权限的“ audit”用户，但没有添加“ WRITER”。</p>
<blockquote><p>另外：在生产系统中，用户帐户数据将在后端数据库（很可能是目录服务）中进行管理，而不是在Spring Configuration中进行硬编码。连接到这样的数据库的示例应用程序很容易在Internet上找到，例如在<a href="https://github.com/spring-projects/spring-security/tree/master/samples">Spring Security Samples中</a> 。</p>
</blockquote><p>访问决策在Admin应用程序中。对于“ ADMIN”角色（此后端需要全局），我们在Spring Security中执行此操作：</p>
<pre><code class="prettyprint java">@Configuration
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {

@Override
  protected void configure(HttpSecurity http) throws Exception {
    http
    ...
      .authorizeRequests()
        .antMatchers("/index.html", "/login", "/").permitAll()
        .antMatchers("/admin/**").hasRole("ADMIN")
        .anyRequest().authenticated()
    ...
  }
  
}
</code></pre><p>对于“ READER”和“ WRITER”角色，应用程序本身是分开的，并且由于应用程序是用JavaScript实现的，因此我们需要做出访问决定。一种方法是在主页中嵌入计算视图：</p>
<pre><code class="prettyprint html"><div class="container">
  <h1>Admin</h1>
  <div ng-show="authenticated" ng-include="template"></div>
  <div ng-show="!authenticated" ng-include="'unauthenticated.html'"></div>
</div>
</code></pre><p>Angular JS将“ ng-include”属性值作为表达式求值，然后使用结果加载模板。</p>
<blockquote><p>提示：更复杂的应用程序可能会使用其他机制对其自身进行模块化，例如，我们在本系列几乎所有其他应用程序中使用的<code>$routeProvider</code>服务。</p>
</blockquote><p>首先通过定义实用程序函数在我们的控制器中初始化<code>template</code>变量：</p>
<pre><code class="prettyprint javascript">var computeDefaultTemplate = function(user) {
  $scope.template = user && user.roles
      && user.roles.indexOf("ROLE_WRITER")>0 ? "write.html" : "read.html";		
}
</code></pre><p>然后在控制器加载时使用实用程序功能：</p>
<pre><code class="prettyprint javascript">angular.module('admin', []).controller('home',

function($scope, $http) {
	
  $http.get('user').success(function(data) {
    if (data.name) {
      $scope.authenticated = true;
      $scope.user = data;
      computeDefaultTemplate(data);
    } else {
      $scope.authenticated = false;
    }
    $scope.error = null
  })
  ...
      
})
</code></pre><p>应用程序要做的第一件事是查看常规的（对于本系列而言）“ / user”端点，然后提取一些数据，设置authenticated标志，如果用户已通过身份验证，则通过查看用户数据来计算模板。</p><p>为了在后端支持此功能，我们需要一个端点，例如在主应用程序类中：</p>
<pre><code class="prettyprint java">@SpringBootApplication
@RestController
@EnableRedisHttpSession
public class AdminApplication {

  @RequestMapping("/user")
  public Map<String, Object> user(Principal user) {
    Map<String, Object> map = new LinkedHashMap<String, Object>();
    map.put("name", user.getName());
    map.put("roles", AuthorityUtils.authorityListToSet(((Authentication) user)
        .getAuthorities()));
    return map;
  }

  public static void main(String[] args) {
    SpringApplication.run(AdminApplication.class, args);
  }

}
</code></pre>
<blockquote><p>注意：角色名称从带有前缀“ ROLE_”的“ / user”端点返回，因此我们可以将它们与其他类型的权限区分开（这是Spring Security的事情）。因此，JavaScript中需要“ ROLE_”前缀，而Spring Security配置中则不需要。从方法名称中可以明显看出，“角色”是操作的重点。</p>
</blockquote><h2><a href="#why-are-we-here" class="anchor" name="why-are-we-here"></a>我们为什么在这里？</h2><p>现在，我们有了一个不错的小型系统，它具有2个独立的用户界面和一个后端资源服务器，所有这些都由网关中的相同身份验证保护。网关充当微型代理，这一事实使后端安全问题的实现极为简单，并且他们可以自由地专注于自己的业务问题。Spring Session的使用（再次）避免了很多麻烦和潜在的错误。</p><p>强大的功能是后端可以独立地拥有他们喜欢的任何身份验证（例如，如果您知道UI的物理地址和一组本地凭据，则可以直接进入UI）。网关施加一组完全不相关的约束，只要它可以验证用户并向他们分配满足后端访问规则的元数据。这是一个出色的设计，能够独立开发和测试后端组件。如果愿意，我们可以返回到外部OAuth2服务器（如<a href="https://spring.io/blog/2015/02/03/sso-with-oauth2-angular-js-and-spring-security-part-v" title="系列文章中的第五篇">第V部分中的内容</a> ，甚至是完全不同的东西），以在网关上进行身份验证，而无需触摸后端。</p><p>此体系结构的一个额外功能（单个网关控制身份验证，以及所有组件之间的共享会话令牌）是“单点注销”（我们在<a href="https://spring.io/blog/2015/02/03/sso-with-oauth2-angular-js-and-spring-security-part-v" title="系列文章中的第五篇">第V部分中</a>难以实现的一项功能）免费提供。更准确地说，在我们完成的系统中会自动提供一种用于单次注销的用户体验的特殊方法：如果用户从任何UI（网关，UI后端或Admin后端）注销，则他将从所有UI中注销。其他情况，假设每个单独的UI以相同的方式（使会话无效）实现“注销”功能。</p><p>如果您仍然很开心，请尝试该系列的<a href="https://spring.io/blog/2015/05/13/modularizing-the-client-angular-js-and-spring-security-part-vii">下</a>一篇文章，该文章主要是关于Javascript的，但仍然显示Spring后端如何使事情变得更容易。</p>
<blockquote><p>谢谢：我要再次感谢所有帮助我开发本系列文章的人，尤其是<a href="https://spring.io/team/rwinch">Rob Winch</a>和<a href="https://twitter.com/thspaeth">ThorstenSpäth</a>对文章和源代码的认真评论。自从<a href="https://spring.io/blog/2015/01/12/spring-and-angular-js-a-secure-single-page-application" title="系列文章的第一篇">第一部分</a>出版以来，它并没有太大变化，但是所有其他部分都是根据读者的评论和见解而发展的，所以也感谢阅读本文并费心参与讨论的任何人。</p>
</blockquote></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">var disqus_shortname = 'spring-io';
      var disqus_identifier = 2011;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));</script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });</script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>