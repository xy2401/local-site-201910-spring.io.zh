<!DOCTYPE html>
<html data-code-prettify="" data-mobile-support="" data-search="">
<head>
<title>The Portable, Cloud-Ready HTTP Session</title>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no" id="Viewport" name="viewport" />
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png" />
<link href="https://fonts.googleapis.com/css?family=Varela+Round|Montserrat:400,700" rel="stylesheet" type="text/css" />
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css" />
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M" name="google-site-verification" />

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css" />

<meta content="summary" name="twitter:card" />
<meta content="@springcentral" name="twitter:site" />
<meta name="twitter:title" content="The Portable, Cloud-Ready HTTP Session" />
<meta name="twitter:description" content="&lt;h2&gt;&lt;a href=&quot;#a-framework-for-all-seasons-and-architectures&quot; class=&quot;anchor&quot; name=&quot;a-framework-for-all-seasons-and-architectures&quot;&gt;&lt;/a&gt;A Framework for all Seasons (and Architectures)&lt;/h2&gt;
&lt;p&gt;Spring walks an interesting line. It provides a lot of value no matter where you run it, and - because it’s built on dependency injection layer - it offers a natural piece of indirection between the underlying layer and the applications that run on top of it. This indirection promotes code portability through decoupling: your application code is ignorant of where the &lt;code&gt;javax.sql.DataSource&lt;/code&gt; (or whatever) handle it’s using comes from, be it a JNDI lookup, environment variables, or a simple new’d-up bean provided by Spring. This decoupling and the rich toolbox of features on top of Spring supporting all manner of use cases - batch processing, integration, stream processing, web services, microservices, operations, web applications, security, etc. - have made Spring a logical choice for developers deploying to (sometimes-embedded) web containers like Apache Tomcat or Eclipse Jetty, to application servers like WebSphere and WildFly, and to cloud runtimes like Google App Engine, Heroku, OpenShift, and (my personal favorite these days) Cloud Foundry. This portability is &lt;em&gt;also&lt;/em&gt; what makes it easy to forklift most (reasonably-written!) applications from the application servers into lighter web containers and, ultimately, into the cloud.&lt;/p&gt;
" />
<meta name="twitter:creator" content="@starbuxman" />
<meta name="twitter:image:src" content="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=200" />

<meta property="og:title" content="The Portable, Cloud-Ready HTTP Session" />
<meta property="og:image" content="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=200" />
<meta property="og:description" content="&lt;h2&gt;&lt;a href=&quot;#a-framework-for-all-seasons-and-architectures&quot; class=&quot;anchor&quot; name=&quot;a-framework-for-all-seasons-and-architectures&quot;&gt;&lt;/a&gt;A Framework for all Seasons (and Architectures)&lt;/h2&gt;
&lt;p&gt;Spring walks an interesting line. It provides a lot of value no matter where you run it, and - because it’s built on dependency injection layer - it offers a natural piece of indirection between the underlying layer and the applications that run on top of it. This indirection promotes code portability through decoupling: your application code is ignorant of where the &lt;code&gt;javax.sql.DataSource&lt;/code&gt; (or whatever) handle it’s using comes from, be it a JNDI lookup, environment variables, or a simple new’d-up bean provided by Spring. This decoupling and the rich toolbox of features on top of Spring supporting all manner of use cases - batch processing, integration, stream processing, web services, microservices, operations, web applications, security, etc. - have made Spring a logical choice for developers deploying to (sometimes-embedded) web containers like Apache Tomcat or Eclipse Jetty, to application servers like WebSphere and WildFly, and to cloud runtimes like Google App Engine, Heroku, OpenShift, and (my personal favorite these days) Cloud Foundry. This portability is &lt;em&gt;also&lt;/em&gt; what makes it easy to forklift most (reasonably-written!) applications from the application servers into lighter web containers and, ultimately, into the cloud.&lt;/p&gt;
" />
<meta content="article" property="og:type" />
<meta property="og:article:published_time" content="2015-03-01 23:51:00.0" />
</head>
<body>

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" style="display:none;visibility:hidden" width="0"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">Projects</a>
</li>
<li class="navbar-link">
<a href="/guides">Guides</a>
</li>
<li class="navbar-link active">
<a href="/blog">Blog</a>
</li>
<li class="navbar-link">
<a href="/services">Training & Certification</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form action="/search" class="form-inline form-search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search for documentation, guides, and posts..." type="text" value="" />
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form action="/search" class="form-inline form-search" method="get">
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search..." type="text" value="" />
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">
Home
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">
Projects
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">
Guides
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">
Blog
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">
Training & Certification
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>Engineering</div>
</div>
<div class="blog-category content--title">
<div>Releases</div>
</div>
<div class="blog-category content--title">
<div>News and Events</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">The Portable, Cloud-Ready HTTP Session</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">Engineering</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=20&amp;d=mm" />
<a class="author" rel="author" href="/team/jlong">Josh Long</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2015-03-01 23:51:00.0">March 01, 2015</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" data-disqus-identifier="2002" href="/blog/2015/03/01/the-portable-cloud-ready-http-session#disqus_thread">
</a></div>
</div>
</header>
<div class="blog--post"><h2><a href="#a-framework-for-all-seasons-and-architectures" class="anchor" name="a-framework-for-all-seasons-and-architectures"></a>A Framework for all Seasons (and Architectures)</h2><p>Spring walks an interesting line. It provides a lot of value no matter where you run it, and - because it&rsquo;s built on dependency injection layer - it offers a natural piece of indirection between the underlying layer and the applications that run on top of it. This indirection promotes code portability through decoupling: your application code is ignorant of where the <code>javax.sql.DataSource</code> (or whatever) handle it&rsquo;s using comes from, be it a JNDI lookup, environment variables, or a simple new&rsquo;d-up bean provided by Spring. This decoupling and the rich toolbox of features on top of Spring supporting all manner of use cases - batch processing, integration, stream processing, web services, microservices, operations, web applications, security, etc. - have made Spring a logical choice for developers deploying to (sometimes-embedded) web containers like Apache Tomcat or Eclipse Jetty, to application servers like WebSphere and WildFly, and to cloud runtimes like Google App Engine, Heroku, OpenShift, and (my personal favorite these days) Cloud Foundry. This portability is <em>also</em> what makes it easy to forklift most (reasonably-written!) applications from the application servers into lighter web containers and, ultimately, into the cloud.</p><h2><a href="#the-stateful-fly-in-the-ointment" class="anchor" name="the-stateful-fly-in-the-ointment"></a>The (Stateful) Fly in the Ointment</h2><p>So, what&rsquo;s the problem? Why write this blog at all?</p><p>Things aren&rsquo;t ideal with applications that use the HTTP session, however. Scaling the HTTP session is where things get, - pardon the HTTP session terminology pun - <em>sticky</em>. You see there are two things that your application will need to scale the HTTP session: session affinity and session replication. Session affinity (or <em>sticky sessions</em>) means that requests to a clustered web application will be routed to the node that originally issued the HTTP session cookie. If that application instance should be taken offline, then session replication ensures that the relevant state is available on another node. The client can be routed there seamlessly, retaining all notion of conversational state. It&rsquo;s not <em>that</em> hard to configure HTTP session replication in the popular containers. Here&rsquo;s the page on setting it up <a href="https://tomcat.apache.org/tomcat-6.0-doc/cluster-howto.html">with Apache Tomcat</a> and here&rsquo;s the page on how to set it up with <a href="https://www.eclipse.org/jetty/documentation/9.2.3.v20140905/session-clustering-jdbc.html">Jetty</a>. Typical session replication strategies involve using multicast networking to notify other nodes in a cluster of state changes. Session affinity and session replication work well in small environments where you only have a few nodes. Unless you&rsquo;re using an embedded web container, configuring the HTTP session replication is yet another thing that needs to be configured in the container, outside of the control of the application.</p><h2><a href="#that-rsquo-s-ok-the-cloud-rsquo-ll-fix-it-right" class="anchor" name="that-rsquo-s-ok-the-cloud-rsquo-ll-fix-it-right"></a>That&rsquo;s OK, the Cloud&rsquo;ll Fix It, Right?</h2><p>You&rsquo;d think that - if nothing else - this sort of configuration would get easier and more predictable once you move your application to the cloud, but in fact it can be more painful! Multicast networking is a no-no in most cloud environments, including in Amazon Web Services. Even in higher-level, more application-centric Platform-as-a-Service environments like Heroku or Cloud Foundry, session replication hasn&rsquo;t been super easy. Heroku, for example, <a href="https://devcenter.heroku.com/articles/intro-for-java-developers">offers no session affinity and no session replication</a>. This restriction is understandable: besides the restrictions in multicast networking, applications should - as much as possible - minimize server-side state. Remember, Heroku limits your application&rsquo;s RAM to 512MB! This is more than enough if you don&rsquo;t try to treat your spare RAM as a database or persistence tier! Cloud Foundry, for its part, serves larger communities of developers and runs on-premise in various data-centers so it has to be a bit more practical. Pivotal Web Services (which runs <a href="http://cloudfoundry.org">Cloud Foundry</a>), for example, offers 1GB of RAM for applications, and it has offered session affinity for a few years. It didn&rsquo;t offer session replication until late last year when a change to the buildpack enables session replication for any <code>.war</code>-based web applications <a href="https://blog.pivotal.io/cloud-foundry-pivotal/products/session-replication-on-cloud-foundry-2">deployed to the default, standalone configuration of the Apache Tomcat web server</a>. This support doesn&rsquo;t use multicast networking, though. Instead, it uses the convention of configuring any bound Redis backing-service for use with the Tomcat container&rsquo;s session replication strategy. Using a backing-service like Redis, or perhaps some shared filesystem, are really the only sensible approaches to session replication in the cloud.</p><p>All of these approaches have different tradeoffs:</p>
<ul>
<li>some are container-specific and that implies they don&rsquo;t move readily from one environment to another.</li>
<li>they may introduce additional complexity for operations (if you still have that team!) and that introduces just that much more friction between the application and production</li>
<li>they may use mutlicast networking which doesn&rsquo;t work well in a cloud environment</li>
<li>they may rely on <em>magic</em> like the Cloud Foundry Java buildpack which only knows about <code>.war</code>s deployed to standalone Apache Tomcat, not embedded <code>.jar</code>s or indeed other web containers like Jetty.</li>
<li>an implied limitation to all of these other points is that the persistence strategy isn&rsquo;t pluggable. Multicast isn&rsquo;t for you? Great, use Redis. Redis isn&rsquo;t for you and want to use Memcache or something else not readily supported? Oh&hellip;</li>
</ul><h2><a href="#enter-spring-session" class="anchor" name="enter-spring-session"></a>Enter Spring Session</h2><p>Spring Session provides a very nice solution for all of these problems. It&rsquo;s a wrapper around the standard Servlet HTTP Session abstraction. It&rsquo;s easy to plug in to any application, whether they&rsquo;re Spring-based or not. It acts as a sort of proxy in front of the HTTP session that forwards requests to a strategy implementation. Out of the box, there&rsquo;s an implementation that supports working with <code>java.util.Map&lt;K,V&gt;</code>s and another that works with Redis, directly. The implementation that uses a <code>java.util.Map&lt;K,V&gt;</code> doesn&rsquo;t sound all that interesting at first, but remember, all your favorite distributed data-grids (Pivotal GemFire, Hazelcast, Oracle Coherence, etc.) can give you a reference to a <code>Map</code> implementation backed by data-grid memory.</p><p>The Redis-specific implementation takes advantage of some efficiencies in Redis, if it&rsquo;s available. Let&rsquo;s look at setting up a dead-simple Spring Session application using Redis. Why Redis? Because it&rsquo;s legitimately &ldquo;web-scale&rdquo; - <a href="http://highscalability.com/blog/2014/9/8/how-twitter-uses-redis-to-scale-105tb-ram-39mm-qps-10000-ins.html">check out this post on how Twitter uses it to scale to 105TB of RAM, 39MM QPS, and 10,000+ instances over on the <em>High Scalability</em> blog</a>!</p><p>In order to get this example to work, I&rsquo;ve added the following Maven dependencies to <a href="https://start.spring.io">a simple Spring Boot project</a>.</p>
<ul>
<li><code>org.springframework.boot</code>:<code>spring-boot-starter-redis</code>:<code>1.2.0.RELEASE</code></li>
<li><code>org.springframework.boot</code>:<code>spring-boot-starter-web</code>:<code>1.2.0.RELEASE</code></li>
<li><code>org.springframework.session</code>:<code>spring-session-data-redis</code>:<code>1.0.0.RELEASE</code></li>
</ul><p>Here&rsquo;s a simple example application:</p>
<pre><code class="prettyprint java">package demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.session.data.redis.config.annotation.web.http.EnableRedisHttpSession;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpSession;
import java.util.UUID;


@EnableRedisHttpSession 
@SpringBootApplication
public class DemoApplication {

	public static void main(String[] args) {
		SpringApplication.run(DemoApplication.class, args);
	}
}

@RestController
class HelloRestController {

	@RequestMapping(&quot;/&quot;)
	String uid(HttpSession session) {
		UUID uid = (UUID) session.getAttribute(&quot;uid&quot;);
		if (uid == null) {
			uid = UUID.randomUUID();
		}
		session.setAttribute(&quot;uid&quot;, uid);
		return uid.toString();
	}
}
</code></pre><p>Before you run it, make sure that you dedicate a clean Redis database to this application. You can, for example, reset the current database using <code>FLUSHDB</code>. The Spring Boot Redis starter automatically connects to a Redis database running on <code>localhost</code>. If you want to point it somewhere specific, use the <a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/redis/RedisProperties.java">various <code>spring.redis.*</code> properties</a>.</p><p>The example is as bare-minimum as possible: it simply confirms that data is being written to the Redis backing-store. Open up your <code>redis-cli</code> utility after interacting with the web application at <code>localhost:8080/</code> in your browser. The first request will trigger a unique session which will be used to cache the <code>uid</code> value. Subsequent requests by the same browser session will see the same value. Enter <code>keys *</code> in the <code>redis-cli</code> to see what&rsquo;s been persisted.</p><h2><a href="#deploying-to-cloudfoundry" class="anchor" name="deploying-to-cloudfoundry"></a>Deploying to CloudFoundry</h2><p>Moving to this cloud can be a bit trickier. If you&rsquo;re deploying this to Cloud Foundry, the Cloud Foundry buildpack will automatically replace the Spring Boot auto-configured <code>RedisConnectionFactory</code> with a <code>RedisConnectionFactory</code> that points to the Redis instance bound to the application. This works <em>if</em> you&rsquo;re running on Cloud Foundry, using the right buildpack, and don&rsquo;t have more than one <code>RedisConnectionFactory</code> in your application.</p><p>I&rsquo;ll be using a Cloud Foundry <code>manifest.yml</code> to describe how this application should look when deployed to Cloud Foundry. In this case, it&rsquo;ll require at minimum a backing-service named <code>redis-session</code> that supports a Redis database. I&rsquo;ve put this file in the root of my project, next to my Maven <code>pom.xml</code>. Note that this <code>manifest.yml</code> contributes an environment variable, <code>SPRING_PROFILES_ACTIVE</code>, that will activate the <code>cloud</code> Spring profile. We&rsquo;ll use this later.</p>
<pre><code class="prettyprint yml"><br />---
applications:
- name: connectors
  memory: 512M
  instances: 1
  host: connectors-${random-word}
  domain: cfapps.io
  path: target/connectors.jar
  services:
    - redis-session
  env:
    SPRING_PROFILES_ACTIVE: cloud
    DEBUG: &quot;true&quot;
    debug: &quot;true&quot;

</code></pre><p>You need to create a Redis instance before pushing the application. I used the following incantation to create a simple Redis instance (called <code>redis-session</code>, we reference it in the <code>manifest.yml</code>) on Pivotal Web Services and then push the application.</p>
<pre><code class="prettyprint bash">cf create-service rediscloud  25mb redis-session
cf push
</code></pre><p>I can deploy the application as-is and things should just work in this example, with just one bound backing-service and one bean of a known type.</p><p>You can use the Spring Cloud PaaS connectors to make short work of explicitly configuring and consuming a cloud-managed Redis backing-service. In this new arrangement, we&rsquo;ll use Spring profiles to keep configuration for running on Cloud Foundry explicit. Add Spring Cloud PaaS connectors like this:</p>
<ul>
<li><code>org.springframework.cloud</code>:<code>spring-boot-starter-cloud-connectors</code>:<code>1.2.0.RELEASE</code></li>
</ul><p>That&rsquo;ll make it so that Spring Boot will autowire instances of every bound backing-service type it knows about. If there&rsquo;s a Redis database with a service ID <code>redis-session</code> then it can be injected using regular Spring qualifiers, like so:</p>
<pre><code class="prettyprint java">   // ..
   @Autowired
   @Qualifier(&quot;redis-session&quot;)
   RedisConnectionFactory rcf;

</code></pre><p>This approach is the simplest, and that&rsquo;s what you&rsquo;ll get if you simply add the Spring Cloud starter dependency. If you want to explicitly configure services, disable the Spring Boot starter by adding the following property to your Spring Boot <code>src/main/resources/application.properties</code>:</p>
<pre><code class="prettyprint properties">spring.cloud.enabled=false
</code></pre><p>Then, use the Spring Cloud PaaS connectors explicitly. The bean definition will <em>only</em> be active when the <code>cloud</code> Spring profile is active. Otherwise, the Spring Boot auto-configuration will kick in (which is what you want when runnning locally).</p>
<pre><code class="prettyprint java">package demo;

import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.Cloud;
import org.springframework.cloud.CloudFactory;
import org.springframework.cloud.service.common.RedisServiceInfo;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Profile;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.session.data.redis.config.annotation.web.http.EnableRedisHttpSession;
import org.springframework.util.ReflectionUtils;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.servlet.http.HttpSession;
import java.lang.reflect.Field;
import java.util.UUID;

@EnableRedisHttpSession
@SpringBootApplication
public class DemoApplication {

	public static void main(String[] args) {
		SpringApplication.run(DemoApplication.class, args);
	}

	@Bean
	@Profile(&quot;cloud&quot;)
	RedisConnectionFactory redisConnectionFactory() {
		CloudFactory cloudFactory = new CloudFactory();
		Cloud cloud = cloudFactory.getCloud();
		RedisServiceInfo redisServiceInfo = (RedisServiceInfo) cloud.getServiceInfo(&quot;redis-session&quot;);
		return cloud.getServiceConnector(redisServiceInfo.getId(),
                     RedisConnectionFactory.class, null);
	}
}

@RestController
class HelloRestController {

	@RequestMapping(&quot;/&quot;)
	String hello(HttpSession session) {
		UUID uid = (UUID) session.getAttribute(&quot;uid&quot;);
		if (uid == null) {
			uid = UUID.randomUUID();
		}
		session.setAttribute(&quot;uid&quot;, uid);
		return uid.toString();
	}
}
</code></pre><h2><a href="#but-wait-there-rsquo-s-more" class="anchor" name="but-wait-there-rsquo-s-more"></a>But Wait, There&rsquo;s More..</h2><p>The whole point of this post was to look at how easily you can get scalable HTTP sessions for your Spring applications in your local environment or in the cloud. I&rsquo;m <em>not</em> recommending that you start cramming your HTTP session with JSF page graphs again! If you need an expiring, scalable, ephemeral-ish store for lightweight business state - like security tokens - then Spring Session can help. Since Spring Session sits between your application and the HTTP session, it can provide a few other useful abstractions above and beyond the Servlet <code>HttpSession</code>. <a href="https://spring.io/team/rwinch">Rob Winch, the lead of Spring Security and Spring Session</a>, has done an amazing job talking about some of these other use cases in the documentation and in other blog posts, so I&rsquo;ll just review here:</p>
<ul>
<li>you can easily <a href="https://github.com/joshlong/bootiful-sessions/tree/master/users">implement &ldquo;Switch Users&rdquo;</a> functionality (sort of like Google Accounts). Check out the <a href="https://docs.spring.io/spring-session/docs/current/reference/html5/guides/users.html">amazing writeup in the docs for more</a>.</li>
<li>Spring Session knows about your Spring websocket traffic and will correctly perpetuate the HTTP session. This avoids <a href="https://issues.apache.org/bugzilla/show_bug.cgi?id=54738">the problems</a> with <a href="https://java.net/jira/browse/WEBSOCKET_SPEC-175">the websocket standard</a> where there&rsquo;s no practical way to perpetuate the HTTP session from websocket traffic. Check out the <a href="https://docs.spring.io/spring-session/docs/current/reference/html5/guides/websocket.html">amazing writeup in the docs for more</a>.</li>
<li>you can pull knobs and levers for everything, including the mechanism used to corellate client requests to server-side session state: <a href="https://github.com/joshlong/bootiful-sessions/tree/master/rest">HTTP headers</a>? Cookies? Something else? The headers approach is pretty darned cool and can give you a <a href="https://spring.io/blog/2015/01/20/the-resource-server-angular-js-and-spring-security-part-iii">sort of poor-man&rsquo;s OAuth access token if used along with Spring Security</a> to secure REST services. Check out the amazing <a href="https://docs.spring.io/spring-session/docs/current/reference/html5/guides/rest.html">writeup in the docs for more</a>.</li>
</ul><p>I was lucky enough to do a webinar on Spring Session last week. <a href="https://spring.io/team/rwinch">Rob</a> gave me the 411 on some things that <em>could</em> be in future releases: </p>
<ul>
<li>session concurrency control (&ldquo;sign me out of my other accounts&rdquo;)</li>
<li>Spring Batch and Spring Integration claim-check support</li>
<li>support for managing accounts - optimized persistence (beyond Java serialization),</li>
<li>smarter, injectable beans (as opposed to beans that are exposed as well-known request attributes but could otherwise be made available as Spring MVC arguments or the like)</li>
</ul><p>Thanks, Rob, for all the great information.</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 2002;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>
Back
</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">All Posts</a>
<a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">Engineering</a>
<a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">Releases</a>
<a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">News and Events</a>
<a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>Get updates from The Spring Team delivered to your inbox</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">Tools</a></li>
<li><a href="https://store.pivotal.io/">Store</a></li>
<li><a href="/blog">Newsletter</a></li>
</ul>
</div>
</div>
&copy; <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a>, Inc. All Rights Reserved.
<a href="https://pivotal.io/terms-of-use">Terms of Use</a> &bullet;
<a href="https://pivotal.io/privacy-policy">Privacy</a> &bullet;
<a href="/trademarks">Trademark Guidelines</a>
<div id="teconsent" style="display:inline-block;"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>