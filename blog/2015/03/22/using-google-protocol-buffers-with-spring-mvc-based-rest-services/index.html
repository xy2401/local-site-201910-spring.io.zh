<html  data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>将Google协议缓冲区与基于Spring MVC的REST服务结合使用</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Using Google Protocol Buffers with Spring MVC-based REST Services">
<meta name="twitter:creator" content="@starbuxman" https:="" ="" developers.google.com="" protocol-buffers="" ="=">Google Protocol Buffers which can be used with REST services as well. 
" > <meta>
<meta name="twitter:image:src" content="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=200">

<meta property="og:title" content="Using Google Protocol Buffers with Spring MVC-based REST Services">
<meta property="og:image" content="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=200">
<meta property="og:type" content="article" https:="" ="" developers.google.com="" protocol-buffers="" ="=">Google Protocol Buffers which can be used with REST services as well. 
" > <meta>
<meta property="og:article:published_time" content="2015-03-22 17:10:00.0">
</head>
<body >

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
 <div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">将Google协议缓冲区与基于Spring MVC的REST服务结合使用</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=20&d=mm"> <a class="author" rel="author" href="/team/jlong">乔什·朗（Josh Long）</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2015-03-22 17:10:00.0">2015年3月22日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2015/03/22/using-google-protocol-buffers-with-spring-mvc-based-rest-services#disqus_thread" data-disqus-identifier="2031">
</a></div>
</div>
</header>
<div class="blog--post"><p>本周，我在巴西圣保罗，参加QCon SP会议。我和一个喜欢Spring的REST堆栈的人进行了有趣的讨论，但想知道是否有比普通JSON更有效的东西。确实有！我经常被问到Spring对基于消息的高速二进制编码的支持。Spring长期支持的Hessian，Burlap等之类的RPC编码，并且Spring Framework 4.1引入了对<a href="https://developers.google.com/protocol-buffers/">Google协议缓冲区的</a>支持， <a href="https://developers.google.com/protocol-buffers/">该协议</a>也可以与REST服务一起使用。</p><p>在Google Protocol Buffer网站上：</p>
<blockquote><p>协议缓冲区是Google的与语言无关，与平台无关的可扩展机制，用于对结构化数据进行序列化（例如XML），但更小，更快，更简单。您定义如何一次构造数据，然后可以使用生成的特殊源代码轻松地使用多种语言在各种数据流之间来回写入和读取结构化数据…</p>
</blockquote><p>Google在其自己的内部，以服务为中心的体系结构中广泛使用协议缓冲区。</p><p>一种<code>.proto</code>文档描述了要编码的类型（_messages_），并包含使用C的任何人都应该熟悉的定义语言<code>struct</code> s。在文档中，您定义类型，这些类型中的字段及其顺序（内存偏移！）。相对于彼此的类型。</p><p>的<code>.proto</code>文件不是实现-它们是对可能通过网络传送的消息的声明性描述。他们可以在编码和解码的消息上规定和验证约束（给定字段的类型或该字段的基数）。您必须使用Protobuf编译器为您选择的语言生成适当的客户端。</p><p>您可以随意使用Google协议缓冲区，但是在本文中，我们将介绍如何使用它来编码REST服务有效负载。这种方法功能强大：您可以使用内容协商将高速协议缓冲区有效负载提供给接受该协议的客户端（以任何数量的语言），而对于那些不接受的客户端，则可以使用诸如JSON之类的更常规的协议。</p><p>协议缓冲消息相对于典型的JSON编码消息提供了许多改进，尤其是在多语言系统中，在该系统中，微服务以各种技术实现，但需要能够以一致的长期方式推理服务之间的通信。</p><p>协议缓冲区是促进稳定API的几个不错的功能：</p>
<ul>
<li>协议缓冲区免费提供向后兼容性。每个字段都在协议缓冲区中编号，因此您不必更改代码的行为即可保持与旧客户端的向后兼容性。不了解新字段的客户不会费心尝试解析它们。</li>
<li>协议缓冲区提供了自然的地方，可以使用<code>required</code> ， <code>optional</code>和<code>repeated</code>关键字。每个客户都以自己的方式实施这些约束。</li>
<li>协议缓冲区是多语言的，并且<a href="https://developers.google.com/protocol-buffers/docs/reference/other">可以与各种技术配合使用</a> 。仅在此博客的示例代码中，就演示了用于Java服务的Ruby，Python和Java客户端。只需使用<em>众多</em>受支持的编译器之一即可。</li>
</ul><p>您可能会认为您可以仅在同类服务环境中使用Java的内置序列化机制，但是由于Protocol Buffers团队很快指出，当他们首次引入该技术时，即使这样也存在一些问题。Java语言专家Josh Bloch的史诗《 <em>有效Java》</em> （第213页）提供了更多详细信息。</p><p>我们先来看一下<code>.proto</code>文献：</p>
<pre><code class="prettyprint json">package demo;

option java_package = &quot;demo&quot;;
option java_outer_classname = &quot;CustomerProtos&quot;;

message Customer {
    required int32 id = 1;
    required string firstName = 2;
    required string lastName = 3;

    enum EmailType {
        PRIVATE = 1;
        PROFESSIONAL = 2;
    }

    message EmailAddress {
        required string email = 1;
        optional EmailType type = 2 [default = PROFESSIONAL];
    }

    repeated EmailAddress email = 5;
}

message Organization {
    required string name = 1;
    repeated Customer customer = 2;
}
</code></pre><p>然后，您将此定义传递给<code>protoc</code>编译器并指定输出类型，如下所示：</p>
<pre><code class="prettyprint sh">protoc -I=$IN_DIR --java_out=$OUT_DIR $IN_DIR/customer.proto
</code></pre><p>这是我整理来生成各种客户端代码的小Bash脚本：</p>
<pre><code class="prettyprint sh">#!/usr/bin/env bash


SRC_DIR=`pwd`
DST_DIR=`pwd`/../src/main/

echo source:            $SRC_DIR
echo destination root:  $DST_DIR

function ensure_implementations(){

    # Ruby and Go aren&#39;t natively supported it seems
    # Java and Python are

    gem list | grep ruby-protocol-buffers || sudo gem install ruby-protocol-buffers
    go get -u github.com/golang/protobuf/{proto,protoc-gen-go}
}

function gen(){
    D=$1
    echo $D
    OUT=$DST_DIR/$D
    mkdir -p $OUT
    protoc -I=$SRC_DIR --${D}_out=$OUT $SRC_DIR/customer.proto
}

ensure_implementations

gen java
gen python
gen ruby
</code></pre><p>这将在<code>src/main/{java,ruby,python}</code>文件夹。首先让我们看一下Spring MVC REST服务本身。</p><h2><a href="#a-spring-mvc-rest-service" class="anchor" name="a-spring-mvc-rest-service"></a> Spring MVC REST服务</h2><p>在我们的示例中，我们将注册一个Spring Framework 4.1的实例。 <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/converter/protobuf/ProtobufHttpMessageConverter.html"><code>org.springframework.http.converter.protobuf.ProtobufHttpMessageConverter</code></a> 。这种类型是<code>HttpMessageConverter</code> 。 <code>HttpMessageConverter</code>在REST服务调用中对请求和响应进行编码和解码。通常会在进行某种形式的内容协商后将其激活：如果客户端指定<code>Accept: application/x-protobuf</code> ，例如，然后我们的REST服务将发回协议缓冲区编码的响应。</p>
<pre><code class="prettyprint java">package demo;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.http.converter.protobuf.ProtobufHttpMessageConverter;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Arrays;
import java.util.Collection;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

@SpringBootApplication
public class DemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }

    @Bean
    ProtobufHttpMessageConverter protobufHttpMessageConverter() {
        return new ProtobufHttpMessageConverter();
    }

    private CustomerProtos.Customer customer(int id, String f, String l, Collection&lt;String&gt; emails) {
        Collection&lt;CustomerProtos.Customer.EmailAddress&gt; emailAddresses =
                emails.stream().map(e -&gt; CustomerProtos.Customer.EmailAddress.newBuilder()
                        .setType(CustomerProtos.Customer.EmailType.PROFESSIONAL)
                        .setEmail(e).build())
                        .collect(Collectors.toList());

        return CustomerProtos.Customer.newBuilder()
                .setFirstName(f)
                .setLastName(l)
                .setId(id)
                .addAllEmail(emailAddresses)
                .build();
    }

    @Bean
    CustomerRepository customerRepository() {
        Map&lt;Integer, CustomerProtos.Customer&gt; customers = new ConcurrentHashMap&lt;&gt;();
        // populate with some dummy data
        Arrays.asList(
                customer(1, &quot;Chris&quot;, &quot;Richardson&quot;, Arrays.asList(&quot;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="a3c0d1cac0cbc2d1c7d0cccde3c6cec2cacf8dc0ccce">[email&#160;protected]</a>&quot;)),
                customer(2, &quot;Josh&quot;, &quot;Long&quot;, Arrays.asList(&quot;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="33595f5c5d5473565e525a5f1d505c5e">[email&#160;protected]</a>&quot;)),
                customer(3, &quot;Matt&quot;, &quot;Stine&quot;, Arrays.asList(&quot;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="f79a84839e9992b7929a969e9bd994989a">[email&#160;protected]</a>&quot;)),
                customer(4, &quot;Russ&quot;, &quot;Miles&quot;, Arrays.asList(&quot;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4e3c2327222b3d0e2b232f2722602d2123">[email&#160;protected]</a>&quot;))
        ).forEach(c -&gt; customers.put(c.getId(), c));

        // our lambda just gets forwarded to Map#get(Integer)
        return customers::get;
    }

}

interface CustomerRepository {
    CustomerProtos.Customer findById(int id);
}


@RestController
class CustomerRestController {

    @Autowired
    private CustomerRepository customerRepository;

    @RequestMapping(&quot;/customers/{id}&quot;)
    CustomerProtos.Customer customer(@PathVariable Integer id) {
        return this.customerRepository.findById(id);
    }
}
</code></pre><p>大部分代码非常简单。这是一个Spring Boot应用程序。Spring Boot自动注册<code>HttpMessageConverter</code>豆，所以我们只需要定义<code>ProtobufHttpMessageConverter</code> bean，并对其进行了适当的配置。的<code>@Configuration</code>类播种一些虚拟日期和一个模拟<code>CustomerRepository</code>宾语。我不会为我们的协议缓冲区复制Java类型， <code>demo/CustomerProtos.java</code> ，这里是代码生成的位旋转和解析代码；并不是所有有趣的东西。一种便利是Java实现自动提供了<em>构建器</em>方法，用于在Java中快速创建这些类型的实例。</p><p>代码生成的类型很笨<code>struct</code>像物体。它们适合用作DTO，但不应用作API的基础。 <em>不要</em>使用Java继承引进新的功能来扩展他们。无论如何，这会破坏实现并且是不好的OOP实践。如果您想保持环境整洁，只需对其进行适当的包装和调整即可，也许可以在该包装器中适当地处理从ORM实体到协议缓冲区客户端类型的转换。</p><p><code>HttpMessageConverter</code>还可与Spring的REST客户端一起使用， <code>RestTemplate</code> 。这是适当的Java语言单元测试：</p>
<pre><code class="prettyprint java">package demo;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.IntegrationTest;
import org.springframework.boot.test.SpringApplicationConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.protobuf.ProtobufHttpMessageConverter;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.web.WebAppConfiguration;
import org.springframework.web.client.RestTemplate;

import java.util.Arrays;

@RunWith(SpringJUnit4ClassRunner.class)
@SpringApplicationConfiguration(classes = DemoApplication.class)
@WebAppConfiguration
@IntegrationTest
public class DemoApplicationTests {

    @Configuration
    public static class RestClientConfiguration {

        @Bean
        RestTemplate restTemplate(ProtobufHttpMessageConverter hmc) {
            return new RestTemplate(Arrays.asList(hmc));
        }

        @Bean
        ProtobufHttpMessageConverter protobufHttpMessageConverter() {
            return new ProtobufHttpMessageConverter();
        }
    }

    @Autowired
    private RestTemplate restTemplate;

    private int port = 8080;

    @Test
    public void contextLoaded() {

        ResponseEntity&lt;CustomerProtos.Customer&gt; customer = restTemplate.getForEntity(
                &quot;http://127.0.0.1:&quot; + port + &quot;/customers/2&quot;, CustomerProtos.Customer.class);

        System.out.println(&quot;customer retrieved: &quot; + customer.toString());

    }

}
</code></pre><p>事情就像您期望的那样工作，不仅在Java和Spring中，而且在Ruby和Python中。为了完整起见，这是一个使用Ruby的简单客户端（省略了客户端类型）：</p>
<pre><code class="prettyprint ruby">#!/usr/bin/env ruby

require &#39;./customer.pb&#39;
require &#39;net/http&#39;
require &#39;uri&#39;

uri = URI.parse(&#39;http://localhost:8080/customers/3&#39;)
body = Net::HTTP.get(uri)
puts Demo::Customer.parse(body)
</code></pre><p>..这是Python中的客户端（省略了客户端类型）：</p>
<pre><code class="prettyprint python"><br />#!/usr/bin/env python

import urllib
import customer_pb2

if __name__ == &#39;__main__&#39;:
    customer = customer_pb2.Customer()
    customers_read = urllib.urlopen(&#39;http://localhost:8080/customers/1&#39;).read()
    customer.ParseFromString(customers_read)
    print customer

</code></pre><h2><a href="#where-to-go-from-here" class="anchor" name="where-to-go-from-here"></a>从这往哪儿走</h2><p>如果您想要使用多种语言的<em>超</em>高速消息编码，则协议缓冲区是一个<em>不错的</em>选择。还有其他一些编码技术，例如<a href="https://avro.apache.org/">Avro</a>或<a href="https://thrift.apache.org/">Thrift</a> ，但没有一种像协议缓冲区那样成熟和根深蒂固。您也不一定需要将协议缓冲区与REST一起使用。如果您的风格如此，则可以将其插入某种RPC服务中。几乎与Cloud Foundry的构建包一样，客户端实现的数量也是如此-因此，您几乎可以在Cloud Foundry上运行任何东西，并在所有服务中享受相同的高速，一致的消息传递！</p><p>该<a href="https://github.com/joshlong/spring-and-google-protocol-buffers">示例</a>的<a href="https://github.com/joshlong/spring-and-google-protocol-buffers">代码也可以在线获得</a> ，所以请立即查看！</p><h2><a href="#also" class="anchor" name="also"></a>也..</h2><p>嗨，帮派，在2015年，我一直试图根据我在社区或<a href="https://pivotal.io/blog">Pivotal博客</a>上引起社会关注的事情，每周随机发布技术提示样式的帖子。我每周都会使用这些-_ish_（好！好！ -像<em>春季的“本周”</em>那样定期做这些事情并不容易，但是到目前为止，我还没有错过任何一个星期！ :-)）的机会是，其本身并不专注于特定的新版本，而是专注于将Spring在服务中应用到某些跨领域或可能受益于其焦点的社区用例。到目前为止，我们已经研究了各种各样的事物-Vaadin，Activiti，12要素应用程序样式配置，更智能的服务到服务调用，Couchbase等，以及-还有很多有趣的东西。我想知道您还想谈什么。如果您对自己想看到的内容有任何想法，或者您自己有贡献的社区帖子，请通过<a href="https://twitter.com/starbuxman">Twitter（@starbuxman）</a>或通过电子邮件<a href="https://twitter.com/starbuxman">与我联系</a> （jlong [at]关键[dot] io ）。我将一如既往地为您服务。</p></div>
</div>
<section id="disqus_thread"></section>
<script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 2031;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>