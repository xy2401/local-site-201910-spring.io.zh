<html  data-code-prettify="" data-mobile-support="" data-search=""><head></head><body >﻿
<title>Spring微服务</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Microservices with Spring">
<meta name="twitter:description" >
<meta name="twitter:image:src" content="https://gravatar.com/avatar/0b0bedf6c0dab07b13a322eed9350873?s=200">

<meta property="og:title" content="Microservices with Spring">
<meta property="og:image" content="https://gravatar.com/avatar/0b0bedf6c0dab07b13a322eed9350873?s=200">
<meta class="anchor" name="introduction" property="og:description" content="<h1><a href=" #introductio="=">Introduction
<p><strong>NOTE:</strong> <em><a href="#recent-updates">Revised July 2019</a></em></p>
<p>A simple example of setting up a microservices system using Spring, Spring Boot and Spring Cloud.</p>
<p><a href="http://martinfowler.com/articles/microservices.html">Microservices</a> allow large systems to be built up from a number of collaborating components. It does at the process level what Spring has always done at the component level: loosely coupled processes instead of loosely coupled components.</p>
<a href="https://raw.githubusercontent.com/paulc4/microservices-demo/master/shopping-system.jpg"><img src="https://raw.githubusercontent.com/paulc4/microservices-demo/master/shopping-system.jpg" title="点击放大" alt="购物申请" style="width:400px;float:right;margin:0px 5px 5px 10px"></a>
<p>For example imagine an online shop with separate microservices for user-accounts, product-catalog order-processing and shopping carts:</p>
">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2015-07-14 06:28:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Spring微服务</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/0b0bedf6c0dab07b13a322eed9350873?s=20&d=mm"> <span class="author">保罗·查普曼</span>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2015-07-14 06:28:00.0">2015年7月14日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2015/07/14/microservices-with-spring#disqus_thread" data-disqus-identifier="2181">
</a></div>
</div>
</header>
<div class="blog--post"><h1><a href="#introduction" class="anchor" name="introduction"></a>介绍</h1>
<p><strong>注意：</strong> <em><a href="#recent-updates">2019年7月修订</a></em></p>
<p>一个使用Spring，Spring Boot和Spring Cloud设置微服务系统的简单示例。</p>
<p><a href="http://martinfowler.com/articles/microservices.html">微服务</a>允许使用许多协作组件来构建大型系统。它在流程级别上执行Spring一直在组件级别上所做的工作：松散耦合的流程而不是松散耦合的组件。</p>
<a href="https://raw.githubusercontent.com/paulc4/microservices-demo/master/shopping-system.jpg"><img src="https://raw.githubusercontent.com/paulc4/microservices-demo/master/shopping-system.jpg" title="点击放大" alt="购物申请" style="width:400px;float:right;margin:0px 5px 5px 10px"></a>
<p>例如，假设一个网上商店为用户帐户，产品目录订单处理和购物车提供了单独的微服务：</p>
<p>不可避免地，必须设置和配置许多活动部件才能构建这样的系统。如何使它们协同工作还不是很明显-您需要对Spring Boot非常熟悉，因为Spring Cloud充分利用了它，因此需要几个Netflix或其他OSS项目，当然，还有一些Spring配置“不可思议”！</p>
<a href="https://raw.githubusercontent.com/paulc4/microservices-demo/master/mini-system.jpg"><img src="https://raw.githubusercontent.com/paulc4/microservices-demo/master/mini-system.jpg" title="点击放大" alt="演示申请" style="width:400px;float:left;margin:5px 10px 5px 0"></a>
<p>在本文中，我旨在通过逐步构建最简单的系统来阐明事物的工作方式。因此，我将只实现大型系统的一小部分-用户帐户服务。</p>
<p><em>Web应用程序</em>将使用RESTful API向<em>Account-Service</em>微<em>服务</em>发出请求。我们还需要添加<em>发现</em>服务-这样其他进程就可以彼此找到对方。</p>
<p>此应用程序的代码在这里： <a href="https://github.com/paulc4/microservices-demo">https</a> : <a href="https://github.com/paulc4/microservices-demo">//github.com/paulc4/microservices-demo</a> 。</p>
<p>特意详细介绍了其工作方式。不耐烦的读者可能更喜欢只看一下<a href="https://github.com/paulc4/microservices-demo">代码</a> 。请注意，它在一个项目中包含<em>三个</em>微服务。</p><h2><a href="#learn-more" class="anchor" name="learn-more"></a>学到更多</h2>
<ul>
<li>报名参加<a href="https://springoneplatform.io/">SpringOne Platform 2019</a> –这是使用Spring构建可伸缩微服务应用程序的顶级会议。今年10月7日至10日，我们将在德克萨斯州奥斯汀市。使用折扣代码<strong>S1P_Save200</strong>可以节省机票费用。需要说服您的经理的帮助吗？使用<a href="https://springoneplatform.io/2019/convince-your-manager">此页面</a> 。</li>
<li>获得Matt Stine的免费电子书“ <a href="https://content.pivotal.io/ebooks/migrating-to-cloud-native-application-architectures">迁移到云原生架构”</a></li>
<li>该<a href="https://content.pivotal.io/webinars/mar-21-tools-and-recipes-to-replatform-monolithic-apps-to-modern-cloud-environments-webinar">网络研讨会</a>讨论工具和配方，以帮助您将整体式应用程序重新平台化为现代云环境。</li>
</ul>
<a name="recent-updates"></a><h2><a href="#updates-june-2018" class="anchor" name="updates-june-2018"></a>更新（2018年6月）</h2>
<p>自从我最初撰写此博客以来，进行了许多更改：</p>
<ol>
<li>有关在同一主机上使用同一服务的多个实例的<a href="#configuration-options">讨论</a> 。演示应用程序已更新为匹配。</li>
<li><a href="#load-balanced-resttemplate">讨论</a> <code>@LoadBalanced</code> -这个作品<em>是</em>如何从<em>布里克斯顿</em>发布列车（ <em>改变</em> <a href="https://projects.spring.io/spring-cloud">春云</a> 1.1.0。发布）。</li>
<li><a href="#accountsconfiguration-class">将</a> Accounts微服务重构<a href="#accountsconfiguration-class">配置</a>到其自己的类中<code>AccountsConfiguration</code> 。</li>
<li>升级到Spring Boot 2，因此一些Boot类更改了程序包。</li>
<li>将<a href="#running-the-system">演示应用程序</a>升级到Spring Cloud <em>Finchley</em>发行培训（包括最后注释中的各种修复-感谢您的反馈）。</li>
<li>Eureka服务器依赖项已更改为<code>spring-cloud-starter-netflix-eureka-server</code> 。</li>
</ol>
<p>使用Spring Boot 1.5.10和Spring Cloud Edgeware SR3的先前版本可作为git tag v1.2.0获得。</p>
<p> </p>
<p><em>好，让我们开始吧……</em></p><h1><a href="#service-registration" class="anchor" name="service-registration"></a>服务注册</h1>
<p>当您有多个流程协同工作时，它们需要彼此查找。如果您曾经使用过Java的RMI机制，您可能会记得它依赖于中央注册表，因此RMI进程可以相互找到。微服务具有相同的要求。</p>
<p>Netflix的开发人员在构建系统并创建名为Eureka的注册服务器（希腊文中的“我找到了它”）时遇到了这个问题。对我们来说幸运的是，他们使发现服务器开源，并且Spring已整合到Spring Cloud中，从而使运行Eureka服务器变得更加容易。这是<em>完整的</em>发现服务器应用程序：</p>
<pre><code class="prettyprint java">@SpringBootApplication
@EnableEurekaServer
public class ServiceRegistrationServer {

  public static void main(String[] args) {
    // Tell Boot to look for registration-server.yml
    System.setProperty(&quot;spring.config.name&quot;, &quot;registration-server&quot;);
    SpringApplication.run(ServiceRegistrationServer.class, args);
  }
}
</code></pre>
<p>真的就是这么简单！</p>
<p>Spring Cloud基于Spring Boot构建，并利用父级和入门级POM。 <a href="https://github.com/paulc4/microservices-demo/blob/master/pom.xml">POM</a>的重要部分是：</p>
<pre><code class="prettyprint xml">    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;
    &lt;/parent&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;!-- Setup Spring Boot --&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;!-- Setup Spring MVC &amp; REST, use Embedded Tomcat --&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;!-- Spring Cloud starter --&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;!-- Eureka for service registration --&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

   &lt;!-- Spring Cloud dependencies --&gt;
    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
                &lt;version&gt;Finchley.RELEASE&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;
</code></pre>
<p>自从我最初写文章将Spring Boot用作父项而不是Spring Cloud以来，此POM发生了变化。通过依赖关系管理部分提供了Spring Cloud依赖关系。</p>
<p>github代码中还包含一个示例gradle构建文件。</p>

<style>
.infoblock {
border: 1px solid #AAF;
    background-color: white;
    color: #303030;
    margin: 0 0 0 0.5em;
    padding: 0.5em 0 0.5em 1em;
    float: right;
    font-size: 88%;
    width: 45%
}
</style>
<div class="infoblock">
<p style="margin:0 0 0 0">
<b>注意：</b> <i>芬奇利。RELEASE</i>是当前的“发行版”-一组协调的发行版-请参阅Spring Cloud <a href="https://projects.spring.io/spring-cloud/#release-trains">主页上的</a>注释。
</p>
</div>
<p>默认情况下，Spring Boot应用程序查找<code>application.properties</code>要么<code>application.yml</code>配置文件。通过设置<code>spring.config.name</code>属性，我们可以告诉Spring Boot寻找不同的文件-如果您在同一项目中有多个Spring Boot应用程序，则很有用-稍后我会做。</p>
<p>该应用程序寻找<code>registration-server.properties</code>要么<code>registration-server.yml</code> 。这是来自的相关配置<code>registration-server.yml</code> ：</p>
<pre><code class="prettyprint yml"># Configure this Discovery Server
eureka:
  instance:
    hostname: localhost
  client:  # Not a client, don&#39;t register with yourself (unless running
           # multiple discovery servers for redundancy)
    registerWithEureka: false
    fetchRegistry: false

server:
  port: 1111   # HTTP (Tomcat) port
</code></pre>
<p>默认情况下，Eureka在端口8761上运行，但是在这里我们将使用端口<code>1111</code>代替。另外，通过在我的过程中包括注册码，我可能是服务器或客户端。该配置指定我不是客户端，并停止尝试向其注册的服务器进程。</p>

<div class="infoblock">
<h2>使用领事</h2>
<p style="margin-bottom:10px">Spring Cloud还支持<a href="https://www.consul.io">Consul</a>作为Eureka的替代方案。您使用脚本启动Consul Agent（其注册服务器），然后客户端使用它来查找其微服务。有关详细信息，请参见此博客<a href="https://spring.io/blog/2015/05/27/spring-cloud-consul-1-0-0-m1-available-now">文章</a>或项目<a href="https://cloud.spring.io/spring-cloud-consul">主页</a> 。
</p>
</div>
<p>立即尝试运行<em>RegistrationServer</em> （有关运行该应用程序的帮助，请参见<a href="#running-the-system">下文</a> ）。您可以在此处打开Eureka仪表板： <a href="http://localhost:1111">http：// localhost：1111</a> ，显示“应用程序”的部分将为空。</p>
<p>从现在开始，我们将参考<em>发现服务器，</em>因为它可能是Eureka或Consul（请参阅侧面板）。</p><h1><a href="#creating-a-microservice-em-account-service-em" class="anchor" name="creating-a-microservice-em-account-service-em"></a>创建<em>微服务</em> ： <em>帐户服务</em></h1>
<p>微服务是处理明确定义的需求的独立流程。</p>
<a href="https://raw.githubusercontent.com/paulc4/microservices-demo/master/beans-vs-processes.jpg"><img src="https://raw.githubusercontent.com/paulc4/microservices-demo/master/beans-vs-processes.jpg" title="点击放大" alt="豆与流程" style="width:400px;float:right;margin:10px 0 5px 15px"></a>
<p>在使用Spring配置应用程序时，我们强调松散耦合和紧密内聚，这些并不是新概念（Larry Constantine最早在1960年代后期定义了这些<a href="https://en.wikipedia.org/wiki/Cohesion_%28computer_science%29">参考</a> - <a href="https://en.wikipedia.org/wiki/Cohesion_%28computer_science%29">值得称赞</a> ），但是现在我们将它们应用，而不是用于交互组件（Spring Beans），而是互动过程。</p>
<p>在此示例中，我有一个简单的帐户管理微服务，该服务使用Spring Data来实现JPA <code>AccountRepository</code>和Spring REST为帐户信息提供RESTful接口。在大多数方面，这是一个简单的Spring Boot应用程序。</p>
<p>使其与众不同的是，它在启动时会向<em>发现服务器</em>注册。这是Spring Boot启动类：</p>
<pre><code class="prettyprint java">@EnableAutoConfiguration
@EnableDiscoveryClient
@Import(AccountsWebApplication.class)
public class AccountsServer {

    @Autowired
    AccountRepository accountRepository;

    public static void main(String[] args) {
        // Will configure using accounts-server.yml
        System.setProperty(&quot;spring.config.name&quot;, &quot;accounts-server&quot;);

        SpringApplication.run(AccountsServer.class, args);
    }
}
</code></pre>
<p>注释可以完成工作：</p>
<ol>
<li><code>@EnableAutoConfiguration</code> -将其定义为Spring Boot应用程序。</li>
<li><code>@EnableDiscoveryClient</code> -这样可以进行服务注册和发现。在这种情况下，此过程使用其应用程序名称（见下文）向<em>发现服务器</em>服务注册自己。</li>
<li><code>@Import(AccountsWebApplication.class)</code> -此Java配置类设置了其他所有内容（有关更多详细信息，请参见<a href="#accountswebapplication-configuration">下文</a> ）。</li>
</ol>
<p>使之成为微服务的原因是通过以下方式向<em>发现服务器</em>注册<code>@EnableDiscoveryClient</code>并且其YML配置完成了设置：</p>
<pre><code class="prettyprint yml"># Spring properties
spring:
  application:
     name: accounts-service

# Discovery Server Access
eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:1111/eureka/

# HTTP Server
server:
  port: 2222   # HTTP (Tomcat) port
</code></pre>
<p>注意这个文件</p>
<ol>
<li>将应用程序名称设置为<code>accounts-service</code> 。此服务以该名称注册，也可以通过该名称访问-参见下文。</li>
<li>指定要监听的自定义端口（2222）。我所有的进程都使用Tomcat，但它们不能全部监听端口8080。</li>
<li>上一节中的Eureka服务流程的URL。</li>
</ol>
<a href="https://raw.githubusercontent.com/paulc4/microservices-demo/master/dashboard.png"><img src="https://raw.githubusercontent.com/paulc4/microservices-demo/master/dashboard.png" title="点击放大" alt="尤里卡仪表板" style="width:450px;float:right;margin:0px 5px 5px 10px"></a>
<p>立即运行<em>AccountsService</em>应用程序，并使其完成初始化。刷新仪表板<a href="http://localhost:1111">http：// localhost：1111</a> ，您应该看到“应用程序”下列出的ACCOUNTS-SERVICE。注册最多需要30秒（默认情况下），因此请耐心等待-检查<em>RegistrationService</em>的日志输出</p>

<div class="infoblock">
<p style="margin:0 0 0 0">
<b>警告：</b>请勿尝试使用Eclipse / STS的内部Web查看器显示XML输出，因为它不能这样做。请改用您喜欢的网络浏览器。
</p>
</div>
<p>有关更多详细信息，请转到此处： <a href="http://localhost:1111/eureka/apps/">http：// localhost：1111 / eureka / apps /</a> ，您应该看到类似以下内容：</p>
<pre><code class="prettyprint xml">&lt;applications&gt;
    &lt;versions__delta&gt;1&lt;/versions__delta&gt;
    &lt;apps__hashcode&gt;UP_1_&lt;/apps__hashcode&gt;
    &lt;application&gt;
        &lt;name&gt;ACCOUNTS-SERVICE&lt;/name&gt;
        &lt;instance&gt;
            &lt;hostName&gt;autgchapmp1m1.corp.emc.com&lt;/hostName&gt;
            &lt;app&gt;ACCOUNTS-SERVICE&lt;/app&gt;
            &lt;ipAddr&gt;172.16.84.1&lt;/ipAddr&gt;&lt;status&gt;UP&lt;/status&gt;
            &lt;overriddenstatus&gt;UNKNOWN&lt;/overriddenstatus&gt;
            &lt;port enabled=&quot;true&quot;&gt;3344&lt;/port&gt;
            &lt;securePort enabled=&quot;false&quot;&gt;443&lt;/securePort&gt;
            ...
        &lt;/instance&gt;
    &lt;/application&gt;
&lt;/applications&gt;

</code></pre>
<p>或者，访问<a href="http://localhost:1111/eureka/apps/ACCOUNTS-SERVICE">http：// localhost：1111 / eureka / apps / ACCOUNTS-SERVICE</a> ，仅查看<em>AccountsService</em>的详细信息-如果未注册，则将获得404。</p><h2><a href="#configuration-options" class="anchor" name="configuration-options"></a>配置选项</h2>
<p><strong>注册时间：</strong>注册最多需要30秒，因为这是默认的客户端刷新时间。您可以通过设置<code>eureka.instance.leaseRenewalIntervalInSeconds</code>属性设置为较小的数字（在演示应用程序中，我将其设置为5）。在<a href="https://cloud.spring.io/spring-cloud-static/docs/1.0.x/spring-cloud.html#_why_is_it_so_slow_to_register_a_service">生产中</a> <em>不建议</em>这样<em>做</em> 。见<a href="https://github.com/spring-cloud/spring-cloud-netflix/issues/373">也</a> 。</p>
<pre><code class="prettyprint yml">eureka:
  instance:
    leaseRenewalIntervalInSeconds: 5         # DO NOT DO THIS IN PRODUCTION
</code></pre>
<p><strong>注册ID：</strong>进程（微服务）使用唯一ID向发现服务注册。如果另一个进程使用<em>相同的</em> ID注册，则将其视为重新启动（例如某种故障转移或恢复），并且第一个进程注册将被丢弃。这为我们提供了我们所需要的容错系统。</p>
<p>要运行<em>同一</em>进程的多个实例（以实现负载平衡和弹性），它们需要使用唯一的ID注册。当我第一次写此博客时，这是自动的，并且自<em>Brixton</em>发布以来，它再次成为<em>现实</em> 。</p>
<p>在<em>Angel</em>发布系列中，客户端用来在发现服务器中注册的instance-id是从客户端的服务名称（与Spring应用程序名称相同）以及客户端的主机名称派生的。因此，在同一主机上运行的相同进程将具有相同的ID，因此只能注册一个。</p>
<p>幸运的是，您可以通过客户端的Eureka元数据映射手动设置id属性，如下所示：</p>
<pre><code class="prettyprint yml">eureka:
  instance:
    metadataMap:
      instanceId: ${spring.application.name}:${spring.application.instance_id:${server.port}}
</code></pre>
<p>自<em>Brixton</em>发布以来， <em>这是默认设置</em> 。那怎么办呢？</p>
<p>我们正在设定<code>instanceId</code>至<code>application-name:instance_id</code> ，但如果<code>instance_id</code>未定义，我们将使用<code>application-name::server-port</code>代替。请注意<code>spring.application.instance_id</code> <em>仅</em>在使用Cloud Foundry时设置，但是它方便地为同一应用程序的每个实例提供唯一的ID号。当使用服务器端口在其他地方运行时，我们可以做类似的事情（因为同一台计算机上的不同实例<em>必须</em>侦听不同的端口。您经常会看到的另一个例子是<code>${spring.application.name}:${spring.application.instance_id:${random.value}}</code>但是我个人发现使用端口号可以使每个实例易于识别-随机值只是长字符串，并不代表任何意义。</p>
<p><strong>注意：</strong>语法<code>${x:${y}}</code>是Spring属性的简写<code>${x} != null ? ${x} : ${y}</code> 。</p>
<p>自从<em>Brixton</em>发布以来，还有一个专用属性：</p>
<pre><code class="prettyprint yml">eureka:
  instance:
    instanceId: ${spring.application.name}:${spring.application.instance_id:${random.value}}
</code></pre><h1><a href="#accessing-the-microservice-em-web-service-em" class="anchor" name="accessing-the-microservice-em-web-service-em"></a>访问<em>微服务</em> ： <em>Web服务</em></h1>
<p>为了使用RESTful服务，Spring提供了<code>RestTemplate</code>类。这使您可以将HTTP请求发送到RESTful服务器，并以多种格式（例如JSON和XML）获取数据。</p>

<div class="infoblock" style="width:50%">
<p style="margin:0 0 0 0">
<b>注意：</b>帐户微服务通过HTTP提供RESTful接口，但是可以使用任何合适的协议。使用<a href="https://rabbitmq.docs.pivotal.io">AMQP</a>或JMS进行消息传递是一种明显的选择（在这种情况下，不再需要发现服务器-进程需要知道要交谈的队列的名称，请考虑使用<a href="https://cloud.spring.io/spring-cloud-config/">Spring Cloud Configuration Server</a> <a>）。
</a></p><a>
</a></div><a>
<p>可以使用哪种格式取决于类路径上是否存在编组类-例如，由于JAXB是Java的标准部分，因此始终可以检测到。如果类路径中存在Jackson罐，则支持JSON。</p>
<p>微服务（发现）客户端可以使用<code>RestTemplate</code> Spring会自动将其配置为支持微服务（稍后将进行更多介绍）。</p></a><h2><a></a><a href="#encapsulating-microservice-access" class="anchor" name="encapsulating-microservice-access"></a>封装微服务访问</h2>
<p>这是<code>WebAccountService</code>对于我的<em>客户</em>应用程序：</p>
<pre><code class="prettyprint java">@Service
public class WebAccountsService {

    @Autowired        // NO LONGER auto-created by Spring Cloud (see below)
    @LoadBalanced     // Explicitly request the load-balanced template
                      // with Ribbon built-in
    protected RestTemplate restTemplate; 

    protected String serviceUrl;

    public WebAccountsService(String serviceUrl) {
        this.serviceUrl = serviceUrl.startsWith(&quot;http&quot;) ?
               serviceUrl : &quot;http://&quot; + serviceUrl;
    }

    public Account getByNumber(String accountNumber) {
        Account account = restTemplate.getForObject(serviceUrl
                + &quot;/accounts/{number}&quot;, Account.class, accountNumber);

        if (account == null)
            throw new AccountNotFoundException(accountNumber);
        else
            return account;
    }
    ...
}
</code></pre>
<p>请注意，我的<code>WebAccountService</code>仅仅是RestTemplate从微服务获取数据的包装。有趣的部分是<code>serviceUrl</code>和<code>RestTemplate</code> 。</p><h2><a href="#accessing-the-microservice" class="anchor" name="accessing-the-microservice"></a>访问微服务</h2>
<p>如下图所示<code>serviceUrl</code>由主程序提供给<code>WebAccountController</code> （依次将其传递给<code>WebAccountService</code> ）：</p>
<pre><code class="prettyprint java">@SpringBootApplication
@EnableDiscoveryClient
@ComponentScan(useDefaultFilters=false)  // Disable component scanner
public class WebServer {

    // Case insensitive: could also use: http://accounts-service
    public static final String ACCOUNTS_SERVICE_URL
                                        = &quot;http://ACCOUNTS-SERVICE&quot;;

    public static void main(String[] args) {
        // Will configure using web-server.yml
        System.setProperty(&quot;spring.config.name&quot;, &quot;web-server&quot;);
        SpringApplication.run(WebServer.class, args);
    }

    @LoadBalanced    // Make sure to create the load-balanced template
    @Bean
    RestTemplate restTemplate() {
        return new RestTemplate();
    }

    /**
     * Account service calls microservice internally using provided URL.
     */
    @Bean
    public WebAccountsService accountsService() {
        return new WebAccountsService(ACCOUNTS_SERVICE_URL);
    }

    @Bean
    public WebAccountsController accountsController() {
         return new WebAccountsController
                       (accountsService());  // plug in account-service
    }
}
</code></pre>
<p>需要注意的几点：</p>
<ol>
<li>的<code>WebController</code>是返回HTML的典型Spring MVC基于视图的控制器。该应用程序使用Thymeleaf作为视图技术（用于生成动态HTML）</li>
<li><code>WebServer</code>也是<code>@EnableDiscoveryClient</code>但是在这种情况下，除了向<em>发现服务器</em>注册本身（这是不必要的，因为它不提供自己的服务）之外，它还使用Eureka定位帐户服务。</li>
<li>从Spring Boot继承的默认组件扫描程序设置用于查找<code>@Component</code>类，在这种情况下，找到了我的<code>WebAccountController</code>并尝试创建它。但是，我想自己创建它，所以我禁用了扫描仪<code>@ComponentScan(useDefaultFilters=false)</code> 。</li>
<li>我传递给的<em>服务网址</em> <code>WebAccountController</code>是用于向<em>发现服务器</em>注册自身的服务的名称-默认情况下，该名称与<code>spring.application.name</code>对于这个过程<code>account-service</code> -看<code>account-service.yml</code>以上。不需要使用大写字母，但确实有助于强调<em>ACCOUNTS-SERVICE</em>是逻辑主机（将通过发现获得），而不是实际主机。</li>
</ol><h2><a href="#load-balanced-resttemplate" class="anchor" name="load-balanced-resttemplate"></a>负载均衡的RestTemplate</h2>
<p>的<code>RestTemplate</code> Bean将被Spring Cloud拦截并自动配置（由于<code>@LoadBalanced</code>注释）以使用自定义<code>HttpRequestClient</code>使用Netflix <a href="http://techblog.netflix.com/2013/01/announcing-ribbon-tying-netflix-mid.html">Ribbon</a>进行微服务查找。功能区还是一个负载平衡器，因此，如果您有一个服务的多个实例，它将为您选择一个。（Eureka和Consul都不自己执行负载平衡，因此我们使用Ribbon代替）。</p>
<p><strong>注意：</strong>来自<em>Brixton</em> Release Train（Spring Cloud 1.1.0。释放），RestTemplate将不再自动创建。它最初是为您创建，造成混乱和潜在的冲突（有时弹簧可以<em>太大</em>的帮助！）。</p>
<p>请注意，此实例使用<code>@LoadBalanced</code> 。（ <a href="https://github.com/spring-cloud/spring-cloud-commons/blob/master/spring-cloud-commons/src/main/java/org/springframework/cloud/client/loadbalancer/LoadBalanced.java">注释</a>本身带有<code>@Qualifier</code> -有关详情，请参见<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-autowired-annotation-qualifiers">此处</a> ）。因此，如果您有多个RestTemplate bean，则可以确保注入正确的一个，如下所示：</p>
<pre><code class="prettyprint java">    @Autowired
    @LoadBalanced     // Make sure to inject the load-balanced template
    protected RestTemplate restTemplate;
</code></pre>
<p>如果查看<a href="https://github.com/spring-cloud/spring-cloud-netflix/blob/master/spring-cloud-netflix-core/src/main/java/org/springframework/cloud/netflix/ribbon/RibbonClientHttpRequestFactory.java">RibbonClientHttpRequestFactory</a> ，将看到以下代码：</p>
<pre><code class="prettyprint java">    String serviceId = originalUri.getHost();
    ServiceInstance instance =
             loadBalancer.choose(serviceId);  // loadBalancer uses Ribbon
    ... if instance non-null (service exists) ...
    URI uri = loadBalancer.reconstructURI(instance, originalUri);
</code></pre>
<p>的<code>loadBalancer</code>接受逻辑服务名（已在<em>Discovery-server中</em>注册），并将其转换为所选微服务的实际主机名。</p>
<p>一种<code>RestTemplate</code>实例是线程安全的，可用于访问应用程序不同部分中的任意数量的服务（例如，我可能有一个<code>CustomerService</code>包装相同<code>RestTemplate</code>实例访问客户数据微服务）。</p><h2><a href="#configuration" class="anchor" name="configuration"></a>组态</h2>
<p>下面的相关配置来自<code>web-server.yml</code> 。它用于：</p>
<ol>
<li>设置应用名称</li>
<li>定义用于访问发现服务器的URL</li>
<li>将Tomcat端口设置为3333</li>
</ol>
<pre><code class="prettyprint yml"># Spring Properties
spring:
  application:
     name: web-service

# Discovery Server Access
eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:1111/eureka/

# HTTP Server
server:
  port: 3333   # HTTP (Tomcat) port
</code></pre>
<a name="running-the-system"></a><h1><a href="#how-to-run-the-demo" class="anchor" name="how-to-run-the-demo"></a>如何运行演示</h1>
<p>该系统的一个小样例位于<a href="https://github.com/paulc4/microservices-demo">http://github.com/paulc4/microservices-demo</a> 。克隆它，然后加载到您喜欢的IDE中或直接使用maven。项目主页上的<a href="https://github.com/paulc4/microservices-demo/blob/master/README.md">自述文件</a>中包含有关如何运行演示的建议。</p>
<hr style="height:6px"><h1><a href="#extra-notes" class="anchor" name="extra-notes"></a>额外注意事项</h1>
<p>有关这些应用程序使用Spring Boot的一些说明。如果您不熟悉Spring Boot，这可以解释一些“魔术”！</p><h2><a href="#view-templating-engines" class="anchor" name="view-templating-engines"></a>查看模板引擎</h2>
<p>尤里卡仪表板（内部<code>RegistrationServer</code> ）是使用FreeMarker模板实现的，而其他两个应用程序则使用Thymeleaf。为了确保每个人都使用正确的视图引擎，每个YML文件中都有额外的配置。</p>
<p>这是在结尾<code>registration-server.yml</code>禁用Thymeleaf。</p>
<pre><code class="prettyprint yml">...
# Discovery Server Dashboard uses FreeMarker.  Don&#39;t want Thymeleaf templates
spring:
  thymeleaf:
    enabled: false     # Disable Thymeleaf spring:
</code></pre>
<p>由于两者<code>AccountService</code>和<code>WebService</code>使用百里香叶，我们还需要将它们指向各自的模板。这是一部分<code>account-server.yml</code> ：</p>
<pre><code class="prettyprint yml"># Spring properties
spring:
  application:
     name: accounts-service  # Service registers under this name
  freemarker:
    enabled: false      # Ignore Eureka dashboard FreeMarker templates
  thymeleaf:
    cache: false        # Allow Thymeleaf templates to be reloaded at runtime
    prefix: classpath:/accounts-server/templates/
                        # Template location for this application only
...
</code></pre>
<p><code>web-server.yml</code>相似，但其模板由</p>
<pre><code class="prettyprint yml">   prefix: classpath:/web-server/templates/
</code></pre>
<p>注意每个末尾的/ <code>spring.thymeleaf.prefix</code> classpath-这很<em>关键</em> 。</p><h2><a href="#command-line-execution" class="anchor" name="command-line-execution"></a>命令行执行</h2>
<p>罐子被编译为自动运行<code>io.pivotal.microservices.services.Main</code>从命令行调用时-请参见<a href="https://github.com/paulc4/microservices-demo/blob/master/src/main/java/io/pivotal/microservices/services/Main.java">Main.java</a> 。</p>
<p>Spring Boot选项设置<code>start-class</code>可以在<a href="https://github.com/paulc4/microservices-demo/blob/master/pom.xml">POM中</a>看到：</p>
<pre><code class="prettyprint xml">    &lt;properties&gt;
        &lt;!-- Stand-alone RESTFul application for testing only --&gt;
        &lt;start-class&gt;io.pivotal.microservices.services.Main&lt;/start-class&gt;
    &lt;/properties&gt;
</code></pre><h2><a href="#accountsconfiguration-class" class="anchor" name="accountsconfiguration-class"></a> AccountsConfiguration类</h2>
<pre><code class="prettyprint java">@SpringBootApplication
@EntityScan(&quot;io.pivotal.microservices.accounts&quot;)
@EnableJpaRepositories(&quot;io.pivotal.microservices.accounts&quot;)
@PropertySource(&quot;classpath:db-config.properties&quot;)
public class AccountsWebApplication {
...
}
</code></pre>
<p>这是AccountService的主要配置类，AccountService是使用Spring Data的经典Spring Boot应用程序。注释完成了大部分工作：</p>
<ol>
<li><code>@SpringBootApplication</code> -将其定义为Spring Boot应用程序。这个方便的注释结合了<code>@EnableAutoConfiguration</code> ， <code>@Configuration</code>和<code>@ComponentScan</code> （默认情况下，这会导致Spring搜索包含此类的包及其子包中的组件-潜在的Spring Bean： <code>AccountController</code>和<code>AccountRepository</code> ）。</li>
<li><code>@EntityScan("io.pivotal.microservices.accounts")</code> -因为我使用的是JPA，所以我需要指定<code>@Entity</code>类。通常，这是您在JPA的<code>persistence.xml</code>或在创建<code>LocalContainerEntityManagerFactoryBean</code> 。Spring Boot将为我创建该工厂bean，因为<code>spring-boot-starter-data-jpa</code>依赖关系在类路径上。因此，另一种指定在哪里找到<code>@Entity</code>类是通过使用<code>@EntityScan</code> 。这会发现<code>Account</code> 。</li>
<li><code>@EnableJpaRepositories("io.pivotal.microservices.accounts")</code> -寻找扩展Spring Data的类<code>Repository</code>标记接口，并使用JPA自动实现它们-请参见<a href="https://projects.spring.io/spring-data-jpa">Spring Data JPA</a> 。</li>
<li><code>@PropertySource("classpath:db-config.properties")</code> -配置我的属性<code>DataSource</code> –请参见<a href="https://github.com/paulc4/microservices-demo/blob/master/src/main/resources/db-config.properties">db-config.properties</a> 。</li>
</ol><h2><a href="#configuring-properties" class="anchor" name="configuring-properties"></a>配置属性</h2>
<p>如上所述，Spring Boot应用程序会寻找<code>application.properties</code>要么<code>application.yml</code>配置自己。由于此应用程序中使用的所有三台服务器都在同一项目中，因此它们将自动使用相同的配置。</p>
<p>为避免这种情况，每个用户都可以通过设置<code>spring.config.name</code>属性。</p>
<p>例如，这是<code>WebServer.java</code> 。</p>
<pre><code class="prettyprint java">public static void main(String[] args) {
  // Tell server to look for web-server.properties or web-server.yml
  System.setProperty(&quot;spring.config.name&quot;, &quot;web-server&quot;);
  SpringApplication.run(WebServer.class, args);
}
</code></pre>
<p>在运行时，应用程序将找到并使用<code>web-server.yml</code>在<code>src/main/resources</code> 。</p><h2><a href="#logging" class="anchor" name="logging"></a>记录中</h2>
<p>Spring Boot默认为Spring设置INFO级别的日志记录。由于我们需要检查日志以获取微服务正常工作的证据，因此我将级别提高到WARN以减少日志量。</p>
<p>为此，需要在每个<code>xxxx-server.yml</code>配置文件。通常，这是定义它们的最佳位置，因为<em>无法</em>在属性文件中指定日志记录属性（在处理@PropertySource指令之前，日志记录已被初始化）。Spring Boot手册中对此有注释，但是很容易错过。</p>
<p>我没有选择在每个YAML文件中复制日志记录配置，而是选择将其放在logback配置文件中，因为Spring Boot使用<a href="https://github.com/paulc4/microservices-demo/blob/master/src/main/resources/logback.xml">logback-</a>参见<a href="https://github.com/paulc4/microservices-demo/blob/master/src/main/resources/logback.xml">src / main / resources / logback.xml</a> 。所有三个服务将共享相同的<code>logback.xml</code> 。</p>
</div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 2181;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>