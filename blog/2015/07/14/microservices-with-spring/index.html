<html dir="ltr" data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>Spring微服务</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>System.config({baseURL: "/b92013b"});</script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>System.import('app/main.js')</script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Microservices with Spring">
<meta name="twitter:description" class="anchor" content="<h1><a href=" #introductio="="></head><body dir="ltr">Introduction
<p><strong>NOTE:</strong> <em><a href="#recent-updates">Revised July 2019</a></em></p>
<p>A simple example of setting up a microservices system using Spring, Spring Boot and Spring Cloud.</p>
<p><a href="http://martinfowler.com/articles/microservices.html">Microservices</a> allow large systems to be built up from a number of collaborating components. It does at the process level what Spring has always done at the component level: loosely coupled processes instead of loosely coupled components.</p>
<a href="https://raw.githubusercontent.com/paulc4/microservices-demo/master/shopping-system.jpg"><img src="https://raw.githubusercontent.com/paulc4/microservices-demo/master/shopping-system.jpg" title="点击放大" alt="购物申请" style="width:400px;float:right;margin:0px 5px 5px 10px"></a>
<p>For example imagine an online shop with separate microservices for user-accounts, product-catalog order-processing and shopping carts:</p>
">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/0b0bedf6c0dab07b13a322eed9350873?s=200">

<meta property="og:title" content="Microservices with Spring">
<meta property="og:image" content="https://gravatar.com/avatar/0b0bedf6c0dab07b13a322eed9350873?s=200">
<meta class="anchor" name="introduction" property="og:description" content="<h1><a href=" #introductio="=">Introduction
<p><strong>NOTE:</strong> <em><a href="#recent-updates">Revised July 2019</a></em></p>
<p>A simple example of setting up a microservices system using Spring, Spring Boot and Spring Cloud.</p>
<p><a href="http://martinfowler.com/articles/microservices.html">Microservices</a> allow large systems to be built up from a number of collaborating components. It does at the process level what Spring has always done at the component level: loosely coupled processes instead of loosely coupled components.</p>
<a href="https://raw.githubusercontent.com/paulc4/microservices-demo/master/shopping-system.jpg"><img src="https://raw.githubusercontent.com/paulc4/microservices-demo/master/shopping-system.jpg" title="点击放大" alt="购物申请" style="width:400px;float:right;margin:0px 5px 5px 10px"></a>
<p>For example imagine an online shop with separate microservices for user-accounts, product-catalog order-processing and shopping carts:</p>
">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2015-07-14 06:28:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">// Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }</script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Spring微服务</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/0b0bedf6c0dab07b13a322eed9350873?s=20&d=mm"> <span class="author">保罗·查普曼</span>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2015-07-14 06:28:00.0">2015年7月14日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2015/07/14/microservices-with-spring#disqus_thread" data-disqus-identifier="2181">
</a></div>
</div>
</header>
<div class="blog--post"><h1><a href="#introduction" class="anchor" name="introduction"></a>介绍</h1>
<p><strong>注意：</strong> <em><a href="#recent-updates">2019年7月修订</a></em></p>
<p>一个使用Spring，Spring Boot和Spring Cloud设置微服务系统的简单示例。</p>
<p><a href="http://martinfowler.com/articles/microservices.html">微服务</a>允许使用许多协作组件来构建大型系统。它在流程级别上执行Spring一直在组件级别上所做的工作：松散耦合的流程而不是松散耦合的组件。</p>
<a href="https://raw.githubusercontent.com/paulc4/microservices-demo/master/shopping-system.jpg"><img src="https://raw.githubusercontent.com/paulc4/microservices-demo/master/shopping-system.jpg" title="点击放大" alt="购物申请" style="width:400px;float:right;margin:0px 5px 5px 10px"></a>
<p>例如，假设一个网上商店为用户帐户，产品目录订单处理和购物车提供了单独的微服务：</p>
<p>不可避免地，必须设置和配置许多移动部件才能构建这样的系统。如何使它们协同工作还不是很明显-您需要熟悉Spring Boot，因为Spring Cloud充分利用了它，因此需要几个Netflix或其他OSS项目，当然，还有一些Spring配置“不可思议”！</p>
<a href="https://raw.githubusercontent.com/paulc4/microservices-demo/master/mini-system.jpg"><img src="https://raw.githubusercontent.com/paulc4/microservices-demo/master/mini-system.jpg" title="点击放大" alt="演示申请" style="width:400px;float:left;margin:5px 10px 5px 0"></a>
<p>在本文中，我旨在通过逐步构建最简单的系统来阐明事物的工作方式。因此，我将只实现大型系统的一小部分-用户帐户服务。</p>
<p><em>Web应用程序</em>将使用RESTful API向<em>Account-Service</em>微<em>服务</em>发出请求。我们还需要添加<em>发现</em>服务-这样其他进程就可以彼此找到对方。</p>
<p>此应用程序的代码是在这里： <a href="https://github.com/paulc4/microservices-demo">https://github.com/paulc4/microservices-demo</a> 。</p>
<p>特意详细介绍了其工作原理。不耐烦的读者可能更喜欢只看一下<a href="https://github.com/paulc4/microservices-demo">代码</a> 。请注意，它在一个项目中包含<em>三个</em>微服务。</p><h2><a href="#learn-more" class="anchor" name="learn-more"></a>学到更多</h2>
<ul>
<li>报名参加<a href="https://springoneplatform.io/">SpringOne Platform 2019</a> –这是使用Spring构建可伸缩微服务应用程序的顶级会议。今年10月7日至10日，我们将在德克萨斯州奥斯汀市。使用折扣代码<strong>S1P_Save200</strong>可以节省机票费用。需要说服您的经理的帮助吗？使用<a href="https://springoneplatform.io/2019/convince-your-manager">此页面</a> 。</li>
<li>获得Matt Stine的免费电子书“ <a href="https://content.pivotal.io/ebooks/migrating-to-cloud-native-application-architectures">迁移到云原生架构”</a></li>
<li>该<a href="https://content.pivotal.io/webinars/mar-21-tools-and-recipes-to-replatform-monolithic-apps-to-modern-cloud-environments-webinar">网络研讨会</a>讨论工具和配方，以帮助您将整体式应用程序重新平台化为现代云环境。</li>
</ul>
<a name="recent-updates"></a><h2><a href="#updates-june-2018" class="anchor" name="updates-june-2018"></a>更新（2018年6月）</h2>
<p>自从我最初撰写此博客以来，进行了许多更改：</p>
<ol>
<li>有关在同一主机上使用同一服务的多个实例的<a href="#configuration-options">讨论</a> 。演示应用程序已更新为匹配。</li>
<li>一个<a href="#load-balanced-resttemplate">讨论</a>的<code>@LoadBalanced</code>这个作品<em>是</em>如何从<em>布里克斯顿</em>发布列车（ <em>改变</em> - <a href="https://projects.spring.io/spring-cloud">春季云</a> 1.1.0。发布）。</li>
<li><a href="#accountsconfiguration-class">将</a> Accounts微服务重构<a href="#accountsconfiguration-class">配置</a>到其自己的<code>AccountsConfiguration</code>类中。</li>
<li>升级到Spring Boot 2，因此一些Boot类更改了程序包。</li>
<li>将<a href="#running-the-system">演示应用程序</a>升级到Spring Cloud <em>Finchley</em>发行培训（包括最后注释中的各种修复-感谢您的反馈）。</li>
<li>Eureka服务器依赖项已更改为<code>spring-cloud-starter-netflix-eureka-server</code> 。</li>
</ol>
<p>使用Spring Boot 1.5.10和Spring Cloud Edgeware SR3的先前版本可作为git tag v1.2.0获得。</p>
<p> </p>
<p><em>好，让我们开始吧……</em></p><h1><a href="#service-registration" class="anchor" name="service-registration"></a>服务注册</h1>
<p>当您有多个流程一起工作时，它们需要彼此查找。如果您曾经使用过Java的RMI机制，您可能会记得它依赖于中央注册表，因此RMI进程可以相互找到。微服务具有相同的要求。</p>
<p>Netflix的开发人员在构建系统并创建名为Eureka的注册服务器（希腊文中的“我找到了它”）时遇到了这个问题。对我们来说幸运的是，他们使发现服务器开源，并且Spring已集成到Spring Cloud中，从而使运行Eureka服务器变得更加容易。这是<em>完整的</em>发现服务器应用程序：</p>
<pre><code class="prettyprint java">@SpringBootApplication
@EnableEurekaServer
public class ServiceRegistrationServer {

  public static void main(String[] args) {
    // Tell Boot to look for registration-server.yml
    System.setProperty("spring.config.name", "registration-server");
    SpringApplication.run(ServiceRegistrationServer.class, args);
  }
}
</code></pre>
<p>真的就是这么简单！</p>
<p>Spring Cloud基于Spring Boot构建，并利用父级和入门级POM。 <a href="https://github.com/paulc4/microservices-demo/blob/master/pom.xml">POM</a>的重要部分是：</p>
<pre><code class="prettyprint xml">    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.0.1.RELEASE</version>
    </parent>

    <dependencies>
        <dependency>
            <!-- Setup Spring Boot -->
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>

        <dependency>
            <!-- Setup Spring MVC & REST, use Embedded Tomcat -->
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <!-- Spring Cloud starter -->
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter</artifactId>
        </dependency>

        <dependency>
            <!-- Eureka for service registration -->
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-eureka-server</artifactId>
        </dependency>
    </dependencies>

   <!-- Spring Cloud dependencies -->
    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>Finchley.RELEASE</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
</code></pre>
<p>自从我最初写文章将Spring Boot用作父项而不是Spring Cloud以来，此POM发生了变化。通过依赖关系管理部分提供了Spring Cloud依赖关系。</p>
<p>github代码中还包含一个示例gradle构建文件。</p>

<style>.infoblock {
border: 1px solid #AAF;
    background-color: white;
    color: #303030;
    margin: 0 0 0 0.5em;
    padding: 0.5em 0 0.5em 1em;
    float: right;
    font-size: 88%;
    width: 45%
}</style>
<div class="infoblock">
<p style="margin:0 0 0 0">
<b>注意：</b> <i>芬奇利。RELEASE</i>是当前的“发行版”-一组协调的发行版-请参阅Spring Cloud <a href="https://projects.spring.io/spring-cloud/#release-trains">主页上的</a>注释。
</p>
</div>
<p>默认情况下，Spring Boot应用程序会寻找<code>application.properties</code>或<code>application.yml</code>文件进行配置。通过设置<code>spring.config.name</code>属性，我们可以告诉Spring Boot查找不同的文件（如果您在同一项目中有多个Spring Boot应用程序，则很有用），就像我稍后会做的那样。</p>
<p>该应用程序查找<code>registration-server.properties</code>或<code>registration-server.yml</code> 。这是<code>registration-server.yml</code>的相关配置：</p>
<pre><code class="prettyprint yml"># Configure this Discovery Server
eureka:
  instance:
    hostname: localhost
  client:  # Not a client, don't register with yourself (unless running
           # multiple discovery servers for redundancy)
    registerWithEureka: false
    fetchRegistry: false

server:
  port: 1111   # HTTP (Tomcat) port
</code></pre>
<p>默认情况下，Eureka在端口8761上运行，但是这里我们将使用端口<code>1111</code> 。另外，通过在我的过程中包括注册码，我可能是服务器或客户端。该配置指定我不是客户端，并停止尝试向其注册的服务器进程。</p>

<div class="infoblock">
<h2>使用领事</h2>
<p style="margin-bottom:10px">Spring Cloud还支持<a href="https://www.consul.io">领事</a>作为替代尤里卡。您使用脚本启动Consul Agent（其注册服务器），然后客户端使用它来查找其微服务。有关详细信息，请参见此博客<a href="https://spring.io/blog/2015/05/27/spring-cloud-consul-1-0-0-m1-available-now">文章</a>或项目<a href="https://cloud.spring.io/spring-cloud-consul">主页</a> 。
</p>
</div>
<p>立即尝试运行<em>RegistrationServer</em> （有关运行该应用程序的帮助，请参见<a href="#running-the-system">下文</a> ）。您可以在此处打开Eureka仪表板： <a href="http://localhost:1111">http：// localhost：1111</a> ，显示“应用程序”的部分将为空。</p>
<p>从现在开始，我们将参考<em>发现服务器，</em>因为它可能是Eureka或Consul（请参阅侧面板）。</p><h1><a href="#creating-a-microservice-em-account-service-em" class="anchor" name="creating-a-microservice-em-account-service-em"></a>创建<em>微服务</em> ： <em>帐户服务</em></h1>
<p>微服务是处理明确定义的需求的独立流程。</p>
<a href="https://raw.githubusercontent.com/paulc4/microservices-demo/master/beans-vs-processes.jpg"><img src="https://raw.githubusercontent.com/paulc4/microservices-demo/master/beans-vs-processes.jpg" title="点击放大" alt="豆与流程" style="width:400px;float:right;margin:10px 0 5px 15px"></a>
<p>在使用Spring配置应用程序时，我们强调松散耦合和紧密内聚，这些并不是新概念（Larry Constantine最早在1960年代后期定义了这些<a href="https://en.wikipedia.org/wiki/Cohesion_%28computer_science%29">参考</a> - <a href="https://en.wikipedia.org/wiki/Cohesion_%28computer_science%29">值得称赞</a> ），但是现在我们将它们应用，而不是用于交互组件（Spring Beans），而是互动过程。</p>
<p>在此示例中，我有一个简单的帐户管理微服务，该服务使用Spring Data实现JPA <code>AccountRepository</code>并使用Spring REST为帐户信息提供RESTful接口。在大多数方面，这是一个简单的Spring Boot应用程序。</p>
<p>使其与众不同的是，它在启动时<em>便向发现服务器</em>注册。这是Spring Boot启动类：</p>
<pre><code class="prettyprint java">@EnableAutoConfiguration
@EnableDiscoveryClient
@Import(AccountsWebApplication.class)
public class AccountsServer {

    @Autowired
    AccountRepository accountRepository;

    public static void main(String[] args) {
        // Will configure using accounts-server.yml
        System.setProperty("spring.config.name", "accounts-server");

        SpringApplication.run(AccountsServer.class, args);
    }
}
</code></pre>
<p>注释可以完成工作：</p>
<ol>
<li><code>@EnableAutoConfiguration</code>将其定义为Spring Boot应用程序。</li>
<li><code>@EnableDiscoveryClient</code>这将启用服务注册和发现。在这种情况下，此过程使用其应用程序名称（见下文）向<em>发现服务器</em>服务注册自己。</li>
<li><code>@Import(AccountsWebApplication.class)</code> -此Java配置类设置了其他所有内容（有关更多详细信息，请参见<a href="#accountswebapplication-configuration">下文</a> ）。</li>
</ol>
<p>使之成为微服务的原因是通过<code>@EnableDiscoveryClient</code>向<em>发现服务器</em> <code>@EnableDiscoveryClient</code> ，其YML配置完成了设置：</p>
<pre><code class="prettyprint yml"># Spring properties
spring:
  application:
     name: accounts-service

# Discovery Server Access
eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:1111/eureka/

# HTTP Server
server:
  port: 2222   # HTTP (Tomcat) port
</code></pre>
<p>注意这个文件</p>
<ol>
<li>将应用程序名称设置为<code>accounts-service</code> 。此服务以该名称注册，也可以通过该名称访问-参见下文。</li>
<li>指定要监听的自定义端口（2222）。我所有的进程都使用Tomcat，但它们不能全部监听端口8080。</li>
<li>上一部分中的Eureka服务流程的URL。</li>
</ol>
<a href="https://raw.githubusercontent.com/paulc4/microservices-demo/master/dashboard.png"><img src="https://raw.githubusercontent.com/paulc4/microservices-demo/master/dashboard.png" title="点击放大" alt="尤里卡仪表板" style="width:450px;float:right;margin:0px 5px 5px 10px"></a>
<p>立即运行<em>AccountsService</em>应用程序，并使其完成初始化。刷新仪表板<a href="http://localhost:1111">http：// localhost：1111</a> ，您应该看到“应用程序”下列出的ACCOUNTS-SERVICE。注册最多需要30秒（默认情况下），请耐心等待-检查<em>RegistrationService</em>的日志输出</p>

<div class="infoblock">
<p style="margin:0 0 0 0">
<b>警告：</b>请勿尝试使用Eclipse / STS的内部Web查看器显示XML输出，因为它不能这样做。请改用您喜欢的网络浏览器。
</p>
</div>
<p>有关更多详细信息，请转到此处： <a href="http://localhost:1111/eureka/apps/">http：// localhost：1111 / eureka / apps /</a> ，您应该看到类似以下内容：</p>
<pre><code class="prettyprint xml"><applications>
    <versions__delta>1</versions__delta>
    <apps__hashcode>UP_1_</apps__hashcode>
    <application>
        <name>ACCOUNTS-SERVICE</name>
        <instance>
            <hostName>autgchapmp1m1.corp.emc.com</hostName>
            <app>ACCOUNTS-SERVICE</app>
            <ipAddr>172.16.84.1</ipAddr><status>UP</status>
            <overriddenstatus>UNKNOWN</overriddenstatus>
            <port enabled="true">3344</port>
            <securePort enabled="false">443</securePort>
            ...
        </instance>
    </application>
</applications>

</code></pre>
<p>另外，也可以转到<a href="http://localhost:1111/eureka/apps/ACCOUNTS-SERVICE">http：// localhost：1111 / eureka / apps / ACCOUNTS-SERVICE</a>并仅查看<em>AccountsService</em>的详细信息-如果未注册，则将获得404。</p><h2><a href="#configuration-options" class="anchor" name="configuration-options"></a>配置选项</h2>
<p><strong>注册时间：</strong>注册最多需要30秒，因为这是默认的客户端刷新时间。您可以通过将<code>eureka.instance.leaseRenewalIntervalInSeconds</code>属性设置为较小的值（在演示应用程序中将其设置为5）来更改此设置。在<a href="https://cloud.spring.io/spring-cloud-static/docs/1.0.x/spring-cloud.html#_why_is_it_so_slow_to_register_a_service">生产中</a> <em>不建议</em>这样<em>做</em> 。见<a href="https://github.com/spring-cloud/spring-cloud-netflix/issues/373">也</a> 。</p>
<pre><code class="prettyprint yml">eureka:
  instance:
    leaseRenewalIntervalInSeconds: 5         # DO NOT DO THIS IN PRODUCTION
</code></pre>
<p><strong>注册ID：</strong>进程（微服务）使用唯一ID向发现服务注册。如果另一个进程使用<em>相同的</em> ID注册，则将其视为重新启动（例如某种故障转移或恢复），并且第一个进程注册将被丢弃。这为我们提供了我们所需要的容错系统。</p>
<p>要运行<em>同一</em>进程的多个实例（以实现负载平衡和弹性），它们需要使用唯一的ID注册。当我第一次写此博客时，这是自动的，并且自<em>Brixton</em>发布以来，它再次成为<em>现实</em> 。</p>
<p>在<em>Angel</em>发布系列中，客户端用来在发现服务器中注册的instance-id是从客户端的服务名称（与Spring应用程序名称相同）以及客户端的主机名派生的。因此，在同一主机上运行的相同进程将具有相同的ID，因此只能注册一个。</p>
<p>幸运的是，您可以通过客户端的Eureka元数据映射手动设置id属性，如下所示：</p>
<pre><code class="prettyprint yml">eureka:
  instance:
    metadataMap:
      instanceId: ${spring.application.name}:${spring.application.instance_id:${server.port}}
</code></pre>
<p>自<em>Brixton</em>发布以来， <em>这是默认设置</em> 。那怎么办呢？</p>
<p>我们将<code>instanceId</code>设置为<code>application-name:instance_id</code> ，但是如果未定义<code>instance_id</code> ，我们将改用<code>application-name::server-port</code> 。请注意， <em>仅</em>在使用Cloud Foundry时设置<code>spring.application.instance_id</code>但它方便地为同一应用程序的每个实例提供唯一的ID号。当使用服务器端口在其他地方运行时，我们可以做类似的事情（因为同一台计算机上的不同实例<em>必须</em>侦听不同的端口。您经常会看到的另一个示例是<code>${spring.application.name}:${spring.application.instance_id:${random.value}}</code>但我个人发现使用端口号可以使每个实例易于识别-随机值是只是长串，什么都没有。</p>
<p><strong>注意：</strong>语法<code>${x:${y}}</code>是<code>${x} != null ? ${x} : ${y}</code></p><code>${x} != null ? ${x} : ${y}</code></div><code>${x} != null ? ${x} : ${y}</code></div><code>${x} != null ? ${x} : ${y}</code></article><code>${x} != null ? ${x} : ${y}</code></div><code>${x} != null ? ${x} : ${y}</code></div><code>${x} != null ? ${x} : ${y}</code></div><code>${x} != null ? ${x} : ${y}</code></div><code>${x} != null ? ${x} : ${y}</code></body></html>