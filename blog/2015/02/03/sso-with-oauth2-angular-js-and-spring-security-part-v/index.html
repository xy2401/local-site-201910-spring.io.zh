<html dir="ltr" data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>带有OAuth2的SSO：Angular JS和Spring Security Part V</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>System.config({baseURL: "/b92013b"});</script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>System.import('app/main.js')</script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="SSO with OAuth2: Angular JS and Spring Security Part V">
<meta name="twitter:description" content="<blockquote>
 <p>Note: the source code and test for this blog continue to evolve, but the changes to the text are not being maintained here. Please see <a href=" https:="" ="" spring.io guides="" tutorials="" spring-security-and-angular-js="" ="="></meta>the tutorial version for the most up to date content. 

<p>In this article we continue <a href=" http: blog 2015 01 28 the-api-gateway-pattern-angular-js-and-spring-security-part-iv" title="系列文章中的第四篇"></head><body dir="ltr">our discussion of how to use <a href="http://projects.spring.io/spring-security">Spring Security</a> with <a href="http://angularjs.org">Angular JS</a> in a “single page application”. Here we show how to use <a href="http://projects.spring.io/spring-security-oauth/">Spring Security OAuth</a> together with <a href="http://projects.spring.io/spring-cloud/">Spring Cloud</a> to extend our API Gateway to do Single Sign On and OAuth2 token authentication to backend resources. This is the fifth in a series of articles, and you can catch up on the basic building blocks of the application or build it from scratch by reading the <a href="http://spring.io/blog/2015/01/12/spring-and-angular-js-a-secure-single-page-application" title="系列文章的第一篇">first article</a>, or you can just go straight to the <a href="https://github.com/dsyer/spring-security-angular/tree/master/oauth2">source code in Github</a>. In the <a href="http://spring.io/blog/2015/01/28/the-api-gateway-pattern-angular-js-and-spring-security-part-iv" title="系列文章中的第四篇">last article</a> we built a small distributed application that used <a href="https://github.com/spring-projects/spring-session/">Spring Session</a> to authenticate the backend resources and <a href="http://projects.spring.io/spring-cloud/">Spring Cloud</a> to implement an embedded API Gateway in the UI server. In this article we extract the authentication responsibilities to a separate server to make our UI server the first of potentially many Single Sign On applications to the authorization server. This is a common pattern in many applications these days, both in the enterprise and in social startups. We will use an OAuth2 server as the authenticator, so that we can also use it to grant tokens for the backend resource server. Spring Cloud will automatically relay the access token to our backend, and enable us to further simplify the implementation of both the UI and resource servers.<p></p>
">
<meta name="twitter:creator" content="@david_syer">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=200">

<meta property="og:title" content="SSO with OAuth2: Angular JS and Spring Security Part V">
<meta property="og:image" content="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=200">
<meta property="og:description" content="<blockquote>
 <p>Note: the source code and test for this blog continue to evolve, but the changes to the text are not being maintained here. Please see <a href=" https:="" ="" spring.io guides="" tutorials="" spring-security-and-angular-js="" ="="></meta>the tutorial version for the most up to date content. 

<p>In this article we continue <a href=" http: blog 2015 01 28 the-api-gateway-pattern-angular-js-and-spring-security-part-iv" title="系列文章中的第四篇">our discussion of how to use <a href="http://projects.spring.io/spring-security">Spring Security</a> with <a href="http://angularjs.org">Angular JS</a> in a “single page application”. Here we show how to use <a href="http://projects.spring.io/spring-security-oauth/">Spring Security OAuth</a> together with <a href="http://projects.spring.io/spring-cloud/">Spring Cloud</a> to extend our API Gateway to do Single Sign On and OAuth2 token authentication to backend resources. This is the fifth in a series of articles, and you can catch up on the basic building blocks of the application or build it from scratch by reading the <a href="http://spring.io/blog/2015/01/12/spring-and-angular-js-a-secure-single-page-application" title="系列文章的第一篇">first article</a>, or you can just go straight to the <a href="https://github.com/dsyer/spring-security-angular/tree/master/oauth2">source code in Github</a>. In the <a href="http://spring.io/blog/2015/01/28/the-api-gateway-pattern-angular-js-and-spring-security-part-iv" title="系列文章中的第四篇">last article</a> we built a small distributed application that used <a href="https://github.com/spring-projects/spring-session/">Spring Session</a> to authenticate the backend resources and <a href="http://projects.spring.io/spring-cloud/">Spring Cloud</a> to implement an embedded API Gateway in the UI server. In this article we extract the authentication responsibilities to a separate server to make our UI server the first of potentially many Single Sign On applications to the authorization server. This is a common pattern in many applications these days, both in the enterprise and in social startups. We will use an OAuth2 server as the authenticator, so that we can also use it to grant tokens for the backend resource server. Spring Cloud will automatically relay the access token to our backend, and enable us to further simplify the implementation of both the UI and resource servers.<p></p>
">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2015-02-03 14:30:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">// Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }</script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">带有OAuth2的SSO：Angular JS和Spring Security Part V</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=20&d=mm"> <a class="author" rel="author" href="/team/dsyer">戴夫·瑟</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2015-02-03 14:30:00.0">2015年2月3日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2015/02/03/sso-with-oauth2-angular-js-and-spring-security-part-v#disqus_thread" data-disqus-identifier="1907">
</a></div>
</div>
</header>
<div class="blog--post"><blockquote><p>注意：此博客的源代码和测试在不断发展，但此处未保留对文本的更改。请参阅<a href="https://spring.io/guides/tutorials/spring-security-and-angular-js/">本教程的版本</a>为最最新的内容。</p>
</blockquote><p>在本文中，我们继续<a href="https://spring.io/blog/2015/01/28/the-api-gateway-pattern-angular-js-and-spring-security-part-iv" title="系列文章中的第四篇">讨论</a>如何在“单页应用程序”中将<a href="https://projects.spring.io/spring-security">Spring Security</a>与<a href="http://angularjs.org">Angular JS</a>一起使用。在这里，我们展示了如何结合使用<a href="https://projects.spring.io/spring-security-oauth/">Spring Security OAuth</a>和<a href="https://projects.spring.io/spring-cloud/">Spring Cloud</a>来扩展我们的API网关以执行单一登录和OAuth2令牌身份验证以后端资源。这是系列文章中的第五篇，您可以了解应用程序的基本构建块，或者通过阅读<a href="https://spring.io/blog/2015/01/12/spring-and-angular-js-a-secure-single-page-application" title="系列文章的第一篇">第一篇文章</a>从头开始构建它，或者直接进入<a href="https://github.com/dsyer/spring-security-angular/tree/master/oauth2">Github中</a>的<a href="https://github.com/dsyer/spring-security-angular/tree/master/oauth2">源代码</a> 。在<a href="https://spring.io/blog/2015/01/28/the-api-gateway-pattern-angular-js-and-spring-security-part-iv" title="系列文章中的第四篇">上一篇文章中，</a>我们构建了一个小型分布式应用程序，该应用程序使用<a href="https://github.com/spring-projects/spring-session/">Spring Session</a>认证后端资源，并使用<a href="https://projects.spring.io/spring-cloud/">Spring Cloud</a>在UI服务器中实现嵌入式API网关。在本文中，我们将身份验证职责提取到单独的服务器，以使我们的UI服务器成为授权服务器中潜在的许多Single Sign On应用程序中的第一个。在企业和社交创业公司中，这是当今许多应用程序中的常见模式。我们将使用OAuth2服务器作为身份验证器，以便我们也可以使用它为后端资源服务器授予令牌。Spring Cloud将自动将访问令牌中继到我们的后端，并使我们能够进一步简化UI和资源服务器的实现。</p>
<blockquote><p>提醒：如果您正在使用示例应用程序浏览本文，请确保清除浏览器的cookie和HTTP Basic凭据缓存。在Chrome中，对单个服务器执行此操作的最佳方法是打开一个新的隐身窗口。</p>
</blockquote><h2><a href="#creating-an-oauth2-authorization-server" class="anchor" name="creating-an-oauth2-authorization-server"></a>创建OAuth2授权服务器</h2><p>我们的第一步是创建一个新服务器来处理身份验证和令牌管理。按照<a href="https://spring.io/blog/2015/01/12/spring-and-angular-js-a-secure-single-page-application" title="系列文章的第一篇">第一部分中</a>的步骤，我们可以从<a href="https://start.spring.io">Spring Boot Initializr</a>开始。例如在类似UN * X的系统上使用curl：</p>
<pre><code class="prettyprint">$ curl https://start.spring.io/starter.tgz -d style=web \
-d style=security -d name=authserver | tar -xzvf - 
</code></pre><p>然后，您可以将该项目（默认情况下是普通的Maven Java项目）导入您喜欢的IDE中，或者仅在命令行上使用文件和“ mvn”。</p><h3><a href="#adding-the-oauth2-dependencies" class="anchor" name="adding-the-oauth2-dependencies"></a>添加OAuth2依赖项</h3><p>我们需要添加<a href="https://projects.spring.io/spring-security-oauth">Spring OAuth</a>依赖项，因此在我们的<a href="https://github.com/dsyer/spring-security-angular/blob/master/oauth2/authserver/pom.xml">POM中</a>添加：</p>
<pre><code class="prettyprint xml"><dependency>
  <groupId>org.springframework.security.oauth</groupId>
  <artifactId>spring-security-oauth2</artifactId>
  <version>2.0.5.RELEASE</version>
</dependency>
</code></pre><p>授权服务器非常容易实现。最低版本如下所示：</p>
<pre><code class="prettyprint java">@SpringBootApplication
public class AuthserverApplication extends WebMvcConfigurerAdapter {

  public static void main(String[] args) {
    SpringApplication.run(AuthserverApplication.class, args);
  }
  
  @Configuration
  @EnableAuthorizationServer
  protected static class OAuth2Config extends AuthorizationServerConfigurerAdapter {

    @Autowired
    private AuthenticationManager authenticationManager;
    
    @Override
    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
      endpoints.authenticationManager(authenticationManager);
    }

@Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
      clients.inMemory()
          .withClient("acme")
          .secret("acmesecret")
          .authorizedGrantTypes("authorization_code", "refresh_token",
              "password").scopes("openid");
    }

}
</code></pre><p>我们只需要做两件事（添加<code>@EnableAuthorizationServer</code> ）：</p>
<ul>
<li><p>用秘密和一些授权的授权类型（包括“ authorization_code”）注册客户端“ acme”。</p></li>
<li><p>从Spring Boot自动配置中注入默认的<code>AuthenticationManager</code>并将其连接到OAuth2端点。</p></li>
</ul><p>现在，让它在端口9999上运行，并使用可预测的密码进行测试：</p>
<pre><code class="prettyprint properties">server.port=9999
security.user.password=password
server.contextPath=/uaa
</code></pre><p>我们还设置了上下文路径，以使其不使用默认值（“ /”），因为否则，您可以将本地主机上其他服务器的cookie发送到错误的服务器。因此，使服务器运行，我们可以确保其正常工作：</p>
<pre><code class="prettyprint">$ mvn spring-boot:run
</code></pre><p>或在您的IDE中启动<code>main()</code>方法。</p><h3><a href="#testing-the-authorization-server" class="anchor" name="testing-the-authorization-server"></a>测试授权服务器</h3><p>我们的服务器使用的是Spring Boot的默认安全设置，因此像<a href="https://spring.io/blog/2015/01/12/spring-and-angular-js-a-secure-single-page-application" title="系列文章的第一篇">第I部分中</a>的服务器一样，它将受到HTTP Basic身份验证的保护。要启动<a href="https://tools.ietf.org/html/rfc6749#section-1.3.1">授权代码令牌授予，</a>您可以访问授权端点，例如，访问<a href="http://localhost:9999/uaa/oauth/authorize?response_type=code&client_id=acme&redirect_uri=http://example.com">http：// localhost：9999 / uaa / oauth / authorize？response_type = code＆client_id = acme＆redirect_uri = http：//example.com</a>即可，重定向到附带授权码的example.com，例如<a href="http://example.com/?code=jYWioI">http://example.com/?code=jYWioI</a> 。</p>
<blockquote><p>注意：出于本示例应用程序的目的，我们创建了没有注册重定向的客户端“ acme”，这使我们能够获得example.com的重定向。在生产应用程序中，您应始终注册重定向（并使用HTTPS）。</p>
</blockquote><p>可以使用令牌端点上的“ acme”客户端凭据将代码交换为访问令牌：</p>
<pre><code class="prettyprint">$ curl acme:<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="2b4a48464e584e48594e5f6b4744484a474344585f">[email protected]</a>:9999/uaa/oauth/token  \
-d grant_type=authorization_code -d client_id=acme     \
-d redirect_uri=http://example.com -d code=jYWioI
{"access_token":"2219199c-966e-4466-8b7e-12bb9038c9bb","token_type":"bearer","refresh_token":"d193caf4-5643-4988-9a4a-1c03c9d657aa","expires_in":43199,"scope":"openid"}
</code></pre><p>访问令牌是一个UUID（“ 2219199c…”），由服务器中的内存中令牌存储支持。我们还获得了刷新令牌，当当前令牌过期时，我们可以使用它来获取新的访问令牌。</p>
<blockquote><p>注意：由于我们允许“ acme”客户端获得“密码”授权，因此我们还可以使用curl和用户凭据（而不是授权码）直接从令牌端点获取令牌。这不适用于基于浏览器的客户端，但对测试很有用。</p>
</blockquote><p>如果您点击上面的链接，您将会看到Spring OAuth提供的whitelabel UI。首先，我们将使用它，稍后我们可以像在<a href="https://spring.io/blog/2015/01/12/the-login-page-angular-js-and-spring-security-part-ii" title="系列第二篇">第二部分</a>中对自包含服务器所做的那样来完善它。</p><p><span id="changing-the-resource-server"></span></p><h2><a href="#changing-the-resource-server" class="anchor" name="changing-the-resource-server"></a>更改资源服务器</h2><p>如果我们继续<a href="https://spring.io/blog/2015/01/28/the-api-gateway-pattern-angular-js-and-spring-security-part-iv" title="系列文章中的第四篇">第IV部分</a> ，我们的资源服务器将使用<a href="https://github.com/spring-projects/spring-session/">Spring Session</a>进行身份验证，因此我们可以将其删除并用Spring OAuth代替。我们还需要删除Spring Session和Redis依赖项，因此请替换为：</p>
<pre><code class="prettyprint xml"><dependency>
  <groupId>org.springframework.session</groupId>
  <artifactId>spring-session</artifactId>
  <version>1.0.0.RC1</version>
</dependency>
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-redis</artifactId>
</dependency>
</code></pre><p>有了这个：</p>
<pre><code class="prettyprint xml"><dependency>
  <groupId>org.springframework.security.oauth</groupId>
  <artifactId>spring-security-oauth2</artifactId>
</dependency>
</code></pre><p>然后从<a href="https://github.com/dsyer/spring-security-angular/blob/master/vanilla-oauth2/resource/src/main/groovy/demo/ResourceApplication.groovy">主应用程序类中</a>删除会话<code>Filter</code> ，将其替换为方便的<code>@EnableOAuth2Resource</code>annotation（来自Spring Cloud Security）：</p>
<pre><code class="prettyprint java">@SpringBootApplication
@RestController
@EnableOAuth2Resource
class ResourceApplication {

  @RequestMapping('/')
  def home() {
    [id: UUID.randomUUID().toString(), content: 'Hello World']
  }

  static void main(String[] args) {
    SpringApplication.run ResourceApplication, args
  }
}

</code></pre><p>足够让我们获得受保护的资源。运行该应用程序，并使用命令行客户端访问主页：</p>
<pre><code class="prettyprint">$ curl -v localhost:9000
> GET / HTTP/1.1
> User-Agent: curl/7.35.0
> Host: localhost:9000
> Accept: */*
> 
< HTTP/1.1 401 Unauthorized
...
< WWW-Authenticate: Bearer realm="null", error="unauthorized", error_description="An Authentication object was not found in the SecurityContext"
< Content-Type: application/json;charset=UTF-8
{"error":"unauthorized","error_description":"An Authentication object was not found in the SecurityContext"}
</code></pre><p>并且您将看到带有“ WWW-Authenticate”标头的401，指示它想要一个承载令牌。我们将添加少量的外部配置（在“ application.properties”中），以允许资源服务器解码所给的令牌并验证用户身份：</p>
<pre><code class="prettyprint properties">...
spring.oauth2.resource.userInfoUri: http://localhost:9999/uaa/user
</code></pre><p>这告诉服务器它可以使用令牌来访问“ /用户”端点，并使用该令牌来派生身份验证信息（有点类似于Facebook API中的<a href="https://developers.facebook.com/docs/graph-api/reference/v2.2/user/?locale=en_GB">“ / me”端点</a> ）。有效地，它为资源服务器提供了一种解码令牌的方法，如Spring OAuth2中的<code>ResourceServerTokenServices</code>接口所表示的。</p>
<blockquote><p>注意：到目前为止， <code>userInfoUri</code>并不是连接资源服务器和解码令牌的唯一方法。实际上，它是最低的公分母（不是规范的一部分），但是通常可以从OAuth2提供程序（例如Facebook，Cloud Foundry，Github）获得，也可以使用其他选择。例如，您可以在令牌本身中编码用户身份验证（例如，使用<a href="http://jwt.io/" title="Jason Web令牌">JWT</a> ），或使用共享的后端存储。CloudFoundry中还有一个<code>/token_info</code>终结点，该终结点提供的信息比用户信息终结点更详细，但需要更彻底的身份验证。不同的选择（自然地）提供不同的好处和取舍，但是对这些选择的完整讨论不在本文的讨论范围之内。</p>
</blockquote><h2><a href="#implementing-the-user-endpoint" class="anchor" name="implementing-the-user-endpoint"></a>实施用户端点</h2><p>在授权服务器上，我们可以轻松地添加该端点</p>
<pre><code class="prettyprint java">@SpringBootApplication
@RestController
@EnableResourceServer
public class AuthserverApplication {

  @RequestMapping("/user")
  public Principal user(Principal user) {
    return user;
  }

  ...

}

</code></pre><p>我们在<a href="https://spring.io/blog/2015/01/12/the-login-page-angular-js-and-spring-security-part-ii" title="系列第二篇">第II部分中</a>添加了与UI服务器相同的<code>@RequestMapping</code> ，还添加了Spring OAuth中的<code>@EnableResourceServer</code>annotation，该annotation默认情况下可保护授权服务器中除“ / oauth / *”端点之外的所有内容。</p><p>有了该端点，我们可以测试它和问候资源，因为它们现在都接受由授权服务器创建的承载令牌：</p>
<pre><code class="prettyprint">$ TOKEN=2219199c-966e-4466-8b7e-12bb9038c9bb
$ curl -H "Authorization: Bearer $TOKEN" localhost:9000
{"id":"03af8be3-2fc3-4d75-acf7-c484d9cf32b1","content":"Hello World"}
$ curl -H "Authorization: Bearer $TOKEN" localhost:9999/uaa/user
{"details":...,"principal":{"username":"user",...},"name":"user"}
</code></pre><p>（用从您自己的授权服务器获取的访问令牌的值替换为自己可以使用的令牌）。</p><h2><a href="#the-ui-server" class="anchor" name="the-ui-server"></a> UI服务器</h2><p>我们需要完成的该应用程序的最后一部分是UI服务器，提取身份验证部分并委托给授权服务器。因此，与<a href="#changing-the-resource-server">资源服务器一样</a> ，我们首先需要删除Spring Session和Redis依赖项并将其替换为Spring OAuth2。</p><p>完成后，我们也可以删除会话过滤器和“ / user”端点，并设置应用程序以重定向到授权服务器（使用<code>@EnableOAuth2Sso</code>annotation）：</p>
<pre><code class="prettyprint java">@SpringBootApplication
@EnableZuulProxy
@EnableOAuth2Sso
public class UiApplication {

  public static void main(String[] args) {
    SpringApplication.run(UiApplication.class, args);
  }

  @Configuration
  @Order(SecurityProperties.ACCESS_OVERRIDE_ORDER)
  protected static class SecurityConfiguration extends WebSecurityConfigurerAdapter {
</code></pre><p>回顾<a href="https://spring.io/blog/2015/01/28/the-api-gateway-pattern-angular-js-and-spring-security-part-iv" title="系列文章中的第四篇">第四部分</a> ，UI服务器借助于<code>@EnableZuulProxy</code>充当API网关，我们可以在YAML中声明路由映射。因此，“ /用户”端点可以代理到授权服务器：</p>
<pre><code class="prettyprint yaml">zuul:
  routes:
    resource:
      path: /resource/**
      url: http://localhost:9000
    user:
      path: /user/**
      url: http://localhost:9999/uaa/user
</code></pre><p>最后，我们需要改变<code>WebSecurityConfigurerAdapter</code>到<code>OAuth2SsoConfigurerAdapter</code> ，因为现在它会被用来修改通过建立SSO过滤器链的默认<code>@EnableOAuth2Sso</code> ：</p>
<pre><code class="prettyprint">  @Configuration
  protected static class SecurityConfiguration extends OAuth2SsoConfigurerAdapter {

    @Override
    public void match(RequestMatchers matchers) {
      matchers.anyRequest();
    }

    @Override
    public void configure(HttpSecurity http) throws Exception {
      http.authorizeRequests().antMatchers("/index.html", "/home.html", "/")
          .permitAll().anyRequest().authenticated().and().csrf()
          .csrfTokenRepository(csrfTokenRepository()).and()
          .addFilterAfter(csrfHeaderFilter(), CsrfFilter.class);
    }
    
    ... // the csrf*() methods are the same as the old WebSecurityConfigurerAdapter
  }
</code></pre><p>主要的变化（除基类名称外）是匹配器<br>进入他们自己的方法，就不再需要<code>formLogin()</code>了。</p><p>还有一些强制性的外部配置属性<br><code>@EnableOAuth2Sso</code>annotation能够与之联系并进行身份验证<br>权限授权服务器。因此，我们需要在这个<code>application.yml</code> ：</p>
<pre><code class="prettyprint yaml">spring:
  oauth2:
    sso:
      home:
        secure: false
        path: /,/**/*.html
    client:
      accessTokenUri: http://localhost:9999/uaa/oauth/token
      userAuthorizationUri: http://localhost:9999/uaa/oauth/authorize
      clientId: acme
      clientSecret: acmesecret
    resource:
      userInfoUri: http://localhost:9999/uaa/user
</code></pre><p>其中大部分与OAuth2客户端（“ acme”）和<br>授权服务器位置。还有一个<code>userInfoUri</code> （<br>例如在资源服务器中），以便可以在<br>UI应用本身。“家庭”内容是关于允许匿名访问<br>到单页应用程序中的静态资源。</p><h3><a href="#in-the-client" class="anchor" name="in-the-client"></a>在客户中</h3><p>我们仍然需要对前端UI应用程序进行一些细微调整，以触发重定向到授权服务器。第一个是在“ index.html”中的导航栏中，其中“登录”链接从角度路线更改：</p>
<pre><code class="prettyprint html"><div ng-controller="navigation" class="container">
  <ul class="nav nav-pills" role="tablist">
    ...
    <li><a href="#/login">login</a></li>
    ...
  </ul>
</div>
</code></pre><p>到纯HTML链接</p>
<pre><code class="prettyprint html"><div ng-controller="navigation" class="container">
  <ul class="nav nav-pills" role="tablist">
    ...
    <li><a href="login">login</a></li>
    ...
  </ul>
</div>
</code></pre><p>转到的“ / login”端点由Spring Security处理，如果用户未通过身份验证，它将导致重定向到授权服务器。</p><p>我们还可以从Angular配置中删除“导航”控制器中的<code>login()</code>函数的定义以及“ / login”路由，从而简化了实现：</p>
<pre><code class="prettyprint javascript">angular.module('hello', [ 'ngRoute' ]).config(function($routeProvider) {

  $routeProvider.when('/', {
    templateUrl : 'home.html',
    controller : 'home'
  }).otherwise('/');

}). // ...
.controller('navigation',

function($rootScope, $scope, $http, $location, $route) {

  $http.get('user').success(function(data) {
    if (data.name) {
      $rootScope.authenticated = true;
    } else {
      $rootScope.authenticated = false;
    }
  }).error(function() {
    $rootScope.authenticated = false;
  });

  $scope.credentials = {};

  $scope.logout = function() {
    $http.post('logout', {}).success(function() {
      $rootScope.authenticated = false;
      $location.path("/");
    }).error(function(data) {
      $rootScope.authenticated = false;
    });
  }

});
</code></pre><h2><a href="#how-does-it-work" class="anchor" name="how-does-it-work"></a>它是如何工作的？</h2><p>现在一起运行所有服务器，并在浏览器中通过<a href="http://localhost:8080">http：// localhost：8080</a>访问UI。单击“登录”链接，您将被重定向到授权服务器进行身份验证（HTTP Basic弹出窗口）并批准令牌授予（whitelabel HTML），然后使用从OAuth2获取的问候语重定向到UI中的主页。资源服务器使用与我们验证UI相同的令牌。</p><p>如果您使用某些开发人员工具，则可以在浏览器中看到浏览器与后端之间的交互（通常F12会打开它，默认情况下在Chrome中运行，并且需要Firefox中的插件）。总结如下：</p>
<table>
<thead>
<tr>
<th>动词</th>
<th>路径</th>
<th>状态</th>
<th>响应</th>
</tr>
</thead>
<tbody>
<tr>
<td>得到</td>
<td>/</td>
<td>200</td>
<td>index.html</td>
</tr>
<tr>
<td>得到</td>
<td>/css/angular-bootstrap.css</td>
<td>200</td>
<td>Twitter引导CSS</td>
</tr>
<tr>
<td>得到</td>
<td>/js/angular-bootstrap.js</td>
<td>200</td>
<td>Bootstrap和Angular JS</td>
</tr>
<tr>
<td>得到</td>
<td>/js/hello.js</td>
<td>200</td>
<td>应用逻辑</td>
</tr>
<tr>
<td>得到</td>
<td>/home.html</td>
<td>200</td>
<td>主页的HTML部分</td>
</tr>
<tr>
<td>得到</td>
<td>/用户</td>
<td>302</td>
<td>重定向到登录页面</td>
</tr>
<tr>
<td>得到</td>
<td>/登录</td>
<td>302</td>
<td>重定向到身份验证服务器</td>
</tr>
<tr>
<td>得到</td>
<td>（uaa）/ oauth / authorize</td>
<td>401</td>
<td>（忽略）</td>
</tr>
<tr>
<td>得到</td>
<td>/资源</td>
<td>302</td>
<td>重定向到登录页面</td>
</tr>
<tr>
<td>得到</td>
<td>/登录</td>
<td>302</td>
<td>重定向到身份验证服务器</td>
</tr>
<tr>
<td>得到</td>
<td>（uaa）/ oauth / authorize</td>
<td>401</td>
<td>（忽略）</td>
</tr>
<tr>
<td>得到</td>
<td>/登录</td>
<td>302</td>
<td>重定向到身份验证服务器</td>
</tr>
<tr>
<td>得到</td>
<td>（uaa）/ oauth / authorize</td>
<td>200</td>
<td>HTTP基本身份验证发生在此处</td>
</tr>
<tr>
<td>开机自检</td>
<td>（uaa）/ oauth / authorize</td>
<td>302</td>
<td>用户批准授予，重定向到/ login</td>
</tr>
<tr>
<td>得到</td>
<td>/登录</td>
<td>302</td>
<td>重定向到首页</td>
</tr>
<tr>
<td>得到</td>
<td>/用户</td>
<td>200</td>
<td>（代理）JSON身份验证用户</td>
</tr>
<tr>
<td>得到</td>
<td>/home.html</td>
<td>200</td>
<td>主页的HTML部分</td>
</tr>
<tr>
<td>得到</td>
<td>/资源</td>
<td>200</td>
<td>（代理）JSON问候</td>
</tr>
</tbody>
</table><p>带有（uaa）前缀的请求将发送到授权服务器。标记为“忽略”的响应是Angular在XHR调用中收到的响应，并且由于我们没有处理这些数据，因此它们被丢弃在地板上。在“ / user”资源的情况下，我们确实会寻找经过身份验证的用户，但是由于在第一次调用中不存在经过身份验证的用户，因此该响应将被丢弃。</p><p>在用户界面的“ / trace”端点（向下滚动至底部）中，您将看到对<code>remote:true</code>代理“ / user”和“ / resource”的后端请求，其中包含<code>remote:true</code>和Bearer令牌而不是cookie（因为它将会在<a href="https://spring.io/blog/2015/01/28/the-api-gateway-pattern-angular-js-and-spring-security-part-iv" title="系列文章中的第四篇">第IV部分中</a> ）用于身份验证。Spring Cloud Security已为我们解决了这一问题：通过认识到我们拥有<code>@EnableOAuth2Sso</code>和<code>@EnableZuulProxy</code>它发现（默认情况下）我们希望将令牌中继到代理后端。</p>
<blockquote><p>注意：与以前的文章一样，请尝试对“ / trace”使用其他浏览器，以免进行身份验证交叉（例如，如果您使用Chrome浏览器来测试UI，请使用Firefox）。</p>
</blockquote><h2><a href="#the-logout-experience" class="anchor" name="the-logout-experience"></a>登出体验</h2><p>如果单击“注销”链接，您将看到主页更改（不再显示问候语），因此不再通过UI服务器对用户进行身份验证。单击后退的“登陆”，虽然和你其实<em>并不</em>需要通过在授权服务器的认证和审批周期要回去（因为你已经不是已注销）。关于这是否是理想的用户体验，这是一个非常棘手的问题（Single Sign Out： <a href="https://www.sciencedirect.com/science/article/pii/S2214212614000179">Science Direct文章</a>和<a href="https://wiki.shibboleth.net/confluence/display/SHIB2/SLOIssues">Shibboleth docs</a> ），将有不同的意见。理想的用户体验在技术上可能不可行，并且有时您还必须怀疑用户确实想要他们想要的内容。“我要'注销'注销我”听起来很简单，但显而易见的回答是，“注销了什么？您是要退出此SSO服务器控制的<em>所有</em>系统，还是只单击您单击“注销”链接的系统？我们没有空间在这里更广泛地讨论此主题，但是它确实值得更多关注。如果您有兴趣，那么将对有关原理的讨论以及有关<a href="https://openid.net/connect/">Open ID Connect</a>规范中实现的一些（相当不令人反感的）想法。</p><h2><a href="#conclusion" class="anchor" name="conclusion"></a>结论</h2><p>这是我们通过Spring Security和Angular JS堆栈进行的简要介绍的结尾将近结束。现在，我们有了一个不错的架构，在三个独立的组件（UI / API网关，资源服务器和授权服务器/令牌授予者）中明确职责。现在，所有层中的非业务代码数量已降至最低，并且很容易看到使用更多业务逻辑在何处扩展和改进实现。下一步将整理授权服务器中的UI，并可能添加更多测试，包括JavaScript客户端上的测试。另一个有趣的任务是提取所有样板代码并将其放置在一个库中（例如“ spring-security-angular”），该库包含Spring Security和Spring Session自动配置以及Angular中用于导航控制器的一些webjar资源。阅读了本系列的文章之后，任何希望学习Angular JS或Spring Security的内部工作原理的人都可能会感到失望，但是如果您想了解他们如何能够很好地协同工作以及如何进行一些配置很长一段路，然后希望您将有一个很好的经验。<a href="https://projects.spring.io/spring-cloud/">Spring Cloud</a>是新的，这些示例在编写时需要快照，但是有可用的候选版本以及即将发布的GA版本，因此请检查并<a href="https://github.com/spring-cloud">通过Github</a>或<a href="https://gitter.im/spring-cloud/spring-cloud">gitter.im</a>发送一些反馈。</p><p>本系列的<a href="https://spring.io/blog/2015/03/23/multiple-ui-applications-and-a-gateway-single-page-application-with-spring-and-angular-js-part-vi">下一篇文章</a>是关于访问决策（除了身份验证之外）的，并在同一代理后面使用多个UI应用程序。</p><h2><a href="#addendum-bootstrap-ui-and-jwt-tokens-for-the-authorization-server" class="anchor" name="addendum-bootstrap-ui-and-jwt-tokens-for-the-authorization-server"></a>附录：授权服务器的Bootstrap UI和JWT令牌</h2><p>您可以<a href="https://github.com/dsyer/spring-security-angular/tree/master/oauth2">在Github</a>的<a href="https://github.com/dsyer/spring-security-angular/tree/master/oauth2">源代码中</a>找到该应用程序的另一个版本，该版本具有漂亮的登录页面和用户批准页面，其实现方式与我们在<a href="https://spring.io/blog/2015/01/12/the-login-page-angular-js-and-spring-security-part-ii" title="系列第二篇">第二部分中</a>所做的相似。它还使用<a href="http://jwt.io/" title="Jason Web令牌">JWT</a>对令牌进行编码，因此资源服务器可以使用令牌中的足够多的信息来进行简单的身份验证，而不是使用“ / user”端点。浏览器客户端仍通过UI服务器使用它，以便可以确定用户是否已通过身份验证（与真实应用程序中对资源服务器的可能调用次数相比，它不需要非常频繁地进行身份验证）。</p></div>
</div>
<section id="disqus_thread"></section>
<script src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js" data-cfasync="false"></script><script type="text/javascript">var disqus_shortname = 'spring-io';
      var disqus_identifier = 1907;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));</script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });</script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>