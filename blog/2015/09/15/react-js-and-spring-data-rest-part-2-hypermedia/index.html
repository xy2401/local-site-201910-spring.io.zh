<html  data-code-prettify="" data-mobile-support="" data-search=""><head></head><body >﻿
<title>React.js和Spring Data REST：第2部分-超媒体</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="React.js and Spring Data REST: Part 2 - Hypermedia">
<meta name="twitter:description" >
<meta name="twitter:creator" content="@gregturn">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/43e9a9d63f7f4f9891c9fcd592b89cfa?s=200">

<meta property="og:title" content="React.js and Spring Data REST: Part 2 - Hypermedia">
<meta property="og:image" content="https://gravatar.com/avatar/43e9a9d63f7f4f9891c9fcd592b89cfa?s=200">
<meta property="og:description" >
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2015-09-15 13:34:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">React.js和Spring Data REST：第2部分-超媒体</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/43e9a9d63f7f4f9891c9fcd592b89cfa?s=20&d=mm"> <a class="author" rel="author" href="/team/gturnquist">格雷格·特恩奎斯特</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2015-09-15 13:34:00.0">2015年9月15日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2015/09/15/react-js-and-spring-data-rest-part-2-hypermedia#disqus_thread" data-disqus-identifier="2236">
</a></div>
</div>
</header>
<div class="blog--post"><div id="preamble">
<div class="sectionbody">
<div class="admonitionblock note">
<table>
<tbody>
<tr>
<td class="icon"> <i class="fa icon-note" title="注意"></i> </td>
<td class="content">要查看此代码的更新，请访问我们的<a href="https://spring.io/guides/tutorials/react-and-spring-data-rest/">React.js和Spring Data REST教程</a> 。</td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph">
<p>在上<a href="https://spring.io/blog/2015/09/01/react-js-and-spring-data-rest-part-1-basic-features">一课程中</a> ，您了解了如何使用Spring Data REST站起来使用后端薪资服务来存储员工数据。它缺少的一个关键功能是使用超媒体控件和按链接导航。相反，它对找到数据的路径进行了硬编码。</p>
</div>
<div class="paragraph">
<p>随时从该存储库中<a href="https://github.com/gregturn/react-and-spring-data-rest/tree/master/hypermedia">获取代码</a>并继续。该会话基于上一会话的应用程序，并添加了其他内容。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_in_the_beginning_there_was_data_and_then_there_was_rest">最初有数据...然后有RES​​T</h2>
<div class="sectionbody">
<div class="quoteblock">
<blockquote>人们对将任何基于HTTP的接口称为REST API的人数感到沮丧。今天的示例是SocialSite REST API。那就是RPC。它尖叫着RPC ....在超文本是一个约束的概念上，需要采取什么措施才能使REST体系结构风格清晰明了？换句话说，如果应用程序状态的引擎（以及API）不是由超文本驱动的，则它不能是RESTful的，也不能是REST API。期。是否有一些需要修复的故障手册？
</blockquote>
<div class="attribution">— <a href="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven">罗伊·菲尔丁</a> （ <a href="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven">Roy T. Fielding）</a><br>
</div>
</div>
<div class="paragraph">
<p>那么，超媒体控件到底是什么，即超文本，又该如何使用它们呢？为了找出答案，让我们退后一步，看看REST的核心任务。</p>
</div>
<div class="paragraph">
<p>REST的概念是借用使网络如此成功的想法并将其应用于API。尽管Web的规模巨大，动态特性以及客户端（即浏览器）的更新速度很低，但是Web取得了惊人的成功。罗伊·菲尔丁（Roy Fielding）试图利用其一些约束和功能，看看是否能够提供类似的API生产和消费量。</p>
</div>
<div class="paragraph">
<p>限制之一是限制动词的数量。对于REST，主要的是GET，POST，PUT，DELETE和PATCH。还有其他人，但我们不会在这里介绍。</p>
</div>
<div class="ulist">
<ul>
<li>GET-在不更改系统的情况下获取资源状态</li>
<li>POST-创建新资源，而不用说</li>
<li>PUT-替换现有资源，覆盖现有资源（如果有的话）</li>
<li>删除-删除现有资源</li>
<li>PATCH-部分更改现有资源</li>
</ul>
</div>
<div class="paragraph">
<p>这些是具有良好规范的标准化HTTP动词。通过选择并使用已经创造的HTTP操作，我们不必发明新的语言并教育行业。</p>
</div>
<div class="paragraph">
<p>REST的另一个限制是使用媒体类型来定义数据格式。与其每个人都写自己的方言来交换信息，不如发展一些媒体类型。最受欢迎的一种是HAL，媒体类型为application / hal + json。这是Spring Data REST的默认媒体类型。敏锐的价值在于，REST没有集中的单一媒体类型。相反，人们可以开发媒体类型并将其插入。试试看。随着不同需求的出现，行业可以灵活地移动。</p>
</div>
<div class="paragraph">
<p>REST的关键功能是包括指向相关资源的链接。例如，如果您正在查看订单，则RESTful API将包括到相关客户的链接，到商品目录的链接，以及到从其下订单的商店的链接。在本节中，您将介绍分页，并了解如何也使用导航分页链接。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_turning_on_paging_from_the_backend">从后端开启分页</h2>
<div class="sectionbody">
<div class="paragraph">
<p>要开始使用前端超媒体控件，您需要打开一些额外的控件。Spring Data REST提供了页面支持。要使用它，只需调整存储库定义：</p>
</div>
<div class="listingblock">
<div class="title">src / main / java / com / greglturnquist / payroll / EmployeeRepository.java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface EmployeeRepository extends PagingAndSortingRepository&lt;Employee, Long&gt; {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您的界面现已扩展<code>PagingAndSortingRepository</code>它添加了额外的选项来设置页面大小，还添加了导航链接以在页面之间跳转。后端的其余部分是相同的（一些<a href="https://github.com/gregturn/react-and-spring-data-rest/blob/master/hypermedia/src/main/java/com/greglturnquist/payroll/DatabaseLoader.java">额外的预加载数据</a>使事情变得有趣）。</p>
</div>
<div class="paragraph">
<p>重新启动应用程序（ <code>./mvnw spring-boot:run</code> ），并查看其工作原理。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl localhost:8080/api/employees?size=2
{
  "_links" : {
    "first" : {
      "href" : "http://localhost:8080/api/employees?page=0&amp;size=2"
    },
    "self" : {
      "href" : "http://localhost:8080/api/employees"
    },
    "next" : {
      "href" : "http://localhost:8080/api/employees?page=1&amp;size=2"
    },
    "last" : {
      "href" : "http://localhost:8080/api/employees?page=2&amp;size=2"
    }
  },
  "_embedded" : {
    "employees" : [ {
      "firstName" : "Frodo",
      "lastName" : "Baggins",
      "description" : "ring bearer",
      "_links" : {
        "self" : {
          "href" : "http://localhost:8080/api/employees/1"
        }
      }
    }, {
      "firstName" : "Bilbo",
      "lastName" : "Baggins",
      "description" : "burglar",
      "_links" : {
        "self" : {
          "href" : "http://localhost:8080/api/employees/2"
        }
      }
    } ]
  },
  "page" : {
    "size" : 2,
    "totalElements" : 6,
    "totalPages" : 3,
    "number" : 0
  }
}</pre>
</div>
</div>
<div class="paragraph">
<p>默认页面大小为20，因此要查看实际使用情况， <code>?size=2</code>应用。不出所料，只列出了两名员工。此外，还有一个<strong>first</strong> ， <strong>next</strong>和<strong>last</strong>链接。还有一个<strong>自</strong>链接，没有上下文， <em>包括页面参数</em> 。</p>
</div>
<div class="paragraph">
<p>如果您导航到<strong>下一个</strong>环节，你会再看到<strong>上一个</strong>链接，以及：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl "http://localhost:8080/api/employees?page=1&amp;size=2"
{
  "_links" : {
    "first" : {
      "href" : "http://localhost:8080/api/employees?page=0&amp;size=2"
    },
    "prev" : {
      "href" : "http://localhost:8080/api/employees?page=0&amp;size=2"
    },
    "self" : {
      "href" : "http://localhost:8080/api/employees"
    },
    "next" : {
      "href" : "http://localhost:8080/api/employees?page=2&amp;size=2"
    },
    "last" : {
      "href" : "http://localhost:8080/api/employees?page=2&amp;size=2"
    }
  },
...</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">在URL查询参数中使用“＆”时，命令行认为这是换行符。用引号引起来的整个URL绕过它。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>看起来很整洁，但是当您更新前端以利用它时，效果会更好。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_navigating_by_relationship">通过关系导航</h2>
<div class="sectionbody">
<div class="paragraph">
<p>而已！后端不需要任何其他更改即可开始使用Spring Data REST提供的即用型超媒体控件。您可以切换到在前端工作。（这是Spring Data REST的优点所在。没有凌乱的控制器更新！）</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">需要指出的是，该应用程序不是“特定于Spring Data REST的”。而是使用<a href="http://stateless.co/hal_specification.html">HAL</a> ， <a href="https://tools.ietf.org/html/rfc6570">URI模板</a>和其他标准。这样就可以轻松使用rest.js：该库附带HAL支持。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在上一个会话中，您将路径硬编码为<code>/api/employees</code> 。相反，您应该硬编码的唯一路径是根。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">...
var root = '/api';
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>方便的一点<a href="https://github.com/gregturn/react-and-spring-data-rest/blob/master/hypermedia/src/main/resources/static/follow.js"><code>follow()</code>功能</a> ，您现在可以从根目录开始并导航至所需的位置！</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">componentDidMount: function () {
    this.loadFromServer(this.state.pageSize);
},</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上一个会话中，加载直接在内部完成<code>componentDidMount()</code> 。在此会议中，我们将在页面大小更新时重新加载整个员工列表。为此，我们已将事情转移到<code>loadFromServer()</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">loadFromServer: function (pageSize) {
    follow(client, root, [
        {rel: 'employees', params: {size: pageSize}}]
    ).then(employeeCollection =&gt; {
        return client({
            method: 'GET',
            path: employeeCollection.entity._links.profile.href,
            headers: {'Accept': 'application/schema+json'}
        }).then(schema =&gt; {
            this.schema = schema.entity;
            return employeeCollection;
        });
    }).done(employeeCollection =&gt; {
        this.setState({
            employees: employeeCollection.entity._embedded.employees,
            attributes: Object.keys(this.schema.properties),
            pageSize: pageSize,
            links: employeeCollection.entity._links});
    });
},</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>loadFromServer</code>与上一个会话非常相似，但是如果使用<code>follow()</code> ：</p>
</div>
<div class="ulist">
<ul>
<li>follow（）函数的第一个参数是<code>client</code>用于进行REST调用的对象。
</li>
<li>第二个参数是起始的根URI。
</li>
<li>第三个参数是要导航的一系列关系。每个可以是字符串或对象。
</li>
</ul>
</div>
<div class="paragraph">
<p>关系数组可以很简单<code>["employees"]</code> ，表示在首次调用时，在<strong>_links中</strong>查找名为<strong>employee</strong>的关系（或<strong>rel</strong> ）。找到它的<strong>href</strong>并导航到它。如果阵列中存在其他关系，请冲洗并重复。</p>
</div>
<div class="paragraph">
<p>有时，仅靠依靠是不够的。在这段代码中，它还会插入查询参数<strong>？。大小= <pagesize></pagesize></strong> 。您还可以看到其他选项。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_grabbing_json_schema_metadata">抓取JSON模式元数据</h2>
<div class="sectionbody">
<div class="paragraph">
<p>导航与基于尺寸的<strong>员工</strong>查询后<strong>，employeeCollection</strong>是在你的指尖。在上一个会话中，我们将其命名为day并将其显示在内部<code><EmployeeList /></code> 。今天，您正在执行另一个调用以获取一些发现的<a href="https://json-schema.org/">JSON模式元数据</a> <code>/api/profile/employees</code> 。</p>
</div>
<div class="paragraph">
<p>您可以自己查看数据：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ curl http://localhost:8080/api/profile/employees -H 'Accept:application/schema+json'
{
  "title" : "Employee",
  "properties" : {
    "firstName" : {
      "title" : "First name",
      "readOnly" : false,
      "type" : "string"
    },
    "lastName" : {
      "title" : "Last name",
      "readOnly" : false,
      "type" : "string"
    },
    "description" : {
      "title" : "Description",
      "readOnly" : false,
      "type" : "string"
    }
  },
  "definitions" : { },
  "type" : "object",
  "$schema" : "http://json-schema.org/draft-04/schema#"
}</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">/ profile / employees中元数据的默认格式为ALPS。不过，在这种情况下，您正在使用内容协商来获取JSON模式。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>通过在中捕获此信息<app></app> `组件的状态，稍后在构建输入表单时可以充分利用它。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="creating-new-records">创建新记录</h2>
<div class="sectionbody">
<div class="paragraph">
<p>有了此元数据，您现在可以向UI添加一些额外的控件。创建一个新的React组件， <code><CreateDialog /></code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">var CreateDialog = React.createClass({

    handleSubmit: function (e) {
        e.preventDefault();
        var newEmployee = {};
        this.props.attributes.forEach(attribute =&gt; {
            newEmployee[attribute] = React.findDOMNode(this.refs[attribute]).value.trim();
        });
        this.props.onCreate(newEmployee);

        // clear out the dialog's inputs
        this.props.attributes.forEach(attribute =&gt; {
            React.findDOMNode(this.refs[attribute]).value = '';
        });

        // Navigate away from the dialog to hide it.
        window.location = "#";
    },

    render: function () {
        var inputs = this.props.attributes.map(attribute =&gt;
            &lt;p key={attribute}&gt;
                &lt;input type="text" placeholder={attribute} ref={attribute} className="field" /&gt;
            &lt;/p&gt;
        );

        return (
            &lt;div&gt;
                &lt;a href="#createEmployee"&gt;Create&lt;/a&gt;

                &lt;div id="createEmployee" className="modalDialog"&gt;
                    &lt;div&gt;
                        &lt;a href="#" title="Close" className="close"&gt;X&lt;/a&gt;

                        &lt;h2&gt;Create new employee&lt;/h2&gt;

                        &lt;form&gt;
                            {inputs}
                            &lt;button onClick={this.handleSubmit}&gt;Create&lt;/button&gt;
                        &lt;/form&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        )
    }

});</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个新组件既有<code>handleSubmit()</code>功能和预期的一样<code>render()</code>功能。</p>
</div>
<div class="paragraph">
<p>让我们以相反的顺序深入研究这些功能，然后先来看一下<code>render()</code>功能。</p>
</div>
<div class="sect2">
<h3 id="hypermedia-rendering">渲染图</h3>
<div class="paragraph">
<p>您的代码映射到<strong>attribute</strong>属性中找到的JSON Schema数据，并将其转换为<code><p><input></p></code>元素。</p>
</div>
<div class="ulist">
<ul>
<li>
React再次需要使用<strong>key</strong>来区分多个子节点。
</li>
<li>这是一个简单的基于文本的输入字段。
</li>
<li>
<strong>占位符</strong>是我们可以向用户显示字段的位置。
</li>
<li>您可能曾经拥有过<strong>name</strong>属性，但这不是必需的。借助React， <strong>ref</strong>是获取特定DOM节点的机制（您将很快看到）。
</li>
</ul>
</div>
<div class="paragraph">
<p>这代表了组件的动态特性，它是通过从服务器加载数据来驱动的。</p>
</div>
<div class="paragraph">
<p>在此组件的顶级内部<code><div></code>是一个锚标签，另一个<code><div></code> 。锚标记是打开对话框的按钮。和嵌套<code><div></code>是隐藏的对话框本身。在此示例中，您使用的是纯HTML5和CSS3。根本没有JavaScript！您可以<a href="https://github.com/gregturn/react-and-spring-data-rest/blob/master/hypermedia/src/main/resources/static/main.css">看到</a>用于显示/隐藏对话框<a href="https://github.com/gregturn/react-and-spring-data-rest/blob/master/hypermedia/src/main/resources/static/main.css">的CSS代码</a> 。我们不会在这里深入探讨。</p>
</div>
<div class="paragraph">
<p>坐落在里面<code><div id="createEmployee"></code>是一种表单，在其中注入了输入字段的动态列表，后跟“ <strong>创建”</strong>按钮。该按钮有一个<code>onClick={this.handleSubmit}</code>事件处理程序。这是注册事件处理程序的React方法。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">React不会在每个DOM元素上创建大量事件处理程序。相反，它具有<a href="https://facebook.github.io/react/docs/interactivity-and-dynamic-uis.html#under-the-hood-autobinding-and-event-delegation">性能更高且更复杂的</a>解决方案。关键是您不必管理该基础结构，而可以专注于编写功能代码。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="_handling_user_input">处理用户输入</h3>
<div class="paragraph">
<p>的<code>handleSubmit()</code>函数首先阻止事件在层次结构中冒泡。然后，它使用相同的JSON Schema属性属性来查找每个<code><input></code>使用<code>React.findDOMNode(this.refs[attribute])</code> 。</p>
</div>
<div class="paragraph">
<p><code>this.refs</code>是一种通过名称获取并获取特定React组件的方法。从这种意义上讲，您只能获得虚拟DOM组件。要获取实际的DOM元素，您需要使用<code>React.findDOMNode()</code> 。</p>
</div>
<div class="paragraph">
<p>遍历每个输入并建立<code>newEmployee</code>对象，我们调用一个回调来<code>onCreate()</code>新员工。此功能位于内部顶部<code>App.onCreate</code>并作为另一个属性提供给此React组件。看一下顶层函数的工作方式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">onCreate: function (newEmployee) {
    follow(client, root, ['employees']).then(employeeCollection =&gt; {
        return client({
            method: 'POST',
            path: employeeCollection.entity._links.self.href,
            entity: newEmployee,
            headers: {'Content-Type': 'application/json'}
        })
    }).then(response =&gt; {
        return follow(client, root, [
            {rel: 'employees', params: {'size': this.state.pageSize}}]);
    }).done(response =&gt; {
        this.onNavigate(response.entity._links.last.href);
    });
},</code></pre>
</div>
</div>
<div class="paragraph">
<p>再一次使用<code>follow()</code>功能以导航到执行POST操作的<strong>员工</strong>资源。在这种情况下，不需要应用任何参数，因此基于字符串的rels数组很好。在这种情况下，将返回POST调用。这允许下一个<code>then()</code>子句来处理POST的结果。</p>
</div>
<div class="paragraph">
<p>通常将新记录添加到数据集的末尾。由于您正在查看某个页面，因此合乎逻辑的是期望新员工记录不在当前页面上。要处理此问题，您需要获取应用了相同页面大小的一批新数据。该承诺将为其中的final子句返回<code>done()</code> 。</p>
</div>
<div class="paragraph">
<p>由于用户可能希望看到新创建的员工，因此您可以使用超媒体控件并导航到<strong>最后一个</strong>条目。</p>
</div>
<div class="paragraph">
<p>这在我们的UI中引入了分页的概念。让我们接下来解决这个问题！</p>
</div>
<div id="NOTE" class="exampleblock">
<div class="content">
<div class="paragraph">
<p>第一次使用基于承诺的API？<a href="https://promisesaplus.com/">承诺</a>是一种启动异步操作，然后注册一个函数以在任务完成时做出响应的方法。承诺被设计为链接在一起以避免“回调地狱”。请看以下流程：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">when.promise(async_func_call())
	.then(function(results) {
		/* process the outcome of async_func_call */
	})
	.then(function(more_results) {
		/* process the previous then() return value */
	})
	.done(function(yet_more) {
		/* process the previous then() and wrap things up */
	});</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关更多详细信息，请查看<a href="http://know.cujojs.com/tutorials/promises/consuming-promises">有关promise的本教程</a> 。</p>
</div>
<div class="paragraph">
<p>要记住的秘密是<code>then()</code>函数<em>需要</em>返回某些值，无论它是值还是其他承诺。 <code>done()</code>函数不会返回任何内容，并且您之后也不会链接任何内容。如果您还没有注意到， <code>client</code> （这是<code>rest</code>来自rest.js）以及<code>follow</code>函数返回承诺。</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_paging_through_data">分页数据</h2>
<div class="sectionbody">
<div class="paragraph">
<p>您在后端设置分页，并且在创建新员工时已经开始利用它。</p>
</div>
<div class="paragraph">
<p>在<a href="#creating-new-records">上一节中</a> ，您使用了页面控件来跳至<strong>最后</strong>一页。动态地将其应用于UI并让用户根据需要进行导航将非常方便。根据可用的导航链接动态调整控件会很棒。</p>
</div>
<div class="paragraph">
<p>首先，让我们看看<code>onNavigate()</code>您使用的功能。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">onNavigate: function(navUri) {
    client({method: 'GET', path: navUri}).done(employeeCollection =&gt; {
        this.setState({
            employees: employeeCollection.entity._embedded.employees,
            attributes: this.state.attributes,
            pageSize: this.state.pageSize,
            links: employeeCollection.entity._links
        });
    });
},</code></pre>
</div>
</div>
<div class="paragraph">
<p>在顶部，内部定义<code>App.onNavigate</code> 。同样，这是为了允许在顶部组件中管理UI的状态。经过之后<code>onNavigate()</code>下降到<code><EmployeeList /></code> React组件，对以下处理程序进行了编码，以处理某些按钮上的单击：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">handleNavFirst: function(e){
    e.preventDefault();
    this.props.onNavigate(this.props.links.first.href);
},
handleNavPrev: function(e) {
    e.preventDefault();
    this.props.onNavigate(this.props.links.prev.href);
},
handleNavNext: function(e) {
    e.preventDefault();
    this.props.onNavigate(this.props.links.next.href);
},
handleNavLast: function(e) {
    e.preventDefault();
    this.props.onNavigate(this.props.links.last.href);
},</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些函数中的每一个都会拦截默认事件并阻止其冒泡。然后，它调用<code>onNavigate()</code>通过适当的超媒体链接起作用。</p>
</div>
<div class="paragraph">
<p>现在，根据哪些链接出现在超链接中而有条件地显示控件<code>EmployeeList.render</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">render: function () {
    var employees = this.props.employees.map(employee =&gt;
        &lt;Employee key={employee._links.self.href} employee={employee} onDelete={this.props.onDelete}/&gt;
    );

    var navLinks = [];
    if ("first" in this.props.links) {
        navLinks.push(&lt;button key="first" onClick={this.handleNavFirst}&gt;&amp;lt;&amp;lt;&lt;/button&gt;);
    }
    if ("prev" in this.props.links) {
        navLinks.push(&lt;button key="prev" onClick={this.handleNavPrev}&gt;&amp;lt;&lt;/button&gt;);
    }
    if ("next" in this.props.links) {
        navLinks.push(&lt;button key="next" onClick={this.handleNavNext}&gt;&amp;gt;&lt;/button&gt;);
    }
    if ("last" in this.props.links) {
        navLinks.push(&lt;button key="last" onClick={this.handleNavLast}&gt;&amp;gt;&amp;gt;&lt;/button&gt;);
    }

    return (
        &lt;div&gt;
            &lt;input ref="pageSize" defaultValue={this.props.pageSize} onInput={this.handleInput}/&gt;
            &lt;table&gt;
                &lt;tr&gt;
                    &lt;th&gt;First Name&lt;/th&gt;
                    &lt;th&gt;Last Name&lt;/th&gt;
                    &lt;th&gt;Description&lt;/th&gt;
                    &lt;th&gt;&lt;/th&gt;
                &lt;/tr&gt;
                {employees}
            &lt;/table&gt;
            &lt;div&gt;
                {navLinks}
            &lt;/div&gt;
        &lt;/div&gt;
    )
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>与上一届会议一样， <code>this.props.employees</code>变成一个数组<code><Element /></code>组件。然后建立一个数组<code>navLinks</code> ，一组HTML按钮。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">由于React是基于XML的，因此您不能将“ <”放在<code><button></code>元件。您必须改为使用编码版本。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>然后你可以看到<code>{navLinks}</code>插入返回的HTML的底部。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_deleting_existing_records">删除现有记录</h2>
<div class="sectionbody">
<div class="paragraph">
<p>删除条目要容易得多。保留其基于HAL的记录，并将<strong>DELETE</strong>应用于其<strong>自身</strong>链接。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">var Employee = React.createClass({
    handleDelete: function () {
        this.props.onDelete(this.props.employee);
    },
    render: function () {
        return (
            &lt;tr&gt;
                &lt;td&gt;{this.props.employee.firstName}&lt;/td&gt;
                &lt;td&gt;{this.props.employee.lastName}&lt;/td&gt;
                &lt;td&gt;{this.props.employee.description}&lt;/td&gt;
                &lt;td&gt;
                    &lt;button onClick={this.handleDelete}&gt;Delete&lt;/button&gt;
                &lt;/td&gt;
            &lt;/tr&gt;
        )
    }
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Employee组件的此更新版本在行末显示一个额外的条目，即一个删除按钮。注册调用<code>this.handleDelete</code>当点击。的<code>handleDelete()</code>然后，该函数可以调用传递的回调，同时提供上下文相关的重要信息<code>this.props.employee</code>记录。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<div class="title">重要</div>
</td>
<td class="content">这再次表明，最容易在一处管理顶部组件中的状态。情况并非<em>总是</em>如此，但是通常情况下，在一个地方管理状态可以更轻松，更简单地保持状态。通过使用特定于组件的详细信息调用回调（ <code>this.props.onDelete(this.props.employee)</code> ），协调组件之间的行为非常容易。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>追踪<code>onDelete()</code>功能回到顶部<code>App.onDelete</code> ，您可以查看其运作方式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">onDelete: function (employee) {
    client({method: 'DELETE', path: employee._links.self.href}).done(response =&gt; {
        this.loadFromServer(this.state.pageSize);
    });
},</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用基于页面的UI删除记录后要应用的行为有些棘手。在这种情况下，它将使用相同的页面大小从服务器重新加载整个数据。然后显示第一页。</p>
</div>
<div class="paragraph">
<p>如果要删除最后一页上的最后一条记录，它将跳到第一页。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_adjusting_the_page_size">调整页面大小</h2>
<div class="sectionbody">
<div class="paragraph">
<p>查看超媒体的真正效果的一种方法是更新页面大小。Spring Data REST根据页面大小流畅地更新导航链接。</p>
</div>
<div class="paragraph">
<p>在顶部有一个HTML元素<code>ElementList.render</code> ： <code><input ref="pageSize" defaultValue={this.props.pageSize} onInput={this.handleInput}/></code> 。</p>
</div>
<div class="ulist">
<ul>
<li>
<code>ref="pageSize"</code>通过this.refs.pageSize可以轻松获取该元素。
</li>
<li>
<code>defaultValue</code>使用状态的<strong>pageSize</strong>对其进行初始化。
</li>
<li>
<code>onInput</code>注册一个处理程序，如下所示。
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">handleInput: function (e) {
    e.preventDefault();
    var pageSize = React.findDOMNode(this.refs.pageSize).value;
    if (/^[0-9]+$/.test(pageSize)) {
        this.props.updatePageSize(pageSize);
    } else {
        React.findDOMNode(this.refs.pageSize).value =
            pageSize.substring(0, pageSize.length - 1);
    }
},</code></pre>
</div>
</div>
<div class="paragraph">
<p>它阻止事件冒泡。然后，它使用的<strong>ref</strong>属性<code><input></code>找到DOM节点并提取其值，全部通过React的<code>findDOMNode()</code>辅助功能。它通过检查输入是否为数字字符串来测试输入是否确实是数字。如果是这样，它将调用回调，将新的页面大小发送到<code>App</code>反应组件。如果不是，则将刚刚输入的字符从输入中删除。</p>
</div>
<div class="paragraph">
<p>是什么<code>App</code>当它得到一个<code>updatePageSize()</code> ？看看这个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">updatePageSize: function (pageSize) {
    if (pageSize !== this.state.pageSize) {
        this.loadFromServer(pageSize);
    }
},</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于新的页面大小会导致所有导航链接发生更改，因此最好重新获取数据并从头开始。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_putting_it_all_together">放在一起</h2>
<div class="sectionbody">
<div class="paragraph">
<p>有了所有这些不错的添加，您现在已经拥有了一个非常完善的UI。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://github.com/gregturn/react-and-spring-data-rest/raw/master/hypermedia/images/hypermedia-1.png" alt="超媒体1">
</div>
</div>
<div class="paragraph">
<p>您可以在顶部看到页面大小设置，在每行上看到删除按钮，在底部看到导航按钮。导航按钮说明了超媒体控件的强大功能。</p>
</div>
<div class="paragraph">
<p>在下面，您可以看到<code>CreateDialog</code>并将元数据插入HTML输入占位符。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://github.com/gregturn/react-and-spring-data-rest/raw/master/hypermedia/images/hypermedia-2.png" alt="超媒体2">
</div>
</div>
<div class="paragraph">
<p>这确实显示了结合使用超媒体和域驱动的元数据（JSON模式）的强大功能。网页不必知道哪个字段是哪个字段。而是，用户可以<em>看到</em>它并知道如何使用它。如果您将另一个字段添加到<code>Employee</code>域对象，此弹出窗口将自动显示它。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_review">评论</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在此会话中：</p>
</div>
<div class="ulist">
<ul>
<li>您打开了Spring Data REST的分页功能。
</li>
<li>您抛出了硬编码的URI路径，并开始使用结合了关系名称或“ rels”的根URI。
</li>
<li>您更新了UI，以动态使用基于页面的超媒体控件。
</li>
<li>您添加了创建和删除员工以及根据需要更新UI的功能。
</li>
<li>您可以更改页面大小并灵活地响应UI。
</li>
</ul>
</div>
<div class="paragraph">
<p>有问题吗？</p>
</div>
<div class="paragraph">
<p>您使网页具有动态性。但是打开另一个浏览器选项卡，然后将其指向同一应用程序。一个标签中的更改不会更新另一个标签中的任何内容。</p>
</div>
<div class="paragraph">
<p>这是我们在下届会议上可以解决的问题。在此之前，祝您编程愉快！</p>
</div>
</div>
</div></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 2236;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>