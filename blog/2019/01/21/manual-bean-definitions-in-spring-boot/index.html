<html dir="ltr" data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>Spring Boot中的手动Bean定义</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>System.config({baseURL: "/b92013b"});</script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>System.import('app/main.js')</script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Manual Bean Definitions in Spring Boot">
<meta name="twitter:description" content="<div class=" paragrap="="> 
 </head><body dir="ltr"><p>Suppose you want to use Spring Boot, but you don’t want to <code>@EnableAutoConfiguration</code>. What should you do exactly? In an <a href="https://spring.io/blog/2018/12/12/how-fast-is-spring">earlier article</a> I showed that Spring is intrinsically fast and lightweight, but one of the short pieces of advice improve startup time was to consider manually importing the Spring Boot autoconfigurations, instead of sucking them all in automatically. It won’t be the right thing to do for all applications, but it might help, and it certainly won’t hurt to understand what the options are. In this piece we explore various ways of doing manual configuration and assess their impact.</p> 

">
<meta name="twitter:creator" content="@david_syer">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=200">

<meta property="og:title" content="Manual Bean Definitions in Spring Boot">
<meta property="og:image" content="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=200">
<meta property="og:description" content="<div class=" paragrap="="> 
 <p>Suppose you want to use Spring Boot, but you don’t want to <code>@EnableAutoConfiguration</code>. What should you do exactly? In an <a href="https://spring.io/blog/2018/12/12/how-fast-is-spring">earlier article</a> I showed that Spring is intrinsically fast and lightweight, but one of the short pieces of advice improve startup time was to consider manually importing the Spring Boot autoconfigurations, instead of sucking them all in automatically. It won’t be the right thing to do for all applications, but it might help, and it certainly won’t hurt to understand what the options are. In this piece we explore various ways of doing manual configuration and assess their impact.</p> 

">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2019-01-21 14:32:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">// Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }</script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Spring Boot中的手动Bean定义</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=20&d=mm"> <a class="author" rel="author" href="/team/dsyer">戴夫·瑟</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2019-01-21 14:32:00.0">一月21，2019</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2019/01/21/manual-bean-definitions-in-spring-boot#disqus_thread" data-disqus-identifier="3545">
</a></div>
</div>
</header>
<div class="blog--post"><div class="paragraph">
<p>假设您要使用Spring Boot，但不想使用<code>@EnableAutoConfiguration</code> 。你到底应该怎么做？在<a href="https://spring.io/blog/2018/12/12/how-fast-is-spring">较早的文章中，</a>我证明了Spring本质上是快速且轻量级的，但是缩短建议启动时间的简短建议之一是考虑手动导入Spring Boot自动配置，而不是自动吸收它们。并不是对所有应用程序都正确，但这可能会有所帮助，并且了解选项是肯定不会受到伤害的。在本文中，我们探索了进行手动配置的各种方法并评估了它们的影响。</p>
</div>
<div class="sect1">
<h2 id="full-autoconfiguration-hello-world-webflux"><a class="anchor" href="#full-autoconfiguration-hello-world-webflux"></a>全自动配置：Hello World WebFlux</h2>
<div class="sectionbody">
<div class="paragraph">
<p>作为基线，让我们看一下具有单个HTTP端点的Spring Boot应用程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@RestController
public class DemoApplication {

  @GetMapping("/")
  public Mono<String> home() {
    return Mono.just("Hello World");
  }

  public void main(String[] args) {
    SpringApplication.run(DemoApplication.class, args);
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您按照前一篇文章中的建议进行了所有调整，然后运行了该应用程序，则该过程应大约一秒钟左右开始，或者更长一些，具体取决于您的硬件。在那段时间，它的<code>@GetMapping</code>很大-设置日志记录系统，读取并绑定到配置文件，启动Netty并侦听端口8080，为应用程序中的<code>@GetMapping</code>提供路由，并提供默认的错误处理。如果Spring Boot Actuator在类路径上，那么您还将获得一个/ health和一个/ info端点（因此启动它会花费更长的时间）。</p>
</div>
<div class="paragraph">
<p>该<code>@SpringBootApplication</code>annotation，在你不知道的情况下，是元注解为<code>@EnableAutoConfiguration</code> ，这就是提供所有有用的功能是免费的。这就是使Spring Boot受欢迎的原因，所以我们不想丢掉任何东西，但是我们可以仔细看看实际发生的情况，也许可以手动进行一些操作，看看我们是否学到了什么。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">如果您想尝试一下此代码，可以很容易地从<a href="https://spring.io">Spring Initializr中</a>获取一个空的WebFlux应用程序。只需选中“反应式Web”复选框并下载项目。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="manual-imports-of-autoconfiguration"><a class="anchor" href="#manual-imports-of-autoconfiguration"></a>手动导入自动配置</h2>
<div class="sectionbody">
<div class="paragraph">
<p>虽然<code>@EnableAutoConfiguration</code>功能使得添加新功能到应用程序容易，它也带走了一些控制哪些功能被启用。大多数人都乐于做出这种妥协-使用的简便性超过了控制的损失。可能会影响性能-应用程序的启动速度可能会慢一些，因为Spring Boot必须做一些工作才能找到所有这些功能并安装它们。实际上，找到正确的功能并不需要付出大量的努力：没有类路径扫描，并且经过仔细的优化后，条件评估非常快。JVM加载类占用了此应用程序之一的大量启动时间（大约80％），因此实际上，使其启动更快的唯一方法是，通过安装更少的功能来要求它做更少的事情。</p>
</div>
<div class="paragraph">
<p>始终可以使用<code>@EnableAutoConfiguration</code>annotation中的<code>exclude</code>属性来禁用自动配置。一些单独的自动配置还具有可以在外部设置的自己的布尔配置标志，例如，对于JMX，我们可以使用<code>spring.jmx.enabled=false</code> （例如，作为System属性或在属性文件中）。我们可以走这条路，手动关闭所有我们不想使用的东西，但这有点笨拙，并且如果类路径发生变化，也不会阻止其他东西被打开。</p>
</div>
<div class="paragraph">
<p>取而代之的是，让我们看看使用现有的自动配置类可以做些什么，而只是应用我们想要使用的对应于我们喜欢的功能的类。我们可以将其称为“点菜”方法，而不是完全自动配置附带的“您可以吃的所有东西”。自动配置类只是常规的<code>@Configuration</code>因此原则上我们可以<code>@Import</code>它们导入到没有<code>@EnableAutoConfiguration</code>的应用程序中。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<div class="title">警告</div>
</td>
<td class="content">在没有阅读本文的其余部分之前，请勿这样做。这不是使用Spring Boot自动配置的正确方法。它可能会损坏某些东西，但与往常一样，行驶里程可能会有所不同。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>例如，这是上面的应用程序，具有我们想要的所有功能（不包括执行器）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootConfiguration
@Import({
    WebFluxAutoConfiguration.class,
    ReactiveWebServerFactoryAutoConfiguration.class,
    ErrorWebFluxAutoConfiguration.class,
    HttpHandlerAutoConfiguration.class,
    ConfigurationPropertiesAutoConfiguration.class,
    PropertyPlaceholderAutoConfiguration.class
})
@RestController
public class DemoApplication {

  @GetMapping("/")
  public Mono<String> home() {
    return Mono.just("Hello World");
  }

  public void main(String[] args) {
    SpringApplication.run(DemoApplication.class, args);
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此版本的应用程序仍将具有我们上面描述的所有功能，但启动速度更快（大约30％左右）。那么，我们为加快启动速度而放弃了什么？这是一个简短的摘要：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Spring Boot自动配置的全部功能集包括实际应用程序中可能实际需要的其他东西，而不是特定的小样本。换句话说，并不是所有应用程序都可以使用30％的加速，并且里程数可能会有所不同。</p>
</li>
<li>
<p>手动配置比较脆弱，很难猜测。如果编写的其他应用程序做的事情稍有不同，则需要导入不同的配置。您可以通过将其提取到便利类或注释中并重新使用来减轻这种情况。</p>
</li>
<li>
<p>就配置类的顺序而言， <code>@Import</code> <code>@EnableAutoConfiguration</code>行为与<code>@EnableAutoConfiguration</code> 。如果某些类具有依赖早期类的条件行为，则该顺序在<code>@Import</code>中很重要。为了减轻压力，您只需要小心。</p>
</li>
<li>
<p>在典型的实际应用中，还有另一个排序问题。为了模仿<code>@EnableAutoConfiguration</code>的行为，您需要首先处理用户配置，以便他们可以覆盖Spring Boot中的条件配置。如果使用<code>@ComponentScan</code> ，则无法控制扫描的顺序，也无法控制与<code>@Imports</code>相比处理这些类的顺序。您可以使用其他注释来缓解这种情况（请参见下文）。</p>
</li>
<li>
<p>实际上，从未设计过将Spring Boot自动配置用于这种方式，这样做可能会在您的应用程序中引入一些细微的错误。唯一的缓解方法是按您期望的方式进行详尽的测试，并谨慎对待升级。</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="adding-actuators"><a class="anchor" href="#adding-actuators"></a>添加执行器</h3>
<div class="paragraph">
<p>如果执行器在类路径中，我们也可以添加它们：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootConfiguration
@Import({
    WebFluxAutoConfiguration.class,
    ReactiveWebServerFactoryAutoConfiguration.class,
    ErrorWebFluxAutoConfiguration.class,
    HttpHandlerAutoConfiguration.class,
    EndpointAutoConfiguration.class,
    HealthIndicatorAutoConfiguration.class, HealthEndpointAutoConfiguration.class,
    InfoEndpointAutoConfiguration.class, WebEndpointAutoConfiguration.class,
    ReactiveManagementContextAutoConfiguration.class,
    ManagementContextAutoConfiguration.class,
    ConfigurationPropertiesAutoConfiguration.class,
    PropertyPlaceholderAutoConfiguration.class
})
@RestController
public class DemoApplication {

  @GetMapping("/")
  public Mono<String> home() {
    return Mono.just("Hello World");
  }

  public void main(String[] args) {
    SpringApplication.run(DemoApplication.class, args);
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>与完整的<code>@EndpointAutoConfiguration</code>应用程序相比，该应用程序的启动速度甚至更快（甚至可能快50％），因为我们只包括了与两个默认端点有关的配置。默认情况下，Spring Boot会激活所有端点，但不会将它们暴露给HTTP。如果我们只关心/ health和/ info这是浪费的，但是当然，它也会在表上留下很多真正有用的功能。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">Spring Boot将来可能会做得更多，以禁用尚未暴露或尚未使用的执行器。例如，在<a href="https://github.com/spring-projects/spring-boot/issues/7578">惰性执行器</a>和<a href="https://github.com/spring-projects/spring-boot/issues/15451">条件端点</a> （已经在Spring Boot 2.1.2中）中看到了问题。
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="what-s-the-difference"><a class="anchor" href="#what-s-the-difference"></a>有什么不同？</h3>
<div class="paragraph">
<p>手动配置的应用程序有51个bean，而完全配置的自动配置的应用程序有107个bean（不包括执行器）。因此，启动速度更快一点也就不足为奇了。在继续介绍实现示例应用程序的其他方法之前，让我们看一下为了使它更快地启动而遗漏的内容。如果您在两个应用程序中都列出了bean定义，您将看到所有差异都来自我们遗漏的自动配置，而Spring Boot并没有排除这些自动配置。这是列表（假设您使用的是<code>spring-boot-start-webflux</code> ，没有手动排除项）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>AutoConfigurationPackages
CodecsAutoConfiguration
JacksonAutoConfiguration
JmxAutoConfiguration
ProjectInfoAutoConfiguration
ReactorCoreAutoConfiguration
TaskExecutionAutoConfiguration
TaskSchedulingAutoConfiguration
ValidationAutoConfiguration
HttpMessageConvertersAutoConfiguration
RestTemplateAutoConfiguration
WebClientAutoConfiguration</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，这是我们不需要的12种自动配置（无论如何），并且在自动配置的应用程序中导致了56个额外的bean。它们都提供了有用的功能，因此我们可能希望有一天再次包含它们，但是现在让我们假设我们很乐意生活而无需他们做什么。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">
<code>spring-boot-autoconfigure</code>具有122种自动配置（ <code>spring-boot-actuator-autoconfigure</code>还有更多），而上面完全引导的自动配置示例应用程序仅使用了18种。要使用哪一个进行计算很早，并且甚至在加载任何类之前，大多数都会被Spring Boot丢弃。这是非常快的（几毫秒）。
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-boot-autoconfiguration-imports"><a class="anchor" href="#spring-boot-autoconfiguration-imports"></a> Spring Boot自动配置导入</h2>
<div class="sectionbody">
<div class="paragraph">
<p>与用户配置（必须首先应用）和自动配置之间的差异相关的排序问题可以通过使用不同的注释部分解决。Spring Boot为此提供了一个注释： <code>@ImportAutoConfiguration</code> ，它来自<code>spring-boot-autoconfigure</code>但在Spring Boot Test附带的<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests">测试片</a>功能中使用。所以可以更换<code>@Import</code>在实施例上面注释<code>@ImportAutoConfiguration</code>和效果是将autoconfigurations的延迟处理，直到所有的用户配置之后（例如，通过拿起<code>@ComponentScan</code>或<code>@Import</code> ）。</p>
</div>
<div class="paragraph">
<p>如果我们准备将自动配置列表整理到自定义注释中，我们甚至可以走得更远。除了将它们复制到显式的<code>@ImportAutoConfiguration</code> ，我们还可以编写如下的自定义注释：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@ImportAutoConfiguration
public @interface EnableWebFluxAutoConfiguration {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此annotation的主要功能是使用<code>@ImportAutoConfiguration</code>元annotation。有了这个，我们可以将新注释添加到我们的应用程序中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootConfiguration
@EnableWebFluxAutoConfiguration
@RestController
public class DemoApplication {

  @GetMapping("/")
  public Mono<String> home() {
    return Mono.just("Hello World");
  }

  public void main(String[] args) {
    SpringApplication.run(DemoApplication.class, args);
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>并在<code>/META-INF/spring.factories</code>列出实际的配置类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>com.example.config.EnableWebFluxAutoConfiguration=\
org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\
org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\
org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样做的好处是应用程序代码不再需要手动枚举配置，而且Spring Boot现在可以解决排序问题（属性文件条目在使用之前进行了排序）。缺点是，它仅对需要这些功能的应用程序有用，并且在想要做一些不同的工作的任何应用程序中都必须替换或扩充。尽管它仍然很快-Spring Boot在簿记（排序和排序）方面做了一些额外的工作，但并不是很多。在具有正确的JVM标志的正确硬件上，它可能仍会在不到700毫秒内启动。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="functional-bean-definitions"><a class="anchor" href="#functional-bean-definitions"></a>功能Bean定义</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在之前的文章中，我提到了功能性bean定义将是使应用程序从Spring启动的最有效方法。仍然是这种情况，我们可以通过将所有Spring Boot自动配置重写为<code>ApplicationContextInitializers</code> ，从该应用程序中挤出大约10％的空间。您可以手动执行此操作，也可以使用一些已经为您准备好的初始化程序，只要您不介意尝试一些实验性功能即可。当前有两个项目正在积极探索基于功能bean定义的新工具和新编程模型的思想： <a href="https://github.com/spring-projects/spring-fu">Spring Fu</a>和<a href="https://github.com/spring-projects-experimental/spring-init">Spring Init</a> 。两者都至少提供了最少的功能Bean定义集来替换或包装Spring Boot自动配置。Spring Fu是基于API（DSL）的，并且不使用反射或注释。Spring Init具有功能性的bean定义，并且还具有用于“点菜”配置的基于注释的编程模型的原型。两者在其他地方都有更详细的介绍。</p>
</div>
<div class="paragraph">
<p>这里要注意的要点是功能Bean定义更快，但是，如果这是您的主要关注点，请记住，这只是10％的效果。一旦将所有功能放回到上面精简的应用程序中，就可以重新加载所有必需的类，并且返回大致相同的启动时间。换句话说，运行时<code>@Configuration</code>处理的成本不能完全忽略不计，但也并不是很高（在这些小型应用程序中约为10％，或者可能为100ms）。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="summary-and-future-directions"><a class="anchor" href="#summary-and-future-directions"></a>摘要和未来方向</h2>
<div class="sectionbody">
<div class="paragraph">
<p>这是一张图表，总结了来自不同应用程序<a href="https://github.com/spring-projects/spring-petclinic">Spring PetClinic的</a>一些基准测试结果：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQpSEfx0Y1W9aD3XVyn91-S0jtUp2DRCQSy_W_LMGyMR91YLAQ1mL7MiR1BRd8VzshvtuxzL6WAnlxf/pubchart?oid=1003506885&format=image" alt="pubchart？oid = 1003506885＆format = image">
</div>
<div class="title">图1。Petclinic启动时间（秒）</div>
</div>
<div class="paragraph">
<p>它不是一个“真实的”应用程序，但是比简单的示例重，并且在运行时使用了更多功能（例如Hibernate），因此它更加实际。有两种版本，“演示”和“执行器”，后者与“执行器”相同。对于这两个示例，最快的启动时间是黄点，这是功能性bean的定义，但仅落后10％（在此应用程序中约为200ms）的是“点菜”选项（绿色和红色）。Green使用自定义注释，例如上面的<code>@EnableWebFluxAutoConfiguration</code> 。红色是一个不同的“点菜”选项，其中自动配置组可以通过一个不同的自定义注释（当前名称为<code>@SpringInitApplication</code> ，并在Spring Init中进行原型化）一起导入。蓝色是完全引导的自动配置（即装即用的Spring Boot）。</p>
</div>
<div class="paragraph">
<p>Spring Boot自动配置非常方便，但是可以称为“随便吃”。当前（从2.1.x版本开始）它可能提供的功能比某些应用程序使用或需要的功能更多。通过“点菜”方法，您可以将Spring Boot用作准备好的和预先测试的配置的便捷集合，并选择要使用的零件。如果这样做，则<code>@ImportAutoConfiguration</code>是该工具箱的重要组成部分，但是随着我们对该主题进行进一步研究，确切地应该以最佳方式使用它可能会发生变化。Spring Boot的未来版本以及可能的其他新项目，例如Spring Fu或Spring Init，将使自动运行或显式选择更容易地缩小运行时使用的配置的选择范围。归根结底，运行时<code>@Configuration</code>处理不是免费的，但也不是特别昂贵（尤其是对于Spring Boot 2.1.x）。使用的功能越少，加载的类就越少，这可以加快启动速度。归根结底，我们并不希望<code>@EnableAutoConfiguration</code>会失去其价值或知名度，并且请记住您的工作量可能会有所不同：本文中的PetClinic和简单示例并不能指导您使用更大，更复杂的产品应用程序。</p>
</div>
</div>
</div></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">var disqus_shortname = 'spring-io';
      var disqus_identifier = 3545;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));</script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });</script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>