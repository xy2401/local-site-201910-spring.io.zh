<!DOCTYPE html>
<html data-code-prettify="" data-mobile-support="" data-search="">
<head>
<title>Manual Bean Definitions in Spring Boot</title>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no" id="Viewport" name="viewport" />
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png" />
<link href="https://fonts.googleapis.com/css?family=Varela+Round|Montserrat:400,700" rel="stylesheet" type="text/css" />
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css" />
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M" name="google-site-verification" />

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css" />

<meta content="summary" name="twitter:card" />
<meta content="@springcentral" name="twitter:site" />
<meta name="twitter:title" content="Manual Bean Definitions in Spring Boot" />
<meta name="twitter:description" content="&lt;div class=&quot;paragraph&quot;&gt; 
 &lt;p&gt;Suppose you want to use Spring Boot, but you don’t want to &lt;code&gt;@EnableAutoConfiguration&lt;/code&gt;. What should you do exactly? In an &lt;a href=&quot;https://spring.io/blog/2018/12/12/how-fast-is-spring&quot;&gt;earlier article&lt;/a&gt; I showed that Spring is intrinsically fast and lightweight, but one of the short pieces of advice improve startup time was to consider manually importing the Spring Boot autoconfigurations, instead of sucking them all in automatically. It won’t be the right thing to do for all applications, but it might help, and it certainly won’t hurt to understand what the options are. In this piece we explore various ways of doing manual configuration and assess their impact.&lt;/p&gt; 
&lt;/div&gt;
" />
<meta name="twitter:creator" content="@david_syer" />
<meta name="twitter:image:src" content="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=200" />

<meta property="og:title" content="Manual Bean Definitions in Spring Boot" />
<meta property="og:image" content="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=200" />
<meta property="og:description" content="&lt;div class=&quot;paragraph&quot;&gt; 
 &lt;p&gt;Suppose you want to use Spring Boot, but you don’t want to &lt;code&gt;@EnableAutoConfiguration&lt;/code&gt;. What should you do exactly? In an &lt;a href=&quot;https://spring.io/blog/2018/12/12/how-fast-is-spring&quot;&gt;earlier article&lt;/a&gt; I showed that Spring is intrinsically fast and lightweight, but one of the short pieces of advice improve startup time was to consider manually importing the Spring Boot autoconfigurations, instead of sucking them all in automatically. It won’t be the right thing to do for all applications, but it might help, and it certainly won’t hurt to understand what the options are. In this piece we explore various ways of doing manual configuration and assess their impact.&lt;/p&gt; 
&lt;/div&gt;
" />
<meta content="article" property="og:type" />
<meta property="og:article:published_time" content="2019-01-21 14:32:00.0" />
</head>
<body>

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" style="display:none;visibility:hidden" width="0"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">Projects</a>
</li>
<li class="navbar-link">
<a href="/guides">Guides</a>
</li>
<li class="navbar-link active">
<a href="/blog">Blog</a>
</li>
<li class="navbar-link">
<a href="/services">Training & Certification</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form action="/search" class="form-inline form-search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search for documentation, guides, and posts..." type="text" value="" />
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form action="/search" class="form-inline form-search" method="get">
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search..." type="text" value="" />
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">
Home
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">
Projects
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">
Guides
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">
Blog
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">
Training & Certification
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>Engineering</div>
</div>
<div class="blog-category content--title">
<div>Releases</div>
</div>
<div class="blog-category content--title">
<div>News and Events</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Manual Bean Definitions in Spring Boot</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">Engineering</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=20&amp;d=mm" />
<a class="author" rel="author" href="/team/dsyer">Dave Syer</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2019-01-21 14:32:00.0">January 21, 2019</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" data-disqus-identifier="3545" href="/blog/2019/01/21/manual-bean-definitions-in-spring-boot#disqus_thread">
</a></div>
</div>
</header>
<div class="blog--post"><div class="paragraph">
<p>Suppose you want to use Spring Boot, but you don&#8217;t want to
<code>@EnableAutoConfiguration</code>. What should you do exactly? In an
<a href="https://spring.io/blog/2018/12/12/how-fast-is-spring">earlier article</a>
I showed that Spring is intrinsically fast and lightweight, but one of
the short pieces of advice improve startup time was to consider
manually importing the Spring Boot autoconfigurations, instead of
sucking them all in automatically. It won&#8217;t be the right thing to do
for all applications, but it might help, and it certainly won&#8217;t hurt
to understand what the options are. In this piece we explore various
ways of doing manual configuration and assess their impact.</p>
</div>
<div class="sect1">
<h2 id="full-autoconfiguration-hello-world-webflux"><a class="anchor" href="#full-autoconfiguration-hello-world-webflux"></a>Full Autoconfiguration: Hello World WebFlux</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As a baseline, let&#8217;s look at a Spring Boot application that has a
single HTTP endpoint:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
@RestController
public class DemoApplication {

  @GetMapping("/")
  public Mono&lt;String&gt; home() {
    return Mono.just("Hello World");
  }

  public void main(String[] args) {
    SpringApplication.run(DemoApplication.class, args);
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you run this app with all the tweaks suggested in the earlier
article it should start in round about a second, or a bit longer
depending on your hardware. It does a lot in that time - sets up a
logging system, reads and binds to configuration files, starts Netty
and listens on port 8080, providing a route to the <code>@GetMapping</code> in
the application, and also provides default error handling. If the
Spring Boot Actuator is on the classpath, you also get a /health and
an /info endpoint (and it will take a bit longer to start up because
of that).</p>
</div>
<div class="paragraph">
<p>The <code>@SpringBootApplication</code> annotation, in case you didn&#8217;t know, is
meta-annotated with <code>@EnableAutoConfiguration</code> and this is what
provides all that useful functionality for free. That&#8217;s what makes
Spring Boot popular, so we don&#8217;t want to lose any of it, but we can
take a closer look at what is actually happening and maybe do some of
it manually, to see if we learn anything.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
if you want to try this code out, it&#8217;s easy to get an empty
WebFlux app from the <a href="https://spring.io">Spring Initializr</a>. Just select
the "Reactive Web" checkbox and download the project.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="manual-imports-of-autoconfiguration"><a class="anchor" href="#manual-imports-of-autoconfiguration"></a>Manual Imports of Autoconfiguration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>While the <code>@EnableAutoConfiguration</code> feature makes adding features to
an application easy, it also takes away some control over which
features are enabled. Most people are happy to make that compromise -
the ease of use outweighs the loss of control. Potentially there are
performance penalties - the application might start a bit slower
because Spring Boot has to do some work to find all those features and
install them. In fact there is not a significant amount of effort
involved in finding the right features: there is no classpath scan,
and condition evaluation is extremely fast, after careful
optimization. The bulk (80% or so) of startup time for one of this
application is taken up by the JVM loading classes, so practically the
only way to make it start up quicker is to ask it to do less, by
installing fewer features.</p>
</div>
<div class="paragraph">
<p>Autoconfiguration can always be disabled using the <code>exclude</code> attribute
in the <code>@EnableAutoConfiguration</code> annotation. Some individual
autoconfigurations also have their own boolean configuration flag that
can be set externally, e.g. for JMX we could use
<code>spring.jmx.enabled=false</code> (as a System property or in a properties
file, for example). We could go down that road and manually switch off
everything we didn&#8217;t want to use, but that gets a bit clumsy and
doesn&#8217;t stop additional things being switched on if the classpath
changes.</p>
</div>
<div class="paragraph">
<p>Instead, let&#8217;s see what we can do using the existing autoconfiguration
classes but just applying the ones we know we want to use,
corresponding to the features we like. We could call this the "a la
carte" approach, as opposed to "all you can eat" that comes with full
autoconfiguration. Autoconfiguration classes are just regular
<code>@Configuration</code> so in principle we can <code>@Import</code> them into an
application that does not <code>@EnableAutoConfiguration</code>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Don&#8217;t do this without reading the rest of the article. It&#8217;s
not the right way to use Spring Boot Autoconfiguration. It might break
something, but as always your mileage may vary.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For example, here is the application above, with all the features we
want (excluding actuators):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootConfiguration
@Import({
    WebFluxAutoConfiguration.class,
    ReactiveWebServerFactoryAutoConfiguration.class,
    ErrorWebFluxAutoConfiguration.class,
    HttpHandlerAutoConfiguration.class,
    ConfigurationPropertiesAutoConfiguration.class,
    PropertyPlaceholderAutoConfiguration.class
})
@RestController
public class DemoApplication {

  @GetMapping("/")
  public Mono&lt;String&gt; home() {
    return Mono.just("Hello World");
  }

  public void main(String[] args) {
    SpringApplication.run(DemoApplication.class, args);
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This version of the application will still have all the features we
described above, but will start faster (probably by 30% or so). So
what did we give up to get that faster start up? Here&#8217;s a quick
rundown:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The full features set of Spring Boot autoconfiguration includes
other stuff that might actually be needed in a real application, as
opposed to the specific tiny sample. In other words, the 30% speed up
is not going to be available for all applications, and your mileage
may vary.</p>
</li>
<li>
<p>The manual configuration is brittle, and hard to guess. If you wrote
another application that did slightly different things, you would need
a different configuration import. You can mitigate this by extracting
it into a convenience class or annotation, and re-using it.</p>
</li>
<li>
<p>An <code>@Import</code> does not behave the same way as
<code>@EnableAutoConfiguration</code> in relation to ordering of configuration
classes. The order is important within the <code>@Import</code> in case some
classes have conditional behaviour that depend on earlier
classes. To mitigate you just have to be careful.</p>
</li>
<li>
<p>There is another ordering problem in a typical real-world
application. To mimic the behaviour of <code>@EnableAutoConfiguration</code> you
need the user configurations to be processed first, so that they can
override the conditional configuration in Spring Boot. If you use
<code>@ComponentScan</code>, you can&#8217;t control the order of the scan, or the
order those classes are processed compared to <code>@Imports</code>. You can
mitigate this by using a different annotation (see below).</p>
</li>
<li>
<p>The Spring Boot autoconfigurations were actually never designed to
be used this way, and doing so might introduce subtle bugs in your
application. The only mitigations for this are exhaustive testing that
it works the way you expect, and being cautious about upgrades.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="adding-actuators"><a class="anchor" href="#adding-actuators"></a>Adding Actuators</h3>
<div class="paragraph">
<p>We can also add the actuators if they are on the classpath:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootConfiguration
@Import({
    WebFluxAutoConfiguration.class,
    ReactiveWebServerFactoryAutoConfiguration.class,
    ErrorWebFluxAutoConfiguration.class,
    HttpHandlerAutoConfiguration.class,
    EndpointAutoConfiguration.class,
    HealthIndicatorAutoConfiguration.class, HealthEndpointAutoConfiguration.class,
    InfoEndpointAutoConfiguration.class, WebEndpointAutoConfiguration.class,
    ReactiveManagementContextAutoConfiguration.class,
    ManagementContextAutoConfiguration.class,
    ConfigurationPropertiesAutoConfiguration.class,
    PropertyPlaceholderAutoConfiguration.class
})
@RestController
public class DemoApplication {

  @GetMapping("/")
  public Mono&lt;String&gt; home() {
    return Mono.just("Hello World");
  }

  public void main(String[] args) {
    SpringApplication.run(DemoApplication.class, args);
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This app starts even faster comparative to the full
<code>@EndpointAutoConfiguration</code> application (maybe even 50% faster),
because we only included the configuration relevant to the two default
endpoints. Spring Boot activates all endpoints by default but does not
expose them to HTTP. If we only care about /health and /info that is
wasteful, but of course it also leaves a lot of really useful features
on the table.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Spring Boot may well do more in the future to disable actuators
that have not been exposed or have not been used. E.g. see issues on
<a href="https://github.com/spring-projects/spring-boot/issues/7578">lazy
actuators</a> and
<a href="https://github.com/spring-projects/spring-boot/issues/15451">conditional
endpoints</a> (which is already in Spring Boot 2.1.2).
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="what-s-the-difference"><a class="anchor" href="#what-s-the-difference"></a>What&#8217;s the difference?</h3>
<div class="paragraph">
<p>The manually configured application has 51 beans, while the fully
leaded autoconfigured application has 107 beans (not counting
actuators). So it&#8217;s maybe not a surprise that it starts up a bit
quicker. Before we move on to a different way to implement the sample
application, let&#8217;s take a look at what we have left out in order to
get it to start up faster. If you list the bean definitions in both
apps you will see that all the differences come from the
autoconfigurations that we left out, and which would not have been
conditionally excluded by Spring Boot. Here&#8217;s the list (assuming that
you are using <code>spring-boot-start-webflux</code> with no manual exclusions):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>AutoConfigurationPackages
CodecsAutoConfiguration
JacksonAutoConfiguration
JmxAutoConfiguration
ProjectInfoAutoConfiguration
ReactorCoreAutoConfiguration
TaskExecutionAutoConfiguration
TaskSchedulingAutoConfiguration
ValidationAutoConfiguration
HttpMessageConvertersAutoConfiguration
RestTemplateAutoConfiguration
WebClientAutoConfiguration</code></pre>
</div>
</div>
<div class="paragraph">
<p>So that&#8217;s 12 autoconfigurations that we didn&#8217;t need (yet anyway) and
which led to 56 additional beans in the autoconfigured
application. They all provide useful features, so we might want to
include them again one day, but for now let&#8217;s assume that we are happy
to live without whatever they are doing.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<code>spring-boot-autoconfigure</code> has 122 autoconfigurations (there
are more in <code>spring-boot-actuator-autoconfigure</code>) and the fully leaded
autoconfigured sample application above only used 18 of them. The
computation of which ones to use takes place very early and most of
them are discarded by Spring Boot before any classes are even
loaded. It&#8217;s very fast (a few milliseconds).
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-boot-autoconfiguration-imports"><a class="anchor" href="#spring-boot-autoconfiguration-imports"></a>Spring Boot Autoconfiguration Imports</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The ordering issue associated with the difference between user
configuration (which has to be applied first) and autoconfiguration can
be addressed partially by using a different annotation. Spring Boot
provides an annotation for this: <code>@ImportAutoConfiguration</code>, which is
from <code>spring-boot-autoconfigure</code> but used in the
<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests">test
slices</a> features that ship with Spring Boot Test. So you can replace
the <code>@Import</code> annotation in the examples above with
<code>@ImportAutoConfiguration</code> and the effect is to defer processing of
the autoconfigurations until after all the user configurations
(e.g. picked up via <code>@ComponentScan</code> or <code>@Import</code>).</p>
</div>
<div class="paragraph">
<p>We can even go a stage further than that if we are prepared to curate
the list of autoconfigurations into a custom annotation. Instead of
just copying them into an explicit <code>@ImportAutoConfiguration</code>, we can
write a custom annotation like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@ImportAutoConfiguration
public @interface EnableWebFluxAutoConfiguration {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The main feature of this annotation is that it is meta-annotated with
<code>@ImportAutoConfiguration</code>. With that in place we can add the new
annotation to our application:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootConfiguration
@EnableWebFluxAutoConfiguration
@RestController
public class DemoApplication {

  @GetMapping("/")
  public Mono&lt;String&gt; home() {
    return Mono.just("Hello World");
  }

  public void main(String[] args) {
    SpringApplication.run(DemoApplication.class, args);
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and list the actual configuration classes in <code>/META-INF/spring.factories</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>com.example.config.EnableWebFluxAutoConfiguration=\
org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\
org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\
org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration</code></pre>
</div>
</div>
<div class="paragraph">
<p>The advantages of doing this are that the application code no longer
has to manually enumerate the configurations, and also that the
ordering is now taken care of by Spring Boot (the properties file
entry is sorted before it is used). The disadvantage is that it is
only useful for applications which need precisely these features, and
has to be replaced or augmented in any application that wants to do
something a bit different. It is still fast though - Spring Boot does
a little bit of extra work for the book keeping (sorting and
ordering), but not really very much. It will probably still start in
less than 700ms on the right hardware, with the right JVM flags.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="functional-bean-definitions"><a class="anchor" href="#functional-bean-definitions"></a>Functional Bean Definitions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the earlier article I mentioned that functional bean definitions
would be the most efficient way to get an application started with
Spring. This is still the case, and we can squeeze an extra 10% or so
out of this application by re-writing all the Spring Boot
autoconfigurations as <code>ApplicationContextInitializers</code>. You could do
that manually, or you could use some initializers that have already
been prepared for you, as long as you don&#8217;t mind trying out some
experimental features. There are 2 projects currently active exploring
the idea of new tools and new programming models based on functional
bean definitions: <a href="https://github.com/spring-projects/spring-fu">Spring
Fu</a> and
<a href="https://github.com/spring-projects-experimental/spring-init">Spring
Init</a>. Both provide at least a minimal set of functional bean
definitions replacing or wrapping the Spring Boot
autoconfigurations. Spring Fu is API (DSL) based, and doesn&#8217;t use
reflection or annotations. Spring Init has the functional bean
definitions and also has a prototype of an annotation-based
programming model for "a la carte" configuration. Both are covered
in more detail elsewhere.</p>
</div>
<div class="paragraph">
<p>The main point to note here is that functional bean definitions are
faster, but if that is your main concern, remember that it is only a
10% effect. As soon as you put all the features back in the
application that we stripped down above, you are back to loading all
the necessary classes and back to roughly the same approximate startup
time as well. To put this another way, the cost of the
<code>@Configuration</code> processing at runtime is not completely negligible,
but it also isn&#8217;t very high (10% or so in these tiny apps, or maybe
100ms).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="summary-and-future-directions"><a class="anchor" href="#summary-and-future-directions"></a>Summary and Future Directions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Here&#8217;s a graph summarizing some benchmark results from a different
application, the <a href="https://github.com/spring-projects/spring-petclinic">Spring PetClinic</a>:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://docs.google.com/spreadsheets/d/e/2PACX-1vQpSEfx0Y1W9aD3XVyn91-S0jtUp2DRCQSy_W_LMGyMR91YLAQ1mL7MiR1BRd8VzshvtuxzL6WAnlxf/pubchart?oid=1003506885&format=image" alt="pubchart?oid=1003506885&amp;format=image">
</div>
<div class="title">Figure 1. Petclinic Startup Time (Seconds)</div>
</div>
<div class="paragraph">
<p>It&#8217;s not a "real" application, but it is heavier than the simple
sample, and uses a lot more features at runtime (like Hibernate for
example), so it is somewhat more realistic. There are two
versions, "demo" and "actr", where the latter is just the same but
with Actuators. For both samples, the fastest startup time is the
yellow dot, which is functional bean definitions, but only 10% behind
that (about 200ms in this app) are the "a la carte" options (green and
red). Green uses a custom annotation like the
<code>@EnableWebFluxAutoConfiguration</code> one above. Red is a different "a la
carte" option where groups of autoconfigurations can be imported
together via a different custom annotation, currently named
<code>@SpringInitApplication</code> and being prototyped in Spring Init. Blue is
the fully leaded autoconfiguration (out of the box Spring Boot).</p>
</div>
<div class="paragraph">
<p>Spring Boot autoconfiguration is hugely convenient, but can be
characterized as "all you can eat". Currently (as of 2.1.x) it is
maybe providing more features than some applications use or
require. In the "a la carte" approach, you can use Spring Boot as a
convenient collection of prepared and pre-tested configurations and
choose which parts you use. If you do that then
<code>@ImportAutoConfiguration</code> is an important part of the toolkit, but
exactly how you should best use it might change as we research this
topic further. Future versions of Spring Boot, and possibly other new
projects like Spring Fu or Spring Init, will make it easier to narrow
the choice of configurations used at runtime, either automatically or
by explicit choice. At the end of the day, <code>@Configuration</code> processing
at runtime is not free, but it isn&#8217;t particularly expensive either
(especially with Spring Boot 2.1.x). The smaller number of features
you use, the fewer classes are loaded, which lead to faster
startup. At the end of the day we don&#8217;t expect
<code>@EnableAutoConfiguration</code> to lose its value or its popularity, and
remember your mileage may vary: the PetClinic and simple samples in
this article are not a guide to what you can expect with larger, more
complex applications.</p>
</div>
</div>
</div></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 3545;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>
Back
</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">All Posts</a>
<a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">Engineering</a>
<a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">Releases</a>
<a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">News and Events</a>
<a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>Get updates from The Spring Team delivered to your inbox</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">Tools</a></li>
<li><a href="https://store.pivotal.io/">Store</a></li>
<li><a href="/blog">Newsletter</a></li>
</ul>
</div>
</div>
&copy; <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a>, Inc. All Rights Reserved.
<a href="https://pivotal.io/terms-of-use">Terms of Use</a> &bullet;
<a href="https://pivotal.io/privacy-policy">Privacy</a> &bullet;
<a href="/trademarks">Trademark Guidelines</a>
<div id="teconsent" style="display:inline-block;"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>