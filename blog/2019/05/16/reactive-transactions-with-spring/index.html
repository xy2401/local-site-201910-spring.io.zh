<html  data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>与Spring进行反应式交易</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Reactive Transactions with Spring">
<meta name="twitter:description" >
<meta name="twitter:creator" content="@mp911de">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/6494a9d91e9ffef9adc8253257f1b35e?s=200">

<meta property="og:title" content="Reactive Transactions with Spring">
<meta property="og:image" content="https://gravatar.com/avatar/6494a9d91e9ffef9adc8253257f1b35e?s=200">
<meta class="anchor" name="does-spring-framework-support-reactive-transaction" property="og:description" content="<p>Back in 2016, our reactive journey started with Spring Framework 5 accompanied by a couple of reactive integrations. Throughout our journey, other projects joined the reactive movement. With R2DBC, we now also provide a reactive integration for SQL databases. With the growth of transaction-capable integrations, we constantly got asked:</p>
<h2><a href=" #does-spring-framework-support-reactive-transactio="=">Does Spring Framework support Reactive @Transaction?
<p>At the time our journey began, we had no reactive form of transactional integrations, so this question was simple to answer: There’s no need for reactive transaction management. </p>
">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2019-05-16 06:59:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">与Spring进行反应式交易</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/6494a9d91e9ffef9adc8253257f1b35e?s=20&d=mm"> <a class="author" rel="author" href="/team/mp911de">马克·帕鲁奇</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2019-05-16 06:59:00.0">五月16，2019</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2019/05/16/reactive-transactions-with-spring#disqus_thread" data-disqus-identifier="3668">
</a></div>
</div>
</header>
<div class="blog--post"><p>早在2016年，我们的响应式旅程就从Spring Framework 5开始，伴随着几个响应式集成。在我们的整个旅程中，其他项目也加入了反动运动。借助R2DBC，我们现在还为SQL数据库提供了反应式集成。随着具有事务处理能力的集成的发展，我们不断被问到：</p><h2><a href="#does-spring-framework-support-reactive-transaction" class="anchor" name="does-spring-framework-support-reactive-transaction"></a> Spring Framework是否支持Reactive @Transaction？</h2>
<p>在我们的旅程开始之时，我们没有被动式的交易集成形式，所以这个问题很容易回答：不需要被动式的交易管理。</p>
<p>随着时间的流逝，MongoDB开始使用MongoDB Server 4.0支持多文档事务。R2DBC（反应式SQL数据库驱动程序的规范）开始出现，我们决定使用Spring Data R2DBC来使用R2DBC。两个项目都希望公开交易行为，因此他们最终提供了<code>inTransaction(…)</code>模板API上的方法来执行受本机事务保护的工作单元。</p>
<p>虽然使用起来很方便<code>inTransaction(…)</code>方法用于较小的工作量，它不能反映Spring支持事务的方式。当使用命令式编程模型时，Spring Framework允许事务管理的两种安排： <code>@Transactional</code>和<code>TransactionTemplate</code> （分别声明性程序化交易管理）。</p>
<p>两种交易管理方法都建立在<code>PlatformTransactionManager</code> ，它管理交易资源的交易。 <code>PlatformTransactionManager</code>可以是Spring提供的事务管理器实现，也可以是基于JTA的Java EE。</p>
<p>两种方法的共同点是它们将事务状态绑定到<code>ThreadLocal</code>存储，允许进行事务状态管理而无需传递<code>TransactionStatus</code>宾语。交易管理应在后台以非侵入方式进行。<br><code>ThreadLocal</code>之所以以命令式编程方式工作是因为基本假设，即我们不使用线程来继续事务中的工作。</p><h2><a href="#how-imperative-transaction-management-works" class="anchor" name="how-imperative-transaction-management-works"></a>命令性交易管理如何工作</h2>
<p>事务管理需要将其事务状态与执行关联。在命令式编程中，这通常是<code>ThreadLocal</code>存储–事务状态绑定到<code>Thread</code> 。基本假设是事务代码在容器调用它的同一线程上执行。</p>
<p>反应式编程模型消除了命令式（同步/阻塞）编程模型的基本假设。仔细研究响应式执行，我们可以观察到代码在不同的线程上执行。使用进程间通信时，这一点更加明显。我们不能再安全地假设我们的代码已在同一线程上完全执行。</p>
<p>假设的这种更改会使依赖于<code>ThreadLocal</code> 。</p>
<p>由于集成和优化（例如运算符融合），线程切换在任意时间发生。此更改将破坏所有依赖的代码<code>ThreadLocal</code> 。结果是我们需要一种不同的安排来反映交易状态，而又不会通过<code>TransactionStatus</code>一直反对。</p>
<p>关联带外数据并不是反应空间中的新要求。我们在其他领域（例如<code>SecurityContext</code>使用Spring Security来实现反应性方法安全性（仅举一个例子）。从3.1版开始，Project Reactor是Spring在其之上建立其反应式支持的反应式库，它为订户上下文提供了支持。</p>
<p>反应堆<code>Context</code>反应式编程是什么<code>ThreadLocal</code>是命令式编程：上下文允许将上下文数据绑定到特定执行。对于反应式编程，这是一个<code>Subscription</code> 。反应堆<code>Context</code>让Spring将事务状态以及所有资源和同步绑定到特定的<code>Subscription</code> 。现在，所有使用Project Reactor的反应式代码都可以参与反应式事务。返回标量值并想要访问事务详细信息的代码必须进行重写，以使用反应性类型来参与事务。否则， <code>Context</code>不可用。</p><h2><a href="#reactive-transaction-management" class="anchor" name="reactive-transaction-management"></a>反应式交易管理</h2>
<p>从Spring Framework 5.2 M2开始，Spring通过以下方式支持反应式事务管理： <code>ReactiveTransactionManager</code> SPI。</p>
<p><code>ReactiveTransactionManager</code>是用于使用事务资源的反应性和非阻塞式集成的事务管理抽象。这是反应的基础<code>@Transactional</code>返回的方法<code>Publisher</code>类型和用于使用的程序化交易管理<code>TransactionalOperator</code> 。</p>
<p>前两个反应式事务管理器实现是：</p>
<ul>
<li>通过Spring Data R2DBC 1.0 M2进行R2DBC</li>
<li>通过Spring Data实现MongoDB MongoDB 2.2 M4</li>
</ul>
<p>让我们看一下反应式交易的样子：</p>
<pre><code class="prettyprint java">class TransactionalService {

  final DatabaseClient db

  TransactionalService(DatabaseClient db) {
    this.db = db;
  }

  @Transactional
  Mono&lt;Void&gt; insertRows() {

    return db.execute()
      .sql(&quot;INSERT INTO person (name, age) VALUES(&#39;Joe&#39;, 34)&quot;)
      .fetch().rowsUpdated()
      .then(db.execute().sql(&quot;INSERT INTO contacts (name) VALUES(&#39;Joe&#39;)&quot;)
      .then();
  }
}
</code></pre>
<p>在注释驱动的安排中，反应式事务看起来与命令式事务非常相似。不过，主要区别在于我们与<code>DatabaseClient</code> ，这是一种反应式资源抽象。所有交易管理都是在后台进行的，利用Spring的交易拦截器和<code>ReactiveTransactionManager</code> 。</p>
<p>Spring根据方法返回类型区分要应用的事务管理类型：</p>
<ul>
<li>方法返回一个<code>Publisher</code>类型：反应式交易管理</li>
<li>所有其他退货类型：强制性交易管理</li>
</ul>
<p>这种区别非常重要，因为您仍然可以使用命令性组件，例如JPA或JDBC查询。将这些结果包装成一个<code>Publisher</code>类型信号指示Spring应用反应式而非命令式事务管理。话虽如此，被动交易安排并没有打开<code>ThreadLocal</code>绑定事务，这是JPA或JDBC必需的。</p><h2><a href="#transactionaloperator" class="anchor" name="transactionaloperator"></a>交易操作员</h2>
<p>下一步，我们来看一下使用<code>TransactionalOperator</code> ：</p>
<pre><code class="prettyprint java">ConnectionFactory factory = …
ReactiveTransactionManager tm = new R2dbcTransactionManager(factory);
DatabaseClient db = DatabaseClient.create(factory);

TransactionalOperator rxtx = TransactionalOperator.create(tm);

Mono&lt;Void&gt; atomicOperation = db.execute()
  .sql(&quot;INSERT INTO person (name, age) VALUES(&#39;joe&#39;, &#39;Joe&#39;)&quot;)
  .fetch().rowsUpdated()
  .then(db.execute()
    .sql(&quot;INSERT INTO contacts (name) VALUES(&#39;Joe&#39;)&quot;)
    .then())
  .as(rxtx::transactional);
</code></pre>
<p>上面的代码包含一些值得注意的组件：</p>
<ul>
<li><code>R2dbcTransactionManager</code> ：这是R2DBC的反应式事务管理器<code>ConnectionFactory</code> 。</li>
<li><code>DatabaseClient</code> ：客户端使用R2DBC驱动程序提供对SQL数据库的访问。</li>
<li><code>TransactionalOperator</code> ：此运算符将所有上游R2DBC发布者与事务上下文相关联。您可以使用两种运算符样式<code>as(…::transactional)</code>或使用<code>execute(txStatus -> …)</code> 。</li>
</ul>
<p>订阅后会延迟启动反应式事务。操作员启动事务，设置适当的隔离级别，并将数据库连接与其订户上下文相关联。所有参与（上游） <code>Publisher</code>实例使用一个<code>Context</code>绑定事务连接。</p>
<p>反应功能操作员链可以是线性的（通过使用单个<code>Publisher</code> ）或非线性（通过合并多个流）。反应性交易会影响所有上游<code>Publisher</code>使用操作符样式时。将交易范围限制为一组特定的<code>Publisher</code> s，应用回调样式，如下：</p>
<pre><code class="prettyprint java">TransactionalOperator rxtx = TransactionalOperator.create(tm);

Mono&lt;Void&gt; outsideTransaction = db.execute()
  .sql(&quot;INSERT INTO person (name, age) VALUES(&#39;Jack&#39;, 31)&quot;)
  .then();

Mono&lt;Void&gt; insideTransaction = rxtx.execute(txStatus -&gt; {
  return db.execute()
    .sql(&quot;INSERT INTO person (name, age) VALUES(&#39;Joe&#39;, 34)&quot;)
    .fetch().rowsUpdated()
    .then(db.execute()
      .sql(&quot;INSERT INTO contacts (name) VALUES(&#39;Joe Black&#39;)&quot;)
      .then());
  }).then();

Mono&lt;Void&gt; completion = outsideTransaction.then(insideTransaction);
</code></pre>
<p>在上面的示例中，交易管理仅限于<code>Publisher</code>内订阅的实例<code>execute(…)</code> 。或者，换句话说，事务是有作用域的。 <code>Publisher</code>内的实例<code>execute(…)</code>参与交易，并且<code>Publisher</code>命名<code>outsideTransaction</code>在交易之外执行其工作。</p>
<p>R2DBC是Spring与反应式事务的集成之一。另一个集成是通过Spring Data MongoDB进行的MongoDB，您可以使用反应式编程将其用于参与多文档事务。</p>
<p>Spring Data MongoDB随附<code>ReactiveMongoTransactionManager</code>作为一个<code>ReactiveTransactionManager</code>实施。它创建一个会话并管理交易，以便在托管交易中执行的代码参与多文档交易。</p>
<p>以下示例显示了使用MongoDB进行程序化事务管理：</p>
<pre><code class="prettyprint java">ReactiveTransactionManager tm 
  = new ReactiveMongoTransactionManager(databaseFactory);
ReactiveMongoTemplate template = …
template.setSessionSynchronization(ALWAYS);                                          

TransactionalOperator rxtx = TransactionalOperator.create(tm);

Mono&lt;Void&gt; atomic = template.update(Step.class)
  .apply(Update.set(&quot;state&quot;, …))
  .then(template.insert(EventLog.class).one(new EventLog(…))
  .as(rxtx::transactional)
  .then();
</code></pre>
<p>上面的代码设置了一个<code>ReactiveTransactionManager</code>和用途<code>TransactionalOperator</code>在单个事务中执行多个写操作。 <code>ReactiveMongoTemplate</code>被配置为参与被动交易。</p><h2><a href="#next-steps" class="anchor" name="next-steps"></a>下一步</h2>
<p>Reactive Transaction Management随Spring Framework 5.2 M2，Spring Data MongoDB 2.2 M4和Spring Data R2DBC 1.0 M2里程碑版本一起提供。您可以选择这些，然后开始在代码中集成反应式事务管理。我们期待社区的反馈，以便我们可以在6月初发布候选版本之前消除任何尖锐的边缘。</p>
</div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 3668;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>