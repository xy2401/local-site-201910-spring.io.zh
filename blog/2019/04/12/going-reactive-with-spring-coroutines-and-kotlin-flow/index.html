<html  data-code-prettify="" data-mobile-support="" data-search=""><head></head><body >﻿
<title>与弹簧，协程和Kotlin流程反应</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Going Reactive with Spring, Coroutines and Kotlin Flow">
<meta name="twitter:description" >
<meta name="twitter:creator" content="@sdeleuze">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/5778521f67d80de0ee3b213e4f159a59?s=200">

<meta property="og:title" content="Going Reactive with Spring, Coroutines and Kotlin Flow">
<meta property="og:image" content="https://gravatar.com/avatar/5778521f67d80de0ee3b213e4f159a59?s=200">
<meta property="og:description" >
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2019-04-12 08:12:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">与弹簧，协程和Kotlin流程反应</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/5778521f67d80de0ee3b213e4f159a59?s=20&d=mm"> <a class="author" rel="author" href="/team/sdeleuze">塞巴斯蒂安·德勒兹（SébastienDeleuze）</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2019-04-12 08:12:00.0">2019年4月12日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2019/04/12/going-reactive-with-spring-coroutines-and-kotlin-flow#disqus_thread" data-disqus-identifier="3639">
</a></div>
</div>
</header>
<div class="blog--post"><div class="paragraph">
<p>自从我们在2017年1月宣布<a href="https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0">对Kotlin的Spring Framework官方支持</a>以来，发生了很多事情。Kotlin在Google I / O 2017上被宣布为Android的官方开发语言，我们继续在整个Spring产品组合中改进Kotlin的支持，并且Kotlin本身也随着<a href="https://kotlinlang.org/docs/reference/coroutines-overview.html">协同程序</a>等关键新功能而不断发展。</p>
</div>
<div class="paragraph">
<p>我想借此机会利用<a href="https://spring.io/blog/2019/04/10/spring-framework-5-2-0-m1-available-now">Spring Framework 5.2</a>的<a href="https://spring.io/blog/2019/04/10/spring-framework-5-2-0-m1-available-now">第一个里程碑，</a>概述一下Spring和Kotlin所处的位置。我将尽全力专注于具体的改进，因为我相信Spring和Kotlin具有相同的务实心态。</p>
</div>
<div class="paragraph">
<p>我认为一切都与选择有关。我们（Spring团队）提供的选择，以及您作为应用程序开发人员在启动新的Spring Boot应用程序时必须做出的选择。例如：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>我应该使用哪种语言？</p>
</li>
<li>
<p>带注释<code>@Controller</code>还是功能风格？</p>
</li>
<li>
<p>Spring MVC还是WebFlux？</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些问题显然是高度主观的，通常取决于项目环境，但是我将分享我的观点。</p>
</div>
<div class="sect1">
<h2 id="java-or-kotlin"><a class="anchor" href="#java-or-kotlin"></a> Java还是Kotlin？</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Java是显而易见的默认选择，但是<a href="https://kotlinlang.org/">Kotlin</a>是一种越来越流行的替代方法。导致开发人员从Java切换到Kotlin的原因是什么？当人们问我时，我通常会说Kotlin允许Java开发人员利用他们现有的技能来编写更短，更安全和更具表达力的代码。但是要做出明智的选择，我们应该确定更多具体的观点。</p>
</div>
<div class="paragraph">
<p>我最喜欢的Kotlin功能是<code>null</code> ，将（多个）“十亿美元的错误”转化为安全功能。Java的错误不是<code>null</code>本身，就是不要管理<code>null</code>显式地在其类型系统中，导致出现的问题与我们在动态语言中可以观察到的问题接近。Kotlin拥抱<code>null</code>通过在类型系统中使用它来<a href="https://medium.com/@elizarov/dealing-with-absence-of-value-307b80534903">处理价值的缺失</a> 。在Kotlin中，像<code>String</code>不可为空，因此在没有预防措施的情况下可以安全使用，而类似<code>String?</code>为可空值，应谨慎使用。好消息是Kotlin编译器将在编译时引发潜在的错误，您将能够通过<a href="https://kotlinlang.org/docs/reference/null-safety.html#safe-calls">安全调用</a> ， <a href="https://kotlinlang.org/docs/reference/null-safety.html#elvis-operator">elvis运算符</a>或<a href="https://kotlinlang.org/docs/reference/idioms.html#execute-if-not-null">如果不执行就</a>优雅地处理它们<a href="https://kotlinlang.org/docs/reference/idioms.html#execute-if-not-null"><code>null</code></a>块。与Java不同<code>Optional</code> ，Kotlin空安全性也适用于输入参数，并且不会强迫您使用会影响代码性能和可读性的包装器。</p>
</div>
<div class="paragraph">
<p><a href="https://kotlinlang.org/docs/reference/type-safe-builders.html">DSL</a>也是Kotlin的另一个亮点。<a href="https://gradle.org/kotlin/">摇篮科特林DSL</a> （上支持<a href="https://start.spring.io">start.spring.io</a>是<a href="https://github.com/spring-io/initializr/pull/851">指日可待</a> ）是一个很好的例子，允许使用非常丰富，灵活的API以极大的可发现性和信心，感谢科特林静态类型的性质。Spring Framework提供了Kotlin DSL，用于<a href="https://docs.spring.io/spring/docs/5.2.0.M1/spring-framework-reference/languages.html#kotlin-bean-definition-dsl">Bean定义</a> ， <a href="https://docs.spring.io/spring/docs/5.2.0.M1/spring-framework-reference/languages.html#kotlin-web">功能路由</a>甚至<a href="https://docs.spring.io/spring/docs/5.2.0.M1/spring-framework-reference/languages.html#mockmvc-dsl">MockMvc</a> 。</p>
</div>
<div class="paragraph">
<p>我可以详细说明其他许多进行切换的充分理由，例如<a href="https://kotlinlang.org/docs/reference/functions.html#default-arguments">带有默认值的可选参数，</a> <a href="https://kotlinlang.org/docs/reference/java-interop.html">与Java API</a> （如Spring）的<a href="https://kotlinlang.org/docs/reference/java-interop.html">强大互操作性</a> ， <a href="https://kotlinlang.org/docs/reference/">扩展函数</a> ，避免类型擦除的经过<a href="https://kotlinlang.org/docs/reference/inline-functions.html#reified-type-parameters">修饰的类型参数</a> ，默认情况下鼓励的<a href="https://kotlinlang.org/docs/reference/data-classes.html#data-classes">数据类</a>或不变性，但是我认为您应该仅<a href="https://play.kotlinlang.org/byExample/overview">通过示例来学习Kotlin，</a>最终在<a href="https://kotlinlang.org/docs/reference/">参考文档的</a>帮助下做出自己的判断。您还可以按照<a href="https://spring.io/guides/tutorials/spring-boot-kotlin/">Kotlin的</a>步骤逐步进行<a href="https://spring.io/guides/tutorials/spring-boot-kotlin/">Spring Boot教程</a> 。</p>
</div>
<div class="paragraph">
<p>所以说我将在下一个Spring Boot项目中选择Kotlin ;-)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="annotated-controller-or-functional-style"><a class="anchor" href="#annotated-controller-or-functional-style"></a>带注释<code>@Controller</code>还是功能风格？</h2>
<div class="sectionbody">
<div class="paragraph">
<p>正如我在导言中所说，选择取决于上下文，取决于品味。鉴于该语言非常<a href="https://docs.spring.io/spring/docs/5.2.0.M1/spring-framework-reference/languages.html#kotlin-web">出色</a>的DSL和功能编程能力，我非常喜欢<a href="https://docs.spring.io/spring/docs/5.2.0.M1/spring-framework-reference/languages.html#kotlin-web">Kotlin</a>的<a href="https://docs.spring.io/spring/docs/5.2.0.M1/spring-framework-reference/languages.html#kotlin-web">功能路由</a> 。我甚至工作探索我们如何能够在通过实验功能的方式定义春天启动的应用程序配置<a href="https://spring.io/blog/2018/10/02/the-evolution-of-spring-fu">甲府DSLSpring Boot</a>这是在培养<a href="https://github.com/spring-projects/spring-fu">春富</a>库。</p>
</div>
<div class="paragraph">
<p>但是今天，假设我们的团队由<code>@Controller</code>多年的编程模型，而我不想同时更改所有内容，所以让我们继续<code>@Controller</code> 。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-mvc-or-webflux"><a class="anchor" href="#spring-mvc-or-webflux"></a> Spring MVC还是WebFlux？</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我们在Web框架方面提出的选择如下。</p>
</div>
<div class="paragraph">
<p>您可以继续使用Spring MVC和我们不断改进的所有相关众所周知的技术：Tomcat，JPA等。您甚至可以通过使用以下反应性位来使用<code>WebClient</code>现代API代替<code>RestTemplate</code> 。</p>
</div>
<div class="paragraph">
<p>但是，我们还提供了一个反应式堆栈，其中包括<a href="https://docs.spring.io/spring/docs/5.2.0.M1/spring-framework-reference/web-reactive.html#webflux">WebFlux</a> ，这是一个基于<a href="http://www.reactive-streams.org/">Reactive Streams</a>的Web框架，适用于需要更高可伸缩性的人员，不受延迟影响的堆栈（对于面向微服务的体系结构很有用）以及更好的流处理功能。生态系统的其他部分（如Spring Data和Spring Security）也提供响应式支持。</p>
</div>
<div class="sect2">
<h3 id="webflux-with-reactor-api-in-java"><a class="anchor" href="#webflux-with-reactor-api-in-java"></a> Java中带有Reactor API的WebFlux</h3>
<div class="paragraph">
<p>到目前为止，通过使用Reactor <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html">Mono</a>和<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html">Flux</a>或类似RxJava的API，通过WebFlux使用Spring反应堆需要通过将IO相关功能（Web，持久性）从命令式转换为声明式/功能式样式进行相当大的转变。与命令式编程相比，这种破坏性方法具有真正的优势，但又有很大的不同，并且需要不小的学习曲线。</p>
</div>
<div class="paragraph">
<p>让我们看看具体代码的含义，并利用这一机会向您展示如何使用<a href="https://r2dbc.io/">R2DBC</a> （基于JDBC的基于反应流的替代方法）和<a href="https://spring.io/projects/spring-data-r2dbc">Spring Data R2DBC</a>以反应方式访问SQL数据库。</p>
</div>
<div class="paragraph">
<p>如果我们选择Java，我们将编写以下内容<code>UserRepository</code>公开反应式API的类，以使用<a href="https://docs.spring.io/spring-data/r2dbc/docs/1.0.0.M1/api/org/springframework/data/r2dbc/function/DatabaseClient.html"><code>DatabaseClient</code></a> Spring Data R2DBC提供的API。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">class UserRepository {

	private final DatabaseClient client;

	public UserRepository(DatabaseClient client) {
		this.client = client;
	}

	public Mono&lt;Long&gt; count() {
		return client.execute().sql("SELECT COUNT(*) FROM users")
			.as(Long.class).fetch().one();
	}

	public Flux&lt;User&gt; findAll() {
		return client.select().from("users").as(User.class).fetch().all();
	}

	public Mono&lt;User&gt; findOne(String id) {
		return client.execute()
			.sql("SELECT * FROM users WHERE login = :login")
			.bind("login", id).as(User.class).fetch().one();
	}

	public Mono&lt;Void&gt; deleteAll() {
		return client.execute().sql("DELETE FROM users").then();
	}

	public Mono&lt;Void&gt; save(User user) {
		return client.insert().into(User.class).table("users")
			.using(user).then();
	}

	public Mono&lt;Void&gt; init() {
		return client.execute().sql("CREATE TABLE ...").then()
			.then(deleteAll())
			.then(save(new User("smaldini", "Stéphane", "Maldini")))
			.then(save(new User("sdeleuze", "Sébastien", "Deleuze")))
			.then(save(new User("bclozel", "Brian", "Clozel")));
	}
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<div class="title">注意</div>
</td>
<td class="content">保存用户可能是通过fork-join方式完成的，因为这些操作并不相互依赖，但是为了进行比较，我使用与<code>then()</code> 。
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您可以在此类API中看到， <code>void</code>变成<code>Mono<Void></code> ， <code>User</code>变成<code>Mono<User></code> 。这允许以非阻塞方式使用它们，并提供对一组丰富的运算符的访问。但这也强制使用<code>Mono</code>包装器，并显着改变您使用这些API的方式。例如，如果某些操作需要按顺序执行，例如<code>init()</code>方法，使用命令式代码很简单，在这里，我们必须使用<code>then</code>操作员。</p>
</div>
<div class="paragraph">
<p><code>Flux<User></code>提供更多的附加值，因为它允许在使用时将输入的用户作为流处理<code>List<User></code>通常在阻塞堆栈中使用的含义是在处理数据之前将所有数据加载到内存中。注意我们也可以使用<code>Mono<List<User>></code>这里。</p>
</div>
<div class="paragraph">
<p>在控制器方面，您可以看到Spring WebFlux本身支持这些响应类型，还可以看到基于响应流的API的另一个特性，其中异常通常被用作响应类型所携带的错误信号，而不是像常规命令那样抛出异常码。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@RestController
public class UserController {

	private final UserRepository userRepository;

	public UserController(UserRepository userRepository) {
		this.userRepository = userRepository;
	}

	@GetMapping("/")
	public Flux&lt;User&gt; findAll() {
		return userRepository.findAll();
	}

	@GetMapping("/{id}")
	public Mono&lt;User&gt; findOne(@PathVariable String id) {
		return userRepository
			.findOne(id)
			.switchIfEmpty(Mono.error(
				new CustomException("This user does not exist");
	}

	@PostMapping("/")
	public Mono&lt;Void&gt; save(User user) {
		return userRepository.save(user);
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-with-coroutines-api-in-kotlin"><a class="anchor" href="#webflux-with-coroutines-api-in-kotlin"></a> WebFlux与Kotlin中的协程API</h3>
<div class="paragraph">
<p>重要的是要了解，Spring反应式支持是在<a href="http://www.reactive-streams.org/">Reactive Streams的</a>基础上构建的，并考虑了互操作性，并且Reactor用于两个不同的目的：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>我们在Spring反应式基础架构中的任何地方都使用了Reactive Streams实现</p>
</li>
<li>
<p>这也是公开的默认反应式公共API</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>但是Spring反应式支持从一开始就经过设计，可以轻松适应其他异步或反应式API，例如<code>CompletableFuture</code> ，RxJava 2 <a href="https://docs.spring.io/spring/docs/5.2.0.M1/spring-framework-reference/languages.html#coroutines">和现在的协程</a> 。在那种情况下，我们仍会在内部利用Reactor，在公共API级别适应不同的最终用户反应式API。</p>
</div>
<div class="paragraph">
<p>当然继续使用是完全可以的<code>Flux</code>和<code>Mono</code>在Kotlin中，如果您喜欢这种方法，则Spring Framework 5.2引入了一个新的主要功能：现在，我们可以使用<a href="https://kotlinlang.org/docs/reference/coroutines-overview.html">Kotlin协程</a>以更必要的方式利用Spring <a href="https://kotlinlang.org/docs/reference/coroutines-overview.html">反应堆</a> 。</p>
</div>
<div class="paragraph">
<p>协程是Kotlin轻量级线程，允许以命令方式编写非阻塞代码。在语言方面，挂起由<code>suspend</code>关键字提供异步操作的抽象，而在库方面<a href="https://github.com/Kotlin/kotlinx.coroutines">kotlinx.coroutines</a>提供诸如<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html">async {}之</a>类的函数和诸如<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/index.html">Flow之</a>类的类型。 <code>Flux</code>相当于协程世界。</p>
</div>
<div class="paragraph">
<p>在以下情况下启用协程支持<code>kotlinx-coroutines-core</code>和<code>kotlinx-coroutines-reactor</code>依赖关系在类路径中：</p>
</div>
<div class="paragraph">
<p><code>build.gradle.kts</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
	implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:${coroutinesVersion}")
	implementation("org.jetbrains.kotlinx:kotlinx-coroutines-reactor:${coroutinesVersion}")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>那看起来像什么<code>UserRepository</code>和<code>UserController</code>用Kotlin而不是Java编写，并使用协程和<code>Flow</code>代替或<code>Mono</code>和<code>Flux</code> ？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">class UserRepository(private val client: DatabaseClient) {

	suspend fun count(): Long =
		client.execute().sql("SELECT COUNT(*) FROM users")
			.asType&lt;Long&gt;().fetch().awaitOne()

	fun findAll(): Flow&lt;User&gt; =
		client.select().from("users").asType&lt;User&gt;().fetch().flow()

	suspend fun findOne(id: String): User? =
		client.execute()
			.sql("SELECT * FROM users WHERE login = :login")
			.bind("login", id).asType&lt;User&gt;()
			.fetch()
			.awaitOneOrNull()

	suspend fun deleteAll() =
		client.execute().sql("DELETE FROM users").await()

	suspend fun save(user: User) =
		client.insert().into&lt;User&gt;().table("users").using(user).await()

	suspend fun init() {
		client.execute().sql("CREATE TABLE IF NOT EXISTS users (login varchar PRIMARY KEY, firstname varchar, lastname varchar);").await()
		deleteAll()
		save(User("smaldini", "Stéphane", "Maldini"))
		save(User("sdeleuze", "Sébastien", "Deleuze"))
		save(User("bclozel", "Brian", "Clozel"))
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以在这里看到，而不是例如返回<code>Mono<User></code> ， 我们回来<code>User</code> （或更确切地说，其可为null的变体<code>User?</code> ）可以强制使用的暂停功能。的差异<code>init()</code>方法实现很好地说明了这一点，因为我们现在使用常规命令式代码而不是链接式代码<code>then</code>调用。</p>
</div>
<div class="paragraph">
<p>但是，等等，我如何直接在上面使用协程<code>DatabaseClient</code>类型是基于<code>Mono</code>和<code>Flux</code> ？之所以可以做到这一点，是因为Spring Data R2DBC还提供了Kotlin扩展（例如参见<a href="https://github.com/spring-projects/spring-data-r2dbc/blob/master/src/main/kotlin/org/springframework/data/r2dbc/function/RowsFetchSpecExtensions.kt">这一点</a> ），它允许您在其上添加基于协程的方法。 <code>DatabaseClient</code>一旦进口。按照惯例，挂起方法的前缀为<code>await</code>或后缀为<code>AndAwait</code>并获得与他们相似的名字<code>Mono</code>基础的同行。</p>
</div>
<div class="paragraph">
<p>现在让我们更深入地了解一下<code>Flow<User></code>返回类型。首先，请注意我们指的是<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/index.html"><code>kotlinx.coroutines.flow.Flow</code></a> ，不<a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.html"><code>java.util.concurrent.Flow</code></a>这是Java 9+随附的Reactive Streams容器类型。</p>
</div>
<div class="paragraph">
<p>您将使用<code>Flow</code>就像您使用Java 8+一样的API <code>Stream</code>或其等效的Kotlin <code>Sequence</code> ，但最大的不同是它适用于异步操作并管理背压。就是这样<code>Flux</code>在协程世界中等效，适用于热流或冷流，有限流或无限流，主要区别如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Flow</code>基于推送，而<code>Flux</code>是推挽混合动力</p>
</li>
<li>
<p>背压通过暂停功能实现</p>
</li>
<li>
<p><code>Flow</code>只有一个<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/collect.html">悬浮<code>collect</code>方法</a>和运算符实现为<a href="https://kotlinlang.org/docs/reference/extensions.html">扩展</a></p>
</li>
<li>
<p>协程<a href="https://github.com/Kotlin/kotlinx.coroutines/tree/master/kotlinx-coroutines-core/common/src/flow/operators">使操作员易于实施</a></p>
</li>
<li>
<p>扩展允许将自定义运算符添加到<code>Flow</code></p>
</li>
<li>
<p>收集操作正在暂停功能</p>
</li>
<li>
<p><a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/map.html"><code>map</code>操作员</a>支持异步操作（无需<code>flatMap</code> ），因为它需要一个暂停函数参数</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>现在让我们看一下控制器的协程版本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">@RestController
class UserController(private val userRepository: UserRepository) {

	@GetMapping("/")
	fun findAll(): Flow&lt;User&gt; =
		userRepository.findAll()

	@GetMapping("/{id}")
	suspend fun findOne(@PathVariable id: String): User? =
		userRepository.findOne(id) ?:
			throw CustomException("This user does not exist")

	@PostMapping("/")
	suspend fun save(user: User) =
		userRepository.save(user)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>再次您可以看到，该代码与我们将在Spring MVC中使用的常规命令式代码非常接近。</p>
</div>
<div class="paragraph">
<p>除了提供协程扩展<code>Flux</code>和<code>Mono</code>基于的API，例如<code>WebClient</code> ， <code>ServerRequest</code>要么<code>ServerResponse</code> ，Spring WebFlux现在支持本机挂起函数和<code>Flow</code>带注释的返回类型<code>@Controller</code>类。</p>
</div>
</div>
<div class="sect2">
<h3 id="asynchronous-operations-with-imperative-code"><a class="anchor" href="#asynchronous-operations-with-imperative-code"></a>带有命令性代码的异步操作</h3>
<div class="paragraph">
<p>让我们利用<code>WebClient</code>协程扩展，了解如何链接异步调用。我们将请求一个远程HTTP端点以获取其他<code>UserDetail1</code>和<code>UserDetail2</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">@RestController
class UserWithDetailsController(
		private val userRepository: UserRepository,
		private val client: WebClient) {

	@GetMapping("/")
	fun findAll(): Flow&lt;UserWithDetails&gt; =
		userRepository.findAll().map(this::withDetails)

	@GetMapping("/{id}")
	suspend fun findOne(@PathVariable id: String): UserWithDetails {
		val user: User = userRepository.findOne(id) ?:
			throw CustomException("This user does not exist")
		return withDetails(user)
	}

	private suspend fun withDetails(user: User): UserWithDetails {
		val userDetail1 = client.get().uri("/userdetail1/${user.login}")
			.accept(APPLICATION_JSON)
			.awaitExchange().awaitBody&lt;UserDetail1&gt;()
		val userDetail2 = client.get().uri("/userdetail2/${user.login}")
			.accept(APPLICATION_JSON)
			.awaitExchange().awaitBody&lt;UserDetail2&gt;()
		return UserWithDetails(user, userDetail1, userDetail2)
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里我们正在使用<code>WebClient</code>协程扩展像<code>awaitExchange()</code>和<code>awaitBody()</code>以纯粹的命令性方式执行异步和非阻塞操作。由于<code>Flow</code> <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/map.html"><code>map</code>运算符</a>带有一个暂停函数参数，我们可以在其中执行此类操作，而无需执行<code>flatMap</code>就像我们用Java中的反应式API一样。</p>
</div>
</div>
<div class="sect2">
<h3 id="parallel-decomposition"><a class="anchor" href="#parallel-decomposition"></a>平行分解</h3>
<div class="paragraph">
<p>如前所述，协程默认情况下是顺序的，但它们也可用于并行执行操作。让我们重构前面的示例，以同时执行2个远程调用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-kotlin" data-lang="kotlin">@RestController
class UserWithDetailsController(
		private val userRepository: UserRepository,
		private val client: WebClient) {

	@GetMapping("/")
	fun findAll(): Flow&lt;UserWithDetails&gt; =
		userRepository.findAll().map(this::withDetails)

	@GetMapping("/{id}")
	suspend fun findOne(@PathVariable id: String): UserWithDetails {
		val user: User = userRepository.findOne(id) ?:
			throw CustomException("This user does not exist")
		return withDetails(user)
	}

	private suspend fun withDetails(user: User): UserWithDetails = coroutineScope {
		val asyncDetail1 = async {
			client.get().uri("/userdetail1/${user.login}")
				.accept(APPLICATION_JSON)
				.awaitExchange().awaitBody&lt;UserDetail1&gt;()
		}
		val asyncDetail2 = async {
			client.get().uri("/userdetail2/${user.login}")
				.accept(APPLICATION_JSON)
				.awaitExchange().awaitBody&lt;UserDetail2&gt;()
		}
		UserWithDetails(user, asyncDetail1.await(), asyncDetail2.await())
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，我们利用<a href="https://medium.com/@elizarov/structured-concurrency-722d765aa952">结构化并发</a>来触发并行检索两个用户详细信息，方法是创建<code>Deferred<UserDetail1></code>和<code>Deferred<UserDetail2></code>通过的实例<code>async {}</code>生成器，然后我们通过调用2等待这些完成<code>await()</code>将返回<code>UserDetail1</code>和<code>UserDetail2</code>实例（如果有）。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="conclusion"><a class="anchor" href="#conclusion"></a>结论</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我认为将Spring反应堆与协程和Kotlin一起使用<code>Flow</code> API提供了命令式和声明式方法之间的有趣折衷。它允许以一种非常容易实现的方式利用WebFlux和Spring Data的反应性可伸缩性和功能。</p>
</div>
<div class="paragraph">
<p>Spring WebFlux和Spring Data中的协程支持将在即将发布的Spring Boot 2.2版本中提供。您可以阅读<a href="https://docs.spring.io/spring/docs/5.2.0.M1/spring-framework-reference/languages.html#coroutines">参考文档，</a>并可以期望进一步改进，例如协程对<a href="http://rsocket.io/">RSocket的</a>支持。 <code>@MessageMapping</code>端点和<code>RSocketRequester</code>扩展名。Spring Data Moore还将在Spring Data MongoDB，Cassandra和Redis上提供类似的协程扩展。Spring Data可能会在某个时候为<a href="https://jira.spring.io/browse/DATACMNS-1508">协程存储库</a>提供支持。我们还将使<a href="https://github.com/Kotlin/kotlinx.coroutines/issues/284">Reactor和协程上下文可互操作</a>以支持安全性和反应式事务。</p>
</div>
<div class="paragraph">
<p>最后，我想对许多才华横溢的工程师表示感谢，没有他们，这一切都是不可能的：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Kotlin团队的Roman Elizarov和Vsevolod Tolstopyatov在协程和<code>Flow</code></p>
</li>
<li>
<p>Konrad Kaminski最初为社区推动的协程支持Spring</p>
</li>
<li>
<p>杰克·沃顿（Jake Wharton）致力于将Rx和协程统一的原型</p>
</li>
<li>
<p>斯特凡·马尔蒂尼（StéphaneMaldini）和大卫·卡诺克（David Karnok）的鼓舞人心的工作</p>
</li>
<li>
<p>Juergen Hoeller，Rossen Stoyanchev和Brian Dussault充满信心</p>
</li>
<li>
<p>Mark Paluch和Oliver Drotbohm在持久性方面的支持</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>和往常一样，我期待着反馈， <a href="https://github.com/Kotlin/kotlinx.coroutines/issues/254">以及Kotlin团队<code>Flow</code> API，</a>因为它仍处于预览模式。来看看我即将在<a href="https://cfp.devoxx.fr/2019/talk/CWE-1971/Spring_Boot_avec_Kotlin,_Kofu_et_les_Coroutines">法国Devoxx</a> ， <a href="https://jax.de/serverside-enterprise-java/spring-boot-with-kotlin-functional-configuration-and-graalvm/">JAX</a> ， <a href="https://2019.springio.net/sessions/spring-boot-with-kofu-dsl-and-coroutines">Spring I / O</a>或<a href="https://sunny-tech.io/schedule/2019-06-28?sessionId=31">Sunny Tech上</a>进行的演讲，以了解更多信息。</p>
</div>
<div class="paragraph">
<p>干杯!</p>
</div>
</div>
</div>
</div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 3639;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>