<html dir="ltr" data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>Spring Batch 4.2.0。RC1发布了！</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>System.config({baseURL: "/b92013b"});</script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>System.import('app/main.js')</script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Spring Batch 4.2.0.RC1 is released!">
<meta name="twitter:description" class="anchor" content="<p>On behalf of the Spring Batch team, I am pleased to announce the release of Spring Batch 4.2.0.RC1. We have been working on some performance improvements in the core framework, and this post highlights the major changes.</p>
<h2><a href=" #major-performance-improvement="="></head><body dir="ltr">Major Performance Improvements
<p>We have made some performance improvements, including:</p>
<ul> 
 <li><a href="#enhanced-step-partitioning">Enhanced Step Partitioning</a></li> 
 <li><a href="#improved-job-stop">Improved Job Stop</a></li> 
 <li><a href="#faster-writes-with-the-jpaitemwriter">Faster Writes with the <code>JpaItemWriter</code></a></li> 
 <li><a href="#optimized-bean-mapping-with-the-beanwrapperfieldsetmapper">Optimized Bean Mapping with the <code>BeanWrapperFieldSetMapper</code></a></li> 
</ul>
<a name="enhanced-step-partitioning"></a>
<h3><a href="#enhanced-step-partitioning" class="anchor" name="enhanced-step-partitioning"></a>Enhanced Step Partitioning</h3>
<p>Starting a partitioned step is an area where the framework wasn’t well optimized. In this version, we have dug deep into the partitioning process to figure out the root cause of this performance issue. One of the main steps of the partitioning process is to find the last step execution (to see if the current execution is a restart). We found that looking up the last step execution involved loading all step executions from all job executions for a given job instance in-memory, which is obviously inefficient!</p>
">
<meta name="twitter:creator" content="@_benas_">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/18b9001fd20c1e089d19f4a1e994bcdc?s=200">

<meta property="og:title" content="Spring Batch 4.2.0.RC1 is released!">
<meta property="og:image" content="https://gravatar.com/avatar/18b9001fd20c1e089d19f4a1e994bcdc?s=200">
<meta class="anchor" name="major-performance-improvements" property="og:description" content="<p>On behalf of the Spring Batch team, I am pleased to announce the release of Spring Batch 4.2.0.RC1. We have been working on some performance improvements in the core framework, and this post highlights the major changes.</p>
<h2><a href=" #major-performance-improvement="=">Major Performance Improvements
<p>We have made some performance improvements, including:</p>
<ul> 
 <li><a href="#enhanced-step-partitioning">Enhanced Step Partitioning</a></li> 
 <li><a href="#improved-job-stop">Improved Job Stop</a></li> 
 <li><a href="#faster-writes-with-the-jpaitemwriter">Faster Writes with the <code>JpaItemWriter</code></a></li> 
 <li><a href="#optimized-bean-mapping-with-the-beanwrapperfieldsetmapper">Optimized Bean Mapping with the <code>BeanWrapperFieldSetMapper</code></a></li> 
</ul>
<a name="enhanced-step-partitioning"></a>
<h3><a href="#enhanced-step-partitioning" class="anchor" name="enhanced-step-partitioning"></a>Enhanced Step Partitioning</h3>
<p>Starting a partitioned step is an area where the framework wasn’t well optimized. In this version, we have dug deep into the partitioning process to figure out the root cause of this performance issue. One of the main steps of the partitioning process is to find the last step execution (to see if the current execution is a restart). We found that looking up the last step execution involved loading all step executions from all job executions for a given job instance in-memory, which is obviously inefficient!</p>
">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2019-09-17 12:22:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">// Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }</script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category content--title">
<div>工程</div>
</div>
<div class="blog-category active content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Spring Batch 4.2.0。RC1发布了！</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon releases"></div>
<a class="category">发布</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/18b9001fd20c1e089d19f4a1e994bcdc?s=20&d=mm"> <a class="author" rel="author" href="/team/benas">Mahmoud Ben Hassine</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2019-09-17 12:22:00.0">九月17，2019</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2019/09/17/spring-batch-4-2-0-rc1-is-released#disqus_thread" data-disqus-identifier="3792">
</a></div>
</div>
</header>
<div class="blog--post"><p>我很高兴代表Spring Batch团队宣布发布Spring Batch 4.2.0。RC1。我们一直在努力改善核心框架的性能，并且本文重点介绍了主要变化。</p><h2><a href="#major-performance-improvements" class="anchor" name="major-performance-improvements"></a>主要性能改进</h2>
<p>我们对性能进行了一些改进，包括：</p>
<ul>
<li><a href="#enhanced-step-partitioning">增强的步骤分区</a></li>
<li><a href="#improved-job-stop">改善工作停止</a></li>
<li><a href="#faster-writes-with-the-jpaitemwriter">使用<code>JpaItemWriter</code>更快地写入</a></li>
<li><a href="#optimized-bean-mapping-with-the-beanwrapperfieldsetmapper">使用<code>BeanWrapperFieldSetMapper</code>优化Bean映射</a></li>
</ul>
<a name="enhanced-step-partitioning"></a><h3><a href="#enhanced-step-partitioning" class="anchor" name="enhanced-step-partitioning"></a>增强的步骤分区</h3>
<p>开始分区的步骤是框架没有得到很好优化的领域。在此版本中，我们深入研究了分区过程，以找出导致此性能问题的根本原因。分区过程的主要步骤之一是找到最后一步执行（以查看当前执行是否是重新启动）。我们发现，查找最后一步执行涉及在内存中为给定的作业实例从所有作业执行中加载所有步骤执行，这显然效率低下！</p>
<p>我们用在数据库级别进行查询的SQL查询替换了此代码，以仅返回最后一步的执行。结果非常出色：根据我们的基准<a href="#footnotes">partitioned-step-benchmark</a> ，使用这种方法将步骤执行划分为5000个分区几乎快了10倍：</p>
<p><img src="https://raw.githubusercontent.com/benas/spring-batch-sandbox/master/batch2716/perf-partitioning.png" alt="性能分区"></p>
<a name="improved-job-stop"></a><h3><a href="#improved-job-stop" class="anchor" name="improved-job-stop"></a>改善工作停止</h3>
<p>运行作业时，事情可能会出错..为了避免数据损坏，适当地快速停止破坏性的作业应该有效。在v4.1之前的版本中，由于将所有作业执行加载到内存中以查找作业是否正在运行，因此使用<code>CommandLineJobRunner</code>停止作业的性能很差。使用这种方法，使用包含数千个作业执行的生产数据库，停止作业可能需要几分钟的时间！</p>
<p>在此版本中，我们通过使用在数据库级别进行过滤的SQL查询优化了停止过程。同样，结果令人印象深刻：根据我们的基准<a href="#footnotes">停止基准</a> ，在数据库中给定作业的100.000个作业执行后，使用这种方法停止作业的速度几乎快40倍：</p>
<p><img src="https://raw.githubusercontent.com/benas/spring-batch-sandbox/master/batch2422/perf-stop.png" alt="性能停止"></p>
<a name="faster-writes-with-the-jpaitemwriter"></a><h3><a href="#faster-writes-with-the-code-jpaitemwriter-code" class="anchor" name="faster-writes-with-the-code-jpaitemwriter-code"></a>使用<code>JpaItemWriter</code>更快地写入</h3>
<p><code>JpaItemWriter</code>使用<code>javax.persistence.EntityManager#merge</code>函数可在JPA持久性上下文中编写项目。当项目的持久状态未知或已知为更新时，这是有意义的。但是，在许多文件提取作业中，使用<code>javax.persistence.EntityManager#merge</code></p><code>javax.persistence.EntityManager#merge</code></div><code>javax.persistence.EntityManager#merge</code></div><code>javax.persistence.EntityManager#merge</code></article><code>javax.persistence.EntityManager#merge</code></div><code>javax.persistence.EntityManager#merge</code></div><code>javax.persistence.EntityManager#merge</code></div><code>javax.persistence.EntityManager#merge</code></div><code>javax.persistence.EntityManager#merge</code></body></html>