<html  data-code-prettify="" data-mobile-support="" data-search=""><head></head><body >﻿
<title>在Spring Framework 5.0中引入Kotlin支持</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Introducing Kotlin support in Spring Framework 5.0">
<meta name="twitter:description" content="<p><strong>Update: a comprehensive <a href=" https: ="" spring.io guides="" tutorials="" spring-boot-kotlin="" ="=">Spring Boot + Kotlin tutorial is now available.
<p>Following the <a href=" blog 2016 02 15 developing-spring-boot-applications-with-kotlin">Kotlin support on start.spring.io we introduced a few months ago, we have continued to work to ensure that Spring and <a href="https://kotlin.link/">Kotlin</a> play well together. One of the key strengths of Kotlin is that it provides a very good <a href="https://kotlinlang.org/docs/reference/java-interop.html">interoperability</a> with libraries written in Java. But there are ways to go even further and allow writing fully idiomatic Kotlin code when developing your next Spring application. In addition to Spring Framework support for Java 8 that Kotlin applications can leverage like functional web or bean registration APIs, there are additional Kotlin dedicated features that should allow you to reach a new level of productivity.<p></p>
">
<meta name="twitter:creator" content="@sdeleuze">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/5778521f67d80de0ee3b213e4f159a59?s=200">

<meta property="og:title" content="Introducing Kotlin support in Spring Framework 5.0">
<meta property="og:image" content="https://gravatar.com/avatar/5778521f67d80de0ee3b213e4f159a59?s=200">
<meta property="og:description" content="<p><strong>Update: a comprehensive <a href=" https: ="" spring.io guides="" tutorials="" spring-boot-kotlin="" ="=">Spring Boot + Kotlin tutorial is now available.
<p>Following the <a href=" blog 2016 02 15 developing-spring-boot-applications-with-kotlin">Kotlin support on start.spring.io we introduced a few months ago, we have continued to work to ensure that Spring and <a href="https://kotlin.link/">Kotlin</a> play well together. One of the key strengths of Kotlin is that it provides a very good <a href="https://kotlinlang.org/docs/reference/java-interop.html">interoperability</a> with libraries written in Java. But there are ways to go even further and allow writing fully idiomatic Kotlin code when developing your next Spring application. In addition to Spring Framework support for Java 8 that Kotlin applications can leverage like functional web or bean registration APIs, there are additional Kotlin dedicated features that should allow you to reach a new level of productivity.<p></p>
">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2017-01-04 14:05:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">在Spring Framework 5.0中引入Kotlin支持</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/5778521f67d80de0ee3b213e4f159a59?s=20&d=mm"> <a class="author" rel="author" href="/team/sdeleuze">塞巴斯蒂安·德勒兹（SébastienDeleuze）</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2017-01-04 14:05:00.0">一月04，2017</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0#disqus_thread" data-disqus-identifier="2758">
</a></div>
</div>
</header>
<div class="blog--post"><p><strong>更新：现已提供全面的<a href="https://spring.io/guides/tutorials/spring-boot-kotlin/">Spring Boot + Kotlin教程</a> 。</strong></p>
<p>在几个月前我们<a href="https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin">在start.spring.io上</a>对<a href="https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin">Kotlin的支持</a>之后，我们将继续努力以确保Spring和<a href="https://kotlin.link/">Kotlin</a>能够很好地合作。Kotlin的主要优势之一是，它与Java编写的库提供了很好的<a href="https://kotlinlang.org/docs/reference/java-interop.html">互操作性</a> 。但是有很多方法可以使您在开发下一个Spring应用程序时编写完全惯用的Kotlin代码。除了Kotlin应用程序可以像功能性Web或bean注册API一样利用对Java 8的Spring Framework支持之外，还有其他Kotlin专用功能可以使您达到新的生产力水平。</p>
<p>这就是为什么我们在Spring Framework 5.0中引入Kotlin专用支持的原因，我想在这篇博客文章中总结一些功能，这些功能旨在使您的开发人员在一起使用这些技术时可以无缝体验。您可以使用<a href="https://jira.spring.io/issues/?filter=15463">此链接</a>在Spring Framework Bug Tracker中查找与Kotlin相关的问题。</p>
<p><a href="https://kotlinlang.org/docs/reference/extensions.html">Kotlin扩展</a>是我们Kotlin支持的关键组成<a href="https://kotlinlang.org/docs/reference/extensions.html">部分</a> 。它们允许以非介入方式扩展现有的API，为实用程序类或Kotlin特定的类层次结构提供了更好的替代方案，以向Spring添加Kotlin专用功能。诸如<a href="https://github.com/MarioAriasC">Mario Arias的</a> <a href="https://github.com/MarioAriasC/KotlinPrimavera/wiki">KotlinPrimavera之类的</a>库已经展示了我们可以带入Spring API的各种Kotlin帮助器，以允许编写更多惯用的代码。使用Spring Framework 5，我们在Spring Framework依赖项中集成了最有用和最受欢迎的扩展，并且我们正在添加新的扩展！请注意，Kotlin扩展是静态解析的，因此必须将其导入（就像Java中的静态导入一样）。</p><h2><a href="#null-safety-of-spring-framework-api" class="anchor" name="null-safety-of-spring-framework-api"></a> Spring Framework API的零安全</h2>
<p>Spring Framework 5.0为所有包引入了一个正式的非空API声明，带有显式可为空的参数和返回值（现在已注释）。我们的可空性注释符合JSR 305，并且在<a href="https://youtrack.jetbrains.com/issue/KT-10942">KT-10942</a>修复后将由Kotlin支持。从Kotlin的角度来看，这将使整个Spring Framework API为空，并且将允许在编译时处理null值，而不是抛出<code>NullPointerExceptions</code>在运行时。</p><h2><a href="#leveraging-kotlin-nullable-information-in-spring-annotations" class="anchor" name="leveraging-kotlin-nullable-information-in-spring-annotations"></a>在Spring注释中利用Kotlin可为空的信息</h2>
<p>最初基于<a href="https://github.com/rocketraman">Raman Gupta</a>的社区贡献，Spring现在利用<a href="https://kotlinlang.org/docs/reference/null-safety.html">Kotlin空安全支持</a>来确定是否需要HTTP参数，而不必显式定义<code>required</code>属性。那意味着<code>@RequestParam name: String?</code>被视为不需要<code>@RequestParam name: String</code>按要求。Spring Messaging也支持此功能<code>@Header</code>注解。</p>
<p>用类似的方式，春豆注射液<code>@Autowired</code>要么<code>@Inject</code>使用此信息来知道是否需要bean。 <code>@Autowired lateinit var foo: Foo</code>表示一个类型的bean <code>Foo</code>必须在应用程序上下文中注册<code>@Autowired lateinit var foo: Foo?</code>如果此类bean不存在，则不会引发错误。</p><h2><a href="#spring-webflux-functional-dsl" class="anchor" name="spring-webflux-functional-dsl"></a> Spring WebFlux功能性DSL</h2>
<p>Spring Framework 5.0随附了Kotlin路由DSL，可让您利用最近发布的带有清晰且惯用的Kotlin代码的<a href="https://spring.io/blog/2016/09/22/new-in-spring-5-functional-web-framework">Spring Functional Web API</a> ：</p>
<pre><code class="prettyprint kotlin">router {
    (&quot;/blog&quot; and accept(TEXT_HTML)).nest {
        GET(&quot;/&quot;, fooHandler::findAllView)
        GET(&quot;/{slug}&quot;, fooHandler::findOneView)
    }
    (&quot;/api/blog&quot; and accept(APPLICATION_JSON)).nest {
        GET(&quot;/&quot;, barHandler::findAll)
        GET(&quot;/{id}&quot;, barHandler::findOne)
    }
}
</code></pre>
<p>感谢Yevhenii Melnyk的早期原型和帮助！您可以在<a href="https://github.com/mixitconf/mixit/">https://github.com/mixitconf/mixit/上</a>看到使用<a href="https://github.com/mixitconf/mixit/blob/e4925babcbbe8943f1eaec15bfbcd47c7ec0dd94/src/main/kotlin/mixit/web/routes/ApiRoutes.kt">功能性Web API</a>的Spring Boot应用程序的具体示例。</p><h2><a href="#functional-bean-declaration-dsl" class="anchor" name="functional-bean-declaration-dsl"></a>功能bean声明DSL</h2>
<p>Spring Framework 5.0引入了一种新的方式来使用lambda注册bean，以替代XML或JavaConfig， <code>@Configuration</code>和<code>@Bean</code> 。简而言之，可以使用<code>Supplier</code>充当<code>FactoryBean</code> 。</p>
<p>例如，在Java中，您将编写：</p>
<pre><code class="prettyprint java">GenericApplicationContext context = new GenericApplicationContext();
context.registerBean(Foo.class);
context.registerBean(Bar.class, () -&gt; new 
	Bar(context.getBean(Foo.class))
);
</code></pre>
<p>在Kotlin中时，可通过修饰类型参数和<a href="https://github.com/spring-projects/spring-framework/commit/1f011467b8b929928963486f8594eea460b50eb7">功能Bean声明DSL</a>来编写：</p>
<pre><code class="prettyprint kotlin">beans {
    bean&lt;Foo&gt;()
    bean { Bar(ref()) }
}
</code></pre>
<p><code>ApplicationContext</code>与Kotlin相关的可用扩展包括<a href="https://github.com/spring-projects/spring-framework/blob/master/spring-beans/src/main/kotlin/org/springframework/beans/factory/BeanFactoryExtensions.kt">BeanFactoryExtensions</a> ， <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-beans/src/main/kotlin/org/springframework/beans/factory/ListableBeanFactoryExtensions.kt">ListableBeanFactoryExtensions</a> ， <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-context/src/main/kotlin/org/springframework/context/support/GenericApplicationContextExtensions.kt">GenericApplicationContextExtensions</a>和<a href="https://github.com/spring-projects/spring-framework/blob/master/spring-context/src/main/kotlin/org/springframework/context/annotation/AnnotationConfigApplicationContextExtensions.kt">AnnotationConfigApplicationContextExtensions</a> 。</p><h2><a href="#extensions-for-code-resttemplate-code-and-code-webclient-code-api" class="anchor" name="extensions-for-code-resttemplate-code-and-code-webclient-code-api"></a>扩展<code>RestTemplate</code>和<code>WebClient</code> API</h2>
<p>例如， <a href="https://kotlinlang.org/docs/reference/inline-functions.html#reified-type-parameters">Kotlin修饰的类型参数</a>为JVM <a href="https://docs.oracle.com/javase/tutorial/java/generics/erasure.html">泛型类型擦除</a>提供了一种解决方法，因此我们引入了一些扩展，以利用此功能在可能的情况下提供更好的API。</p>
<p>这样就可以为<code>RestTemplate</code>例如（感谢Netflix的<a href="https://github.com/jkschneider">Jon Schneider</a>的贡献）和新<code>WebClient</code> Spring WebFlux API。例如，检索以下内容的列表<code>Foo</code> Java中的对象，您必须编写：</p>
<pre><code class="prettyprint java">Flux&lt;User&gt; users  = client.get().retrieve().bodyToFlux(User.class)
</code></pre>
<p>在带有Spring Framework 5扩展的Kotlin中，您将能够编写：</p>
<pre><code class="prettyprint kotlin">val users = client.get().retrieve().bodyToFlux&lt;User&gt;()
// or (both are equivalent)
val users : Flux&lt;User&gt; = client.get().retrieve().bodyToFlux()
</code></pre>
<p>就像在Java中一样， <code>users</code> Kotlin中的Int是强类型的，但Kotlin聪明的类型推断允许较短的语法。</p>
<p>Spring Framework 5.0中可用的Web API Kotlin扩展包括<a href="https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/kotlin/org/springframework/web/client/RestOperationsExtensions.kt">RestOperationsExtensions</a> ， <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-web-reactive/src/main/kotlin/org/springframework/web/reactive/function/server/ServerRequestExtensions.kt">ServerRequestExtensions</a> ， <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-web-reactive/src/main/kotlin/org/springframework/web/reactive/function/BodyInsertersExtensions.kt">BodyInsertersExtensions</a> ， <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-web-reactive/src/main/kotlin/org/springframework/web/reactive/function/BodyExtractorsExtensions.kt">BodyExtractorsExtensions</a> ， <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-web-reactive/src/main/kotlin/org/springframework/web/reactive/function/client/ClientResponseExtensions.kt">ClientResponseExtensions</a> ， <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-context/src/main/kotlin/org/springframework/ui/ModelExtensions.kt">ModelExtensions</a>和<a href="https://github.com/spring-projects/spring-framework/blob/master/spring-context/src/main/kotlin/org/springframework/ui/ModelMapExtensions.kt">ModelMapExtensions</a> 。</p>
<p>还有趣的是，其他Spring项目（ <a href="https://github.com/spring-projects/spring-data-mongodb/commit/2359357977e8734331a78c88e0702f50f3a3c75e">例如Spring Data MongoDB）</a>也通过此类扩展为Kotlin提供了内置支持。</p><h2><a href="#reactor-kotlin-builtin-support" class="anchor" name="reactor-kotlin-builtin-support"></a> Reactor Kotlin内置支持</h2>
<p><a href="https://projectreactor.io/">Reactor</a>是Spring Framework 5.0的反应式基础，在开发反应式Web应用程序时，您很有可能会使用其<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html">Mono</a> ， <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html">Flux</a>和<a href="https://projectreactor.io/docs/test/release/api/reactor/test/StepVerifier.html">StepVerifier</a> API。</p>
<p>因此，今天我们还将<a href="https://github.com/reactor/reactor-core/commit/5140235171ddd84a83c761a6868aa55fa2036fbd">在即将发布的Reactor 3.1版本中</a>引入<a href="https://github.com/reactor/reactor-core/commit/5140235171ddd84a83c761a6868aa55fa2036fbd">Kotlin内置支持</a> ！它提供了可以创建的扩展<code>Mono</code>通过编写来自任何类实例的实例<code>foo.toMono()</code>许多人会喜欢<code>Mono.just(foo)</code> 。它还支持例如创建<code>Flux</code>从Java 8 <code>Stream</code>实例<code>stream.toFlux()</code> 。 <code>Iterable</code> ， <code>CompletableFuture</code>和<code>Throwable</code>扩展以及<code>KClass</code>还提供了基于Reactor API的变体。</p><h2><a href="#no-need-to-declare-your-bean-class-as-open-anymore" class="anchor" name="no-need-to-declare-your-bean-class-as-open-anymore"></a>无需将您的bean类声明为打开了</h2>
<p>到目前为止，使用Kotlin构建Spring Boot应用程序时面临的几个痛苦点之一就是需要添加一个<code>open</code>每个类的关键字及其使用CGLIB代理的Spring bean的成员函数，例如<code>@Configuration</code>类。产生此要求的根本原因是，在Kotlin中， <a href="https://discuss.kotlinlang.org/t/classes-final-by-default/166">类默认为final</a> 。</p>
<p>幸运的是，Kotlin 1.0.6现在提供了<code>kotlin-spring</code>该插件默认情况下为带有以下注释之一的注释类或元注释打开类及其成员函数的插件：</p>
<ul>
<li><code>@Component</code></li>
<li><code>@Async</code></li>
<li><code>@Transactional</code></li>
<li><code>@Cacheable</code></li>
</ul>
<p>支持元注释意味着用<code>@Configuration</code> ， <code>@Controller</code> ， <code>@RestController</code> ， <code>@Service</code>要么<code>@Repository</code>将自动打开这些注释，因为这些注释使用meta注释<code>@Component</code> 。</p>
<p>我们已经更新了<a href="https://start.spring.io/#!language=kotlin">start.spring.io</a>以默认启用它。您可以查看<a href="https://blog.jetbrains.com/kotlin/2016/12/kotlin-1-0-6-is-here/">此Kotlin 1.0.6博客文章</a>以了解更多详细信息，包括新的<code>kotlin-jpa</code>和<code>kotlin-noarg</code>插件对Spring Data实体真的很有用。</p><h2><a href="#kotlin-based-gradle-build-configuration" class="anchor" name="kotlin-based-gradle-build-configuration"></a>基于Kotlin的Gradle构建配置</h2>
<p>早在5月，Gradle <a href="https://blog.gradle.org/kotlin-meets-gradle">宣布</a>他们将支持Groovy之外的Kotlin编写构建和配置文件。这使您可以在IDE中进行完全自动完成和验证，因为此类文件是常规的静态类型的Kotlin脚本文件。这很可能成为基于Kotlin的项目的自然选择，但这对于Java项目也很有价值。</p>
<p>自5月以来， <a href="https://github.com/gradle/gradle-script-kotlin">kotlin-dsl</a> Gradle项目一直在发展，现在可以记住以下两个警告：</p>
<ul>
<li>您需要Kotlin 1.1 IDEA插件才能自动完成</li>
<li>文档还不完整，但是Gradle团队确实在Kotlin Slack的#gradle频道上提供了帮助，对于1.0版本应对此进行改进。</li>
</ul>
<p><a href="https://github.com/sdeleuze/spring-boot-kotlin-demo">spring-boot-kotlin-demo</a>和<a href="https://github.com/mixitconf/mixit/">mixit</a>项目都使用基于Kotlin的Gradle构建，因此请随意查看。我们正在<a href="https://github.com/spring-io/initializr/issues/334">讨论</a>在start.spring.io上添加此类支持。</p><h2><a href="#kotlin-script-based-templates" class="anchor" name="kotlin-script-based-templates"></a>基于Kotlin脚本的模板</h2>
<p>从4.3版本开始，Spring框架提供了一个<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/view/script/ScriptTemplateView.html">ScriptTemplateView</a>来使用支持<a href="https://www.jcp.org/en/jsr/detail?id=223">JSR-223的</a>脚本引擎来呈现模板，而Spring框架5.0通过支持<a href="https://jira.spring.io/browse/SPR-15064">i18n和嵌套模板而</a>进一步发展。Kotlin 1.1提供了这种支持，并允许渲染基于Kotlin的模板，有关详细信息，请参见此<a href="https://github.com/spring-projects/spring-framework/commit/badde3a479a53e1dd0777dd1bd5b55cb1021cf9e">提交</a> 。</p>
<p>这启用了一些有趣的用例，例如使用<a href="https://github.com/Kotlin/kotlinx.html">kotlinx.html</a> DSL或仅使用Kotlin多行编写类型安全的模板<code>String</code>带有插值功能，如此<a href="https://github.com/sdeleuze/kotlin-script-templating">kotlin-script-tempulation</a>项目中所示。这可以让您在IDE中编写具有完全自动完成和重构支持的模板：</p>
<pre><code class="prettyprint kotlin">import io.spring.demo.*

&quot;&quot;&quot;
${include(&quot;header&quot;)}
&lt;h1&gt;${i18n(&quot;title&quot;)}&lt;/h1&gt;
&lt;ul&gt;
    ${users.joinToLine{ &quot;&lt;li&gt;${i18n(&quot;user&quot;)} ${it.firstname} ${it.lastname}&lt;/li&gt;&quot; }}
&lt;/ul&gt;
${include(&quot;footer&quot;)}
&quot;&quot;&quot;
</code></pre><h2><a href="#conclusion" class="anchor" name="conclusion"></a>结论</h2>
<p>我用Kotlin编写Spring Boot应用程序的次数越多，我就越觉得这两种技术具有相同的思维方式，并允许您使用表达力强，简短易读的代码来更有效地编写应用程序，而Spring Framework 5 Kotlin支持是将这些技术结合起来的重要一步以自然，简单和强大的方式开发技术。</p>
<p>Kotlin可以用来编写<a href="https://github.com/sdeleuze/spring-boot-kotlin-demo">基于注释的Spring Boot应用程序</a> ，但也非常适合Spring Framework 5.0将启用的新型<a href="https://github.com/mixitconf/mixit/">功能性和反应性应用程序</a> 。</p>
<p>Kotlin团队通过修复几乎我们报告的所有痛苦点，做出了出色的贡献，这非常感谢他们。预计即将发布的Kotlin 1.2版本还将修复<a href="https://youtrack.jetbrains.com/issue/KT-11235">KT-11235</a> ，以便允许在不指定数组注释属性的情况下指定单个值<code>arrayOf()</code> 。您将要面对的主要剩余问题可能是<a href="https://youtrack.jetbrains.com/issue/KT-14984">KT-14984</a> ，它需要明确指定lambda类型，而只需指定<code>{ }</code>应该足够了。</p>
<p>通过转到<a href="https://start.spring.io/#!language=kotlin">start.spring.io</a>并生成一个Spring Boot来<a href="https://start.spring.io/#!language=kotlin">随意</a>测试Spring Framework 5.0 Kotlin支持<code>2.0.0</code> （里程碑或快照）项目，然后在此处或在<code>#spring</code> <a href="http://slack.kotlinlang.org/">Kotlin Slack的</a>频道。您还可以<a href="https://github.com/spring-projects/spring-framework/pulls">提供</a>所需的Kotlin扩展；-)</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 2758;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>