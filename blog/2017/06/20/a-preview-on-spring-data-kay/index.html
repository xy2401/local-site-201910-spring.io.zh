<html  data-code-prettify="" data-mobile-support="" data-search=""><head></head><body >﻿
<title>Spring Data Kay预览</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="A preview on Spring Data Kay">
<meta name="twitter:description" >
<meta name="twitter:creator" content="@mp911de">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/6494a9d91e9ffef9adc8253257f1b35e?s=200">

<meta property="og:title" content="A preview on Spring Data Kay">
<meta property="og:image" content="https://gravatar.com/avatar/6494a9d91e9ffef9adc8253257f1b35e?s=200">
<meta property="og:description" >
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2017-06-20 13:16:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Spring Data Kay预览</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/6494a9d91e9ffef9adc8253257f1b35e?s=20&d=mm"> <a class="author" rel="author" href="/team/mp911de">马克·帕鲁奇</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2017-06-20 13:16:00.0">2017年6月20日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2017/06/20/a-preview-on-spring-data-kay#disqus_thread" data-disqus-identifier="2958">
</a></div>
</div>
</header>
<div class="blog--post"><div class="paragraph">
<p>正如我们刚刚发布了Spring Data发布火车Kay的第四个里程碑版本之后，让我们看一下自第一个里程碑以来火车上的13个模块随附的更改和功能。这篇博客文章涵盖了一系列更改，但并不意味着M2和M4之间的550多个更改是全面的。要获取更改的完整列表，请查看我们针对<a href="https://jira.spring.io/issues/?filter=15455">Kay M1</a> ， <a href="https://jira.spring.io/issues/?filter=15456">M2</a> ， <a href="https://jira.spring.io/issues/?filter=15537">M3</a>和<a href="https://jira.spring.io/issues/?filter=15637">M4</a>更改的<a href="https://jira.spring.io/issues/?filter=15640">Jira</a> 。</p>
</div>
<div class="paragraph">
<p>以下是我们主要变更的精选清单：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>反应性支撑的调整</p>
</li>
<li>
<p>可组合存储库</p>
</li>
<li>
<p>改进的CRUD方法命名方案</p>
</li>
<li>
<p>流利的MongoOperations API</p>
</li>
<li>
<p>MongoDB模板API的Kotlin扩展</p>
</li>
<li>
<p>MongoDB整理支持</p>
</li>
<li>
<p>Redis客户端配置</p>
</li>
<li>
<p>Cassandra轻量级事务支持和查询/更新对象</p>
</li>
<li>
<p>Java 9兼容性</p>
</li>
<li>
<p>升级到Elasticsearch 5.4</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我们很乐意听到您的反馈，您将在本文末尾找到与我们联系的方法。</p>
</div>
<div class="sect1">
<h2 id="changes-in-our-reactive-support"><a class="anchor" href="#changes-in-our-reactive-support"></a>反应性支持方面的变化</h2>
<div class="sectionbody">
<div class="paragraph">
<p>去年下半年，我们在与Redis，Cassandra和MongoDB进行响应数据访问的初始草案奠定了<a href="https://spring.io/blog/2016/11/28/going-reactive-with-spring-data">重要基础</a>之后，Couchbase加入了响应方。Couchbase驱动程序是完全基于RxJava 1构建的反应式，因此反应式模板API使用RxJava 1。Couchbase存储库可与RxJava 1＆2和Reactive Stream类型一起正常运行。</p>
</div>
<div class="paragraph">
<p>同时，我们在预定义中添加了对RxJava 2类型的支持<code>RxJava2CrudRepository</code>和<code>RxJava2SortingRepository</code>接口，因此您可以将RxJava 2类型与所有反应性存储库（Apache Cassandra，Couchbase和MongoDB）一起使用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Repository
interface RxJava2PersonRepostitory extends
                    RxJava2SortingRepository&lt;Person, String&gt; {

  Flowable&lt;Person&gt; findByFirstnameAndLastname(String firstname, String lastname);

  Maybe&lt;Person&gt; findByLastname(String lastname);

  Single&lt;Person&gt; findProjectedByLastname(Maybe&lt;String&gt; lastname);

  Observable&lt;ProjectedPerson&gt; findProjectedByLastname(Single&lt;String&gt; lastname);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Data将在接下来的几个月内进入GA。那是在RxJava 1的功能冻结之后，该功能将在2018年3月以后不再维护。因此，我们决定弃用RxJava 1存储库，并用即将发布的候选版本删除它们。放心，RxJava 1支持仍然有效，因此，如果需要RxJava 1存储库，则可以将这些接口复制到项目代码中。</p>
</div>
<div class="paragraph">
<p>如果您是反应式MongoDB存储库的用户，您可能会想知道我们已将其重命名<code>@InfiniteStream</code>至<code>@Tailable</code>反映底层光标，尽管无限流听起来很花哨。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="composable-repositories"><a class="anchor" href="#composable-repositories"></a>可组合存储库</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Data Repositories是用于实现DDD风格的信息库的工具。它们的实现被设计为包含3个主要部分：特定于商店的基本实现，支持查询方法的查询执行引擎以及将定制功能链接到存储库实例的可选定制实现。</p>
</div>
<div class="paragraph">
<p>随着时间的流逝，我们发现我们的初始设计在存储库实现方面受到限制。存储库可以通过以下方式提供“按示例查询”操作<code>QueryByExampleExecutor</code>或Querydsl支持<code>QuerydslPredicateExecutor</code> 。两者都是特定于商店的基本存储库实现的正交功能，并且需要一些技巧才能起作用。</p>
</div>
<div class="paragraph">
<p>这种情况类似于自定义实现部分：仅支持一个自定义实现对象，该对象需要将所有要链接的功能带入存储库对象。</p>
</div>
<div class="paragraph">
<p>可组合存储库通过将面向组合的方法转变为一流的公民，消除了上述设计限制。存储库不再局限于基本实现和自定义实现，而是由片段组成。片段代表接口以及实现对象。多个片段构成了用于实现存储库的组成。</p>
</div>
<div class="paragraph">
<p>考虑以下存储库声明：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">class Person extends Contact {
  // …
}

interface PersonRepository extends CrudRepository&lt;Person, String&gt;,
                                      ContactFragment,
                                      PersonBatchExecutor {
}

interface ContactFragment {
  Iterable&lt;Contact&gt; search(ContactQuery query);
}

interface PersonBatchExecutor {
  void bulkEdit(PersonQuery query, PersonUpdate update);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上方，我们有一个简单的域对象<code>Person</code>这也是<code>Contact</code> 。该存储库由CRUD操作组成： <code>Contact</code>通过搜索<code>ContactFragment</code>以及一些通过<code>PersonBatchExecutor</code> 。每个接口存储库都是由实现支持的片段接口。</p>
</div>
<div class="paragraph">
<p>对存储库方法的调用根据其方法实现进行路由。CRUD操作被路由到其特定于商店的实现，同时调用<code>search(ContactQuery query)</code>路由到用户提供的实现<code>ContactFragment</code> （如下所示）。</p>
</div>
<div class="paragraph">
<p>引导时，配置组件将扫描<em>声明的</em>片段接口的实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">interface ContactFragment {
  Iterable&lt;Contact&gt; search(ContactQuery query);
}

class ContactFragmentImpl implements ContactFragment {

  @Override
  Iterable&lt;Contact&gt; search(ContactQuery query) {
    // …
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>片段实现是功能齐全的Spring Bean。使用片段接口名称并添加实现后缀按名称查找它们，即默认情况下为<code>ContactFragment</code>被抬头为<code>ContactFragmentImpl</code> 。</p>
</div>
<div class="sect2">
<h3 id="ordering-of-overrides"><a class="anchor" href="#ordering-of-overrides"></a>覆盖顺序</h3>
<div class="paragraph">
<p>Java允许组合多次声明同一方法的接口。从API角度来看，具有相同名称和签名的多个方法无需进一步区分即可合并为一个方法。</p>
</div>
<div class="paragraph">
<p>在实现方面，可以有多个实现声明相同的方法签名。可组合存储库使用<strong>接口声明顺序</strong>来消除多个实现之间的歧义。</p>
</div>
<div class="paragraph">
<p>看下面的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public interface ContactFragment {
  Iterable&lt;Contact&gt; search(ContactQuery query);
}

public interface PersonFragment {
  Iterable&lt;Contact&gt; search(ContactQuery query);
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">// Calls search(…) on ContactFragment
public interface PersonRepository implements CrudRepository&lt;Person, String&gt;,
  ContactFragment, PersonFragment {
  …
}

// Calls search(…) on PersonFragment
public interface PersonRepository implements CrudRepository&lt;Person, String&gt;,
  PersonFragment, ContactFragment {
  …
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>的第一个声明<code>PersonRepository</code>首先会调用<code>search(…)</code>方法开启<code>ContactFragmentImpl</code>如<code>ContactFragment</code>首先声明。因此，第二个声明将选择<code>PersonFragmentImpl</code>用于调用<code>search(…)</code>方法。</p>
</div>
<div class="paragraph">
<p>如果没有片段有助于实现，则特定于商店的方面（例如Querydsl）和基本实现将成为后备。</p>
</div>
<div class="paragraph">
<p>复合存储库是链接自定义实现片段的选项。它们提供了一种强大的方式来定义单个查询并将其挂钩，而不会丢失Spring Data的其余预建选项。如果您以前使用过自定义实现功能，请放心，这些操作将按预期继续。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="improved-naming-for-crud-repository-methods"><a class="anchor" href="#improved-naming-for-crud-repository-methods"></a>改进了CRUD存储库方法的命名</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在第一代Spring Data中，方法的命名方案<code>CrudRepository</code>造成了几个问题。特别是采用参数的方法是通用类型变量。在某些情况下（例如域或标识符类型的实现<code>Iterable</code> ），他们可以有效地解决相同的方法，并导致由<code>save(…)</code>和<code>delete(…)</code> 。</p>
</div>
<div class="paragraph">
<p>在Kay版本中，我们决定重命名以下方法所指导的方法：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>能够通过名称和（原始）参数类型查找方法。</p>
</li>
<li>
<p>方法命名<code>…All(…)</code>影响项目集合和/或返回集合。</p>
</li>
<li>
<p>带有标识符的方法被命名<code>…ById(…)</code> 。</p>
</li>
<li>
<p>让我们放下<code>ID extends Serializable</code>需求。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>我们不再需要<code>Serializable</code>方法重命名后的标识符。这是JPA标识符处理引入的约束，而Spring Data仅与JPA一起使用。我们的NoSql存储库不强制执行此可序列化的标识符，因此消除此要求可降低许多地方的复杂性。</p>
</div>
<div class="paragraph">
<p>新的<code>CrudRepository</code>具有一致的命名方案，而不会引起分辨率歧义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">interface CrudRepository&lt;T, ID&gt; extends Repository&lt;T, ID&gt; {

    S save(S entity);

    Iterable&lt;S&gt; saveAll(Iterable&lt;S&gt; entities)

    Optional&lt;T&gt; findById(ID id);

    boolean existsById(ID id);

    Iterable&lt;T&gt; findAllById(Iterable&lt;ID&gt; ids);

    void deleteById(ID id);

    void delete(T entity);

    void deleteAll(Iterable&lt;? extends T&gt; entities);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是，如果您以前有一个名为<code>id</code>实体标识符不是哪个？这个属性的查询方法不会与<code>findById(…)</code>以及其他…ById（...）`方法？是的</p>
</div>
<div class="paragraph">
<p>如果在这种情况下运行，则可以在方法名称中插入自定义区别，例如<code>findPersonById(…)</code>如果您与<code>Person</code>实体。Spring Data的方法解析使用前缀关键字，例如<code>find</code> ， <code>exists</code> ， <code>count</code>和<code>delete</code>和终止<code>By</code>关键词。您介于两者之间的所有内容<code>find</code>和<code>By</code>使您的方法名称更具表现力，并且不影响查询派生。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="fluent-mongooperations-api"><a class="anchor" href="#fluent-mongooperations-api"></a>流利的MongoOperations API</h2>
<div class="sectionbody">
<div class="paragraph">
<p>的<code>MongoOperations</code>与MongoDB进行更底层的交互时，接口是核心组件之一。它提供了广泛的方法，涵盖了从收集/索引创建和CRUD操作到更高级的功能（如映射减少和聚合）的需求。</p>
</div>
<div class="paragraph">
<p>看着<code>MongoOperations</code>一个人可以为每种方法找到多个重载。其中大多数仅涵盖API的可选/可为空的部分。尽管这很方便，但它也变得非常冗长，难以理解。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">// ...excerpt from MongoOperations

&lt;T&gt; List&lt;T&gt; find(Query query, Class&lt;T&gt; entityClass);
&lt;T&gt; List&lt;T&gt; find(Query query, Class&lt;T&gt; entityClass, String collectionName);

&lt;T&gt; T findOne(Query query, Class&lt;T&gt; entityClass);
&lt;T&gt; T findOne(Query query, Class&lt;T&gt; entityClass, String collectionName);

&lt;T&gt; CloseableIterator&lt;T&gt; stream(Query query, Class&lt;T&gt; entityType);
&lt;T&gt; CloseableIterator&lt;T&gt; stream(Query query, Class&lt;T&gt; entityType, String collectionName);</code></pre>
</div>
</div>
<div class="paragraph">
<p>用<code>FluentMongoOperations</code>我们引入了专门针对常见方法的界面<code>MongoOperations</code>提供更易读，流畅的API。入口点<code>insert(…)</code> ， <code>find(…)</code> ， <code>update(…)</code>等遵循基于要执行的操作的自然命名架构。从入口点开始，API旨在仅提供上下文相关的方法，以指导调用实际方法的终止方法。 <code>MongoOperations</code>对方。</p>
</div>
<div class="paragraph">
<p>让我们看一个具体的例子。想象一下，您拥有一系列《星球大战》角色，其中包括<code>Jedi</code> s。经典中<code>MongoOperations</code>设置该集合中所有实体的查找样式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Query query = new BasicQuery(new Document());
List&lt;SWCharacter&gt; all = ops.find(query, SWCharacter.class, "star-wars");</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用<code>FluentMongoOperations</code>以上可以表示为</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">List&lt;SWCharacter&gt; all = ops.find(SWCharacter.class)
  .inCollection("star-wars")
  .all();</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果<code>SWCharacter</code>通过定义集合<code>@Document</code>或者您使用类名作为集合名， <code>….inCollection("star-wars")</code>可以如下所示跳过步骤。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">List&lt;SWCharacter&gt; all = ops.find(SWCharacter.class).all();</code></pre>
</div>
</div>
<div class="paragraph">
<p>有时，MongoDB中的集合包含不同类型的实体。像一个<code>Jedi</code>在一个集合内<code>SWCharacter</code> s。通过完善请求<code>….as(Jedi.class)</code>将导致查询结果被映射到<code>Jedi</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Optional&lt;Jedi&gt; luke = ops.find(SWCharacter.class)
  .as(Jedi.class)
  .matching(query(where("firstname").is("luke")))
  .one();</code></pre>
</div>
</div>
<div class="paragraph">
<p>在检索单个实体，多个作为<code>List</code>要么<code>Stream</code>就像通过终止方法完成的一样<code>first()</code> ， <code>one()</code> ， <code>all()</code>要么<code>stream()</code> 。</p>
</div>
<div class="paragraph">
<p>通过编写地理空间查询时<code>near(NearQuery)</code>终止方法的数量更改为仅可用于执行<code>geoNear</code> MongoDB中的命令将实体提取为<code>GeoResult</code>中<code>GeoResults</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">GeoResults&lt;Jedi&gt; results = mongoOps.query(SWCharacter.class)
  .as(Jedi.class)
  .near(alderaan) // NearQuery.near(-73.9667, 40.78).maxDis…
  .all();</code></pre>
</div>
</div>
<div class="paragraph">
<p>相同的工作方式适用于的其他API部分<code>FluentMongoOperations</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">ops.update(Jedi.class)
  .matching(query(where("lastname").is("solo")))
  .apply(update("firstname", "han"))
  .upsert();

ops.remove(SWCharacter.class)
  .matching(query(where("name").is("yoda")))
  .all();

ops.aggregateAndReturn(Jedi.class)
  .by(newAggregation(Person.class, project("firstna...
  .all();</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mongodb-collation-support"><a class="anchor" href="#mongodb-collation-support"></a> MongoDB整理支持</h2>
<div class="sectionbody">
<div class="paragraph">
<p>MongoDB 3.4引入了对<a href="https://docs.mongodb.com/manual/reference/collation/">归类的</a>本机支持，允许为以下内容指定特定于语言的规则<code>String</code>比较。现在可以在大多数MongoDB命令中使用排序规则。创建集合或索引时，还可以<code>query</code> ， <code>findAndModify</code> ， <code>remove</code>和其他操作。</p>
</div>
<div class="paragraph">
<p>绝对值得一提的是，从MongoDB 3.4开始，现在可以使用不同的排序规则来设置涉及相同字段的多个索引。这对MongoDB本身的查询计划很重要，因为只有定义相同归类的查询才能真正使用索引。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">CollectionOptions collectionOptions = CollectionOptions.empty()
  .collation(Collation.of("en_US")
     .strength(primary().includeCase()));

template.createCollection("persons", collectionOptions);

IndexDefinition index = new Index()
  .named("en-name-idx")
  .on("name", Direction.ASC)
  .collation(Collation.of("en").caseFirst(off()));

template.indexOps("persons").ensureIndex(index);</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果没有提供排序规则，则MongoDB将使用简单的二进制比较，也可以通过以下方式显式设置<code>Collation.simple()</code> 。使用<code>Collation</code>在整个Spring Data MongoDB中的支持，我们引入了各种扩展点<code>Query</code> ， <code>NearQuery</code> ， <code>AggregationOptions</code> ， 和别的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Query query = query(where("firstName").is("Amél"))
  .collation(collation);

NearQuery nearQuery = near(-73.9667, 40.78)
  .query(where(…))
  .collation(Collation.of("fr")));

AggregationOptions options = new AggregationOptions.Builder()
  .collation(Collation.of("en_US"))
  .build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>在撰写本文时，定义<code>Collation</code>通过<code>@Indexed</code>不支持。展望未来，我们将利用Java 8可重复注释添加此功能。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="redis-client-configuration"><a class="anchor" href="#redis-client-configuration"></a> Redis客户端配置</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果考虑所有各种Redis操作模式（独立，Sentinel，群集），那么Spring Data Redis连接工厂的配置可能会很麻烦。使用特定于客户端的方面（SSL支持，池等）需要其他配置对象或条件配置。</p>
</div>
<div class="paragraph">
<p>我们将Redis客户端配置组织到特定于环境和客户端的部分。特定于环境的配置包含端点，数据库和身份验证（基于密码）详细信息：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>RedisStandaloneConfiguration</code> -用于Redis Standalone。如果使用复制，还可以使用它来连接特定的Redis Master或Slave节点。</p>
</li>
<li>
<p><code>RedisSentinelConfiguration</code> -在Redis节点由Redis Sentinel管理时使用。</p>
</li>
<li>
<p><code>RedisClusterConfiguration</code> -用于Redis集群。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>两个受支持的客户端Lettuce和Jedis均使用其特定于客户端的配置进行配置： <code>LettuceClientConfiguration</code>和<code>JedisClientConfiguration</code> 。我们之所以引入这种分裂，是因为每个客户端的发展都是彼此独立的，并且只有很少的共同点。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">RedisStandaloneConfiguration envConfig =
  new RedisStandaloneConfiguration("localhost", 6379);
envConfig.setDatabase(2);
envConfig.setPassword(RedisPassword.of("foobared"));

LettuceClientConfiguration clientConfig = LettuceClientConfiguration.builder()
        .clientResources(…)
        .clientOptions(…)
        .commandTimeout(Duration.ofMillis(500))
        .shutdownTimeout(Duration.ofMillis(200))
        .useSsl().disablePeerVerification()
        .build();

connectionFactory = new LettuceConnectionFactory(envConfig, clientConfig);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">RedisStandaloneConfiguration envConfig =
  new RedisStandaloneConfiguration("localhost", 6379);
envConfig.setDatabase(2);
envConfig.setPassword(RedisPassword.of("foobared"));

JedisClientConfiguration clientConfig = JedisClientConfiguration.builder()
        .clientName(environment.getProperty("spring.application.name"))
        .connectTimeout(Duration.ofMillis(200))
        .readTimeout(Duration.ofMillis(500))
        .useSsl().sslParameters(…).and()
        .usePooling().poolConfig(…)
        .build();

connectionFactory = new JedisConnectionFactory(envConfig, clientConfig);</code></pre>
</div>
</div>
<div class="paragraph">
<p>以前，某些属性是在连接工厂上设置的，有些具有客户端特定的对象。客户端配置是不可变的。您仍然可以在没有客户端配置的情况下使用连接工厂，但是我们不赞成使用配置设置器。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-data-for-apache-cassandra"><a class="anchor" href="#spring-data-for-apache-cassandra"></a> Apache Cassandra的Spring数据</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在此版本中，我们简化了模块的库布局。用于Apache Cassandra的Spring Data附带了两个库，即Spring CQL和Spring Data Cassandra。通过Spring Data Kay，我们合并了<code>spring-cql</code>进入<code>spring-data-cassandra</code>因为大部分用法都在里面<code>spring-data-cassandra</code>无论如何。通过此更改，我们已经应用了两个软件包重命名。我们将完成即将发布的RC1版本的内容。</p>
</div>
<div class="sect2">
<h3 id="cassandra-query-update-objects"><a class="anchor" href="#cassandra-query-update-objects"></a> Cassandra查询和更新对象</h3>
<div class="paragraph">
<p><code>Query</code>和<code>Update</code>对象允许对查询谓词和选择性更新进行细粒度控制。以前，我们支持通过更新所有属性来保留整个行，或者支持不基于映射的基于CQL的更新。</p>
</div>
<div class="paragraph">
<p><code>Query</code>和<code>Update</code>现在使用实体模型中的详细信息来支持属性到Cassandra的列映射。我们的查询映射器会在执行查询之前先转换值（映射的UDT，特定于数据类型的转换），因此您不需要自己将查询值转换为特定于Cassandra的表示形式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">class Person {

  @PrimaryKeyColumn(name="last_name", ordinal = 0, type = PARTITIONED)
  String lastname;

  @PrimaryKeyColumn(name="firs_tname", ordinal = 1, type = CLUSTERED)
  String firstname;

  List&lt;String&gt; episodes;

  String mood;
}

Query query = Query.query(Criteria.where("lastname").is("White"))
  .and(Criteria.where("firstname").in("Walter", "Skyler"))
  .sort(Sort.by("firstname").ascending())
  .withAllowFiltering()
  .limit(10);

List&lt;Person&gt; people = cassandraOperations.select(query, Person.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Query</code>包含过滤条件，排序和一组查询选项以控制查询的执行。您可以将其与各种模板一起用于Template API <code>select</code>和<code>update</code>查询数据以供选择或约束更新选择的方法。</p>
</div>
<div class="paragraph">
<p>说到其中<code>Update</code>允许您指定一组更新分配。
<code>Update</code>支持自Apache Cassandra 3.10起的所有更新运算符（设置，添加到列表，从集合中删除等等）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Update update = Update.update("mood", "Bad")
  .addTo("episodes").appendAll("S1E1", "S1E2");

Query query = Query.query(Criteria.where("lastname").is("White"))
  .and(Criteria.where("firstname").is("Skyler"))
  .queryOptions(WriteOptions.builder().ttl(100).build());

cassandraOperations.update(query, update, Person.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>查找有关的更多详细信息<code>Query</code>和<code>Update</code>在<a href="https://docs.spring.io/spring-data/cassandra/docs/current-SNAPSHOT/reference/html/#cassandra-template.query">参考文档中</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="lightweight-transactions"><a class="anchor" href="#lightweight-transactions"></a>轻量级交易</h3>
<div class="paragraph">
<p>支持轻量级交易（比较并设置交易） <code>insert</code>和<code>update</code>通过查询选项对实体进行的操作。运算结果通过返回实体还是实体来报告交易是否已应用<code>null</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">InsertOptions lwtOptions = InsertOptions.builder().withIfNotExists().build();

User user = new User("heisenberg", "Walter", "White");
User inserted = template.insert(user, lwtOptions);
User second = template.insert(user, lwtOptions); // returns null</code></pre>
</div>
</div>
<div class="paragraph">
<p>此版本附带了对基本轻量级交易的支持，我们希望听到您的反馈。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="java-9-compatibility"><a class="anchor" href="#java-9-compatibility"></a> Java 9兼容性</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="the-problem"><a class="anchor" href="#the-problem"></a>问题</h3>
<div class="paragraph">
<p>即将发布的Java 9发行版将与以前的发行版有所不同。它将破坏许多不适应更改的现有应用程序。这是由Java平台模块系统（JPMS）和相关的Java内部封装引起的。应用程序可能损坏的三个潜在原因：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>非法使用内部API。遵循以下原则可以得到一个例外：</p>
<div class="literalblock">
<div class="content">
<pre>module &lt;xyz&gt; does not "open &lt;package.abc&gt;" to unnamed module @&lt;random string&gt;</pre>
</div>
</div>
</li>
<li>
<p>更改了内部API的行为（或删除了内部API）。</p>
</li>
<li>
<p>默认情况下，未命名的模块只能访问该模块<code>java.base</code> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这对于许多情况已经足够，但不幸的是，并非对所有情况都足够。因此，可能必须使用以下命令将其他模块指定为依赖项<code>--add-modules <module name></code> 。
Java本身定义了<a href="http://cr.openjdk.java.net/~mr/jigsaw/ea/module-summary.html">所有模块及其内容的列表，</a>这将有助于找到要使用的正确模块名称。</p>
</div>
</div>
<div class="sect2">
<h3 id="spring-data-compatibility"><a class="anchor" href="#spring-data-compatibility"></a> Spring数据兼容性</h3>
<div class="paragraph">
<p>我们很高兴地宣布，Spring Data是Java 9的良好公民！</p>
</div>
<div class="paragraph">
<p>团队进行了更改，以确保我们的代码可以在Java 9上运行而无需任何操作<code>--permit-illegal-access</code>命令行参数，它是解决第一个要点中提到的问题所必需的。我们也不会使用适用于第二个要点的任何API。</p>
</div>
<div class="paragraph">
<p>不幸的是，这种兼容性有两个警告：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>它不包括某些商店。我们在<a href="https://jira.spring.io/browse/DATACMNS-1033">DATACMNS-1033中</a>跟踪我们对它们各自兼容性的<a href="https://jira.spring.io/browse/DATACMNS-1033">了解</a></p>
</li>
<li>
<p>您可能仍然会遇到第三个问题。一个已知的例子是这样的异常：</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>java.lang.NoClassDefFoundError: javax/xml/bind/JAXBException</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以通过添加来解决<code>--add-modules java.xml.bind</code>打电话给<code>java</code></p>
</div>
</li>
<li>
<p>当前，我们不能使用生成的属性访问器（在Ingalls发布系列中引入），因为生成的属性访问器无法再注入到原始类加载器中。这会导致轻微的性能下降。我们仍在寻找性能与Java 8兼容版本相同的Java 9兼容版本（有关详细信息，请参见<a href="https://jira.spring.io/browse/DATACMNS-1080">DATACMNS-1080</a> ）。</p>
</li>
<li>
<p>仍然需要编译和执行测试<code>--permit-illegal-access</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>每个相关人员都希望尽可能顺利地迁移到Java 9，您确实可以提供帮助。获取JDK 9的早期访问版本，并使用它构建和运行您的应用程序。如果遇到问题，请对遇到问题的项目提出问题。</p>
</div>
</div>
<div class="sect2">
<h3 id="unnamed-modules"><a class="anchor" href="#unnamed-modules"></a>未命名的模块</h3>
<div class="paragraph">
<p>如果您已经研究过Jigsaw项目，则可能已经注意到Spring Data附带的模块描述符不正确，即所谓的未命名模块。这有一个主要的缺点，就是我们无法在模块定义中指定模块依赖关系，而必须在执行时使用<code>--add-modules</code>命令行选项。</p>
</div>
<div class="paragraph">
<p>问题是我们依赖的所有库都需要提供模块描述符。虽然我们几乎没有必需的依赖项，但是我们有许多可选的依赖项。只有当所有这些库都提供适当的模块时，我们才能开始自己提供适当的模块。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="upgrade-to-elasticsearch-5-4"><a class="anchor" href="#upgrade-to-elasticsearch-5-4"></a>升级到Elasticsearch 5.4</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我们升级了Spring Data Elasticsearch（感谢Moshin和Artur！）到5.4使用传输客户端。</p>
</div>
<div class="paragraph">
<p>此次升级需要对我们的公共API进行一些更改。的<code>scan</code>方法被替换为<code>scroll</code>在Template API中返回分页结果并对齐注释的方法（ <code>@CompletionField</code> ， <code>@Field</code> ， <code>@GeoPointField</code> ， <code>@InnerField</code> ）到Elasticsearch的API。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="summary"><a class="anchor" href="#summary"></a>摘要</h2>
<div class="sectionbody">
<div class="paragraph">
<p>自从Spring Data Kay里程碑式的开发以来，这已经走了很长的一段路，我们希望您对发布的发布版本印象深刻。我们将为即将发布的候选版本添加一些次要功能，并在8月初向GA挺短的时间。如果您有任何疑问，反馈或希望与我们讨论功能，请通过<a href="https://jira.spring.io/browse/DATACMNS">Jira</a> ， <a href="https://stackoverflow.com/questions/tagged/spring-data">Stack Overflow</a> ， <a href="https://twitter.com/SpringData">Twitter</a>或<a href="https://gitter.im/spring-projects/spring-data">Gitter</a>进行访问。</p>
</div>
</div>
</div></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 2958;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>