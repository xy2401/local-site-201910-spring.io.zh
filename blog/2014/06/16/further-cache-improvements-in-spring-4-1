<!DOCTYPE html>
<html data-code-prettify="" data-mobile-support="" data-search="">
<head>
<title>Further Cache Improvements in Spring 4.1</title>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no" id="Viewport" name="viewport" />
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png" />
<link href="https://fonts.googleapis.com/css?family=Varela+Round|Montserrat:400,700" rel="stylesheet" type="text/css" />
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css" />
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M" name="google-site-verification" />

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css" />

<meta content="summary" name="twitter:card" />
<meta content="@springcentral" name="twitter:site" />
<meta name="twitter:title" content="Further Cache Improvements in Spring 4.1" />
<meta name="twitter:description" content="&lt;p&gt;This post is a follow-up of my earlier &lt;a href=&quot;http://spring.io/blog/2014/04/14/cache-abstraction-jcache-jsr-107-annotations-support&quot;&gt;post related to JSR-107&lt;/a&gt;. Adding JSR-107 support gave us the opportunity to review our own and see how the two can live happily together. Spring 4.1 also contains a series of improvements reported by the community.&lt;/p&gt;
&lt;p&gt;I am also happy to announce that a new getting started guide dedicated to the cache abstraction has been published, check &lt;a href=&quot;http://spring.io/guides/gs/caching/&quot;&gt;Caching Data with Spring&lt;/a&gt;!&lt;/p&gt;
&lt;h1&gt;&lt;a href=&quot;#cacheresolver&quot; class=&quot;anchor&quot; name=&quot;cacheresolver&quot;&gt;&lt;/a&gt;CacheResolver&lt;/h1&gt;
&lt;p&gt;One of the nicest features we found in JSR-107 was the ability to resolve the cache to use at runtime, that is based on the actual method execution. So far, our own support was relying on cache name(s) being specified at the annotation (or aspect definition) level. Several issues were raised to report that when more than one &lt;code&gt;CacheManager&lt;/code&gt; is used, it is required to be able to customize the manager to which those names were resolved to.&lt;/p&gt;
" />
<meta name="twitter:creator" content="@snicoll" />
<meta name="twitter:image:src" content="https://gravatar.com/avatar/33d0963a20138828608f3f61927545b8?s=200" />

<meta property="og:title" content="Further Cache Improvements in Spring 4.1" />
<meta property="og:image" content="https://gravatar.com/avatar/33d0963a20138828608f3f61927545b8?s=200" />
<meta property="og:description" content="&lt;p&gt;This post is a follow-up of my earlier &lt;a href=&quot;http://spring.io/blog/2014/04/14/cache-abstraction-jcache-jsr-107-annotations-support&quot;&gt;post related to JSR-107&lt;/a&gt;. Adding JSR-107 support gave us the opportunity to review our own and see how the two can live happily together. Spring 4.1 also contains a series of improvements reported by the community.&lt;/p&gt;
&lt;p&gt;I am also happy to announce that a new getting started guide dedicated to the cache abstraction has been published, check &lt;a href=&quot;http://spring.io/guides/gs/caching/&quot;&gt;Caching Data with Spring&lt;/a&gt;!&lt;/p&gt;
&lt;h1&gt;&lt;a href=&quot;#cacheresolver&quot; class=&quot;anchor&quot; name=&quot;cacheresolver&quot;&gt;&lt;/a&gt;CacheResolver&lt;/h1&gt;
&lt;p&gt;One of the nicest features we found in JSR-107 was the ability to resolve the cache to use at runtime, that is based on the actual method execution. So far, our own support was relying on cache name(s) being specified at the annotation (or aspect definition) level. Several issues were raised to report that when more than one &lt;code&gt;CacheManager&lt;/code&gt; is used, it is required to be able to customize the manager to which those names were resolved to.&lt;/p&gt;
" />
<meta content="article" property="og:type" />
<meta property="og:article:published_time" content="2014-06-16 07:18:00.0" />
</head>
<body>

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" style="display:none;visibility:hidden" width="0"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">Projects</a>
</li>
<li class="navbar-link">
<a href="/guides">Guides</a>
</li>
<li class="navbar-link active">
<a href="/blog">Blog</a>
</li>
<li class="navbar-link">
<a href="/services">Training & Certification</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form action="/search" class="form-inline form-search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search for documentation, guides, and posts..." type="text" value="" />
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form action="/search" class="form-inline form-search" method="get">
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search..." type="text" value="" />
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">
Home
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">
Projects
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">
Guides
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">
Blog
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">
Training & Certification
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>Engineering</div>
</div>
<div class="blog-category content--title">
<div>Releases</div>
</div>
<div class="blog-category content--title">
<div>News and Events</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Further Cache Improvements in Spring 4.1</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">Engineering</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/33d0963a20138828608f3f61927545b8?s=20&amp;d=mm" />
<a class="author" rel="author" href="/team/snicoll">St√©phane Nicoll</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2014-06-16 07:18:00.0">June 16, 2014</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" data-disqus-identifier="1635" href="/blog/2014/06/16/further-cache-improvements-in-spring-4-1#disqus_thread">
</a></div>
</div>
</header>
<div class="blog--post"><p>This post is a follow-up of my earlier <a href="https://spring.io/blog/2014/04/14/cache-abstraction-jcache-jsr-107-annotations-support">post related to JSR-107</a>. Adding JSR-107 support gave us the opportunity to review our own and see how the two can live happily together. Spring 4.1 also contains a series of improvements reported by the community.</p><p>I am also happy to announce that a new getting started guide dedicated to the cache abstraction has been published, check <a href="https://spring.io/guides/gs/caching/">Caching Data with Spring</a>!</p><h1><a href="#cacheresolver" class="anchor" name="cacheresolver"></a>CacheResolver</h1><p>One of the nicest features we found in JSR-107 was the ability to resolve the cache to use at runtime, that is based on the actual method execution. So far, our own support was relying on cache name(s) being specified at the annotation (or aspect definition) level. Several issues were raised to report that when more than one <code>CacheManager</code> is used, it is required to be able to customize the manager to which those names were resolved to.</p><p>What we did ultimately was creating a similar <code>CacheResolver</code> abstraction to give the most flexible options. As you might suspect, the default implementation takes a <code>CacheManager</code> and resolves the cache(s) to use based on the provided cache names. Because such names are no longer required, Spring 4.1 allows you to write the following:</p>
<pre><code class="prettyprint java">@Cacheable
public Book findBook(ISBN isbn) {...}
</code></pre><p>Of course, you have to specify your own <code>CacheResolver</code> that knows what to do with this particular invocation or you need to provide the cache(s) to use in a different manner (keep reading).</p><p>Just as the <code>value</code> attribute of the annotation is no longer required, the <code>CacheManager</code> may be omitted as long as a <code>CacheResolver</code> is set. You may actually have an implementation of it that does not rely on the <code>CacheManager</code> at all if you are managing your <code>Cache</code> instances in a different way.</p><h1><a href="#operation-level-customizations" class="anchor" name="operation-level-customizations"></a>Operation-level customizations</h1><p>The community also reported that they wanted to be able to control the cache behaviour in a much more fine-grained manner. Spring 4.1 allows you to specify the <code>CacheResolver</code> (or <code>CacheManager</code>) and <code>KeyGenerator</code> to use per operation. </p><p>For instance, the following applies a custom <code>KeyGenerator</code> to that specific operation</p>
<pre><code class="prettyprint java">@Cacheable(value=&quot;book&quot;, keyGenerator=&quot;myKeyGenerator&quot;)
public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)
</code></pre><p>This looks for a <code>KeyGenerator</code> bean with name <code>myKeyGenerator</code>. CacheManager and cache resolver instances can be set in a similar fashion.</p><h1><a href="#class-level-customizations" class="anchor" name="class-level-customizations"></a>Class-level customizations</h1><p>Another community feedback was the ability to share those customizations at method level <strong>without</strong> enabling any default cache behaviour. Meet <code>@CacheConfig</code> which provides the same customizations at class-level, i.e. cache names, <code>CacheResolver</code> (or <code>CacheManager</code>) and <code>KeyGenerator</code>.</p>
<pre><code class="prettyprint java">@CacheConfig(cacheNames=&quot;book&quot;, keyGenerator=&quot;myKeyGenerator&quot;) 
public class BookRepository {

    @Cacheable
    public Book findBook(ISBN isbn) {...}

    public Book thisIsNotCached(String someArg) {...}
}
</code></pre><h1><a href="#jcache-integration" class="anchor" name="jcache-integration"></a>JCache integration</h1><p>One of the main goal when we implemented the JSR-107 support was to leverage what we already had in our own abstraction so that existing apps can transition in a very smooth manner. JCache support actually uses Spring&rsquo;s caching abstraction internally which allows you to reuse your existing caching infrastructure with the standard annotations. When you specify a JSR-107 customization component such as a <code>javax.cache.annotation.CacheResolver</code> or a <code>javax.cache.annotation.CacheKeyGenerator</code>, we route it through our abstraction using an adapter.</p><p>What that means concretely is that you can keep your existing infrastructure and chose whichever mechanism you want. For instance, you can have a <code>ConcurrentMapCacheManager</code> that uses <code>ConcurrentHashMap</code> behinds the scenes with the standard JSR-107 annotations.</p><p>If you want to try that, check <a href="https://github.com/snicoll/gs-caching/tree/jsr-107">this fork of the guide</a> that uses JCache instead of the Spring annotations (commit <a href="https://github.com/snicoll/gs-caching/commit/32fea97e3e0a5031c2e9f124ae0ab5b2f58aa617">32fea97</a> shows what was actually changed)</p><h1><a href="#wrapping-up" class="anchor" name="wrapping-up"></a>Wrapping Up</h1><p>Spring 4.1 is due this summer and it will provide a major enhancement of its caching abstraction; adding support for JSR-107 helped us to further improve that. There are other small enhancements that were not covered in this post such as a better exception handling and a convenient <code>putIfAbsent</code> method on the <code>Cache</code> interface.</p><p>As always, we welcome community feedback, please try these features and let us know if you run into any issue.</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 1635;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>
Back
</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">All Posts</a>
<a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">Engineering</a>
<a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">Releases</a>
<a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">News and Events</a>
<a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>Get updates from The Spring Team delivered to your inbox</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">Tools</a></li>
<li><a href="https://store.pivotal.io/">Store</a></li>
<li><a href="/blog">Newsletter</a></li>
</ul>
</div>
</div>
&copy; <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a>, Inc. All Rights Reserved.
<a href="https://pivotal.io/terms-of-use">Terms of Use</a> &bullet;
<a href="https://pivotal.io/privacy-policy">Privacy</a> &bullet;
<a href="/trademarks">Trademark Guidelines</a>
 <div id="teconsent" style="display:inline-block;"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>