<html  data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>部署Spring Boot应用程序</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Deploying Spring Boot Applications">
<meta name="twitter:creator" content="@starbuxman" http:="" ="" projects.spring.io="" spring-boot="" ="=">Spring Boot 1.0 RC4 just dropped and 1.0 can’t be too far behind, and there are <em>all sort of cool features</em> coming! 
<p>One of the many questions I get around this concerns deployment strategies for Boot applications. Spring Boot builds on top of Spring and serves wherever Spring can serve. It enjoys Spring’s portability. Spring Boot lets the developer focus on the application’s development first, and removes the need to be overly concerned with every other aspect of its lifecycle, including deployment and management. </p>
" > <meta>
<meta name="twitter:image:src" content="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=200">

<meta property="og:title" content="Deploying Spring Boot Applications">
<meta property="og:image" content="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=200">
<meta property="og:type" content="article" http:="" ="" projects.spring.io="" spring-boot="" ="=">Spring Boot 1.0 RC4 just dropped and 1.0 can’t be too far behind, and there are <em>all sort of cool features</em> coming! 
<p>One of the many questions I get around this concerns deployment strategies for Boot applications. Spring Boot builds on top of Spring and serves wherever Spring can serve. It enjoys Spring’s portability. Spring Boot lets the developer focus on the application’s development first, and removes the need to be overly concerned with every other aspect of its lifecycle, including deployment and management. </p>
" > <meta>
<meta property="og:article:published_time" content="2014-03-07 03:20:00.0">
</head>
<body >

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">部署Spring Boot应用程序</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=20&d=mm"> <a class="author" rel="author" href="/team/jlong">乔什·朗（Josh Long）</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2014-03-07 03:20:00.0">2014年3月7日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2014/03/07/deploying-spring-boot-applications#disqus_thread" data-disqus-identifier="1430">
</a></div>
</div>
</header>
<div class="blog--post"><p><a href="https://projects.spring.io/spring-boot/">Spring Boot 1.0 RC4刚刚发布</a> ，1.0不能跟得上太远，而且还有<em>各种各样的酷功能</em> ！</p><p>我遇到的许多问题之一涉及引导应用程序的部署策略。Spring Boot建立在Spring之上，可以在Spring可以服务的任何地方使用。它具有Spring的便携性。Spring Boot使开发人员可以首先专注于应用程序的开发，而无需过多地关注其生命周期的所有其他方面，包括部署和管理。</p><p>它旨在开箱<em>即</em>用地进行<em>生产准备</em> 。作为其一部分，Spring Boot在默认情况下会做一些不同的事情，这些事情起初可能与某些事情有所不同。在本文中，我希望简要介绍一些部署Spring Boot应用程序的常用策略。在深入探讨之前，我将简要地介绍一下它以及一些示例代码。随意跳过本节，从“ <em>嵌入式Web服务器部署”</em>部分开始。</p><h2><a href="#getting-started-with-spring-boot" class="anchor" name="getting-started-with-spring-boot"></a> Spring Boot入门</h2><p>如果您尚未使用Spring Boot，请执行！有很多入门方法，包括<a href="https://start.spring.io">在start.spring.io Webservice上</a>的<a href="https://start.spring.io">Spring Initializr，</a>以及-如果您使用的是<a href="https://spring.io/tools">Spring Tool Suite</a> ，那么还有一个更熟悉的集成向导，最终可以调用相同的webservice。我通常首先检查<em>Actuator</em>和<em>Web</em>复选框，然后选择生成一个<em>Maven Project</em> 。这将为您提供两个入门类， <em>Application.java</em>和<em>ApplicationTests.java</em> ，以及现成的Maven <code>pom.xml</code>文件。</p><p>这是解压缩的入门项目：</p>
<pre><code class="prettyprint sh">➜  pwd
/Users/jlong/Downloads/starter
➜  starter  tree
.
├── pom.xml
└── src
    ├── main
    │   └── java
    │       └── demo
    │           └── Application.java
    └── test
        └── java
            └── demo
                └── ApplicationTests.java

7 directories, 3 files
➜  starter  
</code></pre><p>Maven构建<em>依赖</em>于Spring Boot启动的依赖关系。这些依赖是<em>有根据的</em> 。它们带来了与您之前的任务一致的已知的，可立即使用的堆栈，而不是您<em>可能</em>使用的技术堆栈：换句话说，如果您要构建Web应用程序，则只需依赖Spring Boot入门程序Web依赖性， 像这样：</p>
<pre><code class="prettyprint xml "> &lt;dependency&gt; 
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
 &lt;/dependency&gt;
</code></pre><p>Maven构建<em>从其父级继承</em>有关要使用哪些依赖项版本的信息<code>pom</code> ，也由Spring Boot提供。您无需担心常见的Spring项目版本和第三方依赖项的排队。</p><p>生成的Java类很简单（这就是为什么要<em>生成</em>它们！）。尽管可以，但您不会经常更改类本身。在本博客的最后，您将获得部署Spring Boot应用程序的通用秘诀。这是（希望如此！）您在Spring Boot中会遇到的唯一样板文件。这里是<code>Application.java</code> Spring Boot提供的类：</p>
<pre><code class="prettyprint java">package demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan
@EnableAutoConfiguration
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}

</code></pre><p>为了在发布期间进行演示，我们将添加一个RESTful Spring MVC控制器。这是修订的<code>Application.java</code>带有Spring MVC REST控制器的代码页，当请求执行以下操作时，该控制器会响应“ Hello， <strong>World</strong> ” <code>/hello/World</code>制成：</p>
<pre><code class="prettyprint java">package demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@Configuration
@ComponentScan
@EnableAutoConfiguration
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}

@RestController
class GreetingController {
    
    @RequestMapping(&quot;/hello/{name}&quot;)
    String hello(@PathVariable String name) {
        return &quot;Hello, &quot; + name + &quot;!&quot;;
    }
}

</code></pre><h2><a href="#embedded-web-server-deployment" class="anchor" name="embedded-web-server-deployment"></a>嵌入式Web服务器部署</h2><p>开箱即用，Spring Boot使用<code>public static void main</code>为您启动嵌入式Web服务器的入口点。</p><p>如果您使用Maven构建（ <code>mvn clean install</code> ）（由Spring Boot Initialzr提供），您将获得一个<em>胖子罐</em> 。这个<code>jar</code>方便，因为它包括所有其他依赖项以及存档中的Web服务器之类的东西。你可以给任何人<code>.jar</code>他们可以毫无问题地运行整个Spring应用程序：不需要构建工具，不需要设置，不需要Web服务器配置，等等： <code>java -jar ...your.jar</code> 。</p><h3><a href="#tomcat" class="anchor" name="tomcat"></a>雄猫</h3><p>运行应用程序时，默认情况下，Spring Boot将检测到您具有Spring MVC控制器并启动嵌入式Apache Tomcat 7实例。您应该能够通过打开浏览器并点击来测试REST端点<code>http://localhost:8080/hello/World</code> 。</p><p>嵌入式Tomcat有很多配置选项。您可以通过以下方式轻松地为您的网络服务启用HTTPS（SSL / TLS终止） <a href="https://github.com/joshlong/the-spring-rest-stack/blob/master/code/web/oauth/src/main/java/com/jl/crm/web/Application.java">： <code>EmbeddedServletContainerCustomizer</code> ，就像我在此示例中所做的那样</a> 。那里描述的模块有一个可以在HTTPS上运行的交钥匙式Web应用程序，仅需要SSL / TLS证书，并嵌入了自己的Web服务器。运行该特定应用程序非常简单： <code>java -Dspring.profiles.active=production -Dkeystore.file=file:///$PWD/src/main/resources/keystore.p12 -jar target/oauth-1.0.0.BUILD-SNAPSHOT.jar</code> 。</p><p>这个<code>EmbeddedServletContainerCustomizer</code>配置SPI使您可以为独立的Apache Tomcat实例利用大多数显式XML配置的功能。较小的内容（例如服务器在哪个端口上运行）可以通过在命令行中指定属性来配置（例如<code>--D</code>样式的参数）或通过加载的属性文件（Spring Boot将自动查询名为的文件中的任何属性<code>application.properties</code>在<code>CLASSPATH</code> ， 例如）。因此，要更改Tomcat侦听的端口，可以指定<code>--Dserver.port=8081</code> ，让它监听8081端口。如果指定<code>server.port=0</code> ，它将自动找到一个未使用的端口进行监听。</p><p>默认情况下，Spring Boot使用Tomcat 7。如果要使用Tomcat 8，请<em>这样说</em> ！您只需要覆盖Maven构建的<code>tomcat.version</code>属性，这将触发更高版本的Apache Tomcat的解析。</p>
<pre><code class="prettyprint xml">&lt;properties&gt;
  &lt;tomcat.version&gt;8.0.3&lt;/tomcat.version&gt;
&lt;/properties&gt;
</code></pre><h3><a href="#jetty" class="anchor" name="jetty"></a>码头</h3><p>当然，有些人可能想要使用<a href="https://www.eclipse.org/jetty/">Jetty嵌入式servlet容器</a> 。码头也是一个不错的选择。您可以简单地排除Spring Boot Starter Tomcat模块，然后导入Spring Boot Starter Jetty模块。Spring Boot将自动委托给它。这是修订的<code>dependencies</code>我们的Maven构建部分：</p>
<pre><code class="prettyprint xml">	&lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
		&lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;
        &lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
		&lt;/dependency&gt;
	&lt;/dependencies&gt;
</code></pre><p>如果要切换到Jetty 9，这也很容易。确保您具有以下条件<code>properties</code>在您的Maven版本中。</p>
<pre><code class="prettyprint xml">&lt;properties&gt;
    &lt;java.version&gt;1.7&lt;/java.version&gt;
    &lt;jetty.version&gt;9.1.0.v20131115&lt;/jetty.version&gt;
    &lt;servlet-api.version&gt;3.1.0&lt;/servlet-api.version&gt;
&lt;/properties&gt;
</code></pre><h2><a href="#what-about-the-java-ee-application-server" class="anchor" name="what-about-the-java-ee-application-server"></a> Java EE应用服务器呢？</h2><p>但是，我想您想知道，“如何将其部署到<em>现有的</em> Tomcat安装或经典的Java EE应用程序服务器（其中一些需要花费很多钱！）。像WebSphere，WebLogic或JBoss？”简单！毕竟，它仍然只是春天，因此几乎不需要其他任何内容。您需要进行三个直观的更改： <a href="https://spring.io/guides/gs/convert-jar-to-war/">从<code>jar</code>建立到<code>war</code>在Maven中构建</a> ：注释掉的声明<code>spring-boot-maven-plugin</code>您的插件<code>pom.xml</code>文件，然后更改Maven <code>packaging</code>输入<code>war</code> 。最后，在您的应用程序中添加一个Web入口点。Spring使用Servlet 3 Java配置为您配置几乎所有东西。您只需要给它机会。修改您的<code>Application</code>因此，入口点类：</p>
<pre><code class="prettyprint java">package demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.builder.SpringApplicationBuilder;
import org.springframework.boot.context.web.SpringBootServletInitializer;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@Configuration
@ComponentScan
@EnableAutoConfiguration
public class Application extends SpringBootServletInitializer {

    public static void main(String[] args) {
        SpringApplication.run(applicationClass, args);
    }

    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
        return application.sources(applicationClass);
    }

    private static Class&lt;Application&gt; applicationClass = Application.class;
}


@RestController
class GreetingController {

    @RequestMapping(&quot;/hello/{name}&quot;)
    String hello(@PathVariable String name) {
        return &quot;Hello, &quot; + name + &quot;!&quot;;
    }
} 
</code></pre><p>这个新的基类- <code>SpringBootServletInitializer</code> -利用Servlet 3样式的Java配置API，该API可让您用代码描述只能用<code>web.xml</code>之前。此类配置类是在应用程序启动时发现并调用的。这使Spring Boot有机会向Web服务器告知有关应用程序的信息，包括必需的信息。 <code>Servlet</code> s <code>Filter</code>和<code>Listener</code>通常是各种Spring项目所需的。</p><p>现在，可以使用此新类在内部使用嵌入式Jetty或Tomcat运行应用程序，并且可以将其部署到任何Servlet 3容器中。如果您的类与较大的应用程序服务器附带的类冲突，则可能会遇到问题。在这种情况下，请使用构建工具的功能来排除或制作<code>optional</code>相关的API。这是我必须进行的Maven构建更改，以启动Spring Boot REST服务并在JBoss WildFly（以前称为JBoss AS）上运行：</p>
<pre><code class="prettyprint xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

	&lt;groupId&gt;org.demo&lt;/groupId&gt;
	&lt;artifactId&gt;demo&lt;/artifactId&gt;
	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;

    &lt;packaging&gt;war&lt;/packaging&gt;
	&lt;description&gt;Demo project&lt;/description&gt;

	&lt;parent&gt;
		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
		&lt;version&gt;1.0.0.BUILD-SNAPSHOT&lt;/version&gt;
	&lt;/parent&gt;

	&lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
		&lt;/dependency&gt;
	&lt;/dependencies&gt;

	&lt;properties&gt;
        &lt;start-class&gt;demo.Application&lt;/start-class&gt;
		&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;java.version&gt;1.7&lt;/java.version&gt;
	&lt;/properties&gt;
	&lt;repositories&gt;
		&lt;repository&gt;
			&lt;id&gt;spring-snapshots&lt;/id&gt;
			&lt;name&gt;Spring Snapshots&lt;/name&gt;
			&lt;url&gt;http://repo.spring.io/snapshot&lt;/url&gt;
			&lt;snapshots&gt;
				&lt;enabled&gt;true&lt;/enabled&gt;
			&lt;/snapshots&gt;
		&lt;/repository&gt;
		&lt;repository&gt;
			&lt;id&gt;spring-milestones&lt;/id&gt;
			&lt;name&gt;Spring Milestones&lt;/name&gt;
			&lt;url&gt;http://repo.spring.io/milestone&lt;/url&gt;
			&lt;snapshots&gt;
				&lt;enabled&gt;false&lt;/enabled&gt;
			&lt;/snapshots&gt;
		&lt;/repository&gt;
	&lt;/repositories&gt;
	&lt;pluginRepositories&gt;
		&lt;pluginRepository&gt;
			&lt;id&gt;spring-snapshots&lt;/id&gt;
			&lt;name&gt;Spring Snapshots&lt;/name&gt;
			&lt;url&gt;http://repo.spring.io/snapshot&lt;/url&gt;
			&lt;snapshots&gt;
				&lt;enabled&gt;true&lt;/enabled&gt;
			&lt;/snapshots&gt;
		&lt;/pluginRepository&gt;
		&lt;pluginRepository&gt;
			&lt;id&gt;spring-milestones&lt;/id&gt;
			&lt;name&gt;Spring Milestones&lt;/name&gt;
			&lt;url&gt;http://repo.spring.io/milestone&lt;/url&gt;
			&lt;snapshots&gt;
				&lt;enabled&gt;false&lt;/enabled&gt;
			&lt;/snapshots&gt;
		&lt;/pluginRepository&gt;
	&lt;/pluginRepositories&gt;
&lt;/project&gt;

</code></pre><p>然后，我能够重新运行该构建并<code>cp</code>建<code>.war</code>到<code>$WILDFLY_HOME/standalone/deployments</code>目录。</p><p>如果尚未运行应用程序服务器，则启动它，然后应该可以在以下位置启动应用程序<code>http://localhost:8080/$YOURAPP/hello/World</code> 。再一次，我替换了<code>$YOURAPP</code>应用程序的名称（已构建）。</p><h2><a href="#to-the-cloud" class="anchor" name="to-the-cloud"></a>到云！</h2><p>如果不触及当今增长最快的部署目标：云，关于部署的故事是不完整的。当然，当我们谈论云时，将其具体化是有帮助的：如果您正在谈论直接部署到Amazon Web Services或Google Compute Engine，那么它就照常营业，就像您在云上运行应用程序一样。您自己的数据中心上的Linux机器。因为，基本上，这就是您正在做的事情。</p><h3><a href="#paas-deployment-on-cloud-foundry-and-heroku" class="anchor" name="paas-deployment-on-cloud-foundry-and-heroku"></a>在Cloud Foundry和Heroku上进行PaaS部署</h3><p>如果您试图将应用程序部署到平台即服务，那么Spring吹牛的可移植性在这里为您提供了很多选择。部署到Heroku（尤其是使用胖子方法）是Heroku的现状，因为该平台即服务希望您自带容器！简单地把<code>java -jar</code>你的咒语<code>Procfile</code>然后您就可以参加比赛了。</p><p>随着Cloud Foundry上，你可以将应用程序部署或者独立<em>或</em>作为<code>.war</code>样式的Web应用程序。构建应用程序后（例如，使用<code>mvn clean install</code> ）并<a href="http://docs.cloudfoundry.org/devguide/installcf/">安装了<code>cf</code>命令行工具</a> ，只需回答<code>cf push</code>我的命令提示符如下：</p>
<pre><code class="prettyprint sh">➜  cf push --path target/demo-0.0.1-SNAPSHOT.jar

Name&gt; $YOURAPP

Instances&gt; 1

1: 128M
2: 256M
3: 512M
4: 1G
Memory Limit&gt; 256M

Creating $YOURAPP... OK

1: $YOURAPP
2: none
Subdomain&gt; $YOURAPP

1: cfapps.io
2: none
Domain&gt; cfapps.io

Creating route $YOURAPP.cfapps.io... OK
Binding $YOURAPP.cfapps.io to $YOURAPP... OK

Create services for application?&gt; n

Bind other services to application?&gt; n

Save configuration?&gt; y

Saving to manifest.yml... OK
Uploading $YOURAPP... OK
Preparing to start $YOURAPP... OK
-----&gt; Downloaded app package (8.7M)
-----&gt; Java Buildpack source: system
-----&gt; Downloading Open JDK 1.7.0_51 from http://d2vm4m9hl67ira.cloudfront.net/openjdk/lucid/x86_64/openjdk-1.7.0_51.tar.gz (1.4s)
       Expanding Open JDK to .java-buildpack/open_jdk (1.3s)
-----&gt; Downloading Spring Auto Reconfiguration 0.8.7 from http://d2vm4m9hl67ira.cloudfront.net/auto-reconfiguration/auto-reconfiguration-0.8.7.jar (0.0s)
-----&gt; Uploading droplet (43M)
Checking status of app &#39;$YOURAPP&#39;...
  0 of 1 instances running (1 starting)
  0 of 1 instances running (1 starting)
  1 of 1 instances running (1 running)
Push successful! App &#39;$YOURAPP&#39; available at http://$YOURAPP.cfapps.io

</code></pre><p>该应用程序应该启动并运行，并且可以从以下位置访问<code>http://$YOURAPP.cfapps.io/hello/Cloud%20Foundry</code>再次，我曾经在哪里<code>$YOURAPP</code>作为应用程序名称的占位符。</p><h2><a href="#conclusion" class="anchor" name="conclusion"></a>结论</h2><p>一点都不差<code>Application</code>类和对构建文件的一些调整！</p><p>默认情况下，Spring Boot的目标是准备就绪。这意味着它附带了一些有用的默认值，可以在必要时将其覆盖。默认情况下，Spring Boot提供了嵌入式Apache Tomcat构建。默认情况下，Spring Boot以一种最自然的方式为您配置所有内容，从当今的平台以及领先的平台即服务的开发到生产。</p><p>Spring Boot提供了许多覆盖配置的机会，包括可配置的属性和自定义回调。</p><p>展望未来，我已经可以看到其他几篇文章继续讨论，讨论如何通过监视和管理工具（JMX和JConsole，New Relic等）管理Spring Boot应用程序以及安全问题。令人愉快的是，Spring Boot为所有这些问题以及更多问题提供了答案。</p><h2><a href="#your-next-steps-with-boot" class="anchor" name="your-next-steps-with-boot"></a>下一步启动</h2><p>Spring Boot文档在升级到1.0时迅速汇集在一起，与此同时，还有许多很棒的资源可以继续探索。查看<a href="https://github.com/spring-projects/spring-boot/blob/master/docs/howto.md">我最喜欢的抓包页面之一，以获取提示和技巧， <em>如何</em>记录文档</a> ，不要忘记<a href="https://spring.io/guides">查看Spring IO指南</a> ，其中大多数<a href="https://spring.io/guides">指南</a>基于Spring Boot！</p><p>我很想<a href="https://twitter.com/starbuxman">将此讨论继续进行下去</a> 。我想知道在调查Spring Boot时还想回答什么其他问题，所以不要害羞。我将于2014年4月9日<a href="https://www.meetup.com/virtualJUG/events/164640872/">在Spring Boot</a>上<a href="https://www.meetup.com/virtualJUG/events/164640872/">进行虚拟JUG</a>直播！该活动在全球范围内且具有互动性，因此请提出您的问题，意见和反馈。</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 1430;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>