<!DOCTYPE html>
<html data-code-prettify="" data-mobile-support="" data-search="">
<head>
<title>Spring Integration Java DSL (pre Java 8): Line by line tutorial</title>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no" id="Viewport" name="viewport" />
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png" />
<link href="https://fonts.googleapis.com/css?family=Varela+Round|Montserrat:400,700" rel="stylesheet" type="text/css" />
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css" />
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M" name="google-site-verification" />

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css" />

<meta content="summary" name="twitter:card" />
<meta content="@springcentral" name="twitter:site" />
<meta name="twitter:title" content="Spring Integration Java DSL (pre Java 8): Line by line tutorial" />
<meta name="twitter:description" content="&lt;p&gt;Dear Spring Community!&lt;/p&gt;
&lt;p&gt;Recently we published the&lt;br&gt;&lt;a href=&quot;https://spring.io/blog/2014/11/25/spring-integration-java-dsl-line-by-line-tutorial&quot;&gt;Spring Integration Java DSL: Line by line tutorial&lt;/a&gt;,&lt;br&gt; which uses Java 8 Lambdas extensively. We received some feedback that this is good introduction&lt;br&gt; to the DSL, but a similar tutorial is needed for those users, who can’t move to the Java 8 or aren’t yet familiar&lt;br&gt; with &lt;code&gt;Lambdas&lt;/code&gt;, but wish to take advantage&lt;/p&gt;
&lt;p&gt;So, to help those Spring Integration users who want to moved from XML configuration to Java &amp;amp; Annotation&lt;br&gt;configuration, we provide this &lt;code&gt;line-by-line tutorial&lt;/code&gt; to demonstrate that, even without &lt;code&gt;Lambdas&lt;/code&gt;, we gain&lt;br&gt;a lot from Spring Integration Java DSL usage. Although, most will agree that the lambda syntax provides for a&lt;br&gt;more succinct definition.&lt;/p&gt;
" />
<meta name="twitter:creator" content="@artem_bilan" />
<meta name="twitter:image:src" content="https://gravatar.com/avatar/2158ce6e7c048277890eb64458864c1c?s=200" />

<meta property="og:title" content="Spring Integration Java DSL (pre Java 8): Line by line tutorial" />
<meta property="og:image" content="https://gravatar.com/avatar/2158ce6e7c048277890eb64458864c1c?s=200" />
<meta property="og:description" content="&lt;p&gt;Dear Spring Community!&lt;/p&gt;
&lt;p&gt;Recently we published the&lt;br&gt;&lt;a href=&quot;https://spring.io/blog/2014/11/25/spring-integration-java-dsl-line-by-line-tutorial&quot;&gt;Spring Integration Java DSL: Line by line tutorial&lt;/a&gt;,&lt;br&gt; which uses Java 8 Lambdas extensively. We received some feedback that this is good introduction&lt;br&gt; to the DSL, but a similar tutorial is needed for those users, who can’t move to the Java 8 or aren’t yet familiar&lt;br&gt; with &lt;code&gt;Lambdas&lt;/code&gt;, but wish to take advantage&lt;/p&gt;
&lt;p&gt;So, to help those Spring Integration users who want to moved from XML configuration to Java &amp;amp; Annotation&lt;br&gt;configuration, we provide this &lt;code&gt;line-by-line tutorial&lt;/code&gt; to demonstrate that, even without &lt;code&gt;Lambdas&lt;/code&gt;, we gain&lt;br&gt;a lot from Spring Integration Java DSL usage. Although, most will agree that the lambda syntax provides for a&lt;br&gt;more succinct definition.&lt;/p&gt;
" />
<meta content="article" property="og:type" />
<meta property="og:article:published_time" content="2014-12-01 08:20:00.0" />
</head>
<body>

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" style="display:none;visibility:hidden" width="0"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">Projects</a>
</li>
<li class="navbar-link">
<a href="/guides">Guides</a>
</li>
<li class="navbar-link active">
<a href="/blog">Blog</a>
</li>
<li class="navbar-link">
<a href="/services">Training & Certification</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form action="/search" class="form-inline form-search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search for documentation, guides, and posts..." type="text" value="" />
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form action="/search" class="form-inline form-search" method="get">
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search..." type="text" value="" />
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">
Home
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">
Projects
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">
Guides
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">
Blog
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">
Training & Certification
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>Engineering</div>
</div>
<div class="blog-category content--title">
<div>Releases</div>
</div>
<div class="blog-category content--title">
<div>News and Events</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Spring Integration Java DSL (pre Java 8): Line by line tutorial</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">Engineering</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/2158ce6e7c048277890eb64458864c1c?s=20&amp;d=mm" />
<a class="author" rel="author" href="/team/artembilan">Artem Bilan</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2014-12-01 08:20:00.0">December 01, 2014</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" data-disqus-identifier="1865" href="/blog/2014/12/01/spring-integration-java-dsl-pre-java-8-line-by-line-tutorial#disqus_thread">
</a></div>
</div>
</header>
<div class="blog--post"><p>Dear Spring Community!</p><p>Recently we published the<br /><a href="https://spring.io/blog/2014/11/25/spring-integration-java-dsl-line-by-line-tutorial">Spring Integration Java DSL: Line by line tutorial</a>,<br /> which uses Java 8 Lambdas extensively. We received some feedback that this is good introduction<br /> to the DSL, but a similar tutorial is needed for those users, who can&rsquo;t move to the Java 8 or aren&rsquo;t yet familiar<br /> with <code>Lambdas</code>, but wish to take advantage</p><p>So, to help those Spring Integration users who want to moved from XML configuration to Java &amp; Annotation<br />configuration, we provide this <code>line-by-line tutorial</code> to demonstrate that, even without <code>Lambdas</code>, we gain<br />a lot from Spring Integration Java DSL usage. Although, most will agree that the lambda syntax provides for a<br />more succinct definition.</p><p>We analyse here the same <a href="https://github.com/spring-projects/spring-integration-samples/tree/master/dsl/cafe-dsl">Cafe Demo</a> sample,<br /> but using the pre Java 8 variant for configuration. Many options are the same, so we just copy/paste their description here to<br /> achieve a complete picture. Since this Spring Integration Java DSL configuration is quite different to the<br /> Java 8 lambda style, it will be useful for all users to get a knowlage how we can achieve the same result with a rich variety<br /> of options provided by the Spring Integration Java DSL.</p><p>The source code for our application is placed in a single class, which is a <code>Boot</code> application;<br />significant lines are annotated with a number corresponding to the comments, which follow:</p>
<pre><code class="prettyprint java">@SpringBootApplication                                                   // 1
@IntegrationComponentScan                                                // 2
public class Application {

  public static void main(String[] args) throws Exception {
  	ConfigurableApplicationContext ctx =
			SpringApplication.run(Application.class, args);              // 3

  	Cafe cafe = ctx.getBean(Cafe.class);                                 // 4
  	for (int i = 1; i &lt;= 100; i++) {                                     // 5
  	  Order order = new Order(i);
  	  order.addItem(DrinkType.LATTE, 2, false);
  	  order.addItem(DrinkType.MOCHA, 3, true);
  	  cafe.placeOrder(order);
  	}

  	System.out.println(&quot;Hit &#39;Enter&#39; to terminate&quot;);                      // 6
  	System.in.read();
  	ctx.close();
  }

  @MessagingGateway                                                      // 7
  public interface Cafe {

  	@Gateway(requestChannel = &quot;orders.input&quot;)                            // 8
  	void placeOrder(Order order);                                        // 9

  }

  private final AtomicInteger hotDrinkCounter = new AtomicInteger();

  private final AtomicInteger coldDrinkCounter = new AtomicInteger();    // 10

  @Autowired
  private CafeAggregator cafeAggregator;                                 // 11

  @Bean(name = PollerMetadata.DEFAULT_POLLER)
  public PollerMetadata poller() {                                       // 12
  	return Pollers.fixedDelay(1000).get();
  }

  @Bean
  @SuppressWarnings(&quot;unchecked&quot;)
  public IntegrationFlow orders() {                                      // 13
  	return IntegrationFlows.from(&quot;orders.input&quot;)                         // 14
	  .split(&quot;payload.items&quot;, (Consumer) null)                           // 15
	  .channel(MessageChannels.executor(Executors.newCachedThreadPool()))// 16
	  .route(&quot;payload.iced&quot;,                                             // 17
	    new Consumer&lt;RouterSpec&lt;ExpressionEvaluatingRouter&gt;&gt;() {         // 18

	      @Override
	      public void accept(RouterSpec&lt;ExpressionEvaluatingRouter&gt; spec) {
	      	spec.channelMapping(&quot;true&quot;, &quot;iced&quot;)
                .channelMapping(&quot;false&quot;, &quot;hot&quot;);                         // 19
  	      }

  	    })
  	  .get();                                                            // 20
  }

  @Bean
  public IntegrationFlow icedFlow() {                                    // 21
  	return IntegrationFlows.from(MessageChannels.queue(&quot;iced&quot;, 10))      // 22
	  .handle(new GenericHandler&lt;OrderItem&gt;() {                          // 23

	  	@Override
	  	public Object handle(OrderItem payload, Map&lt;String, Object&gt; headers) {
	  	  Uninterruptibles.sleepUninterruptibly(1, TimeUnit.SECONDS);
	  	  System.out.println(Thread.currentThread().getName()
	  	    + &quot; prepared cold drink #&quot; + coldDrinkCounter.incrementAndGet()
	  	    + &quot; for order #&quot; + payload.getOrderNumber() + &quot;: &quot; + payload);
	  	  return payload;                                                // 24
  	  	}

  	  })
  	  .channel(&quot;output&quot;)                                                 // 25
  	  .get();
  }

  @Bean
  public IntegrationFlow hotFlow() {                                     // 26
  	return IntegrationFlows.from(MessageChannels.queue(&quot;hot&quot;, 10))
	  .handle(new GenericHandler&lt;OrderItem&gt;() {

	  	@Override
	  	public Object handle(OrderItem payload, Map&lt;String, Object&gt; headers) {
	  	  Uninterruptibles.sleepUninterruptibly(5, TimeUnit.SECONDS);    // 27
	  	  System.out.println(Thread.currentThread().getName()
	  	    + &quot; prepared hot drink #&quot; + hotDrinkCounter.incrementAndGet()
	  	    + &quot; for order #&quot; + payload.getOrderNumber() + &quot;: &quot; + payload);
	  	  return payload;
  	  	}

  	  })
  	  .channel(&quot;output&quot;)
  	  .get();
  }

  @Bean
  public IntegrationFlow resultFlow() {                                  // 28
    return IntegrationFlows.from(&quot;output&quot;)                               // 29
      .transform(new GenericTransformer&lt;OrderItem, Drink&gt;() {            // 30

        @Override
        public Drink transform(OrderItem orderItem) {
          return new Drink(orderItem.getOrderNumber(),
            orderItem.getDrinkType(),
            orderItem.isIced(),
            orderItem.getShots());                                       // 31
        }

      })
      .aggregate(new Consumer&lt;AggregatorSpec&gt;() {                        // 32

        @Override
        public void accept(AggregatorSpec aggregatorSpec) {
          aggregatorSpec.processor(cafeAggregator, null);                // 33
        }

      }, null)
      .handle(CharacterStreamWritingMessageHandler.stdout())             // 34
    .get();
  }


  @Component
  public static class CafeAggregator {                                   // 35

  	@Aggregator                                                          // 36
  	public Delivery output(List&lt;Drink&gt; drinks) {
  	  return new Delivery(drinks);
  	}

  	@CorrelationStrategy                                                 // 37
  	public Integer correlation(Drink drink) {
  	  return drink.getOrderNumber();
  	}

  }

}
</code></pre><p>Examining the code line by line&hellip;</p><p><a name="line1" /><br />1.<br /><code>java
@SpringBootApplication
</code><br />This new meta-annotation from Spring Boot 1.2. Includes <code>@Configuration</code> and<br /><code>@EnableAutoConfiguration</code>. Since we are in a Spring Integration application and Spring Boot has auto-configuration<br />for it, the <code>@EnableIntegration</code> is automatically applied, to initialize the Spring Integration infrastructure including an<br />environment for the Java DSL - <code>DslIntegrationConfigurationInitializer</code>, which is picked up by the<br /><code>IntegrationConfigurationBeanFactoryPostProcessor</code> from <code>/META-INF/spring.factories</code>.</p><p><a name="line2" /><br />2.<br /><code>java
@IntegrationComponentScan
</code><br />The Spring Integration analogue of <code>@ComponentScan</code> to scan components based on<br />interfaces, (the Spring Framework&rsquo;s <code>@ComponentScan</code> only looks at classes). Spring Integration supports the discovery of interfaces<br />annotated with <code>@MessagingGateway</code> (see #7 below).</p><p><a name="line3" /><br />3.<br /><code>java
ConfigurableApplicationContext ctx =
SpringApplication.run(Application.class, args);
</code><br />The <code>main</code> method of our class is designed to start the Spring Boot application using the<br />configuration from this class and starts an <code>ApplicationContext</code> via Spring Boot. In addition, it delegates command<br />line arguments to the Spring Boot. For example you can specify <code>--debug</code> to see logs for the boot auto-configuration report.</p><p><a name="line4" /><br />4.<br /><code>java
Cafe cafe = ctx.getBean(Cafe.class);
</code><br />Since we already have an <code>ApplicationContext</code> we can start to interact with application. And <code>Cafe</code><br />is that entry point - in EIP terms a <code>gateway</code>. Gateways are simply interfaces and the application does not interact<br />with the Messaging API; it simply deals with the domain (see #7 below).</p><p><a name="line5" /><br />5.<br /><code>java
for (int i = 1; i &lt;= 100; i++) {
</code><br />To demonstrate the cafe &ldquo;work&rdquo; we intiate 100 orders with two drinks - one hot and one iced. And send the <code>Order</code> to the <code>Cafe</code> gateway.</p><p><a name="line6" /><br />6.<br /><code>java
System.out.println(&quot;Hit &#39;Enter&#39; to terminate&quot;);
</code><br />Typically Spring Integration application are asynchronous, hence to avoid early exit from the <code>main</code> Thread we block the<br /><code>main</code> method until some end-user interaction through the command line. Non daemon threads will keep the application<br />open but <code>System.read()</code> provides us with a mechanism to close the application cleanly.</p><p><a name="line7" /><br />7.<br /><code>java
@MessagingGateway
</code><br />The annotation to mark a business interface to indicate it is a <code>gateway</code> between the<br />end-application and integration layer. It is an analogue of <code>&lt;gateway /&gt;</code> component from Spring Integration XML<br />configuration. Spring Integration creates a <code>Proxy</code> for this interface and populates it as a bean in the<br />application context. The purpose of this <code>Proxy</code> is to wrap parameters in a <code>Message&lt;?&gt;</code> object and send it to the<br /><code>MessageChannel</code> according to the provided options.</p><p><a name="line8" /><br />8.<br /><code>java
@Gateway(requestChannel = &quot;orders.input&quot;)
</code><br />The method level annotation to distinct business logic by methods as well as by the target<br />integration flows. In this sample we use a <code>requestChannel</code> reference of <code>orders.input</code>, which is a <code>MessageChannel</code><br />bean name of our <code>IntegrationFlow</code> input channel (see below #14).</p><p><a name="line9" /><br />9.<br /><code>java
void placeOrder(Order order);
</code><br />The interface method is a central point to interact from end-application with the integration layer. This method has a<br /><code>void</code> return type. It means that our integration flow is <code>one-way</code> and we just send messages to the integration flow, but don&rsquo;t wait for a reply.</p><p><a name="line10" /><br />10.<br /><code>java
private AtomicInteger hotDrinkCounter = new AtomicInteger();
private AtomicInteger coldDrinkCounter = new AtomicInteger();
</code><br />Two counters to gather the information how our cafe works with drinks.</p><p><a name="line11" /><br />11.<br /><code>java
@Autowired
private CafeAggregator cafeAggregator;
</code><br />The POJO for the <code>Aggregator</code> logic (see #33 and #35 below). Since it is a Spring bean, we can simply inject it even to the current <code>@Configuration</code> and use in any place below, e.g. from the <code>.aggregate()</code> EIP-method.</p><p><a name="line12" /><br />12.<br /><code>java
@Bean(name = PollerMetadata.DEFAULT_POLLER)
public PollerMetadata poller() {
</code><br />The <code>default</code> <code>poller</code> bean. It is a analogue of <code>&lt;poller default=&quot;true&quot;&gt;</code> component from Spring Integration XML configuration. Required for endpoints where the <code>inputChannel</code> is a <code>PollableChannel</code>. In this case, it is necessary for the<br />two Cafe <code>queues</code> - hot and iced (see below #18). Here we use the <code>Pollers</code> factory from the DSL project and use its<br />method-chain fluent API to build the poller metadata. Note that <code>Pollers</code> can be used directly from an <code>IntegrationFlow</code> definition,<br />if a specific <code>poller</code> (rather than the default poller) is needed for an endpoint.</p><p><a name="line13" /><br />13.<br /><code>java
@Bean
public IntegrationFlow orders() {
</code><br />The <code>IntegrationFlow</code> bean definition. It is the central component of the Spring Integration Java DSL, although it does not play any role at runtime, just during the bean registration phase. All other code below registers Spring Integration components (<code>MessageChannel</code>, <code>MessageHandler</code>, <code>EventDrivenConsumer</code>, <code>MessageProducer</code>, <code>MessageSource</code> etc.) in the <code>IntegrationFlow</code> object, which is parsed by the <code>IntegrationFlowBeanPostProcessor</code> to process those components and register them as beans in the application context as necessary (some elements, such as channels may already exist).</p><p><a name="line14" /><br />14.<br /><code>java
return IntegrationFlows.from(&quot;orders.input&quot;)
</code><br />The <code>IntegrationFlows</code> is the main <code>factory</code> class to start the <code>IntegrationFlow</code>. It provides a number of overloaded <code>.from()</code> methods to allow starting a flow from a <code>SourcePollingChannelAdapter</code> for a <code>MessageSource&lt;?&gt;</code> implementations, e.g. <code>JdbcPollingChannelAdapter</code>; from a <code>MessageProducer</code>, e.g. <code>WebSocketInboundChannelAdapter</code>; or simply a <code>MessageChannel</code>. All &ldquo;.from()&rdquo; options have several convenient variants to configure the appropriate component for the start of the <code>IntegrationFlow</code>. Here we use just a channel name, which is converted to a <code>DirectChannel</code> bean definition during the bean definition phase while parsing the <code>IntegrationFlow</code>. In the Java 8 variant, we used here a <code>Lambda definition</code> - and this <code>MessageChannel</code> has been implicitly created with the bean name based on the <code>IntegrationFlow</code> bean name.</p><p><a name="line15" /><br />15.<br /><code>java
.split(&quot;payload.items&quot;, (Consumer) null)
</code><br />Since our integration flow accepts messages through the <code>orders.input</code> channel, we are ready to consume and process them. The first EIP-method in our scenario is <code>.split()</code>. We know that the message <code>payload</code> from <code>orders.input</code> channel is an <code>Order</code> domain object, so we can simply use here a Spring (SpEL) Expression to return <code>Collection&lt;OrderItem&gt;</code>. So, this performs the <code>split</code> EI pattern, and we send each collection entry as a separate message to the next channel. In the background, the <code>.split()</code> method registers a <code>ExpressionEvaluatingSplitter</code> <code>MessageHandler</code> implementation and an <code>EventDrivenConsumer</code> for that <code>MessageHandler</code>, wiring in the <code>orders.input</code> channel as the <code>inputChannel</code>.</p><p>The second argument for the <code>.split()</code> EIP-method is for an <code>endpointConfigurer</code> to<br />customize options like <code>autoStartup</code>, <code>requiresReply</code>, <code>adviceChain</code> etc. We use here <code>null</code> to show that we rely<br />on the default options for the endpoint. Many of EIP-methods provide overloaded versions with and without<br /><code>endpointConfigurer</code>. Currently <code>.split(String expression)</code> EIP-method without the <code>endpointConfigurer</code> argument is not available; this will be addressed in a future release.</p><p><a name="line16" /><br />16.<br /><code>java
.channel(MessageChannels.executor(Executors.newCachedThreadPool()))
</code><br />The <code>.channel()</code> EIP-method allows the specification of concrete <code>MessageChannel</code>s between endpoints, as it is done via<br /><code>output-channel</code>/<code>input-channel</code> attributes pair with Spring Integration XML configuration. By default, endpoints in the<br />DSL integration flow definition are wired with <code>DirectChannel</code>s, which get bean names based on the <code>IntegrationFlow</code><br />bean name and <code>index</code> in the flow chain. In this case we select a<br />specific <code>MessageChannel</code> implementation from the <code>Channels</code> factory class; the selected<br />channel here is an <code>ExecutorChannel</code>, to allow distribution of messages from the <code>splitter</code> to separate <code>Thread</code>s, to process<br />them in parallel in the downstream flow.</p><p><a name="line17" /><br />17.<br /><code>java
.route(&quot;payload.iced&quot;,
</code><br />The next EIP-method in our scenario is <code>.route()</code>, to send <code>hot/iced</code> order items to different Cafe kitchens. We again use here a SpEL expression to get the <code>routingKey</code> from the incoming message. In the Java 8 variant, we used a <code>method-reference</code> Lambda expression, but for pre Java 8 style we must use SpEL or an inline interface implementation. Many anonymous classes in a flow can make the flow difficult to read so we prefer SpEL in most cases.</p><p><a name="line18" /><br />18.<br /><code>java
new Consumer&lt;RouterSpec&lt;ExpressionEvaluatingRouter&gt;&gt;() {
</code><br />The second argument of <code>.route()</code> EIP-method is a functional interface <code>Consumer</code> to specify <code>ExpressionEvaluatingRouter</code> options using a <code>RouterSpec</code> Builder. Since we don&rsquo;t have any choice with pre Java 8, we just provide here an inline implementation for this interface.</p><p><a name="line19" /><br />19.<br /><code>java
spec.channelMapping(&quot;true&quot;, &quot;iced&quot;)
.channelMapping(&quot;false&quot;, &quot;hot&quot;);
</code><br />With the <code>Consumer&lt;RouterSpec&lt;ExpressionEvaluatingRouter&gt;&gt;#accept()</code> implementation we can provide desired <code>AbstractMappingMessageRouter</code> options. One of them is <code>channelMappings</code>, when we specify the routing logic by the result of router expresion and the target <code>MessageChannel</code> for the apropriate result. In this case <code>iced</code> and <code>hot</code> are <code>MessageChannel</code> names for <code>IntegrationFlow</code>s below.</p><p><a name="line20" /><br />20.<br /><code>java
.get();
</code><br />This finalizes the flow.<br />Any <code>IntegrationFlows.from()</code> method returns an <code>IntegrationFlowBuilder</code> instance and this <code>get()</code> method extracts an <code>IntegrationFlow</code> object from the <code>IntegrationFlowBuilder</code> configuration. Everything starting from the <code>.from()</code> and up to the method before the <code>.get()</code> is an <code>IntegrationFlow</code> definition. All defined components are stored in the <code>IntegrationFlow</code> and processed by the <code>IntegrationFlowBeanPostProcessor</code> during the bean creation phase.</p><p><a name="line21" /><br />21.<br /><code>java
@Bean
public IntegrationFlow icedFlow() {
</code><br />This is the second <code>IntegrationFlow</code> bean definition - for <code>iced</code> drinks. Here we demonstrate that several <code>IntegrationFlow</code>s<br />can be wired together to create a single complex application. Note: it isn&rsquo;t recommended to inject one <code>IntegrationFlow</code> to<br />another; it might cause unexpected behaviour. Since they provide Integration components for the bean registration and<br /><code>MessageChannel</code>s one of them, the best way to wire and inject is via <code>MessageChannel</code> or <code>@MessagingGateway</code><br />interfaces.</p><p><a name="line22" /><br />22.<br /><code>java
return IntegrationFlows.from(MessageChannels.queue(&quot;iced&quot;, 10))
</code><br />The <code>iced</code> <code>IntegrationFlow</code> starts from a <code>QueueChannel</code> that has a capacity of <code>10</code> messages; it is registered as a bean with the name <code>iced</code>.<br />As you remember we use this name as one of the route mappings (see above #19).</p><p>In our sample, we use here a restricted<br /><code>QueueChannel</code> to reflect the Cafe kitchen busy state from real life. And here is a place where we need that<br /><code>global poller</code> for the next endpoint which is listening on this channel.</p><p><a name="line23" /><br />23.<br /><code>java
.handle(new GenericHandler&lt;OrderItem&gt;() {
</code><br />The <code>.handle()</code> EIP-method of the <code>iced</code> flow demonstrates the concrete Cafe kitchen work. Since we can&rsquo;t minimize<br />the code with something like Java 8 Lambda expression, we provide here an inline implementation for the <code>GenericHandler</code><br />functional interface with the expected <code>payload</code> type as the generic argument. With the Java 8 example, we distribute this <code>.handle()</code><br />between several subscriber subflows for a <code>PublishSubscribeChannel</code>. However in this case, the logic is all<br />implemented in the one method.</p><p><a name="line24" /><br />24.<br /><code>java
Uninterruptibles.sleepUninterruptibly(1, TimeUnit.SECONDS);
System.out.println(Thread.currentThread().getName()
+ &quot; prepared cold drink #&quot; + coldDrinkCounter.incrementAndGet()
+ &quot; for order #&quot; + payload.getOrderNumber() + &quot;: &quot; + payload);
return payload;
</code><br />The business logic implementation for the current <code>.handle()</code> EIP-component. With<br /><code>Uninterruptibles.sleepUninterruptibly(1, TimeUnit.SECONDS);</code> we just block the current <code>Thread</code> for some timeout to demonstrate how<br />quickly the Cafe kitchen prepares a drink. After that we just report to <code>STDOUT</code> that the drink is ready and<br />return the current <code>OrderItem</code> from the <code>GenericHandler</code> for the next endpoint in our <code>IntegrationFlow</code>. In the<br />background, the DSL framework registers a <code>ServiceActivatingHandler</code> for the <code>MethodInvokingMessageProcessor</code> to invoke the<br /><code>GenericHandler#handle</code> at runtime. In addition, the framework registers a <code>PollingConsumer</code> endpoint for the<br /><code>QueueChannel</code> above. This endpoint relies on the <code>default poller</code> to poll messages from the queue. Of course, we<br />always can use a specific <code>poller</code> for any concrete endpoint. In that case, we would have to provide a second<br /><code>endpointConfigurer</code> argument to the <code>.handle()</code> EIP-method.</p><p><a name="line25" /><br />25.<br /><code>java
.channel(&quot;output&quot;)
</code><br />Since it is not the end of our Cafe scenario, we send the result of the current flow to the <code>output</code> channel<br />using the convenient EIP-method <code>.channel()</code> and the name of the <code>MessageChannel</code> bean (see below #29). This is the logical<br /> end of the current iced drink subflow, so we use the <code>.get()</code> method to return the <code>IntegrationFlow</code>. Flows that end<br /> with a reply-producing handler that don&rsquo;t have a final <code>.channel()</code> will return the reply to the message <code>replyChannel</code> header.</p><p><a name="line26" /><br />26.<br /><code>java
@Bean
public IntegrationFlow hotFlow() {
</code><br />The <code>IntegrationFlow</code> definition for <code>hot</code> drinks. It is similar to the previous <code>iced</code> drinks flow, but<br />with specific <code>hot</code> business logic. It starts from the <code>hot</code> <code>QueueChannel</code> which is mapped from the router above.</p><p><a name="line27" /><br />27.<br /><code>java
Uninterruptibles.sleepUninterruptibly(5, TimeUnit.SECONDS);
</code><br />The <code>sleepUninterruptibly</code> for <code>hot</code> drinks. Right, we need more time to boil the water!</p><p><a name="line28" /><br />28.<br /><code>java
@Bean
public IntegrationFlow resultFlow() {
</code><br />One more <code>IntegrationFlow</code> bean definition to prepare the <code>Delivery</code> for the Cafe client based on the <code>Drink</code>s.</p><p><a name="line29" /><br />29.<br /><code>java
return IntegrationFlows.from(&quot;output&quot;)
</code><br />The <code>resultFlow</code> starts from the <code>DirectChannel</code>, which is created during the bean definition phase with this<br />provided name. You should remember that we use the <code>output</code> channel name from the Cafe kitchens flows in the last <code>.channel()</code> in<br />those definitions.</p><p><a name="line30" /><br />30.<br /><code>java
.transform(new GenericTransformer&lt;OrderItem, Drink&gt;() {
</code><br />The <code>.transform()</code> EIP-method is for the appropriate pattern implementation and expects some object to convert one<br />payload to another. In our sample we use an inline implementation of the <code>GenericTransformer</code> functional interface to<br /> convert <code>OrderItem</code> to <code>Drink</code> and we specify that using generic arguments. In the background, the DSL framework<br /> registers a <code>MessageTransformingHandler</code> and an <code>EventDrivenConsumer</code> endpoint with default options to consume messages<br /> from the <code>output</code> <code>MessageChannel</code>.</p><p><a name="line31" /><br />31.<br /><code>java
public Drink transform(OrderItem orderItem) {
return new Drink(orderItem.getOrderNumber(),
orderItem.getDrinkType(),
orderItem.isIced(),
orderItem.getShots());
}
</code><br />The business-specific <code>GenericTransformer#transform()</code> implementation to demonstrate how we benefit from Java<br />Generics to transform one <code>payload</code> to another. Note: Spring Integration uses <code>ConversionService</code> before<br />any method invocation and if you provide some specific <code>Converter</code> implementation, some domain <code>payload</code> can be<br />converted to another automatically, when the framework has an appropriate registered <code>Converter</code>.</p><p><a name="line32" /><br />32.<br /><code>java
.aggregate(new Consumer&lt;AggregatorSpec&gt;() {
</code><br />The <code>.aggregate()</code> EIP-method provides options to configure an <code>AggregatingMessageHandler</code> and its endpoint,<br />similar to what we can do with the <code>&lt;aggregator&gt;</code> component when using Spring Integration XML configuration. Of course, with the Java DSL<br />we have more power to configure the aggregator in place, without any other extra beans. However we demonstrate<br />here an aggregator configuration with annotations (see below #35).<br />From the Cafe business logic perspective we compose the <code>Delivery</code> for the initial <code>Order</code>, since we <code>.split()</code> the original order<br />to the <code>OrderItem</code>s near the beginning.</p><p><a name="line33" /><br />33.<br /><code>java
public void accept(AggregatorSpec aggregatorSpec) {
aggregatorSpec.processor(cafeAggregator, null);
}
</code><br />An inline implementation of the <code>Consumer</code> for the <code>AggregatorSpec</code>. Using the <code>aggregatorSpec</code> Builder we can provide<br />desired options for the <code>aggregator</code> component, which will be registered as an <code>AggregatingMessageHandler</code> bean. Here we<br />just provide the <code>processor</code> as a reference to the autowired (see #11 above) <code>CafeAggregator</code> component (see #35 below).<br />The second argument of the <code>.processor()</code> option is <code>methodName</code>. Since we are relying on the aggregator<br />annotation configuration for the POJO, we don&rsquo;t need to provide the method here and the framework will determine the correct POJO methods<br />in the background.</p><p><a name="line34" /><br />34.<br /><code>java
.handle(CharacterStreamWritingMessageHandler.stdout())
</code><br />It is the end of our flow - the <code>Delivery</code> is delivered to the client! We just print here the message <code>payload</code><br />to STDOUT using out-of-the-box <code>CharacterStreamWritingMessageHandler</code> from Spring Integration Core. This is a<br />case to show how existing components from Spring Integration Core (and its modules) can be used from the Java DSL.</p><p><a name="line35" /><br />35.<br /><code>java
@Component
public static class CafeAggregator {
</code><br />The bean to specify the business logic for the <code>aggregator</code> above. This bean is picked up by the <code>@ComponentScan</code>,<br />which is a part of the <code>@SpringBootApplication</code> meta-annotation (see above #1). So, this component becomes a bean<br />and we can automatically wire (<code>@Autowired</code>) it to other components in the application context (see #11 above).</p><p><a name="line36" /><br />36.<br /><code>java
@Aggregator
public Delivery output(List&lt;Drink&gt; drinks) {
return new Delivery(drinks);
}
</code><br />The POJO-specific <code>MessageGroupProcessor</code> to build the output <code>payload</code> based on the payloads from aggregated<br />messages. Since we mark this method with the <code>@Aggregator</code> annotation, the target <code>AggregatingMessageHandler</code> can extract<br />this method for the <code>MethodInvokingMessageGroupProcessor</code>.</p><p><a name="line37" /><br />37.<br /><code>java
@CorrelationStrategy
public Integer correlation(Drink drink) {
return drink.getOrderNumber();
}
</code><br />The POJO-specific <code>CorrelationStrategy</code> to extract the custom <code>correlationKey</code> from each inbound aggregator message.<br />Since we mark this method with <code>@CorrelationStrategy</code> annotation the target <code>AggregatingMessageHandler</code> can extract<br />this method for the <code>MethodInvokingCorrelationStrategy</code>.<br />There is a similar self-explained <code>@ReleaseStrategy</code> annotation, but we rely in our Cafe sample just on the default<br /><code>SequenceSizeReleaseStrategy</code>, which is based on the <code>sequenceDetails</code> message header populated by the <code>splitter</code><br />from the beginning of our integration flow.</p><p>Well, we have finished describing the Cafe Demo sample based on the Spring Integration Java DSL when Java Lambda<br />support is not available.<br />Compare it with <a href="https://github.com/spring-projects/spring-integration-samples/tree/master/applications/cafe/cafe-si">XML sample</a><br />and also see <a href="https://spring.io/blog/2014/11/25/spring-integration-java-dsl-line-by-line-tutorial">Lambda support tutorial</a><br />to get more information regarding Spring Integration.</p><p>As you can see, using the DSL without lambdas is a little more verbose because you need to provide boilerplate code<br />for inline anonymous implementations of functional interfaces. However, we believe it is important to support the use<br />of the DSL for users who can&rsquo;t yet move to Java 8. Many of the DSL benefits (fluent API, compile-time validation etc)<br />are available for all users.</p><p>The use of lambdas continues the Spring Framework tradition of reducing or eliminating boilerplate code, so we encourage<br />users to try Java 8 and lambdas and to encourage their organizations to consider allowing the use of Java 8 for<br />Spring Integration applications.</p><p>In addition see the <a href="https://github.com/spring-projects/spring-integration-java-dsl/wiki/Spring-Integration-Java-DSL-Reference">Reference Manual</a><br />for more information.</p><p>As always, we look forward to your comments and feedback (<a href="https://stackoverflow.com">StackOverflow</a><br />(<code>spring-integration</code> tag), <a href="https://jira.spring.io/browse/INTEXT">Spring JIRA</a>,<br /><a href="https://github.com/spring-projects/spring-integration-java-dsl/issues">GitHub</a>) and we very much welcome<br /><a href="https://github.com/spring-projects/spring-integration/blob/master/CONTRIBUTING.md">contributions</a>!</p><p>Thank you for your time and patience to read this!</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 1865;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>
Back
</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">All Posts</a>
<a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">Engineering</a>
<a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">Releases</a>
<a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">News and Events</a>
<a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>Get updates from The Spring Team delivered to your inbox</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">Tools</a></li>
<li><a href="https://store.pivotal.io/">Store</a></li>
<li><a href="/blog">Newsletter</a></li>
</ul>
</div>
</div>
&copy; <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a>, Inc. All Rights Reserved.
<a href="https://pivotal.io/terms-of-use">Terms of Use</a> &bullet;
<a href="https://pivotal.io/privacy-policy">Privacy</a> &bullet;
<a href="/trademarks">Trademark Guidelines</a>
<div id="teconsent" style="display:inline-block;"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>