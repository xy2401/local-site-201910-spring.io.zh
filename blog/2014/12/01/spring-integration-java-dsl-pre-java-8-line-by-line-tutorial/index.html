<html dir="ltr" data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>Spring Integration Java DSL（Java 8之前的版本）：逐行教程</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>System.config({baseURL: "/b92013b"});</script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>System.import('app/main.js')</script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Spring Integration Java DSL (pre Java 8): Line by line tutorial">
<meta name="twitter:description" content="<p>Dear Spring Community!</p>
<p>Recently we published the<br><a href=" https:="" ="" spring.io="" blog="" 2014="" 11="" 25="" spring-integration-java-dsl-line-by-line-tutoria="="></head><body dir="ltr">Spring Integration Java DSL: Line by line tutorial,<br> which uses Java 8 Lambdas extensively. We received some feedback that this is good introduction<br> to the DSL, but a similar tutorial is needed for those users, who can’t move to the Java 8 or aren’t yet familiar<br> with <code>Lambdas</code>, but wish to take advantage
<p>So, to help those Spring Integration users who want to moved from XML configuration to Java & Annotation<br>configuration, we provide this <code>line-by-line tutorial</code> to demonstrate that, even without <code>Lambdas</code>, we gain<br>a lot from Spring Integration Java DSL usage. Although, most will agree that the lambda syntax provides for a<br>more succinct definition.</p>
">
<meta name="twitter:creator" content="@artem_bilan">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/2158ce6e7c048277890eb64458864c1c?s=200">

<meta property="og:title" content="Spring Integration Java DSL (pre Java 8): Line by line tutorial">
<meta property="og:image" content="https://gravatar.com/avatar/2158ce6e7c048277890eb64458864c1c?s=200">
<meta property="og:description" content="<p>Dear Spring Community!</p>
<p>Recently we published the<br><a href=" https:="" ="" spring.io="" blog="" 2014="" 11="" 25="" spring-integration-java-dsl-line-by-line-tutoria="=">Spring Integration Java DSL: Line by line tutorial,<br> which uses Java 8 Lambdas extensively. We received some feedback that this is good introduction<br> to the DSL, but a similar tutorial is needed for those users, who can’t move to the Java 8 or aren’t yet familiar<br> with <code>Lambdas</code>, but wish to take advantage
<p>So, to help those Spring Integration users who want to moved from XML configuration to Java & Annotation<br>configuration, we provide this <code>line-by-line tutorial</code> to demonstrate that, even without <code>Lambdas</code>, we gain<br>a lot from Spring Integration Java DSL usage. Although, most will agree that the lambda syntax provides for a<br>more succinct definition.</p>
">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2014-12-01 08:20:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">// Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }</script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Spring Integration Java DSL（Java 8之前的版本）：逐行教程</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/2158ce6e7c048277890eb64458864c1c?s=20&d=mm"> <a class="author" rel="author" href="/team/artembilan">阿尔特姆·比兰（Artem Bilan）</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2014-12-01 08:20:00.0">2014年12月1日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2014/12/01/spring-integration-java-dsl-pre-java-8-line-by-line-tutorial#disqus_thread" data-disqus-identifier="1865">
</a></div>
</div>
</header>
<div class="blog--post"><p>亲爱的春季社区！</p><p>最近，我们发布了<br><a href="https://spring.io/blog/2014/11/25/spring-integration-java-dsl-line-by-line-tutorial">Spring Integration Java DSL：逐行教程</a> ，<br>广泛使用Java 8 Lambda。我们收到了一些反馈，认为这是很好的介绍<br>DSL，但对于那些无法使用Java 8或尚未熟悉Java的用户，则需要一个类似的教程<br>与<code>Lambdas</code> ，但希望利用</p><p>因此，为了帮助那些希望从XML配置转移到Java和注释的Spring Integration用户<br>配置，我们提供此<code>line-by-line tutorial</code>来证明即使没有<code>Lambdas</code> ，我们也可以<br>Spring Integration Java DSL的使用很多。虽然，大多数人都会同意lambda语法提供了<br>更简洁的定义。</p><p>我们在这里分析相同的<a href="https://github.com/spring-projects/spring-integration-samples/tree/master/dsl/cafe-dsl">Cafe Demo</a>示例，<br>但使用Java 8之前的版本进行配置。许多选项是相同的，因此我们只在此处复制/粘贴其描述到<br>取得完整的画面。由于此Spring Integration Java DSL配置与<br>Java 8 lambda样式，对于所有用户来说都是很有用的知识，我们将如何以丰富的多样性实现相同的结果<br>Spring Integration Java DSL提供的选项集。</p><p>我们的应用程序的源代码放在一个单独的类中，它是一个<code>Boot</code>应用程序。<br>有效行用与注释对应的数字注释，该注释如下：</p>
<pre><code class="prettyprint java">@SpringBootApplication                                                   // 1
@IntegrationComponentScan                                                // 2
public class Application {

  public static void main(String[] args) throws Exception {
  	ConfigurableApplicationContext ctx =
			SpringApplication.run(Application.class, args);              // 3

  	Cafe cafe = ctx.getBean(Cafe.class);                                 // 4
  	for (int i = 1; i <= 100; i++) {                                     // 5
  	  Order order = new Order(i);
  	  order.addItem(DrinkType.LATTE, 2, false);
  	  order.addItem(DrinkType.MOCHA, 3, true);
  	  cafe.placeOrder(order);
  	}

  	System.out.println("Hit 'Enter' to terminate");                      // 6
  	System.in.read();
  	ctx.close();
  }

  @MessagingGateway                                                      // 7
  public interface Cafe {

  	@Gateway(requestChannel = "orders.input")                            // 8
  	void placeOrder(Order order);                                        // 9

  }

  private final AtomicInteger hotDrinkCounter = new AtomicInteger();

  private final AtomicInteger coldDrinkCounter = new AtomicInteger();    // 10

  @Autowired
  private CafeAggregator cafeAggregator;                                 // 11

  @Bean(name = PollerMetadata.DEFAULT_POLLER)
  public PollerMetadata poller() {                                       // 12
  	return Pollers.fixedDelay(1000).get();
  }

  @Bean
  @SuppressWarnings("unchecked")
  public IntegrationFlow orders() {                                      // 13
  	return IntegrationFlows.from("orders.input")                         // 14
	  .split("payload.items", (Consumer) null)                           // 15
	  .channel(MessageChannels.executor(Executors.newCachedThreadPool()))// 16
	  .route("payload.iced",                                             // 17
	    new Consumer<RouterSpec<ExpressionEvaluatingRouter>>() {         // 18

	      @Override
	      public void accept(RouterSpec<ExpressionEvaluatingRouter> spec) {
	      	spec.channelMapping("true", "iced")
                .channelMapping("false", "hot");                         // 19
  	      }

  	    })
  	  .get();                                                            // 20
  }

  @Bean
  public IntegrationFlow icedFlow() {                                    // 21
  	return IntegrationFlows.from(MessageChannels.queue("iced", 10))      // 22
	  .handle(new GenericHandler<OrderItem>() {                          // 23

	  	@Override
	  	public Object handle(OrderItem payload, Map<String, Object> headers) {
	  	  Uninterruptibles.sleepUninterruptibly(1, TimeUnit.SECONDS);
	  	  System.out.println(Thread.currentThread().getName()
	  	    + " prepared cold drink #" + coldDrinkCounter.incrementAndGet()
	  	    + " for order #" + payload.getOrderNumber() + ": " + payload);
	  	  return payload;                                                // 24
  	  	}

  	  })
  	  .channel("output")                                                 // 25
  	  .get();
  }

  @Bean
  public IntegrationFlow hotFlow() {                                     // 26
  	return IntegrationFlows.from(MessageChannels.queue("hot", 10))
	  .handle(new GenericHandler<OrderItem>() {

	  	@Override
	  	public Object handle(OrderItem payload, Map<String, Object> headers) {
	  	  Uninterruptibles.sleepUninterruptibly(5, TimeUnit.SECONDS);    // 27
	  	  System.out.println(Thread.currentThread().getName()
	  	    + " prepared hot drink #" + hotDrinkCounter.incrementAndGet()
	  	    + " for order #" + payload.getOrderNumber() + ": " + payload);
	  	  return payload;
  	  	}

  	  })
  	  .channel("output")
  	  .get();
  }

  @Bean
  public IntegrationFlow resultFlow() {                                  // 28
    return IntegrationFlows.from("output")                               // 29
      .transform(new GenericTransformer<OrderItem, Drink>() {            // 30

        @Override
        public Drink transform(OrderItem orderItem) {
          return new Drink(orderItem.getOrderNumber(),
            orderItem.getDrinkType(),
            orderItem.isIced(),
            orderItem.getShots());                                       // 31
        }

      })
      .aggregate(new Consumer<AggregatorSpec>() {                        // 32

        @Override
        public void accept(AggregatorSpec aggregatorSpec) {
          aggregatorSpec.processor(cafeAggregator, null);                // 33
        }

      }, null)
      .handle(CharacterStreamWritingMessageHandler.stdout())             // 34
    .get();
  }


  @Component
  public static class CafeAggregator {                                   // 35

  	@Aggregator                                                          // 36
  	public Delivery output(List<Drink> drinks) {
  	  return new Delivery(drinks);
  	}

  	@CorrelationStrategy                                                 // 37
  	public Integer correlation(Drink drink) {
  	  return drink.getOrderNumber();
  	}

  }

}
</code></pre><p>逐行检查代码…</p><p><a name="line1"></a><br>1。<br><code>java @SpringBootApplication</code><br>来自Spring Boot 1.2的新的元注释。包括<code>@Configuration</code>和<br><code>@EnableAutoConfiguration</code> 。由于我们在Spring Integration应用程序中，并且Spring Boot具有自动配置<br>为此，会自动应用<code>@EnableIntegration</code>来初始化Spring Integration基础架构，包括<br>Java DSL的环境<code>DslIntegrationConfigurationInitializer</code> ，由<br>来自<code>/META-INF/spring.factories</code> <code>IntegrationConfigurationBeanFactoryPostProcessor</code> 。</p><p><a name="line2"></a><br>2。<br><code>java @IntegrationComponentScan</code><br><code>@ComponentScan</code>的Spring Integration类似物可基于以下内容扫描组件<br>接口，（Spring Framework的<code>@ComponentScan</code>仅查看类）。Spring Integration支持发现接口<br>用<code>@MessagingGateway</code>annotation（请参见下面的＃7）。</p><p><a name="line3"></a><br>3。<br><code>java ConfigurableApplicationContext ctx = SpringApplication.run(Application.class, args);</code><br>该类的<code>main</code>方法旨在使用以下命令启动Spring Boot应用程序：<br>从此类进行配置，并通过Spring Boot启动<code>ApplicationContext</code> 。另外，它委托命令<br>Spring Boot的行参数。例如，您可以指定<code>--debug</code>以查看引导自动配置报告的日志。</p><p><a name="line4"></a><br>4。<br><code>java Cafe cafe = ctx.getBean(Cafe.class);</code><br>由于我们已经有了一个<code>ApplicationContext</code>我们可以开始与应用程序进行交互。和<code>Cafe</code><br>该入口点是EIP的<code>gateway</code> 。网关只是接口，应用程序不会交互<br>使用Messaging API；它只处理域（请参阅下面的＃7）。</p><p><a name="line5"></a><br>5，<br><code>java for (int i = 1; i <= 100; i++) {</code><br>为了演示咖啡馆的“工作”，我们开办了100份订单，包括两种饮料-一份热饮料和一份冰镇饮料。并将<code>Order</code>发送到<code>Cafe</code>网关。</p><p><a name="line6"></a><br>6。<br><code>java System.out.println("Hit 'Enter' to terminate");</code><br>通常，Spring Integration应用程序是异步的，因此为了避免提前退出<code>main</code>线程，我们阻止了<br><code>main</code>方法，直到最终用户通过命令行进行交互。非守护程序线程将保留应用程序<br>打开，但<code>System.read()</code>为我们提供了一种干净地关闭应用程序的机制。</p><p><a name="line7"></a><br>7。<br><code>java @MessagingGateway</code><br>用于标记业务接口的注释，以指示它是之间的<code>gateway</code><br>最终应用程序和集成层。它是类似物<code><gateway /></code> Spring Integration XML中的组件<br>组态。Spring Integration为此接口创建了一个<code>Proxy</code> ，并将其作为Bean填充到<br>应用程序上下文。此<code>Proxy</code>的目的是将参数包装在<code>Message<?></code> object and send it to the<br><code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjI4Ij4=">MessageChannel</code> according to the provided options.</p><p><a name="line8" gtc:encodedoriginal="PGEgbmFtZT0ibGluZTgiPg=="></a><br>8.<br><code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjMzIj4=">java @Gateway(requestChannel = "orders.input")</code><br>The method level annotation to distinct business logic by methods as well as by the target<br>integration flows. In this sample we use a <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjM2Ij4=">requestChannel</code> reference of <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjM3Ij4=">orders.input</code>, which is a <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjM4Ij4=">MessageChannel</code><br>bean name of our <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjQwIj4=">IntegrationFlow</code> input channel (see below #14).</p><p><a name="line9" gtc:encodedoriginal="PGEgbmFtZT0ibGluZTkiPg=="></a><br>9.<br><code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjQ1Ij4=">java void placeOrder(Order order);</code><br>The interface method is a central point to interact from end-application with the integration layer. This method has a<br><code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjQ4Ij4=">void</code> return type. It means that our integration flow is <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjQ5Ij4=">one-way</code> and we just send messages to the integration flow, but don’t wait for a reply.</p><p><a name="line10" gtc:encodedoriginal="PGEgbmFtZT0ibGluZTEwIj4="></a><br>10.<br><code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjU0Ij4=">java private AtomicInteger hotDrinkCounter = new AtomicInteger(); private AtomicInteger coldDrinkCounter = new AtomicInteger();</code><br>Two counters to gather the information how our cafe works with drinks.</p><p><a name="line11" gtc:encodedoriginal="PGEgbmFtZT0ibGluZTExIj4="></a><br>11.<br><code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjYwIj4=">java @Autowired private CafeAggregator cafeAggregator;</code><br>The POJO for the <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjYyIj4=">Aggregator</code> logic (see #33 and #35 below). Since it is a Spring bean, we can simply inject it even to the current <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjYzIj4=">@Configuration</code> and use in any place below, e.g. from the <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjY0Ij4=">.aggregate()</code> EIP-method.</p><p><a name="line12" gtc:encodedoriginal="PGEgbmFtZT0ibGluZTEyIj4="></a><br>12.<br><code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjY5Ij4=">java @Bean(name = PollerMetadata.DEFAULT_POLLER) public PollerMetadata poller() {</code><br>The <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjcxIj4=">default</code> <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjcyIj4=">poller</code> bean. It is a analogue of <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjczIj4="><poller default="true"></code> component from Spring Integration XML configuration. Required for endpoints where the <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjc0Ij4=">inputChannel</code> is a <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjc1Ij4=">PollableChannel</code>. In this case, it is necessary for the<br>two Cafe <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjc3Ij4=">queues</code> - hot and iced (see below #18). Here we use the <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjc4Ij4=">Pollers</code> factory from the DSL project and use its<br>method-chain fluent API to build the poller metadata. Note that <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjgwIj4=">Pollers</code> can be used directly from an <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjgxIj4=">IntegrationFlow</code> definition,<br>if a specific <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjgzIj4=">poller</code> (rather than the default poller) is needed for an endpoint.</p><p><a name="line13" gtc:encodedoriginal="PGEgbmFtZT0ibGluZTEzIj4="></a><br>13.<br><code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjg4Ij4=">java @Bean public IntegrationFlow orders() {</code><br>The <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjkwIj4=">IntegrationFlow</code> bean definition. It is the central component of the Spring Integration Java DSL, although it does not play any role at runtime, just during the bean registration phase. All other code below registers Spring Integration components (<code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjkxIj4=">MessageChannel</code>, <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjkyIj4=">MessageHandler</code>, <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjkzIj4=">EventDrivenConsumer</code>, <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjk0Ij4=">MessageProducer</code>, <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjk1Ij4=">MessageSource</code> etc.) in the <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjk2Ij4=">IntegrationFlow</code> object, which is parsed by the <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjk3Ij4=">IntegrationFlowBeanPostProcessor</code> to process those components and register them as beans in the application context as necessary (some elements, such as channels may already exist).</p><p><a name="line14" gtc:encodedoriginal="PGEgbmFtZT0ibGluZTE0Ij4="></a><br>14.<br><code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMzAyIj4=">java return IntegrationFlows.from("orders.input")</code><br>The <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMzA0Ij4=">IntegrationFlows</code> is the main <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMzA1Ij4=">factory</code> class to start the <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMzA2Ij4=">IntegrationFlow</code>. It provides a number of overloaded <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMzA3Ij4=">.from()</code> methods to allow starting a flow from a <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMzA4Ij4=">SourcePollingChannelAdapter</code> for a <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMzA5Ij4=">MessageSource<?></code>实现中，例如<code>JdbcPollingChannelAdapter</code> ；从<code>MessageProducer</code> ，例如<code>WebSocketInboundChannelAdapter</code> ；或者只是一个<code>MessageChannel</code> 。所有“ .from（）”选项都有几个方便的变体，用于为<code>IntegrationFlow</code>的启动配置适当的组件。在这里，我们仅使用通道名称，该名称在解析<code>IntegrationFlow</code>时在bean定义阶段转换为<code>DirectChannel</code> bean定义。在Java 8变体中，我们在这里使用了<code>Lambda definition</code> -并已基于<code>IntegrationFlow</code> bean名称隐式创建了带有<code>MessageChannel</code> bean名称的<code>MessageChannel</code> 。</p><p><a name="line15"></a><br>15<br><code>java .split("payload.items", (Consumer) null)</code><br>由于我们的集成流程通过<code>orders.input</code>通道接受消息，因此我们准备使用和处理它们。在我们的场景中，第一个EIP方法是<code>.split()</code> 。我们知道<code>orders.input</code>通道中的消息<code>payload</code>是<code>Order</code>域对象，因此我们可以在这里简单地使用Spring（SpEL）表达式来返回<code>Collection<OrderItem></code> 。因此，这将执行<code>split</code> EI模式，我们将每个集合条目作为单独的消息发送到下一个通道。在后台， <code>.split()</code>方法注册一个<code>ExpressionEvaluatingSplitter</code> <code>MessageHandler</code>实现和该<code>MessageHandler</code>的<code>EventDrivenConsumer</code> ，并将<code>orders.input</code>通道连接为<code>inputChannel</code> 。</p><p><code>.split()</code> EIP方法的第二个参数是给<code>endpointConfigurer</code><br>像自定义选项<code>autoStartup</code> ， <code>requiresReply</code> ， <code>adviceChain</code>等，我们这里使用<code>null</code> ，表明我们依靠<br>在端点的默认选项上。许多EIP方法都提供带有和不带有的重载版本<br><code>endpointConfigurer</code> 。当前不带<code>endpointConfigurer</code>参数的<code>.split(String expression)</code> EIP方法不可用；这将在以后的版本中解决。</p><p><a name="line16"></a><br>16。<br><code>java .channel(MessageChannels.executor(Executors.newCachedThreadPool()))</code><br><code>.channel()</code> EIP方法允许在端点之间指定具体的<code>MessageChannel</code> ，因为它是通过<br><code>output-channel</code> / <code>input-channel</code>属性与Spring Integration XML配置配对。默认情况下，<br>DSL集成流定义与<code>DirectChannel</code>连接， <code>DirectChannel</code>基于<code>IntegrationFlow</code>获得Bean名称。<br>流链中的bean名称和<code>index</code> 。在这种情况下，我们选择一个<br><code>Channels</code>工厂类中的特定<code>MessageChannel</code>实现；选定的<br>这里的channel是一个<code>ExecutorChannel</code> ，以允许将消息从<code>splitter</code>分发到单独的<code>Thread</code>进行处理<br>它们在下游流中并行。</p><p><a name="line17"></a><br>17。<br><code>java .route("payload.iced",</code><br>在我们的场景中，下一个EIP方法是<code>.route()</code> ，用于将<code>hot/iced</code>订单商品发送到不同的Cafe厨房。我们在这里再次使用SpEL表达式从传入消息中获取<code>routingKey</code> 。在Java 8变体中，我们使用了<code>method-reference</code> Lambda表达式，但是对于Java 8之前的样式，我们必须使用SpEL或内联接口实现。流中的许多匿名类会使流难以阅读，因此在大多数情况下，我们更喜欢SpEL。</p><p><a name="line18"></a><br>18岁<br><code>java new Consumer<RouterSpec<ExpressionEvaluatingRouter>>() {</code><br><code>.route()</code> EIP方法的第二个参数是功能接口<code>Consumer</code>可以使用<code>RouterSpec</code>构建器指定<code>ExpressionEvaluatingRouter</code>选项。由于Java 8之前没有任何选择，因此我们在此为该接口提供内联实现。</p><p><a name="line19"></a><br>19<br><code>java spec.channelMapping("true", "iced") .channelMapping("false", "hot");</code><br>使用<code>Consumer<RouterSpec<ExpressionEvaluatingRouter>>#accept()</code>实现，我们可以提供所需的<code>AbstractMappingMessageRouter</code>选项。其中之一是<code>channelMappings</code> ，当我们通过路由器<code>channelMappings</code>的结果和适当的目标<code>MessageChannel</code>指定路由逻辑时。在这种情况下， <code>iced</code>和<code>hot</code>是下面的<code>IntegrationFlow</code>的<code>MessageChannel</code>名称。</p><p><a name="line20"></a><br>20<br><code>java .get();</code><br>这样就完成了流程。<br>任何<code>IntegrationFlows.from()</code>方法都将返回一个<code>IntegrationFlowBuilder</code>实例，并且此<code>get()</code>方法将从<code>IntegrationFlowBuilder</code>配置中提取一个<code>IntegrationFlow</code>对象。从<code>.from()</code>到<code>.get()</code>之前的方法的所有内容都是<code>IntegrationFlow</code>定义。所有定义的组件都存储在<code>IntegrationFlow</code>并在Bean创建阶段由<code>IntegrationFlowBeanPostProcessor</code>处理。</p><p><a name="line21"></a><br>21<br><code>java @Bean public IntegrationFlow icedFlow() {</code><br>这是<code>IntegrationFlow</code> bean的第二个定义-用于<code>iced</code>饮料。在这里，我们演示了几个<code>IntegrationFlow</code><br>可以连接在一起以创建单个复杂的应用程序。注意：不建议将一个<code>IntegrationFlow</code>注入<br>另一个;它可能会导致意外的行为。由于它们为Bean注册和集成提供了集成组件。<br><code>MessageChannel</code>是其中之一，最佳的连线和插入方式是通过<code>MessageChannel</code>或<code>@MessagingGateway</code><br>接口。</p><p><a name="line22"></a><br>22<br><code>java return IntegrationFlows.from(MessageChannels.queue("iced", 10))</code><br><code>iced</code> <code>IntegrationFlow</code>从具有<code>10</code>消息的<code>QueueChannel</code>开始；它被注册为名称为<code>iced</code>的bean。<br>如您所记得，我们使用此名称作为路由映射之一（请参见上面的＃19）。</p><p>在我们的示例中，我们在此处使用<br><code>QueueChannel</code>从现实生活中反映出Cafe厨房繁忙状态。这是我们需要的地方<br>正在侦听此通道的下一个端点的<code>global poller</code> 。</p><p><a name="line23"></a><br>23。<br><code>java .handle(new GenericHandler<OrderItem>() {</code><br><code>iced</code>流的<code>.handle()</code> EIP方法演示了具体的Cafe厨房工作。因为我们不能最小化<br>带有类似Java 8 Lambda表达式的代码，我们在这里为<code>GenericHandler</code>提供内联实现<br>具有预期<code>payload</code>类型作为通用参数的功能接口。在Java 8示例中，我们分发了<code>.handle()</code><br>在<code>PublishSubscribeChannel</code>几个订阅者子流之间。但是，在这种情况下，逻辑就是全部<br>用一种方法实现。</p><p><a name="line24"></a><br>24<br><code>java Uninterruptibles.sleepUninterruptibly(1, TimeUnit.SECONDS); System.out.println(Thread.currentThread().getName() + " prepared cold drink #" + coldDrinkCounter.incrementAndGet() + " for order #" + payload.getOrderNumber() + ": " + payload); return payload;</code><br>当前<code>.handle()</code> EIP组件的业务逻辑实现。用<br><code>Uninterruptibles.sleepUninterruptibly(1, TimeUnit.SECONDS);</code>我们只是阻止当前<code>Thread</code>一段时间，以演示如何<br>咖啡馆的厨房很快就准备一杯饮料。之后，我们只是向<code>STDOUT</code>报告饮料已经准备好了，<br>从<code>GenericHandler</code>返回当前的<code>OrderItem</code>以获取<code>IntegrationFlow</code>的下一个端点。在里面<br>后台，DSL框架为<code>MethodInvokingMessageProcessor</code>注册了一个<code>ServiceActivatingHandler</code>来调用<br><code>GenericHandler#handle</code>在运行时。此外，该框架还为以下对象注册了<code>PollingConsumer</code>端点：<br>上面的<code>QueueChannel</code> 。该端点依赖<code>default poller</code>来轮询队列中的消息。当然，我们<br>始终可以对任何具体端点使用特定的<code>poller</code> 。在这种情况下，我们将不得不提供第二个<br><code>.handle()</code> EIP方法的<code>endpointConfigurer</code>参数。</p><p><a name="line25"></a><br>25岁<br><code>java .channel("output")</code><br>由于这不是我们Cafe场景的结束，因此我们将当前流的结果发送到<code>output</code>通道<br>使用方便的EIP方法<code>.channel()</code>和<code>MessageChannel</code> bean的名称（请参阅下面的＃29）。这是合乎逻辑的<br>当前冰镇饮料子流的末尾，因此我们使用<code>.get()</code>方法返回<code>IntegrationFlow</code> 。流程结束<br>没有最终<code>.channel()</code>的产生回复的处理程序将把回复返回到消息<code>replyChannel</code>标头。</p><p><a name="line26"></a><br>26<br><code>java @Bean public IntegrationFlow hotFlow() {</code><br>该<code>IntegrationFlow</code>定义为<code>hot</code>饮料。它类似于以前的<code>iced</code>饮料流量，但是<br>具有特定的<code>hot</code>业务逻辑。它从上面的路由器映射的<code>hot</code> <code>QueueChannel</code>开始。</p><p><a name="line27"></a><br>27。<br><code>java Uninterruptibles.sleepUninterruptibly(5, TimeUnit.SECONDS);</code><br>该<code>sleepUninterruptibly</code>的<code>hot</code>饮料。是的，我们需要更多时间煮水！</p><p><a name="line28"></a><br>28。<br><code>java @Bean public IntegrationFlow resultFlow() {</code><br>还有一个<code>IntegrationFlow</code> bean定义，用于基于<code>Drink</code>来为Cafe客户端准备<code>Delivery</code> 。</p><p><a name="line29"></a><br>29。<br><code>java return IntegrationFlows.from("output")</code><br><code>resultFlow</code>从<code>DirectChannel</code>开始， <code>DirectChannel</code>是在bean定义阶段使用此命令创建的<br>提供的名称。您应该记住，我们使用了Cafe Kitchens流中最后一个<code>.channel()</code>中的<code>output</code>通道名称<br>这些定义。</p><p><a name="line30"></a><br>30岁<br><code>java .transform(new GenericTransformer<OrderItem, Drink>() {</code><br><code>.transform()</code> EIP方法适用于适当的模式实现，并且希望某些对象能够转换一个<br>有效载荷到另一个。在我们的示例中，我们使用<code>GenericTransformer</code>功能接口的内联实现来<br>将<code>OrderItem</code>转换为<code>Drink</code> ，然后使用通用参数进行指定。在后台，DSL框架<br>使用默认选项注册<code>MessageTransformingHandler</code>和<code>EventDrivenConsumer</code>端点以使用消息<br>从<code>output</code> <code>MessageChannel</code> 。</p><p><a name="line31"></a><br>31。<br><code>java public Drink transform(OrderItem orderItem) { return new Drink(orderItem.getOrderNumber(), orderItem.getDrinkType(), orderItem.isIced(), orderItem.getShots()); }</code><br>特定于业务的<code>GenericTransformer#transform()</code>实现，以演示我们如何从Java中受益<br>将一个<code>payload</code>转换为另一个<code>payload</code>泛型。注意：Spring Integration之前使用<code>ConversionService</code><br>任何方法调用，如果您提供某些特定的<code>Converter</code>实现，则可以将某些域<code>payload</code><br>当框架具有适当的注册<code>Converter</code>时，将自动转换为另一个。</p><p><a name="line32"></a><br>32。<br><code>java .aggregate(new Consumer<AggregatorSpec>() {</code><br><code>.aggregate()</code> EIP方法提供了用于配置<code>AggregatingMessageHandler</code>及其端点的选项，<br>类似于我们可以使用的<code><aggregator></code>使用Spring Integration XML配置时的组件。当然，使用Java DSL<br>我们拥有更多功能来配置聚合器，而无需任何其他多余的bean。但是我们证明<br>这里是带有注释的聚合器配置（请参见下面的＃35）。<br>从网吧经营逻辑角度来看，我们撰写<code>Delivery</code>初始<code>Order</code> ，因为我们<code>.split()</code>的原始顺序<br>到开始附近的<code>OrderItem</code> 。</p><p><a name="line33"></a><br>33。<br><code>java public void accept(AggregatorSpec aggregatorSpec) { aggregatorSpec.processor(cafeAggregator, null); }</code><br><code>Consumer</code>对<code>AggregatorSpec</code>的内联实现。使用<code>aggregatorSpec</code> Builder我们可以提供<br><code>aggregator</code>组件的所需选项，它将被注册为<code>AggregatingMessageHandler</code> bean。在这里，我们<br>只需提供<code>processor</code>作为对自动装配（参见上文＃11） <code>CafeAggregator</code>组件（参见下文＃35）的参考。<br><code>.processor()</code>选项的第二个参数是<code>methodName</code> 。由于我们依赖聚合器<br>POJO的注释配置，我们无需在此处提供方法，框架将确定正确的POJO方法<br>在后台。</p><p><a name="line34"></a><br>34。<br><code>java .handle(CharacterStreamWritingMessageHandler.stdout())</code><br>这是我们流程的结尾- <code>Delivery</code>已交付给客户！我们只在这里打印消息<code>payload</code><br>使用Spring Integration Core的现成的<code>CharacterStreamWritingMessageHandler</code>到STDOUT。这是一个<br>案例展示了如何从Java DSL使用Spring Integration Core（及其模块）中的现有组件。</p><p><a name="line35"></a><br>35岁<br><code>java @Component public static class CafeAggregator {</code><br>用于为上述<code>aggregator</code>指定业务逻辑的Bean。该bean由<code>@ComponentScan</code>拾取，<br>这是<code>@SpringBootApplication</code>元注释的一部分（请参见上面的＃1）。所以，这个组件变成了一个bean<br>并且我们可以自动<code>@Autowired</code>其（ <code>@Autowired</code> ）连接到应用程序上下文中的其他组件（请参见上面的＃11）。</p><p><a name="line36"></a><br>36。<br><code>java @Aggregator public Delivery output(List<Drink> drinks) { return new Delivery(drinks); }</code><br>特定于POJO的<code>MessageGroupProcessor</code> ，根据聚合后的有效<code>payload</code>来构建输出<code>payload</code>负载<br>消息。由于我们使用<code>@Aggregator</code>annotation标记了此方法，因此目标<code>AggregatingMessageHandler</code>可以提取<br>此方法用于<code>MethodInvokingMessageGroupProcessor</code> 。</p><p><a name="line37"></a><br>37。<br><code>java @CorrelationStrategy public Integer correlation(Drink drink) { return drink.getOrderNumber(); }</code><br>特定于POJO的<code>CorrelationStrategy</code>用于从每个入站聚合消息中提取自定义<code>correlationKey</code> 。<br>由于我们使用<code>@CorrelationStrategy</code>annotation标记了此方法，因此目标<code>AggregatingMessageHandler</code>可以提取<br>此方法用于<code>MethodInvokingCorrelationStrategy</code> 。<br>有一个类似的自我解释的<code>@ReleaseStrategy</code>annotation，但我们的Cafe示例仅依赖默认值<br><code>SequenceSizeReleaseStrategy</code> ，它基于<code>splitter</code>填充的<code>sequenceDetails</code>消息头<br>从我们整合流程的开始。</p><p>好了，我们已经完成了对Java Lambda时基于Spring Integration Java DSL的Cafe Demo示例的描述。<br>不提供支持。<br>与<a href="https://github.com/spring-projects/spring-integration-samples/tree/master/applications/cafe/cafe-si">XML示例</a>进行比较<br>另请参阅<a href="https://spring.io/blog/2014/11/25/spring-integration-java-dsl-line-by-line-tutorial">Lambda支持教程</a><br>获得有关Spring Integration的更多信息。</p><p>如您所见，使用不带lambda的DSL更加冗长，因为您需要提供样板代码<br>用于功能接口的内联匿名实现。但是，我们认为支持使用非常重要<br>尚无法迁移到Java 8的用户使用DSL的方式。DSL的许多好处（流畅的API，编译时验证等）<br>适用于所有用户。</p><p>lambda的使用延续了Spring Framework减少或消除样板代码的传统，因此我们鼓励<br>用户尝试使用Java 8和lambda，并鼓励其组织考虑允许将Java 8用于<br>Spring Integration应用程序。</p><p>另外请参阅<a href="https://github.com/spring-projects/spring-integration-java-dsl/wiki/Spring-Integration-Java-DSL-Reference">参考手册</a><br>想要查询更多的信息。</p><p>一如既往，我们期待您的评论和反馈（ <a href="https://stackoverflow.com">StackOverflow</a><br>（ <code>spring-integration</code>标签）， <a href="https://jira.spring.io/browse/INTEXT">Spring JIRA</a> ，<br><a href="https://github.com/spring-projects/spring-integration-java-dsl/issues">GitHub</a> ），我们非常欢迎<br><a href="https://github.com/spring-projects/spring-integration/blob/master/CONTRIBUTING.md">贡献</a> ！</p><p>感谢您的时间和耐心阅读！</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">var disqus_shortname = 'spring-io';
      var disqus_identifier = 1865;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));</script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });</script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>