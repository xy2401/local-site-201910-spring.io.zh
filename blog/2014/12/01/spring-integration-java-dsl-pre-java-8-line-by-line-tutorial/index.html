<html  data-code-prettify="" data-mobile-support="" data-search=""><head></head><body >﻿
<title>Spring Integration Java DSL（Java 8之前的版本）：逐行教程</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Spring Integration Java DSL (pre Java 8): Line by line tutorial">
<meta name="twitter:description" >
<meta name="twitter:creator" content="@artem_bilan">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/2158ce6e7c048277890eb64458864c1c?s=200">

<meta property="og:title" content="Spring Integration Java DSL (pre Java 8): Line by line tutorial">
<meta property="og:image" content="https://gravatar.com/avatar/2158ce6e7c048277890eb64458864c1c?s=200">
<meta property="og:description" >
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2014-12-01 08:20:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Spring Integration Java DSL（Java 8之前的版本）：逐行教程</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/2158ce6e7c048277890eb64458864c1c?s=20&d=mm"> <a class="author" rel="author" href="/team/artembilan">阿尔特姆·比兰（Artem Bilan）</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2014-12-01 08:20:00.0">2014年12月1日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2014/12/01/spring-integration-java-dsl-pre-java-8-line-by-line-tutorial#disqus_thread" data-disqus-identifier="1865">
</a></div>
</div>
</header>
<div class="blog--post"><p>亲爱的 Spring 社区！</p><p>最近，我们发布了<br><a href="https://spring.io/blog/2014/11/25/spring-integration-java-dsl-line-by-line-tutorial">Spring Integration Java DSL：逐行教程</a> ，<br>广泛使用Java 8 Lambda。我们收到了一些反馈，认为这是很好的介绍<br>DSL，但对于那些无法使用Java 8或尚未熟悉Java的用户，则需要类似的教程<br>与<code>Lambdas</code> ，但希望利用</p><p>因此，为希望从XML配置转移到Java和注释的那些Spring Integration用户提供帮助<br>配置，我们提供此<code>line-by-line tutorial</code>证明这一点，即使没有<code>Lambdas</code> ，我们获得<br>Spring Integration Java DSL的使用很多。虽然，大多数人都会同意lambda语法提供了<br>更简洁的定义。</p><p>我们在这里分析相同的<a href="https://github.com/spring-projects/spring-integration-samples/tree/master/dsl/cafe-dsl">Cafe Demo</a>示例，<br>但使用Java 8之前的版本进行配置。许多选项是相同的，因此我们只在此处将其说明复制/粘贴到<br>取得完整的画面。由于此Spring Integration Java DSL配置与<br>Java 8 lambda样式，对于所有用户来说都是很有用的知识，我们将如何以丰富的多样性实现相同的结果<br>Spring Integration Java DSL提供的选项集。</p><p>我们应用程序的源代码放在一个类中，这是一个<code>Boot</code>应用;<br>有效行用与注释对应的数字注释，该注释如下：</p>
<pre><code class="prettyprint java">@SpringBootApplication                                                   // 1
@IntegrationComponentScan                                                // 2
public class Application {

  public static void main(String[] args) throws Exception {
  	ConfigurableApplicationContext ctx =
			SpringApplication.run(Application.class, args);              // 3

  	Cafe cafe = ctx.getBean(Cafe.class);                                 // 4
  	for (int i = 1; i &lt;= 100; i++) {                                     // 5
  	  Order order = new Order(i);
  	  order.addItem(DrinkType.LATTE, 2, false);
  	  order.addItem(DrinkType.MOCHA, 3, true);
  	  cafe.placeOrder(order);
  	}

  	System.out.println(&quot;Hit &#39;Enter&#39; to terminate&quot;);                      // 6
  	System.in.read();
  	ctx.close();
  }

  @MessagingGateway                                                      // 7
  public interface Cafe {

  	@Gateway(requestChannel = &quot;orders.input&quot;)                            // 8
  	void placeOrder(Order order);                                        // 9

  }

  private final AtomicInteger hotDrinkCounter = new AtomicInteger();

  private final AtomicInteger coldDrinkCounter = new AtomicInteger();    // 10

  @Autowired
  private CafeAggregator cafeAggregator;                                 // 11

  @Bean(name = PollerMetadata.DEFAULT_POLLER)
  public PollerMetadata poller() {                                       // 12
  	return Pollers.fixedDelay(1000).get();
  }

  @Bean
  @SuppressWarnings(&quot;unchecked&quot;)
  public IntegrationFlow orders() {                                      // 13
  	return IntegrationFlows.from(&quot;orders.input&quot;)                         // 14
	  .split(&quot;payload.items&quot;, (Consumer) null)                           // 15
	  .channel(MessageChannels.executor(Executors.newCachedThreadPool()))// 16
	  .route(&quot;payload.iced&quot;,                                             // 17
	    new Consumer&lt;RouterSpec&lt;ExpressionEvaluatingRouter&gt;&gt;() {         // 18

	      @Override
	      public void accept(RouterSpec&lt;ExpressionEvaluatingRouter&gt; spec) {
	      	spec.channelMapping(&quot;true&quot;, &quot;iced&quot;)
                .channelMapping(&quot;false&quot;, &quot;hot&quot;);                         // 19
  	      }

  	    })
  	  .get();                                                            // 20
  }

  @Bean
  public IntegrationFlow icedFlow() {                                    // 21
  	return IntegrationFlows.from(MessageChannels.queue(&quot;iced&quot;, 10))      // 22
	  .handle(new GenericHandler&lt;OrderItem&gt;() {                          // 23

	  	@Override
	  	public Object handle(OrderItem payload, Map&lt;String, Object&gt; headers) {
	  	  Uninterruptibles.sleepUninterruptibly(1, TimeUnit.SECONDS);
	  	  System.out.println(Thread.currentThread().getName()
	  	    + &quot; prepared cold drink #&quot; + coldDrinkCounter.incrementAndGet()
	  	    + &quot; for order #&quot; + payload.getOrderNumber() + &quot;: &quot; + payload);
	  	  return payload;                                                // 24
  	  	}

  	  })
  	  .channel(&quot;output&quot;)                                                 // 25
  	  .get();
  }

  @Bean
  public IntegrationFlow hotFlow() {                                     // 26
  	return IntegrationFlows.from(MessageChannels.queue(&quot;hot&quot;, 10))
	  .handle(new GenericHandler&lt;OrderItem&gt;() {

	  	@Override
	  	public Object handle(OrderItem payload, Map&lt;String, Object&gt; headers) {
	  	  Uninterruptibles.sleepUninterruptibly(5, TimeUnit.SECONDS);    // 27
	  	  System.out.println(Thread.currentThread().getName()
	  	    + &quot; prepared hot drink #&quot; + hotDrinkCounter.incrementAndGet()
	  	    + &quot; for order #&quot; + payload.getOrderNumber() + &quot;: &quot; + payload);
	  	  return payload;
  	  	}

  	  })
  	  .channel(&quot;output&quot;)
  	  .get();
  }

  @Bean
  public IntegrationFlow resultFlow() {                                  // 28
    return IntegrationFlows.from(&quot;output&quot;)                               // 29
      .transform(new GenericTransformer&lt;OrderItem, Drink&gt;() {            // 30

        @Override
        public Drink transform(OrderItem orderItem) {
          return new Drink(orderItem.getOrderNumber(),
            orderItem.getDrinkType(),
            orderItem.isIced(),
            orderItem.getShots());                                       // 31
        }

      })
      .aggregate(new Consumer&lt;AggregatorSpec&gt;() {                        // 32

        @Override
        public void accept(AggregatorSpec aggregatorSpec) {
          aggregatorSpec.processor(cafeAggregator, null);                // 33
        }

      }, null)
      .handle(CharacterStreamWritingMessageHandler.stdout())             // 34
    .get();
  }


  @Component
  public static class CafeAggregator {                                   // 35

  	@Aggregator                                                          // 36
  	public Delivery output(List&lt;Drink&gt; drinks) {
  	  return new Delivery(drinks);
  	}

  	@CorrelationStrategy                                                 // 37
  	public Integer correlation(Drink drink) {
  	  return drink.getOrderNumber();
  	}

  }

}
</code></pre><p>逐行检查代码…</p><p><a name="line1"></a><br>1。<br><code>java @SpringBootApplication</code><br>来自Spring Boot 1.2的新的元注释。包括<code>@Configuration</code>和<br><code>@EnableAutoConfiguration</code> 。由于我们在Spring Integration应用程序中，并且Spring Boot具有自动配置<br>为此， <code>@EnableIntegration</code>自动应用，以初始化Spring Integration基础架构，包括<br>Java DSL的环境- <code>DslIntegrationConfigurationInitializer</code> ，由<br><code>IntegrationConfigurationBeanFactoryPostProcessor</code>从<code>/META-INF/spring.factories</code> 。</p><p><a name="line2"></a><br>2。<br><code>java @IntegrationComponentScan</code><br>Spring Integration类似物<code>@ComponentScan</code>扫描基于<br>接口，（Spring Framework 的<code>@ComponentScan</code>只看课程）。Spring Integration支持发现接口<br>带有注释<code>@MessagingGateway</code> （请参阅下面的＃7）。</p><p><a name="line3"></a><br>3。<br><code>java ConfigurableApplicationContext ctx = SpringApplication.run(Application.class, args);</code><br>的<code>main</code>我们类的方法旨在使用来启动Spring Boot应用程序<br>此类的配置并启动<code>ApplicationContext</code>通过Spring Boot。另外，它委托命令<br>Spring Boot的行参数。例如，您可以指定<code>--debug</code>查看启动自动配置报告的日志。</p><p><a name="line4"></a><br>4。<br><code>java Cafe cafe = ctx.getBean(Cafe.class);</code><br>由于我们已经有一个<code>ApplicationContext</code>我们可以开始与应用程序进行交互。和<code>Cafe</code><br>是入口点-用EIP术语来说<code>gateway</code> 。网关只是接口，应用程序不会交互<br>使用Messaging API；它只处理域（请参阅下面的＃7）。</p><p><a name="line5"></a><br>5，<br><code>java for (int i = 1; i <= 100; i++) {</code><br>为了演示咖啡馆的“工作”，我们开出了100份订单，包括两种饮料-一份热饮料和一份冰镇饮料。并发送<code>Order</code>到<code>Cafe</code>网关。</p><p><a name="line6"></a><br>6。<br><code>java System.out.println("Hit 'Enter' to terminate");</code><br>通常，Spring Integration应用程序是异步的，因此避免过早退出<code>main</code>线程我们阻止<br><code>main</code>方法，直到最终用户通过命令行进行交互。非守护程序线程将保留应用程序<br>开放但<code>System.read()</code>为我们提供了一种干净地关闭应用程序的机制。</p><p><a name="line7"></a><br>7。<br><code>java @MessagingGateway</code><br>用于标记业务接口以指示它是<code>gateway</code>在。。之间<br>最终应用程序和集成层。它是<code><gateway /></code> Spring Integration XML中的组件<br>组态。Spring Integration创建了一个<code>Proxy</code>此接口，并将其填充为<br>应用程序上下文。目的是<code>Proxy</code>是将参数包装在<code>Message<?></code>对象并将其发送给<br><code>MessageChannel</code>根据提供的选项。</p><p><a name="line8"></a><br>8。<br><code>java @Gateway(requestChannel = "orders.input")</code><br>通过方法以及目标针对不同业务逻辑的方法级别注释<br>整合流程。在此示例中，我们使用<code>requestChannel</code>参考<code>orders.input</code> ，这是一个<code>MessageChannel</code><br>我们的bean名称<code>IntegrationFlow</code>输入通道（请参阅下面的＃14）。</p><p><a name="line9"></a><br>9。<br><code>java void placeOrder(Order order);</code><br>接口方法是从最终应用程序与集成层进行交互的中心点。此方法有一个<br><code>void</code>返回类型。这意味着我们的整合流程是<code>one-way</code>我们只是将消息发送到集成流程，而无需等待回复。</p><p><a name="line10"></a><br>10。<br><code>java private AtomicInteger hotDrinkCounter = new AtomicInteger(); private AtomicInteger coldDrinkCounter = new AtomicInteger();</code><br>两个柜台收集信息，我们的咖啡馆如何与饮料一起工作。</p><p><a name="line11"></a><br>11。<br><code>java @Autowired private CafeAggregator cafeAggregator;</code><br>的POJO <code>Aggregator</code>逻辑（请参见下面的＃33和＃35）。由于它是Spring bean，因此我们甚至可以将其注入当前<code>@Configuration</code>并在下面的任何地方使用，例如<code>.aggregate()</code> EIP方法。</p><p><a name="line12"></a><br>12<br><code>java @Bean(name = PollerMetadata.DEFAULT_POLLER) public PollerMetadata poller() {</code><br>的<code>default</code><code>poller</code> bean 。它是类似物<code><poller default="true"></code> Spring Integration XML配置中的组件。对于其中<code>inputChannel</code>是一个<code>PollableChannel</code> 。在这种情况下，<br>两个咖啡厅<code>queues</code> -热和冰（请参阅下面的＃18）。在这里我们使用<code>Pollers</code> DSL项目中的工厂并使用其<br>方法链流利的API来构建轮询器元数据。注意<code>Pollers</code>可以直接从<code>IntegrationFlow</code>定义，<br>如果具体<code>poller</code> （而不是默认的轮询器）端点。</p><p><a name="line13"></a><br>13<br><code>java @Bean public IntegrationFlow orders() {</code><br>的<code>IntegrationFlow</code> Bean定义。它是Spring Integration Java DSL的核心组件，尽管它在运行时（在bean注册阶段）不起作用。下面的所有其他代码注册Spring Integration组件（ <code>MessageChannel</code> ， <code>MessageHandler</code> ， <code>EventDrivenConsumer</code> ， <code>MessageProducer</code> ， <code>MessageSource</code>等） <code>IntegrationFlow</code>对象，由<code>IntegrationFlowBeanPostProcessor</code>来处理这些组件，并根据需要在应用程序上下文中将它们注册为Bean（某些元素，例如通道可能已经存在）。</p><p><a name="line14"></a><br>14。<br><code>java return IntegrationFlows.from("orders.input")</code><br>的<code>IntegrationFlows</code>是主要的<code>factory</code>上课开始<code>IntegrationFlow</code> 。它提供了许多重载<code>.from()</code>允许从<code>SourcePollingChannelAdapter</code>为一个<code>MessageSource<?></code>实现，例如<code>JdbcPollingChannelAdapter</code> ;从一个<code>MessageProducer</code> ，例如<code>WebSocketInboundChannelAdapter</code> ;或者只是一个<code>MessageChannel</code> 。所有“ .from（）”选项都有几个方便的变体，可以为启动该组件配置适当的组件。 <code>IntegrationFlow</code> 。在这里，我们只使用一个频道名称，该名称会转换为<code>DirectChannel</code>在Bean定义阶段，同时解析<code>IntegrationFlow</code> 。在Java 8变体中，我们在这里使用了<code>Lambda definition</code> - 和这个<code>MessageChannel</code>已经根据Bean名称隐式创建<code>IntegrationFlow</code>Bean name称。</p><p><a name="line15"></a><br>15<br><code>java .split("payload.items", (Consumer) null)</code><br>由于我们的集成流程通过<code>orders.input</code>渠道，我们准备使用它们并对其进行处理。在我们的方案中，第一个EIP方法是<code>.split()</code> 。我们知道消息<code>payload</code>从<code>orders.input</code>频道是一个<code>Order</code>域对象，因此我们只需在此处使用Spring（SpEL）表达式即可返回<code>Collection<OrderItem></code> 。因此，这执行<code>split</code> EI模式，我们将每个集合条目作为单独的消息发送到下一个通道。在后台， <code>.split()</code>方法注册一个<code>ExpressionEvaluatingSplitter</code><code>MessageHandler</code>实施和<code>EventDrivenConsumer</code>为了那个原因<code>MessageHandler</code> ，在<code>orders.input</code>频道作为<code>inputChannel</code> 。</p><p>第二个论点<code>.split()</code> EIP方法适用于<code>endpointConfigurer</code>至<br>自定义选项，例如<code>autoStartup</code> ， <code>requiresReply</code> ， <code>adviceChain</code>等我们在这里用<code>null</code>证明我们依靠<br>在端点的默认选项上。许多EIP方法都提供带或不带的重载版本<br><code>endpointConfigurer</code> 。目前<code>.split(String expression)</code>没有的EIP方法<code>endpointConfigurer</code>参数不可用；这将在以后的版本中解决。</p><p><a name="line16"></a><br>16。<br><code>java .channel(MessageChannels.executor(Executors.newCachedThreadPool()))</code><br>的<code>.channel()</code> EIP方法允许具体规范<code>MessageChannel</code>端点之间的，因为它是通过<br><code>output-channel</code> / <code>input-channel</code>属性与Spring Integration XML配置配对。默认情况下，<br>DSL集成流程定义与<code>DirectChannel</code> s，它根据<code>IntegrationFlow</code><br>Bean name称和<code>index</code>在流链中。在这种情况下，我们选择一个<br>具体<code>MessageChannel</code>从实施<code>Channels</code>工厂级选定的<br>这里的频道是<code>ExecutorChannel</code> ，以允许从<code>splitter</code>分开<code>Thread</code> s，要处理<br>它们在下游流中并行。</p><p><a name="line17"></a><br>17。<br><code>java .route("payload.iced",</code><br>我们场景中的下一个EIP方法是<code>.route()</code> ， 发送<code>hot/iced</code>向不同的Cafe厨房订购商品。我们在这里再次使用SpEL表达式来获取<code>routingKey</code>从收到的消息中。在Java 8变体中，我们使用了<code>method-reference</code> Lambda表达式，但是对于Java 8之前的样式，我们必须使用SpEL或内联接口实现。流中的许多匿名类会使流难以阅读，因此在大多数情况下，我们更喜欢SpEL。</p><p><a name="line18"></a><br>18岁<br><code>java new Consumer<RouterSpec<ExpressionEvaluatingRouter>>() {</code><br>第二个论点<code>.route()</code> EIP方法是功能接口<code>Consumer</code>指定<code>ExpressionEvaluatingRouter</code>使用一个选项<code>RouterSpec</code>建造者。由于Java 8之前没有任何选择，因此我们在此为该接口提供内联实现。</p><p><a name="line19"></a><br>19<br><code>java spec.channelMapping("true", "iced") .channelMapping("false", "hot");</code><br>随着<code>Consumer<RouterSpec<ExpressionEvaluatingRouter>>#accept()</code>我们可以提供所需的实施<code>AbstractMappingMessageRouter</code>选项。其中之一是<code>channelMappings</code> ，当我们根据路由器的扩展结果和目标指定路由逻辑时<code>MessageChannel</code>为适当的结果。在这种情况下<code>iced</code>和<code>hot</code>是<code>MessageChannel</code>的名字<code>IntegrationFlow</code> s。</p><p><a name="line20"></a><br>20<br><code>java .get();</code><br>这样就完成了流程。<br>任何<code>IntegrationFlows.from()</code>方法返回一个<code>IntegrationFlowBuilder</code>实例和这个<code>get()</code>方法提取<code>IntegrationFlow</code>来自的对象<code>IntegrationFlowBuilder</code>组态。一切都从<code>.from()</code>以及之前的方法<code>.get()</code>是一个<code>IntegrationFlow</code>定义。所有定义的组件都存储在<code>IntegrationFlow</code>并由<code>IntegrationFlowBeanPostProcessor</code>在Bean创建阶段。</p><p><a name="line21"></a><br>21<br><code>java @Bean public IntegrationFlow icedFlow() {</code><br>这是第二个<code>IntegrationFlow</code> bean 定义-为<code>iced</code>饮料。这里我们展示了<code>IntegrationFlow</code> s<br>可以连接在一起以创建单个复杂的应用程序。注意：不建议注入一个<code>IntegrationFlow</code>至<br>另一个;它可能会导致意外的行为。由于它们为Bean注册和集成提供了集成组件。<br><code>MessageChannel</code>其中之一，最好的接线和注入方法是通过<code>MessageChannel</code>要么<code>@MessagingGateway</code><br>接口。</p><p><a name="line22"></a><br>22<br><code>java return IntegrationFlows.from(MessageChannels.queue("iced", 10))</code><br>的<code>iced</code><code>IntegrationFlow</code>从一个开始<code>QueueChannel</code>具有的能力<code>10</code>信息;它被注册为具有以下名称的bean： <code>iced</code> 。<br>如您所记得，我们使用此名称作为路由映射之一（请参见上面的＃19）。</p><p>在我们的示例中，我们在此处使用<br><code>QueueChannel</code>从现实生活中反映出咖啡厅厨房的忙碌状态。这是我们需要的地方<br><code>global poller</code>用于在此频道上侦听的下一个端点。</p><p><a name="line23"></a><br>23。<br><code>java .handle(new GenericHandler<OrderItem>() {</code><br>的<code>.handle()</code>的EIP方法<code>iced</code>流程演示了具体的Cafe厨房工作。因为我们不能最小化<br>带有类似Java 8 Lambda表达式的代码，我们在此为<code>GenericHandler</code><br>功能与预期的接口<code>payload</code>类型作为通用参数。在Java 8示例中，我们分发了<code>.handle()</code><br>在几个订户子流之间<code>PublishSubscribeChannel</code> 。但是，在这种情况下，逻辑就是全部<br>用一种方法实现。</p><p><a name="line24"></a><br>24<br><code>java Uninterruptibles.sleepUninterruptibly(1, TimeUnit.SECONDS); System.out.println(Thread.currentThread().getName() + " prepared cold drink #" + coldDrinkCounter.incrementAndGet() + " for order #" + payload.getOrderNumber() + ": " + payload); return payload;</code><br>当前的业务逻辑实现<code>.handle()</code> EIP组件。用<br><code>Uninterruptibles.sleepUninterruptibly(1, TimeUnit.SECONDS);</code>我们只是阻止当前<code>Thread</code>超时来演示如何<br>咖啡馆的厨房很快就准备一杯饮料。之后，我们只向<code>STDOUT</code>饮料准备好了<br>返回当前<code>OrderItem</code>来自<code>GenericHandler</code>在我们的下一个端点<code>IntegrationFlow</code> 。在里面<br>在后台，DSL框架注册了一个<code>ServiceActivatingHandler</code>为了<code>MethodInvokingMessageProcessor</code>调用<br><code>GenericHandler#handle</code>在运行时。此外，该框架还注册了一个<code>PollingConsumer</code>的端点<br><code>QueueChannel</code>以上。该端点依赖于<code>default poller</code>轮询队列中的消息。当然，我们<br>总是可以使用特定的<code>poller</code>对于任何具体的端点。在这种情况下，我们将不得不提供第二个<br><code>endpointConfigurer</code>争论<code>.handle()</code> EIP方法。</p><p><a name="line25"></a><br>25<br><code>java .channel("output")</code><br>由于这不是我们Cafe场景的结束，因此我们将当前流的结果发送到<code>output</code>渠道<br>使用便捷的EIP方法<code>.channel()</code>和名称<code>MessageChannel</code> Bean（请参见下面的＃29）。这是合乎逻辑的<br>当前冰饮料子流的末尾，因此我们使用<code>.get()</code>返回的方法<code>IntegrationFlow</code> 。流程结束<br>没有最终答案的回复处理程序<code>.channel()</code>将返回对消息的回复<code>replyChannel</code>标头。</p><p><a name="line26"></a><br>26<br><code>java @Bean public IntegrationFlow hotFlow() {</code><br>的<code>IntegrationFlow</code>的定义<code>hot</code>饮料。它类似于以前的<code>iced</code>饮料流，但是<br>与具体<code>hot</code>商业逻辑。它从<code>hot</code><code>QueueChannel</code>从上面的路由器映射的。</p><p><a name="line27"></a><br>27。<br><code>java Uninterruptibles.sleepUninterruptibly(5, TimeUnit.SECONDS);</code><br>的<code>sleepUninterruptibly</code>对于<code>hot</code>饮料。是的，我们需要更多时间煮水！</p><p><a name="line28"></a><br>28岁<br><code>java @Bean public IntegrationFlow resultFlow() {</code><br>多一个<code>IntegrationFlow</code> bean定义准备<code>Delivery</code>根据<code>Drink</code> s。</p><p><a name="line29"></a><br>29。<br><code>java return IntegrationFlows.from("output")</code><br>的<code>resultFlow</code>从开始<code>DirectChannel</code> ，它是在bean定义阶段使用此命令创建的<br>提供的名称。您应该记住，我们使用<code>output</code>咖啡馆厨房的频道名称在最后流动<code>.channel()</code>在<br>这些定义。</p><p><a name="line30"></a><br>30岁<br><code>java .transform(new GenericTransformer<OrderItem, Drink>() {</code><br>的<code>.transform()</code> EIP方法适用于适当的模式实现，并且希望某些对象能够转换一个<br>有效载荷到另一个。在我们的示例中，我们使用了<code>GenericTransformer</code>功能接口<br>兑换<code>OrderItem</code>至<code>Drink</code>并使用通用参数进行指定。在后台，DSL框架<br>注册一个<code>MessageTransformingHandler</code>和<code>EventDrivenConsumer</code>具有使用消息的默认选项的端点<br>来自<code>output</code><code>MessageChannel</code> 。</p><p><a name="line31"></a><br>31。<br><code>java public Drink transform(OrderItem orderItem) { return new Drink(orderItem.getOrderNumber(), orderItem.getDrinkType(), orderItem.isIced(), orderItem.getShots()); }</code><br>特定业务<code>GenericTransformer#transform()</code>实现以展示我们如何从Java中受益<br>泛型改造一个<code>payload</code>到另一个。注意：Spring Integration的使用<code>ConversionService</code>之前<br>任何方法调用，如果您提供一些特定的方法<code>Converter</code>实施，某些领域<code>payload</code>可<br>当框架有适当的注册时，自动转换为另一个<code>Converter</code> 。</p><p><a name="line32"></a><br>32。<br><code>java .aggregate(new Consumer<AggregatorSpec>() {</code><br>的<code>.aggregate()</code> EIP方法提供了用于配置<code>AggregatingMessageHandler</code>及其端点<br>类似于我们可以使用的<code><aggregator></code>使用Spring Integration XML配置时的组件。当然，使用Java DSL<br>我们拥有更多功能来配置聚合器，而无需任何其他多余的bean。但是我们证明<br>这里是带有注释的聚合器配置（请参见下面的＃35）。<br>从Cafe业务逻辑的角度来看，我们构成了<code>Delivery</code>对于最初<code>Order</code> ， 因为我们<code>.split()</code>原始订单<br>到<code>OrderItem</code>即将开始。</p><p><a name="line33"></a><br>33。<br><code>java public void accept(AggregatorSpec aggregatorSpec) { aggregatorSpec.processor(cafeAggregator, null); }</code><br>的内联实现<code>Consumer</code>为了<code>AggregatorSpec</code> 。使用<code>aggregatorSpec</code>我们可以提供的建造者<br>所需的选项<code>aggregator</code>组件，将被注册为<code>AggregatingMessageHandler</code> bean 。在这里，我们<br>只需提供<code>processor</code>作为自动接线的参考（请参见上面的＃11） <code>CafeAggregator</code>组件（请参见下面的＃35）。<br>第二个论点<code>.processor()</code>选项是<code>methodName</code> 。由于我们依赖聚合器<br>POJO的注释配置，我们无需在此处提供方法，框架将确定正确的POJO方法<br>在后台。</p><p><a name="line34"></a><br>34。<br><code>java .handle(CharacterStreamWritingMessageHandler.stdout())</code><br>这是我们流程的终点- <code>Delivery</code>交付给客户！我们只是在这里打印消息<code>payload</code><br>开箱即用到STDOUT <code>CharacterStreamWritingMessageHandler</code>来自Spring Integration Core。这是一个<br>案例展示了如何从Java DSL使用Spring Integration Core（及其模块）中的现有组件。</p><p><a name="line35"></a><br>35岁<br><code>java @Component public static class CafeAggregator {</code><br>用于指定业务逻辑的bean <code>aggregator</code>以上。这个 bean 被<code>@ComponentScan</code> ，<br>这是<code>@SpringBootApplication</code>元注释（请参见上面的＃1）。所以，这个组件变成了一个bean<br>我们可以自动连线（ <code>@Autowired</code> ）到应用程序上下文中的其他组件（请参见上面的＃11）。</p><p><a name="line36"></a><br>36。<br><code>java @Aggregator public Delivery output(List<Drink> drinks) { return new Delivery(drinks); }</code><br>特定于POJO <code>MessageGroupProcessor</code>建立输出<code>payload</code>基于聚合的有效载荷<br>消息。由于我们用<code>@Aggregator</code>注释，目标<code>AggregatingMessageHandler</code>可以提取<br>这种方法<code>MethodInvokingMessageGroupProcessor</code> 。</p><p><a name="line37"></a><br>37。<br><code>java @CorrelationStrategy public Integer correlation(Drink drink) { return drink.getOrderNumber(); }</code><br>特定于POJO <code>CorrelationStrategy</code>提取风俗<code>correlationKey</code>来自每个入站聚合消息。<br>由于我们用<code>@CorrelationStrategy</code>标注目标<code>AggregatingMessageHandler</code>可以提取<br>这种方法<code>MethodInvokingCorrelationStrategy</code> 。<br>有类似的自我解释<code>@ReleaseStrategy</code>注释，但我们仅在默认示例中使用Cafe示例<br><code>SequenceSizeReleaseStrategy</code> ，它基于<code>sequenceDetails</code>由<code>splitter</code><br>从我们整合流程的开始。</p><p>好了，我们已经完成了Java Lambda时基于Spring Integration Java DSL的Cafe Demo示例的描述。<br>不提供支持。<br>与<a href="https://github.com/spring-projects/spring-integration-samples/tree/master/applications/cafe/cafe-si">XML示例</a>进行比较<br>另请参阅<a href="https://spring.io/blog/2014/11/25/spring-integration-java-dsl-line-by-line-tutorial">Lambda支持教程</a><br>获得有关Spring Integration的更多信息。</p><p>如您所见，使用不带lambda的DSL更加冗长，因为您需要提供样板代码<br>用于功能接口的内联匿名实现。但是，我们认为支持使用非常重要<br>尚无法迁移到Java 8的用户的DSL数量。DSL的许多优点（流畅的API，编译时验证等）<br>适用于所有用户。</p><p>lambda的使用延续了Spring Framework减少或消除样板代码的传统，因此我们鼓励<br>用户尝试使用Java 8和lambda，并鼓励其组织考虑允许将Java 8用于<br>Spring Integration应用程序。</p><p>另外请参阅<a href="https://github.com/spring-projects/spring-integration-java-dsl/wiki/Spring-Integration-Java-DSL-Reference">参考手册</a><br>想要查询更多的信息。</p><p>一如既往，我们期待您的评论和反馈（ <a href="https://stackoverflow.com">StackOverflow</a><br>（ <code>spring-integration</code>标签）， <a href="https://jira.spring.io/browse/INTEXT">Spring JIRA</a> ，<br><a href="https://github.com/spring-projects/spring-integration-java-dsl/issues">GitHub</a> ），我们非常欢迎<br><a href="https://github.com/spring-projects/spring-integration/blob/master/CONTRIBUTING.md">贡献</a> ！</p><p>感谢您的时间和耐心阅读！</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 1865;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>