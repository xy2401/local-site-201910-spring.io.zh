<html  data-code-prettify="" data-mobile-support="" data-search=""><head></head><body >﻿
<title>Spring Integration Java DSL：逐行教程</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Spring Integration Java DSL: Line by line tutorial">
<meta name="twitter:description" >
<meta name="twitter:creator" content="@artem_bilan">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/2158ce6e7c048277890eb64458864c1c?s=200">

<meta property="og:title" content="Spring Integration Java DSL: Line by line tutorial">
<meta property="og:image" content="https://gravatar.com/avatar/2158ce6e7c048277890eb64458864c1c?s=200">
<meta property="og:description" >
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2014-11-25 13:10:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Spring Integration Java DSL：逐行教程</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/2158ce6e7c048277890eb64458864c1c?s=20&d=mm"> <a class="author" rel="author" href="/team/artembilan">阿尔特姆·比兰（Artem Bilan）</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2014-11-25 13:10:00.0">2014年11月25日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2014/11/25/spring-integration-java-dsl-line-by-line-tutorial#disqus_thread" data-disqus-identifier="1862">
</a></div>
</div>
</header>
<div class="blog--post"><p>亲爱的春季社区！</p><p>在<a href="https://spring.io/blog/2014/11/24/spring-integration-java-dsl-1-0-ga-released">Spring Integration Java DSL 1.0 GA</a>发布公告之后，我想向您介绍Spring Integration Java DSL，作为基于经典的逐行教程<br><a href="https://github.com/spring-projects/spring-integration-samples/tree/master/dsl/cafe-dsl">Cafe Demo</a>集成示例。<br>我们在这里介绍<a href="https://projects.spring.io/spring-boot/">Spring Boot</a>支持，Spring Framework <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-java">Java和Annotation</a>配置， <a href="https://github.com/spring-projects/spring-integration-java-dsl/blob/master/src/main/java/org/springframework/integration/dsl/IntegrationFlow.java"><code>IntegrationFlow</code></a>特性并向Java 8 <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">Lambda</a>支持致敬，这是DSL风格的灵感。当然，所有这些都由<a href="https://projects.spring.io/spring-integration/">Spring Integration Core</a>项目提供支持。</p><p>对于那些尚未对Java 8感兴趣的人，我们提供了类似的教程，但没有Lambda： <a href="https://spring.io/blog/2014/12/01/spring-integration-java-dsl-pre-java-8-line-by-line-tutorial">Spring Integration Java DSL（Java 8之前的版本）：逐行教程</a> 。</p><p>但是，在我们开始介绍Cafe演示应用程序之前，这里只是一个简短的示例，供您入门……</p>
<pre><code class="prettyprint java">@Configuration
@EnableAutoConfiguration
@IntegrationComponentScan
public class Start {

	public static void main(String[] args) throws InterruptedException {
		ConfigurableApplicationContext ctx = 
                                 SpringApplication.run(Start.class, args);

		List&lt;String&gt; strings = Arrays.asList(&quot;foo&quot;, &quot;bar&quot;);
		System.out.println(ctx.getBean(Upcase.class).upcase(strings));

		ctx.close();
	}

	@MessagingGateway
	public interface Upcase {

		@Gateway(requestChannel = &quot;upcase.input&quot;)
		Collection&lt;String&gt; upcase(Collection&lt;String&gt; strings);

	}

	@Bean
	public IntegrationFlow upcase() {
	     return f -&gt; f
		 	.split()                                         // 1
			.&lt;String, String&gt;transform(String::toUpperCase)  // 2
			.aggregate();                                    // 3
	}

}
</code></pre><p>我们将基础设施的描述（注释等）留给咖啡馆的主要流程描述。在这里，我们希望您专注于最后<code>@Bean</code> ， <code>IntegrationFlow</code>以及将消息发送到该流的网关方法。</p><p>在里面<code>main</code>方法，我们将字符串集合发送到网关，并将结果打印到STDOUT。该流程首先将集合拆分为单个<code>String</code> s（1）;然后将每个字符串转换为大写（2），最后我们将它们重新聚合回一个集合（3）<br>由于这是流程的结束，因此框架将聚合的结果返回给网关，并且新的有效负载成为网关方法的返回值。</p><p>等效的XML配置可能是…</p>
<pre><code class="prettyprint xml">&lt;int:gateway service interface=&quot;foo.Upcase&quot; 
                 default-request-channel=&quot;upcase.input&quot;&gt;

&lt;int:splitter input-channel=&quot;upcase.input&quot; output-channel=&quot;transform&quot;/&gt;

&lt;int:transformer expression=&quot;payload.toUpperCase()&quot;
    input-channel=&quot;transform&quot;
    output-channel=&quot;aggregate&quot; /&gt;

&lt;int:aggregator input-channle=&quot;aggregate&quot; /&gt;
</code></pre><p>要么…</p>
<pre><code class="prettyprint xml">&lt;int:gateway service interface=&quot;foo.Upcase&quot; 
                default-request-channel=&quot;upcase.input&quot;&gt;

&lt;int:chain input-channel=&quot;upcase.input&quot;&gt;
    &lt;int:splitter /&gt;
    &lt;int:transformer expression=&quot;payload.toUpperCase()&quot; /&gt;
    &lt;int:aggregator /&gt;
&lt;/int:chain&gt;
</code></pre><h2><a href="#cafe-demo" class="anchor" name="cafe-demo"></a>咖啡馆演示</h2><p>目的<code>Cafe Demo</code>该应用程序将演示如何使用企业集成模式（EIP）来反映<code>order-delivery</code>现实生活中的场景。通过此应用程序，我们可以处理多种饮料订单-热和冰。运行应用程序后，我们可以在标准输出中看到（ <code>System.out.println</code> ）如何更快地准备冷饮<br>比热。但是，整个订单的交货都推迟到热饮准备好为止。</p><p>为了反映域模型，我们有几个类： <code>Order</code> ， <code>OrderItem</code> ， <code>Drink</code>和<code>Delivery</code> 。集成方案中都提到了它们，但是由于它们很简单，因此我们这里不再对其进行分析。</p><p>我们的应用程序的源代码仅放在一个类中。有效行用与注释对应的数字注释，该注释如下：</p>
<pre><code class="prettyprint java">@SpringBootApplication               // 1
@IntegrationComponentScan            // 2
public class Application {

  public static void main(String[] args) throws Exception {
  	ConfigurableApplicationContext ctx =
  	              SpringApplication.run(Application.class, args);// 3

  	Cafe cafe = ctx.getBean(Cafe.class);                         // 4
  	for (int i = 1; i &lt;= 100; i++) {                             // 5
       Order order = new Order(i);
       order.addItem(DrinkType.LATTE, 2, false); //hot
       order.addItem(DrinkType.MOCHA, 3, true);  //iced
       cafe.placeOrder(order);
  	}

  	System.out.println(&quot;Hit &#39;Enter&#39; to terminate&quot;);              // 6
  	System.in.read();
  	ctx.close();
  }

  @MessagingGateway                                              // 7
  public interface Cafe {

  	@Gateway(requestChannel = &quot;orders.input&quot;)                    // 8
  	void placeOrder(Order order);                                // 9

  }

  private AtomicInteger hotDrinkCounter = new AtomicInteger();

  private AtomicInteger coldDrinkCounter = new AtomicInteger();  // 10

  @Bean(name = PollerMetadata.DEFAULT_POLLER)
  public PollerMetadata poller() {                               // 11
  	return Pollers.fixedDelay(1000).get();
  }

  @Bean
  public IntegrationFlow orders() {                             // 12
  	return f -&gt; f                                               // 13
  	  .split(Order.class, Order::getItems)                      // 14
  	  .channel(c -&gt; c.executor(Executors.newCachedThreadPool()))// 15
  	  .&lt;OrderItem, Boolean&gt;route(OrderItem::isIced, mapping -&gt; mapping // 16
  	    .subFlowMapping(&quot;true&quot;, sf -&gt; sf                        // 17
  	      .channel(c -&gt; c.queue(10))                            // 18
  	      .publishSubscribeChannel(c -&gt; c                       // 19
  	        .subscribe(s -&gt;                                     // 20
  	          s.handle(m -&gt; sleepUninterruptibly(1, TimeUnit.SECONDS)))// 21
  	        .subscribe(sub -&gt; sub                               // 22
  	          .&lt;OrderItem, String&gt;transform(item -&gt;
  	            Thread.currentThread().getName()
  	              + &quot; prepared cold drink #&quot;
  	              + this.coldDrinkCounter.incrementAndGet()
  	              + &quot; for order #&quot; + item.getOrderNumber()
  	              + &quot;: &quot; + item)                                 // 23
  	          .handle(m -&gt; System.out.println(m.getPayload())))))// 24
  	    .subFlowMapping(&quot;false&quot;, sf -&gt; sf                        // 25
  	      .channel(c -&gt; c.queue(10))
  	      .publishSubscribeChannel(c -&gt; c
  	        .subscribe(s -&gt;
  	          s.handle(m -&gt; sleepUninterruptibly(5, TimeUnit.SECONDS)))// 26
  	        .subscribe(sub -&gt; sub
  	          .&lt;OrderItem, String&gt;transform(item -&gt;
  	            Thread.currentThread().getName()
  	              + &quot; prepared hot drink #&quot;
  	              + this.hotDrinkCounter.incrementAndGet()
  	              + &quot; for order #&quot; + item.getOrderNumber()
  	              + &quot;: &quot; + item)
  	          .handle(m -&gt; System.out.println(m.getPayload()))))))
  	  .&lt;OrderItem, Drink&gt;transform(orderItem -&gt;
  	    new Drink(orderItem.getOrderNumber(),
  	      orderItem.getDrinkType(),
  	      orderItem.isIced(),
  	      orderItem.getShots()))                                // 27
  	  .aggregate(aggregator -&gt; aggregator                       // 28
  	    .outputProcessor(group -&gt;                               // 29
  	      new Delivery(group.getMessages()
  	        .stream()
  	        .map(message -&gt; (Drink) message.getPayload())
  	        .collect(Collectors.toList())))                     // 30
  	    .correlationStrategy(m -&gt;
  	      ((Drink) m.getPayload()).getOrderNumber()), null)     // 31
  	  .handle(CharacterStreamWritingMessageHandler.stdout());   // 32
  }

}
</code></pre><p>逐行检查代码…</p><p>1个</p>
<pre><code class="prettyprint java">@SpringBootApplication
</code></pre><p>来自Spring Boot 1.2的新的元注释。包括<code>@Configuration</code>和<code>@EnableAutoConfiguration</code> 。由于我们在Spring Integration应用程序中，并且Spring Boot具有自动配置功能，因此<code>@EnableIntegration</code>是自动应用的，以初始化包括Java DSL环境在内的Spring Integration基础架构- <code>DslIntegrationConfigurationInitializer</code> ，由<code>IntegrationConfigurationBeanFactoryPostProcessor</code>从<code>/META-INF/spring.factories</code> 。</p><p>2</p>
<pre><code class="prettyprint java">@IntegrationComponentScan
</code></pre><p>Spring Integration类似物<code>@ComponentScan</code>扫描基于<br>接口，（Spring Framework 的<code>@ComponentScan</code>只看课程）。Spring Integration支持发现带有注释的接口<code>@MessagingGateway</code> （请参阅下面的＃7）。</p><p>3</p>
<pre><code class="prettyprint java">ConfigurableApplicationContext ctx = SpringApplication.run(Application.class, args);
</code></pre><p>的<code>main</code>我们类的方法旨在使用来启动Spring Boot应用程序<br>此类的配置并启动<code>ApplicationContext</code>通过Spring Boot。另外，它将命令行参数委托给Spring Boot。例如，您可以指定<code>--debug</code>查看启动自动配置报告的日志。</p><p>4</p>
<pre><code class="prettyprint java">Cafe cafe = ctx.getBean(Cafe.class);
</code></pre><p>由于我们已经有一个<code>ApplicationContext</code>我们可以开始与应用程序进行交互。和<code>Cafe</code>是入口点-用EIP术语来说<code>gateway</code> 。网关只是接口，应用程序不与Messaging API交互；它只处理域（请参阅下面的＃7）。</p><p>5</p>
<pre><code class="prettyprint java">for (int i = 1; i &lt;= 100; i++) {
</code></pre><p>为了演示咖啡馆的“工作”，我们开出了100份订单，包括两种饮料-一份热饮料和一份冰镇饮料。并发送<code>Order</code>到<code>Cafe</code>网关。</p><p>6</p>
<pre><code class="prettyprint java">System.out.println(&quot;Hit &#39;Enter&#39; to terminate&quot;);
</code></pre><p>通常，Spring Integration应用程序是异步的，因此避免过早退出<code>main</code>线程我们阻止<code>main</code>方法，直到最终用户通过命令行进行交互。非守护程序线程将使应用程序保持打开状态，但<code>System.read()</code>为我们提供了一种干净地关闭应用程序的机制。</p><p>7</p>
<pre><code class="prettyprint java">@MessagingGateway
</code></pre><p>用于标记业务接口以指示它是<code>gateway</code>在。。之间<br>最终应用程序和集成层。它是<code><gateway /></code> Spring Integration XML配置中的组件。Spring Integration创建了一个<code>Proxy</code>此接口，并在应用程序上下文中将其填充为Bean。目的是<code>Proxy</code>是将参数包装在<code>Message<?></code>对象并将其发送给<code>MessageChannel</code>根据提供的选项。</p><p>8</p>
<pre><code class="prettyprint java">@Gateway(requestChannel = &quot;orders.input&quot;)
</code></pre><p>通过方法以及目标针对不同业务逻辑的方法级别注释<br>整合流程。在此示例中，我们使用<code>requestChannel</code>参考<code>orders.input</code> ，这是一个<code>MessageChannel</code>我们的bean名称<code>IntegrationFlow</code>输入通道（请参阅下面的＃13）。</p><p>9</p>
<pre><code class="prettyprint java">void placeOrder(Order order);
</code></pre><p>接口方法是从最终应用程序与集成层进行交互的中心点。此方法有一个<code>void</code>返回类型。这意味着我们的整合流程是<code>one-way</code>我们只是将消息发送到集成流程，而无需等待回复。</p><p>10</p>
<pre><code class="prettyprint java">private AtomicInteger hotDrinkCounter = new AtomicInteger();
private AtomicInteger coldDrinkCounter = new AtomicInteger();
</code></pre><p>两个柜台收集信息，我们的咖啡馆如何与饮料一起工作。</p><p>11</p>
<pre><code class="prettyprint java">@Bean(name = PollerMetadata.DEFAULT_POLLER)
public PollerMetadata poller() {
</code></pre><p>的<code>default</code><code>poller</code>豆。它是类似物<code><poller default="true"></code> Spring Integration XML配置中的组件。对于其中<code>inputChannel</code>是一个<code>PollableChannel</code> 。在这种情况下，有必要为两个Cafe <code>queues</code> -热和冰（请参阅下面的＃18）。在这里我们使用<code>Pollers</code> DSL项目中的工厂，并使用其方法链流利的API来构建轮询器元数据。注意<code>Pollers</code>可以直接从<code>IntegrationFlow</code>定义（如果有的话） <code>poller</code> （而不是默认的轮询器）端点。</p><p>12</p>
<pre><code class="prettyprint java">@Bean
public IntegrationFlow orders() {
</code></pre><p>的<code>IntegrationFlow</code> Bean定义。它是Spring Integration Java DSL的核心组件，尽管它在运行时（在bean注册阶段）不起作用。下面的所有其他代码注册Spring Integration组件（ <code>MessageChannel</code> ， <code>MessageHandler</code> ， <code>EventDrivenConsumer</code> ， <code>MessageProducer</code> ， <code>MessageSource</code>等） <code>IntegrationFlow</code>对象，由<code>IntegrationFlowBeanPostProcessor</code>至<br>处理这些组件，并根据需要在应用程序上下文中将它们注册为Bean（某些元素，例如通道可能已经存在）。</p><p>13</p>
<pre><code class="prettyprint java">return f -&gt; f
</code></pre><p>的<code>IntegrationFlow</code>是一个<code>Consumer</code>功能接口，因此我们可以减少代码并仅专注于集成方案需求。它的<code>Lambda</code>接受<code>IntegrationFlowDefinition</code>作为争论。此类提供了一套全面的方法，可以与<code>chain</code> 。我们称这些<code>EIP-methods</code> ，因为它们提供EI模式的实现并从Spring Integration Core填充组件。在Bean注册阶段， <code>IntegrationFlowBeanPostProcessor</code>转换此内联（Lambda） <code>IntegrationFlow</code>到<code>StandardIntegrationFlow</code>并处理其组件。我们可以使用<code>IntegrationFlows</code>工厂（例如<code>IntegrationFlow.from("channelX"). ... .get()</code> ），但我们发现Lambda定义更优雅。一个<code>IntegrationFlow</code>使用Lambda定义填充<code>DirectChannel</code>作为一个<code>inputChannel</code>流的名称，并在应用程序上下文中注册为具有名称的bean <code>orders.input</code>在我们的样本中（ <code>flow bean name + ".input"</code> ）。这就是为什么我们使用该名称作为<code>Cafe</code>网关。</p><p>14</p>
<pre><code class="prettyprint java">.split(Order.class, Order::getItems)
</code></pre><p>由于我们的集成流程通过<code>orders.input</code>渠道，我们准备使用它们并对其进行处理。在我们的方案中，第一个EIP方法是<code>.split()</code> 。我们知道消息<code>payload</code>从<code>orders.input</code>频道是一个<code>Order</code>域对象，因此我们只需在此处使用其类型并使用Java 8 <code>method-reference</code>特征。第一个参数是消息的类型<code>payload</code>我们期望，第二个是方法参考<br> <code>getItems()</code>方法，该方法返回<code>Collection<OrderItem></code> 。因此，这执行<code>split</code> EI模式，当我们将每个集合条目作为单独的消息发送到下一个通道时。在后台， <code>.split()</code>方法注册一个<code>MethodInvokingSplitter</code><code>MessageHandler</code>实施与<code>EventDrivenConsumer</code>为了那个原因<code>MessageHandler</code> ，并在<code>orders.input</code>频道作为<code>inputChannel</code> 。</p><p>15</p>
<pre><code class="prettyprint java">.channel(c -&gt; c.executor(Executors.newCachedThreadPool()))
</code></pre><p>的<code>.channel()</code> EIP方法允许具体规范<code>MessageChannel</code>端点之间的，因为它是通过<code>output-channel</code> / <code>input-channel</code>属性与Spring Integration XML配置配对。默认情况下，DSL集成流定义中的端点与<code>DirectChannel</code> s，它基于<code>IntegrationFlow</code>豆名称和<code>index</code>在流链中。在这种情况下，我们使用另一个<code>Lambda</code>表达式，它选择一个特定的<code>MessageChannel</code>从其实施<code>Channels</code>工厂并使用流畅的API对其进行配置。目前的频道是<code>ExecutorChannel</code> ，以允许从<code>splitter</code>分开<code>Thread</code> s，以在下游流中并行处理它们。</p><p>16</p>
<pre><code class="prettyprint java">.&lt;OrderItem, Boolean&gt;route(OrderItem::isIced, mapping -&gt; mapping
</code></pre><p>我们场景中的下一个EIP方法是<code>.route()</code> ， 发送<code>hot/iced</code>向不同的Cafe厨房订购商品。我们在这里再次使用方法参考（ <code>isIced()</code> ）获得<code>routingKey</code>从收到的消息中。第二个Lambda参数代表<code>router mapping</code> -类似于<code><mapping></code>的子元素<code><router></code> Spring Integration XML配置中的组件。但是，由于我们使用的是Java，因此可以进一步支持Lambda！Spring Integration Java DSL引入了<code>subflow</code>的定义<code>router</code>除了传统的<code>channel mapping</code> 。每个子流根据路由执行，如果子流产生结果，则将其传递到路由器之后的流定义中的下一个元素。</p><p>17</p>
<pre><code class="prettyprint java">.subFlowMapping(&quot;true&quot;, sf -&gt; sf 
</code></pre><p>指定当前路由器的集成流程<code>mappingKey</code> 。在此样本中，我们有两个子流- <code>hot</code>和<code>iced</code> 。子流是一样的<code>IntegrationFlow</code>功能接口，因此我们可以像在顶层一样使用其Lambda <code>IntegrationFlow</code>定义。子流与其父级没有任何运行时依赖关系，只是一种逻辑关系。</p><p>18岁</p>
<pre><code class="prettyprint java">.channel(c -&gt; c.queue(10))
</code></pre><p>我们已经知道Lambda定义<code>IntegrationFlow</code>从...开始<code>[FLOW_BEAN_NAME].input</code><code>DirectChannel</code> ，因此可能是一个问题，“如果我们指定<code>.channel()</code>再次？”。DSL会处理这种情况，并将这两个通道与<code>BridgeHandler</code>和端点。在我们的示例中，我们在此处使用<br><code>QueueChannel</code>从现实生活中反映出咖啡厅厨房的忙碌状态。这是我们需要的地方<code>global poller</code>用于在此频道上侦听的下一个端点。</p><p>19</p>
<pre><code class="prettyprint java">.publishSubscribeChannel(c -&gt; c
</code></pre><p>的<code>.publishSubscribeChannel()</code> EIP方法是<code>.channel()</code>为一个<br><code>MessageChannels.publishSubscribe()</code> ，但<code>.subscribe()</code>当我们可以将子流指定为通道的订阅者时选择。是的，再分流一次！因此，可以将子流指定为任意深度。独立于存在<code>.subscribe()</code>子流，父流中的下一个端点也是该流的订阅者<code>.publishSubscribeChannel()</code> 。<br>由于我们在<code>.route()</code>子流已经存在，最后一个订阅者是一个隐式<code>BridgeHandler</code>只是将消息弹出到顶层-类似的隐式<code>BridgeHandler</code>弹出消息到下一个<code>.transform()</code>主流中的端点。还有关于此流程当前位置的另一注：先前的EIP方法是<code>.channel(c -> c.queue(10))</code>而这个是为了<code>MessageChannel</code>太。因此，它们再次与隐式绑定<code>BridgeHandler</code>也一样在实际应用中，我们可以避免这种情况<code>.publishSubscribeChannel()</code>单单<code>.handle()</code>适用于Cafe厨房，但我们的目标是尽可能覆盖DSL功能。这就是为什么我们将厨房工作分配到同一子流程的多个子流程<code>PublishSubscribeChannel</code> 。</p><p>20</p>
<pre><code class="prettyprint java">.subscribe(s -&gt;
</code></pre><p>的<code>.subscribe()</code>方法接受<code>IntegrationFlow</code>作为参数，可以将其指定为Lambda以将订户配置为<code>subflow</code> 。在这里，我们使用几个子流订阅服务器来避免多行Lambda，并使用Spring Integration功能覆盖一些DSL。</p><p>21</p>
<pre><code class="prettyprint java">s.handle(m -&gt; sleepUninterruptibly(1, TimeUnit.SECONDS)))
</code></pre><p>这里我们用一个简单的<code>.handle()</code> EIP方法只是为了阻止当前线程超时，以演示Cafe厨房准备饮料的速度。在这里我们使用谷歌番石榴<code>Uninterruptibles.sleepUninterruptibly</code> ，以避免使用<code>try...catch</code>尽管您可以这样做，但Lambda将是多行的。或者，您可以将该代码移至单独的方法，然后在此处使用<code>method reference</code> 。</p><p>由于我们不使用任何<code>Executor</code>在<code>.publishSubscribeChannel()</code>所有订阅者将在同一线程上依次执行；在我们的情况下，它是<code>TaskScheduler</code>的主题来自<code>poller</code>在上一个<code>QueueChannel</code> 。这就是为什么<code>sleep</code>阻止所有下游过程，并允许演示<code>busy state</code>对于限于10<br><code>QueueChannel</code> 。</p><p>22</p>
<pre><code class="prettyprint java">.subscribe(sub -&gt; sub
</code></pre><p>下一个子流订阅者，仅在此之后执行<code>sleep</code> 1秒钟<code>iced</code>喝。我们在这里再使用一个子流，因为<code>.handle()</code>前一个是<code>one-way</code>与Lambda的本质有关<code>MessageHandler</code> 。这就是为什么要进行整个流程的过程，我们有几个订阅者：一些子流程在工作之后完成，并且不向父流程返回任何内容。</p><p>23</p>
<pre><code class="prettyprint java"> .&lt;OrderItem, String&gt;transform(item -&gt;
  	            Thread.currentThread().getName()
  	              + &quot; prepared cold drink #&quot;
  	              + this.coldDrinkCounter.incrementAndGet()
  	              + &quot; for order #&quot; + item.getOrderNumber()
  	              + &quot;: &quot; + item)         
</code></pre><p>的<code>transformer</code>当前订户子流中的要转换的是<code>OrderItem</code>下一个友好的STDOUT消息<code>.handle</code> 。在这里，我们看到泛型与Lambda表达式一起使用。这是使用<code>GenericTransformer</code>功能界面。</p><p>24</p>
<pre><code class="prettyprint java">.handle(m -&gt; System.out.println(m.getPayload())))))
</code></pre><p>的<code>.handle()</code>这里只是为了演示如何使用Lambda表达式打印<code>payload</code>到STDOUT。这表明我们的饮料已经准备好了。之后，最终（隐式）的订户<code>PublishSubscribeChannel</code>只是发送带有<code>OrderItem</code>到<code>.transform()</code>在主流中。</p><p>25</p>
<pre><code class="prettyprint java">.subFlowMapping(&quot;false&quot;, sf -&gt; sf
</code></pre><p>的<code>.subFlowMapping()</code>为了<code>hot</code>饮料。其实和以前的很像<code>iced</code>饮料子流，但具有特定的<code>hot</code>商业逻辑。</p><p>26</p>
<pre><code class="prettyprint java">s.handle(m -&gt; sleepUninterruptibly(5, TimeUnit.SECONDS)))
</code></pre><p>的<code>sleepUninterruptibly</code>对于<code>hot</code>饮料。是的，我们需要更多时间煮水！</p><p>27</p>
<pre><code class="prettyprint java"> .&lt;OrderItem, Drink&gt;transform(orderItem -&gt;
  	    new Drink(orderItem.getOrderNumber(),
  	      orderItem.getDrinkType(),
  	      orderItem.isIced(),
  	      orderItem.getShots()))      
</code></pre><p>主要的<code>OrderItem</code>至<code>Drink</code><code>transformer</code> ，当<code>.route()</code> Cafe厨房订户完成饮料准备后，子流将返回其结果。</p><p>28</p>
<pre><code class="prettyprint java">.aggregate(aggregator -&gt; aggregator
</code></pre><p>的<code>.aggregate()</code> EIP方法提供了类似的选项来配置<code>AggregatingMessageHandler</code>和它的端点，就像我们可以使用<code><aggregator></code>使用Spring Integration XML配置时的组件。当然，使用Java DSL<br>我们拥有更多功能来配置聚合器，而无需任何其他多余的bean。Lambdas又来救援了！从Cafe业务逻辑的角度来看，我们构成了<code>Delivery</code>对于最初<code>Order</code> ， 因为我们<code>.split()</code>原始订单<code>OrderItem</code>即将开始。</p><p>29</p>
<pre><code class="prettyprint java">.outputProcessor(group -&gt; 
</code></pre><p>的<code>.outputProcessor()</code>的<code>AggregatorSpec</code>允许我们在聚合器完成组后发出自定义结果。这是类似的<code>ref</code> / <code>method</code>来自<code><aggregator></code>组件或<code>@Aggregator</code> POJO方法上的注释。我们在这里的目标是<code>Delivery</code>对所有人<code>Drink</code> s。</p><p>30</p>
<pre><code class="prettyprint java">new Delivery(group.getMessages()
  	        .stream()
  	        .map(message -&gt; (Drink) message.getPayload())
  	        .collect(Collectors.toList())))    
</code></pre><p>如您所见，我们在这里使用Java 8 <code>Stream</code>的功能<code>Collection</code> 。我们遍历发布的消息<code>MessageGroup</code>并转换（ <code>map</code> ）他们每个人<code>Drink</code><code>payload</code> 。结果<code>Stream</code> （ <code>.collect()</code> ） （的列表<code>Drink</code> s）传递给<br><code>Delivery</code>构造函数。的<code>Message</code>有了这个新<code>Delivery</code>有效负载将发送到我们的Cafe场景中的下一个端点。</p><p>31</p>
<pre><code class="prettyprint java">.correlationStrategy(m -&gt;
  	      ((Drink) m.getPayload()).getOrderNumber()), null)
</code></pre><p>的<code>.correlationStrategy()</code> Lambda演示了如何自定义聚合器行为。当然，我们在这里只能依靠内置的<code>SequenceDetails</code>来自Spring Integration，默认情况下从<code>.split()</code>在每个拆分邮件的流程开始时，但Lambda示例<code>CorrelationStrategy</code>包括用于说明。（对于XML，我们本可以使用<code>correlation-expression</code>或风俗<br><code>CorrelationStrategy</code> ）。该行中的第二个参数<code>.aggregate()</code> EIP方法适用于<code>endpointConfigurer</code>自定义诸如<code>autoStartup</code> ， <code>requiresReply</code> ， <code>adviceChain</code>等我们在这里用<code>null</code>表明我们依赖于端点的默认选项。许多EIP方法都提供带或不带的重载版本<code>endpointConfigurer</code> ，但是<code>.aggregate()</code>需要端点参数，以避免为<code>AggregatorSpec</code> Lambda参数。</p><p>32</p>
<pre><code class="prettyprint java">.handle(CharacterStreamWritingMessageHandler.stdout());
</code></pre><p>这是我们流程的终点- <code>Delivery</code>交付给客户！我们只是在这里打印消息<code>payload</code>开箱即用到STDOUT <code>CharacterStreamWritingMessageHandler</code>来自Spring Integration Core。这是一个<br>案例展示了如何从Java DSL使用Spring Integration Core（及其模块）中的现有组件。</p><p>好了，我们已经完成了对基于Spring Integration Java DSL的Cafe Demo示例的描述。将其与<a href="https://github.com/spring-projects/spring-integration-samples/tree/master/applications/cafe/cafe-si">XML示例</a>进行比较，以获得有关Spring Integration的更多信息。</p><p>这不是DSL内容的整体教程。我们不在这里审查<code>endpointConfigurer</code>选项， <code>Transformers</code>工厂<code>IntegrationComponentSpec</code>等级制度<code>NamespaceFactories</code> ，我们如何指定几个<code>IntegrationFlow</code> Bean并将它们连接到单个应用程序等，有关更多信息，请参见<a href="https://github.com/spring-projects/spring-integration-java-dsl/wiki/Spring-Integration-Java-DSL-Reference">参考手册</a> 。</p><p>至少此逐行教程应向您展示Spring Integration Java DSL基础知识，以及它在Spring Framework Java和注释配置，Spring Integration基础和Java 8 Lambda支持之间的无缝融合！</p><p>另请参见<a href="https://github.com/spring-projects/spring-integration-samples/tree/master/dsl/si4demo">si4demo，</a>以查看包括Java DSL在内的Spring Integration的演变，如2014 SpringOne / 2GX Conference所示。（视频应会很快出现）。</p><p>一如既往，我们期待您的评论和反馈（ <a href="https://stackoverflow.com">StackOverflow</a> （ <code>spring-integration</code>标签）， <a href="https://jira.spring.io/browse/INTEXT">Spring JIRA</a>和<a href="https://github.com/spring-projects/spring-integration-java-dsl/issues">GitHub</a> ），我们非常欢迎您的<a href="https://github.com/spring-projects/spring-integration/blob/master/CONTRIBUTING.md">贡献</a> ！</p><p>PS即使本教程完全基于Java 8 Lambda支持，我们也不想错过Java 8之前的用户，我们将提供类似的非Lambda博客文章。敬请关注！</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 1862;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>