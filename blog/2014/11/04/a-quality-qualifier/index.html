<html dir="ltr" data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>优质@Qualifier</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>System.config({baseURL: "/b92013b"});</script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>System.import('app/main.js')</script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="A quality @Qualifier">
<meta name="twitter:description" content="<p>Sometimes, <em>teh Twitterz</em> is an amazing place. Just last week I spent some time helping clarify the behavior of Spring’s <code>@Qualifier</code> annotation, which is both older than JSR 330 <em>and</em> offers a richer superset of JSR 330’s <code>@Qualifier</code> annotation. These misguided few seemed to be under the impression that Spring’s annotation didn’t offer the same degree of type-safety as the JSR 330 annotation. I don’t know if it’s because they simply hadn’t read up on the support (which is fairly new, since it’s only been around since 2007), or if it’s because they work for companies that make their money if you stop using Spring, but either way it was an excellent opportunity for a refresher! </p>
">
<meta name="twitter:creator" content="@starbuxman">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=200">

<meta property="og:title" content="A quality @Qualifier">
<meta property="og:image" content="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=200">
<meta property="og:description" content="<p>Sometimes, <em>teh Twitterz</em> is an amazing place. Just last week I spent some time helping clarify the behavior of Spring’s <code>@Qualifier</code> annotation, which is both older than JSR 330 <em>and</em> offers a richer superset of JSR 330’s <code>@Qualifier</code> annotation. These misguided few seemed to be under the impression that Spring’s annotation didn’t offer the same degree of type-safety as the JSR 330 annotation. I don’t know if it’s because they simply hadn’t read up on the support (which is fairly new, since it’s only been around since 2007), or if it’s because they work for companies that make their money if you stop using Spring, but either way it was an excellent opportunity for a refresher! </p>
">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2014-11-04 11:52:00.0">
</head>
<body dir="ltr">

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">// Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }</script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">优质@Qualifier</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=20&d=mm"> <a class="author" rel="author" href="/team/jlong">乔什·朗（Josh Long）</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2014-11-04 11:52:00.0">2014年11月4日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2014/11/04/a-quality-qualifier#disqus_thread" data-disqus-identifier="1808">
</a></div>
</div>
</header>
<div class="blog--post"><p>有时， <em>Twitterz</em>是一个了不起的地方。就在上周，我花了一些时间来帮助弄清Spring的<code>@Qualifier</code>annotation的行为，该注释早于JSR 330， <em>并且</em>提供了JSR 330的<code>@Qualifier</code>annotation的更丰富的超集。这些被误导的少数似乎给人的印象是，Spring的注释没有提供与JSR 330注释相同的类型安全性。我不知道这是因为他们只是没有读过支持文档（这是很新的，因为它自2007年才问世），或者是因为它们为那些在您停止使用Spring就能赚钱的公司工作，但是无论哪种方式，这都是一个极好的机会来复习！</p><p>如果Spring否则无法使用qualifier注释消除Bean引用的歧义。Spring的XML配置支持该版本，但是当然没有类型安全。在本示例中，我们将集中于使用Java配置和组件扫描来注册Bean。随着越来越多的人转向使用Spring已有8年历史的Java配置风格，这个问题似乎越来越频繁地出现。Spring Boot是一种Java配置优先的构建应用程序的方法，该技术在基于Spring Boot的较大应用程序中可能会派上用场。</p><p>它的使用很简单。假设您有两个实现<code>MarketPlace</code>接口的bean。如果声明一个<code>MarketPlace</code>数组，那么Spring将提供实现该接口的所有bean：</p>
<pre><code class="prettyprint java">@Autowired
private MarketPlace[] marketPlaces; 
</code></pre><p>如果只想注入一个，则需要消除引用的歧义。在简单的情况下，您可以按bean ID进行操作：</p>
<pre><code class="prettyprint java">@Autowired 
@Qualifier( "ios") // the use is unique to Spring. It's darned convenient, too!
private MarketPlace marketPlace ;

</code></pre><p>假设您在其他地方定义了ID为<code>ios</code>的bean。这种用法是Spring特有的。您还可以使用<code>@Qualifier</code>创建类型安全的绑定，该绑定通过qualifierannotation的质量将bean定义链接到注入站点。这是一个基于pureplay Spring注释的示例：</p>
<pre><code class="prettyprint java"><br>package spring;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import static spring.Spring.Platform;

@Configuration
@ComponentScan
public class Spring {

    public static void main(String[] args) {
        new AnnotationConfigApplicationContext(Spring.class);
    }

    @Autowired
    @Platform(Platform.OperatingSystems.ANDROID)
    private MarketPlace android;

    @Autowired
    @Platform(Platform.OperatingSystems.IOS)
    private MarketPlace ios;

    @PostConstruct
    public void qualifyTheTweets() {
        System.out.println("ios:" + this.ios);
        System.out.println("android:" + this.android);
    }

    // the type has to be public!
    @Target({ElementType.FIELD,
            ElementType.METHOD,
            ElementType.TYPE,
            ElementType.PARAMETER})
    @Retention(RetentionPolicy.RUNTIME)
    @Qualifier
    public static @interface Platform {

        OperatingSystems value();

        public static enum OperatingSystems {
            IOS,
            ANDROID
        }
    }
}

interface MarketPlace {
}

@Component
@Platform(Platform.OperatingSystems.IOS)
class AppleMarketPlace implements MarketPlace {

    @Override
    public String toString() {
        return "apple";
    }
}

@Component
@Platform(Platform.OperatingSystems.ANDROID)
class GoogleMarketPlace implements MarketPlace {

    @Override
    public String toString() {
        return "android";
    }
}

</code></pre><p>要编译并运行此示例，请确保您具有<code>org.springframework.boot:spring-boot-starter:1.1.8.RELEASE</code> 。</p><p>此示例显示了两个<code>MarketPlace</code>实现的定义，一个用于<code>GoogleMarketPlace</code> ，一个用于<code>AppleMarketPlace</code> 。我们定义一个注释<code>@Platform</code> ，它带有一个<code>Platform.OperatingSystems</code></p><p><code>Platform.OperatingSystems</code></p><code>Platform.OperatingSystems</code></div><code>Platform.OperatingSystems</code></div><code>Platform.OperatingSystems</code></article><code>Platform.OperatingSystems</code></div><code>Platform.OperatingSystems</code></div><code>Platform.OperatingSystems</code></div><code>Platform.OperatingSystems</code></div><code>Platform.OperatingSystems</code></body></html>