<html  data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>Reactor 2.0.0。M1发布，集成了Reactive Streams！</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Reactor 2.0.0.M1 released with Reactive Streams integration!">
<meta name="twitter:description" content="<p>The <a href=" https:="" ="" github.com="" reactor="" reacto="="></head><body >Reactor team is frankly a little giddy at finally being able to announce an initial milestone release of Reactor 2.0! This update includes a fully-compliant <a href="http://www.reactive-streams.org/">Reactive Streams</a> implementation in the completely re-written <code>Stream</code> and <code>Promise</code> APIs! This is a huge step for Reactor users. It opens up integration with other Reactive Streams implementations like <a href="http://www.typesafe.com/activator/template/akka-stream-scala">Akka Streams</a>, <a href="http://ratpack.io/">Ratpack</a>, <a href="https://github.com/ReactiveX/RxJava">RxJava</a> and others. Reactor provides a solid foundation upon which to build modern <code>#uberfastdata</code> applications with demanding high-throughput and low-latency requirements.
">
<meta name="twitter:creator" content="@j_brisbin">
<meta name="twitter:image:src" content="http://gravatar.com/avatar/5500b5cf634f9a3921e4619778a1425f?s=200">

<meta property="og:title" content="Reactor 2.0.0.M1 released with Reactive Streams integration!">
<meta property="og:image" content="http://gravatar.com/avatar/5500b5cf634f9a3921e4619778a1425f?s=200">
<meta property="og:description" content="<p>The <a href=" https:="" ="" github.com="" reactor="" reacto="=">Reactor team is frankly a little giddy at finally being able to announce an initial milestone release of Reactor 2.0! This update includes a fully-compliant <a href="http://www.reactive-streams.org/">Reactive Streams</a> implementation in the completely re-written <code>Stream</code> and <code>Promise</code> APIs! This is a huge step for Reactor users. It opens up integration with other Reactive Streams implementations like <a href="http://www.typesafe.com/activator/template/akka-stream-scala">Akka Streams</a>, <a href="http://ratpack.io/">Ratpack</a>, <a href="https://github.com/ReactiveX/RxJava">RxJava</a> and others. Reactor provides a solid foundation upon which to build modern <code>#uberfastdata</code> applications with demanding high-throughput and low-latency requirements.
">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2014-10-21 15:29:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Reactor 2.0.0。M1发布，集成了Reactive Streams！</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/5500b5cf634f9a3921e4619778a1425f?s=20&d=mm"> <span class="author">乔恩·布里斯宾</span>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2014-10-21 15:29:00.0">2014年10月21日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2014/10/21/reactor-2-0-0-m1-released-with-reactive-streams-integration#disqus_thread" data-disqus-identifier="1790">
</a></div>
</div>
</header>
<div class="blog--post"><p>坦率地说， <a href="https://github.com/reactor/reactor">Reactor</a>团队有点头晕，终于能够宣布Reactor 2.0的最初里程碑发布！此更新包括完全重写的完全兼容的<a href="http://www.reactive-streams.org/">Reactive Streams</a>实现<code>Stream</code>和<code>Promise</code>蜜蜂！对于Reactor用户而言，这是巨大的一步。它开辟了整合与其他反应流实现比如<a href="https://www.typesafe.com/activator/template/akka-stream-scala">阿卡流</a> ， <a href="http://ratpack.io/">Ratpack</a> ， <a href="https://github.com/ReactiveX/RxJava">RxJava</a>等。反应堆为建立现代化的基础奠定了坚实的基础<code>#uberfastdata</code>要求高吞吐量和低延迟要求的应用程序。</p><h3><a href="#stream-and-promise" class="anchor" name="stream-and-promise"></a>流与承诺</h3><p>Reactor 2.0中的标题更改是Stream API。实际上，代码库的大多数其他部分只是经过了微调或在1.1和2.0之间保持不变。事实并非如此<code>Stream</code>和<code>Promise</code> 。这些组件已经完全从头进行了完全重写，以利用反应流规范在功能性反应流管道中提供完全无阻塞的背压。</p><h3><a href="#what-is-backpressure-in-a-reactive-system" class="anchor" name="what-is-backpressure-in-a-reactive-system"></a>反应系统中的背压是多少？</h3><p>Akka名望的Roland Kuhn博士雄辩地讲了这个话题，如果您有兴趣探索无阻塞背压背后的原因，我们鼓励您观看他在该主题上的会议介绍， <a href="https://www.google.com/search?q=site%3Ayoutube.com "reactive streams" "roland kuhn"&rct=j">其中大部分内容都可以在YouTube</a> 。</p><p>TL; DR</p><p>背压是发布者和订阅者关系的倒置，其中<code>Subscriber</code>对<code>Publisher</code> “给我下N个可用商品”，而不是<code>Publisher</code>对一个说<code>Subscriber</code> “拿走我拥有的所有这些物品，无论您是否可以处理它们”。自从<code>Publisher</code>正在被动地向<code>Subscriber</code>而不是相反，没有必要（在完整的Reactive Streams管道中）缓冲数据，因为您永远都不会遇到超出处理能力的数据。实际上，需要一些缓冲或排队，但是像Reactor这样的库使您不必担心如何完成此工作，因此您可以编写完全可响应的代码来对可用数据进行响应，而不是试图弄清楚它们的神奇组合。 <code>BlockingQueue</code>否则必须采用其他低效率的方案来确保异步组件彼此正确隔离。</p><h3><a href="#reactor-implements-reactive-streams" class="anchor" name="reactor-implements-reactive-streams"></a> Reactor实现反应流</h3><p>反应堆团队投入了令人沮丧的大量时间来全面实施反应性流规范。反应堆<code>Stream</code>组件为您提供了有用且易于理解的挂钩，可在这些挂钩上挂起业务逻辑，因此您只需要担心编写适当作用域的功能组件即可响应单个数据元素，而不必花很多时间在代码上样板物流的功能，以处理从一个线程到另一个线程的数据传递，执行有限的排队和缓冲，以及在使用反应性，异步组件时通常需要执行的其他任务。</p><p>在Reactor团队在今年得克萨斯州达拉斯的SpringOne上讨论的<a href="https://github.com/SpringOne2GX-2014/reactive-geocoder">Reactive Geocoder演示中</a> ，可以找到有关代码外观的一个示例（ <a href="http://www.infoq.com/presentations/reactive-streams-reactor">重</a>放在InfoQ上可供SpringOne2GX 2014与会者使用，并将在一段时间后公开）。</p><p>以下是一个小片段，展示了如何创建一个新的<code>Stream</code> ，为其添加业务逻辑，然后将数据发布到其中。</p>
<pre><code class="prettyprint java">// by default Streams use the Disruptor RingBufferDispatcher
HotStream&lt;String&gt; helloStream = Streams.defer(env);

helloStream.map(s -&gt; &quot;Hello &quot; + s + &quot;!&quot;)
           .consume(log::info);

helloStream.broadcastNext(&quot;World&quot;);
</code></pre><p>运行此命令时，您将看到文本“ Hello World！”。已记录。您还应该注意，日志记录是从RingBuffer线程而不是主线程进行的。换句话说，您刚刚将任务提交到另一个线程以异步执行，将结果转换为其他内容，然后使用无响应，基于需求的Reactive Streams无阻塞，无任何嘈杂的Future响应结果。基于，阻止代码！</p><p>您也可以创建“冷”流，这与使用RxJava的流非常相似。 <code>Observable</code> 。</p>
<pre><code class="prettyprint java">// stream contains the single value &quot;Hello World!&quot;
Stream&lt;String&gt; helloStream = Streams.just(&quot;World&quot;);

helloStream.map(s -&gt; &quot;Hello &quot; + s + &quot;!&quot;)
           .consume(log::info);
</code></pre><p>运行此命令时，您将看到文本“ Hello World！”。记录，类似于前面的示例。此处的区别在于，我们无需调用<code>broadcastNext(String)</code>方法，因为这是我们在附加附件时为我们处理的<code>Consumer<String></code> 。您可以从任何值或值集合中创建流，就像创建RxJava一样<code>Observable</code> 。这使您可以将标准Java Collection API与反应式流API混合使用。</p><h3><a href="#stream-is-the-new-black" class="anchor" name="stream-is-the-new-black"></a>流是新的黑色</h3><p>像Spark，Storm和其他大数据库这样的流API证明，在没有无限资源（基本上就是我们在云中运行的任何东西）的系统上运行时，以更具功能性和反应性的方式处理数据更有效。由于用于构建处理流水线的DSL具有声明性，自记录性，因此更易于理解（在许多情况下）。当您将业务逻辑精简到本质时，您确实会注意到，没有很多事物无法表示为转换或消费者功能。您要么接受输入并产生输出，要么简单地接受输入。Reactor的Stream API包含在此范例中，因此为您提供了很多（谁能告诉我这部电影参考资料：“您会说我有很多皮纳塔吗？”）在数据通过管道时处理数据的选项。除了简单的功能，例如<code>map(Function<T,V>)</code>和<code>filter(Predicate<T>)</code>是更复杂的选择，例如<code>buffer(int)</code>要么<code>buffer(int, long, TimeUnit)</code> 。后者提供了非常有用的长度和基于时间的“微批处理”。例如，要对一批通过WAN连接发送的昂贵的数据库更新进行微批量处理，则可能需要对它们进行缓冲，直到达到既定数量或特定的超时时间为止。</p>
<pre><code class="prettyprint java">// create a stream backed by a load-balanced, round-robin assigned Dispatcher
Stream&lt;Update&gt; updateStream = Streams.defer(env, env.getDefaultDispatcherFactory().get());

updateStream.buffer(1024, 350, TimeUnit.MILLISECONDS)
            .consume(driver::batchUpdate);
</code></pre><p>这将收集流更新，直到收集了其中的1024个更新或350毫秒到期为止，以先到者为准。然后，它将通过传递一个<code>List<Update></code>在350毫秒内收集了1024个元素，或者收集了很多元素。这使您可以编写非常高效的系统，以批处理方式处理大量数据，以最大程度地减少网络带宽使用并最大化吞吐量（同时仍保持可预测的延迟）。</p><p>随着微分批处理<code>Stream</code>提供类似的设施<code>filter</code> ， <code>flatMap</code> ， <code>movingBuffer</code> ， <code>join</code> ， <code>merge</code> ， <code>sample</code> ， <code>sort</code> ，以及许多其他不言而喻的操作。很像Scala的collection API或RxJava的Observable，Reactor的<code>Stream</code>提供功能性和反应性方式，以快速，高效和极高的容量处理数据，同时保持可预测的低延迟。毫不夸张地说，您可以使用<code>Stream</code>作为基础组件，用于提交异步任务以执行任务，并以反应方式处理传统的数据收集，然后通过将实时数据与历史数据相结合来混合两种方法。</p><h3><a href="#parallel-processing" class="anchor" name="parallel-processing"></a>并行处理</h3><p>有时有必要将数据流分成并行管道以进行并发处理。反应堆<code>Stream</code>提供了一种极其方便的方法<code>parallel(int)</code>操作。您只需将业务逻辑附加到<code>Stream</code>在之后提供<code>parallel</code>呼叫和数据将在下游管道之间轮流进行并发处理。</p>
<pre><code class="prettyprint java">HotStream&lt;String&gt; stream = Streams.defer(env);

// by default uses number of CPUs as thread count
stream.parallel(substream -&gt; substream.map(greeting -&gt; &quot;Hello &quot; + greeting + &quot;!&quot;)
                                      .consume(log::info));
</code></pre><p>这是一个Reactive Streams实现的有趣示例，它在代码中显示了自己：运行此代码时，您将不会获得任何输出。的<code>.parallel()</code>操作不会在管道上产生“需求”。在Reactive Streams系统中，将数据拉入操作的是管道的末端，而不是将数据推入操作的生产者。由于在此管道的末尾没有终端操作，因此无法获取数据。实际上，这通常不是问题，因为您实际上想在真实应用程序中处理数据。在此示例中，我们可以添加一个<code>.drain()</code>打电话后<code>.parallel()</code>产生需求并通过数据。我们可能不会在生产系统中执行此操作，但是对于测试和演示，我们可以轻松解决。</p>
<pre><code class="prettyprint java">stream.parallel(substream -&gt; substream.map(greeting -&gt; &quot;Hello &quot; + greeting + &quot;!&quot;)
                                      .consume(log::info))
      .drain();
</code></pre><h3><a href="#what-rsquo-s-going-on-and-why-don-rsquo-t-i-see-what-i-expect" class="anchor" name="what-rsquo-s-going-on-and-why-don-rsquo-t-i-see-what-i-expect"></a>发生了什么事，为什么我看不到我的期望？</h3><p>对于反应性系统，有时很难理解为什么事情没有按您期望的那样工作。尽管没有什么库可以使在IDE内对异步流进行实时调试的过程变得更好，但是总有许多可靠的方法记录在案。Reactor添加了一些隐藏的方法，称为<code>.debug()</code>和<code>.log()</code>应该可以帮助您了解流的构造方式以及它们的功能。的<code>.debug()</code>方法将为您提供流连接方式的输出。它将显示哪些动作与每个动作中当前可用的容量有关。的<code>.log()</code>方法将日志记录操作附加到您的流，并输出订阅和发布事件。</p><p>如果我们添加一个<code>.log()</code>在我们之前打电话<code>.parallel()</code>从上面的示例中，我们将获得更多日志记录以告诉我们发生了什么：</p>
<pre><code class="prettyprint java">stream.log()
      .parallel(substream -&gt; substream.map(greeting -&gt; &quot;Hello &quot; + greeting + &quot;!&quot;)
                                      .consume(log::info))
      .drain();
</code></pre><p>将产生：</p>
<pre>[ringBuffer-1] INFO  r.r.a.LoggerAction - onSubscribe: {capacity=0/8188 [0%], current=0, pending=0, waiting=0}
[main] INFO  r.r.a.LoggerAction - subscribe: ConcurrentAction-{dispatcher=RingBuffer:8192, max-capacity=8188}
[ringBuffer-1] INFO  r.r.a.LoggerAction - request: 9223372036854775807
[ringBuffer-1] INFO  r.r.a.LoggerAction - onNext: World
[ringBufferGroup-2] INFO  r.r.StreamTests - Hello World!
</pre><h3><a href="#artifacts" class="anchor" name="artifacts"></a>伪像</h3><p>要将现有应用程序升级到Reactor 2.0，您可能只需要进行一些调整。如果您在Reactor 1.1中使用流，则会发现Reactor 2.0流的值发布有所不同。的<code>.broadcastNext()</code>方法定义于<code>Action</code>子类和<code>HotStream</code>但没有其他操作。Reactor 1.1使用了<code>Deferred</code>发布值，因此需要对您的代码进行调整，以将发布者类型更改为可以访问<code>.broadcastNext()</code>方法。如果您使用的是平原<code>Reactor</code>或基于Spring和基于注释的事件处理，您几乎无需进行任何更改。</p><p>要访问里程碑工件，请使用<code>http://repo.spring.io/libs-milestone</code>您选择的构建系统中的存储库。例如，如果使用Gradle（当然，您使用的是Gradle，对吗？）只需配置您的<code>repositories</code>像这样阻止：</p>
<pre><code class="prettyprint groovy">repositories {
  maven { url &#39;http://repo.spring.io/libs-milestone&#39; }
  mavenCentral()
}
</code></pre><p>要报告错误，请跟随Reactor 2.0的开发，阅读Wiki或以其他方式参与Reactor社区，请访问<a href="https://github.com/reactor/reactor">https://github.com/reactor/reactor</a>的Reactor的GitHub主页。您也可以在此处在线阅读JavaDoc： <a href="https://reactor.github.io/docs/api/2.0.0.M1/index.html">http</a> : <a href="https://reactor.github.io/docs/api/2.0.0.M1/index.html">//reactor.github.io/docs/api/2.0.0.M1/index.html</a></p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 1790;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>