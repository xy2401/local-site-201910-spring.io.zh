<!doctype html><html data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>Reactor 2.0.0.M1 released with Reactive Streams integration!</title>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no" id="Viewport" name="viewport">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="https://fonts.googleapis.com/css?family=Varela+Round|Montserrat:400,700" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>System.config({baseURL: "/b92013b"});</script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>System.import('app/main.js')</script>
<meta content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M" name="google-site-verification">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta content="summary" name="twitter:card">
<meta content="@springcentral" name="twitter:site">
<meta name="twitter:title" content="Reactor 2.0.0.M1 released with Reactive Streams integration!">
<meta name="twitter:description" content="<p>The <a href=" https: github.com reactor reactor"></head><body>Reactor team is frankly a little giddy at finally being able to announce an initial milestone release of Reactor 2.0! This update includes a fully-compliant <a href="http://www.reactive-streams.org/">Reactive Streams</a> implementation in the completely re-written <code>Stream</code> and <code>Promise</code> APIs! This is a huge step for Reactor users. It opens up integration with other Reactive Streams implementations like <a href="http://www.typesafe.com/activator/template/akka-stream-scala">Akka Streams</a>, <a href="http://ratpack.io/">Ratpack</a>, <a href="https://github.com/ReactiveX/RxJava">RxJava</a> and others. Reactor provides a solid foundation upon which to build modern <code>#uberfastdata</code> applications with demanding high-throughput and low-latency requirements.<p></p>
">
<meta name="twitter:creator" content="@j_brisbin">
<meta name="twitter:image:src" content="http://gravatar.com/avatar/5500b5cf634f9a3921e4619778a1425f?s=200">

<meta property="og:title" content="Reactor 2.0.0.M1 released with Reactive Streams integration!">
<meta property="og:image" content="http://gravatar.com/avatar/5500b5cf634f9a3921e4619778a1425f?s=200">
<meta property="og:description" content="<p>The <a href=" https: github.com reactor reactor">Reactor team is frankly a little giddy at finally being able to announce an initial milestone release of Reactor 2.0! This update includes a fully-compliant <a href="http://www.reactive-streams.org/">Reactive Streams</a> implementation in the completely re-written <code>Stream</code> and <code>Promise</code> APIs! This is a huge step for Reactor users. It opens up integration with other Reactive Streams implementations like <a href="http://www.typesafe.com/activator/template/akka-stream-scala">Akka Streams</a>, <a href="http://ratpack.io/">Ratpack</a>, <a href="https://github.com/ReactiveX/RxJava">RxJava</a> and others. Reactor provides a solid foundation upon which to build modern <code>#uberfastdata</code> applications with demanding high-throughput and low-latency requirements.<p></p>
">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2014-10-21 15:29:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" style="display:none;visibility:hidden" width="0"></iframe></noscript>

<script type="text/javascript">// Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }</script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">Projects</a>
</li>
<li class="navbar-link">
<a href="/guides">Guides</a>
</li>
<li class="navbar-link active">
<a href="/blog">Blog</a>
</li>
<li class="navbar-link">
<a href="/services">Training & Certification</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form action="/search" class="form-inline form-search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search for documentation, guides, and posts..." type="text" value="">
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form action="/search" class="form-inline form-search" method="get">
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">
Home
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">
Projects
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">
Guides
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">
Blog
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">
Training & Certification
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>Engineering</div>
</div>
<div class="blog-category content--title">
<div>Releases</div>
</div>
<div class="blog-category content--title">
<div>News and Events</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Reactor 2.0.0.M1 released with Reactive Streams integration!</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">Engineering</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/5500b5cf634f9a3921e4619778a1425f?s=20&d=mm">
<span class="author">Jon Brisbin</span>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2014-10-21 15:29:00.0">October 21, 2014</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" data-disqus-identifier="1790" href="/blog/2014/10/21/reactor-2-0-0-m1-released-with-reactive-streams-integration#disqus_thread">
</a></div>
</div>
</header>
<div class="blog--post"><p>The <a href="https://github.com/reactor/reactor">Reactor</a> team is frankly a little giddy at finally being able to announce an initial milestone release of Reactor 2.0! This update includes a fully-compliant <a href="http://www.reactive-streams.org/">Reactive Streams</a> implementation in the completely re-written <code>Stream</code> and <code>Promise</code> APIs! This is a huge step for Reactor users. It opens up integration with other Reactive Streams implementations like <a href="https://www.typesafe.com/activator/template/akka-stream-scala">Akka Streams</a>, <a href="http://ratpack.io/">Ratpack</a>, <a href="https://github.com/ReactiveX/RxJava">RxJava</a> and others. Reactor provides a solid foundation upon which to build modern <code>#uberfastdata</code> applications with demanding high-throughput and low-latency requirements.</p><h3><a href="#stream-and-promise" class="anchor" name="stream-and-promise"></a>Stream and Promise</h3><p>The headline change in Reactor 2.0 is the Stream API. In fact, most other parts of the codebase were either just lightly refined or remain untouched between 1.1 and 2.0. Not so with <code>Stream</code> and <code>Promise</code>. These components have been completely rewritten from the ground up to take advantage of the Reactive Streams specification to provide fully-non-blocking backpressure in functional reactive streaming pipelines. </p><h3><a href="#what-is-backpressure-in-a-reactive-system" class="anchor" name="what-is-backpressure-in-a-reactive-system"></a>What is backpressure in a reactive system?</h3><p>Dr. Roland Kuhn, of Akka fame, has spoken on the topic quite eloquently and if you’re interested in exploring the reasoning behind non-blocking backpressure, we encourage you to watch his conference presentations on the topic, <a href="https://www.google.com/search?q=site%3Ayoutube.com%20%22reactive%20streams%22%20%22roland%20kuhn%22&rct=j">most of which are available on YouTube</a>.</p><p>TL;DR</p><p>Backpressure is an inversion of the publisher and subscriber relationship where the <code>Subscriber</code> says to the <code>Publisher</code> “give me the next N available items” rather than a <code>Publisher</code> saying to a <code>Subscriber</code> “take all these items I have whether you can handle them or not”. Since the <code>Publisher</code> is passively providing elements of data to the <code>Subscriber</code> rather than the other way around, it’s not necessary (in a fully Reactive Streams pipeline) to buffer data since you’ll never have more data inflight than what you can handle. In reality, some buffering or queueing is necessary but libraries like Reactor take away your need to worry about how this is accomplished so you can write fully reactive code that responds to data as it becomes available rather than trying to figure out what magic combination of <code>BlockingQueue</code> or other kinds of inefficient schemes must be employed to ensure asynchronous components are properly segregated from one another.</p><h3><a href="#reactor-implements-reactive-streams" class="anchor" name="reactor-implements-reactive-streams"></a>Reactor implements Reactive Streams</h3><p>The Reactor team has put in the depressingly large number of hours necessary to implement a comprehensive implementation of the Reactive Streams specification. Reactor’s <code>Stream</code> component provides you with useful and understandable hooks on which to hang your business logic so that you only have to concern yourself with writing the appropriately-scoped functional component that will respond to a single element of data rather than having to dirty your code with a lot of boilerplate logistics to handle passing data from one Thread to another, performing bounded queueing and buffering, and the sundry other tasks usually necessary in working with reactive, asynchronous components.</p><p>An example of how this looks in your code can be found in the <a href="https://github.com/SpringOne2GX-2014/reactive-geocoder">Reactive Geocoder Demo</a> which the Reactor team discussed at this year’s SpringOne in Dallas, Texas (<a href="http://www.infoq.com/presentations/reactive-streams-reactor">replays</a> are available on InfoQ for SpringOne2GX 2014 attendees and will become public some time later). </p><p>Following is a little snippet that shows how to create a new <code>Stream</code>, attach business logic to it, then publish data into it. </p>
<pre><code class="prettyprint java">// by default Streams use the Disruptor RingBufferDispatcher
HotStream<String> helloStream = Streams.defer(env);

helloStream.map(s -> "Hello " + s + "!")
           .consume(log::info);

helloStream.broadcastNext("World");
</code></pre><p>When you run this, you will see the text “Hello World!” logged. You should also notice that the logging has taken place from the RingBuffer thread and not from your main thread. In other words, you’ve just submitted a task to another Thread to be executed asynchronously, have the result transformed into something else, and then responded to the result using Reactive Streams non-blocking, demand-based backpressure without any kind of noisy Future-based, blocking code!</p><p>You can create “cold” streams as well, which are very similar to using RxJava’s <code>Observable</code>.</p>
<pre><code class="prettyprint java">// stream contains the single value "Hello World!"
Stream<String> helloStream = Streams.just("World");

helloStream.map(s -> "Hello " + s + "!")
           .consume(log::info);
</code></pre><p>When you run this, you will see the text “Hello World!” logged, similarly to the previous example. The difference here is that we never had to call the <code>broadcastNext(String)</code> method because that was handled for us when we attached our <code>Consumer<String></code>. You can create streams out of any value or collection of values just like creating an RxJava <code>Observable</code>. This lets you mix standard Java Collection APIs with the reactive, streaming API.</p><h3><a href="#stream-is-the-new-black" class="anchor" name="stream-is-the-new-black"></a>Stream is the new Black</h3><p>Streaming APIs like Spark, Storm, and other Big Data libraries prove that working with data in a more functional and reactive way is more efficient when running on systems without unlimited resources (which is basically anything we run on in the cloud) as well as being more understandable (in many cases) owing to the declarative, self-documentating nature of the DSL used to build up the processing pipeline. When you boil your business logic down to its essence, you really do notice that not many things exist that can’t be expressed as a transformation or consumer function. You either take input and produce output or you simply take input. Reactor’s Stream API is steeped in this paradigm so provides you with a plethora (who can tell me this movie reference: “would you say I have a plethora of pinatas?”) of options for processing data as it passes through your pipeline. Beyond simple functions like <code>map(Function<T,V>)</code> and <code>filter(Predicate<T>)</code> are the more sophisticated options like <code>buffer(int)</code> or <code>buffer(int, long, TimeUnit)</code>. The latter provides extrememly useful length and time-based “microbatching”. For example, to microbatch a set of database updates that are expensive to send across a WAN connection, you might want to buffer them until you either have a set amount or a certain timeout has elapsed.</p>
<pre><code class="prettyprint java">// create a stream backed by a load-balanced, round-robin assigned Dispatcher
Stream<Update> updateStream = Streams.defer(env, env.getDefaultDispatcherFactory().get());

updateStream.buffer(1024, 350, TimeUnit.MILLISECONDS)
            .consume(driver::batchUpdate);
</code></pre><p>This will collect streaming updates until either 1024 of them have been collected or 350 milliseconds have expired, whichever comes first. It will then trigger the downstream processing by passing a <code>List<Update></code> of either 1024 elements or however many were collected in 350ms. This allows you to write very, very efficient systems that deal with high volumes of data in batches to minimize network bandwidth usage and maximize throughput (while still maintaing a predicatble latency).</p><p>Along with microbatching <code>Stream</code> provides facilities like <code>filter</code>, <code>flatMap</code>, <code>movingBuffer</code>, <code>join</code>, <code>merge</code>, <code>sample</code>, <code>sort</code>, and many other operations which are largely self-explanatory. Much like Scala’s collection API or RxJava’s Observable, Reactor’s <code>Stream</code> provides functional and reactive ways to process data quickly, efficiently, and at extremely high volume while maintaining predictable, low latencies. It’s not an exaggeration to say that you could write your entire application using the <code>Stream</code> as a foundational component that is used to submit asynchronous tasks for execution and also to process traditional collections of data in a reactive way–and then mix the two approaches by combining live data with historical data.</p><h3><a href="#parallel-processing" class="anchor" name="parallel-processing"></a>Parallel processing</h3><p>It’s sometimes necessary to split up a stream of data into parallel pipelines for doing concurrent processing. Reactor’s <code>Stream</code> provides an extremely convenient way to do this with the <code>parallel(int)</code> operation. You simply attach your business logic to the <code>Stream</code> provided after the <code>parallel</code> call and data will be round-robined between the downstream pipelines for concurrent processing.</p>
<pre><code class="prettyprint java">HotStream<String> stream = Streams.defer(env);

// by default uses number of CPUs as thread count
stream.parallel(substream -> substream.map(greeting -> "Hello " + greeting + "!")
                                      .consume(log::info));
</code></pre><p>Here’s an interesting example of the Reactive Streams implementation showing itself in your code: when you run this you won’t get any output. The <code>.parallel()</code> operation doesn’t create “demand” on the pipeline. In a Reactive Streams system, it’s the end of the pipeline that pulls data into the operations rather than the producer that pushes it. Since there’s no terminal operation at the end of this pipeline, there’s no way for the data to get pulled through. In reality that’s not usually a problem because you actually want to handle the data in a real application. In this example, we can just add a <code>.drain()</code> call after <code>.parallel()</code> to produce demand and pull data through. We likely wouldn’t do this in a production system but for tests and demos we can take the easy out with a drain.</p>
<pre><code class="prettyprint java">stream.parallel(substream -> substream.map(greeting -> "Hello " + greeting + "!")
                                      .consume(log::info))
      .drain();
</code></pre><h3><a href="#what-rsquo-s-going-on-and-why-don-rsquo-t-i-see-what-i-expect" class="anchor" name="what-rsquo-s-going-on-and-why-don-rsquo-t-i-see-what-i-expect"></a>What’s going on and why don’t I see what I expect?</h3><p>With reactive systems it’s sometimes frustrating to understand why things aren’t working like you expect. While there’s not a lot that a library can do to make the process of live debugging an asynchronous stream inside an IDE better, there’s always the tried-and-true method of copious logging. Reactor adds a couple of somewhat hidden methods called <code>.debug()</code> and <code>.log()</code> that should help you figure out how your streams are constructed and what they’re doing. The <code>.debug()</code> method will provide you with an output of how a stream is wired. It will show what actions are connected to what and what capacities are currently available in each. The <code>.log()</code> method attaches a logging action to your stream and outputs subscribe and publish events.</p><p>If we add a <code>.log()</code> call before our <code>.parallel()</code> from the above example, we’ll get additional logging to tell us what’s happening:</p>
<pre><code class="prettyprint java">stream.log()
      .parallel(substream -> substream.map(greeting -> "Hello " + greeting + "!")
                                      .consume(log::info))
      .drain();
</code></pre><p>Will produce:</p>
<pre>[ringBuffer-1] INFO  r.r.a.LoggerAction - onSubscribe: {capacity=0/8188 [0%], current=0, pending=0, waiting=0}
[main] INFO  r.r.a.LoggerAction - subscribe: ConcurrentAction-{dispatcher=RingBuffer:8192, max-capacity=8188}
[ringBuffer-1] INFO  r.r.a.LoggerAction - request: 9223372036854775807
[ringBuffer-1] INFO  r.r.a.LoggerAction - onNext: World
[ringBufferGroup-2] INFO  r.r.StreamTests - Hello World!</pre><h3><a href="#artifacts" class="anchor" name="artifacts"></a>Artifacts</h3><p>To upgrade an existing application to Reactor 2.0, you’ll likely only need to tweak a few things. If you are using streams in Reactor 1.1, you’ll find that Reactor 2.0 streams differ in their publication of values. The <code>.broadcastNext()</code> method is defined on <code>Action</code> subclasses and <code>HotStream</code> but not some other operations. Reactor 1.1 used a <code>Deferred</code> to publish values so your code will need to be tweaked to change the publisher type to something that has access to the <code>.broadcastNext()</code> method. If you’re using a plain <code>Reactor</code> or the Spring and annotation-based event handling, you won’t have to change hardly anything.</p><p>To access the milestone artifacts, use the <code>http://repo.spring.io/libs-milestone</code> repository in your build system of choice. For example, if using Gradle (of course you’re using Gradle, right?) just configure your <code>repositories</code> block like so:</p>
<pre><code class="prettyprint groovy">repositories {
  maven { url 'http://repo.spring.io/libs-milestone' }
  mavenCentral()
}
</code></pre><p>To report bugs, follow the development of Reactor 2.0, read the wiki, or otherwise get involved in the Reactor community, visit the GitHub home of Reactor at <a href="https://github.com/reactor/reactor">https://github.com/reactor/reactor</a>. You can also read the JavaDoc online here: <a href="https://reactor.github.io/docs/api/2.0.0.M1/index.html">http://reactor.github.io/docs/api/2.0.0.M1/index.html</a></p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">var disqus_shortname = 'spring-io';
      var disqus_identifier = 1790;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>
Back
</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">All Posts</a>
<a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">Engineering</a>
<a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">Releases</a>
<a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">News and Events</a>
<a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>Get updates from The Spring Team delivered to your inbox</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });</script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">Tools</a></li>
<li><a href="https://store.pivotal.io/">Store</a></li>
<li><a href="/blog">Newsletter</a></li>
</ul>
</div>
</div>
© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a>, Inc. All Rights Reserved.
<a href="https://pivotal.io/terms-of-use">Terms of Use</a> •
<a href="https://pivotal.io/privacy-policy">Privacy</a> •
<a href="/trademarks">Trademark Guidelines</a>
<div id="teconsent" style="display:inline-block;"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>