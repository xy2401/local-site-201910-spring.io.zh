<html dir="ltr" data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>Spring 4.1即将进行的JMS改进</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>System.config({baseURL: "/b92013b"});</script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>System.import('app/main.js')</script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Spring 4.1's Upcoming JMS Improvements">
<meta name="twitter:description" class="anchor" content="<p>Spring Framework 4.0 introduced a new <code>spring-messaging</code> module, adding a selection of Spring Integration types such as the core <code>Message</code> abstraction. Spring 4.1 aligns its JMS support to allow you to benefit from that abstraction. But before diving into that, I’d like to show you in details how we further improved the infrastructure for listener endpoints.</p>
<h1><a href=" #annotation-driven-listener-endpoint="="></head><body dir="ltr">Annotation-driven listener endpoints
<p>You are probably used to the <code><xyz:annotation-driven></code> element or the <code>@Enable*</code> counterpart and perhaps you were looking for something similar for JMS. Look no further: the next major release of the Spring framework will allow you to define JMS listeners with a simple annotation.</p>
">
<meta name="twitter:creator" content="@snicoll">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/33d0963a20138828608f3f61927545b8?s=200">

<meta property="og:title" content="Spring 4.1's Upcoming JMS Improvements">
<meta property="og:image" content="https://gravatar.com/avatar/33d0963a20138828608f3f61927545b8?s=200">
<meta class="anchor" name="annotation-driven-listener-endpoints" property="og:description" content="<p>Spring Framework 4.0 introduced a new <code>spring-messaging</code> module, adding a selection of Spring Integration types such as the core <code>Message</code> abstraction. Spring 4.1 aligns its JMS support to allow you to benefit from that abstraction. But before diving into that, I’d like to show you in details how we further improved the infrastructure for listener endpoints.</p>
<h1><a href=" #annotation-driven-listener-endpoint="=">Annotation-driven listener endpoints
<p>You are probably used to the <code><xyz:annotation-driven></code> element or the <code>@Enable*</code> counterpart and perhaps you were looking for something similar for JMS. Look no further: the next major release of the Spring framework will allow you to define JMS listeners with a simple annotation.</p>
">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2014-04-30 12:52:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">// Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }</script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Spring 4.1即将进行的JMS改进</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/33d0963a20138828608f3f61927545b8?s=20&d=mm"> <a class="author" rel="author" href="/team/snicoll">斯特凡·尼科尔（StéphaneNicoll）</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2014-04-30 12:52:00.0">2014年4月30日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2014/04/30/spring-4-1-s-upcoming-jms-improvements#disqus_thread" data-disqus-identifier="1529">
</a></div>
</div>
</header>
<div class="blog--post"><p>Spring Framework 4.0引入了一个新的<code>spring-messaging</code>模块，添加了一些Spring Integration类型的选择，例如核心<code>Message</code>抽象。Spring 4.1调整了其对JMS的支持，使您可以从该抽象中受益。但在深入探讨之前，我想向您详细介绍我们如何进一步改善侦听器端点的基础结构。</p><h1><a href="#annotation-driven-listener-endpoints" class="anchor" name="annotation-driven-listener-endpoints"></a>注释驱动的侦听器端点</h1>
<p>您可能已经习惯了<code><xyz:annotation-driven></code>元素或<code>@Enable*</code>对应对象，也许您正在为JMS寻找类似的东西。不用再看了：Spring框架的下一个主要版本将使您可以使用简单的注释定义JMS侦听器。</p>
<pre><code class="prettyprint java">@Component
public class MyService {

    @JmsListener(containerFactory = "myContainerFactory", destination = "myQueue")
    public void processOrder(String data) { ... }

}
</code></pre>
<p>以下配置（忽略JMS基础结构设置）在<code>myQueue</code>目标的<code>processOrder</code>创建了一个JMS消息侦听器容器，并在消息可用时调用<code>processOrder</code> ：</p>
<pre><code class="prettyprint java">@Configuration
@EnableJms
public class AppConfig {
	
    @Bean
    public DefaultJmsListenerContainerFactory myContainerFactory() {
        DefaultJmsListenerContainerFactory factory =
                new DefaultJmsListenerContainerFactory();
        factory.setConnectionFactory(connectionFactory());
        factory.setDestinationResolver(destinationResolver());
        factory.setConcurrency("3-10");
        return factory;
    }
}
</code></pre>
<p>这与使用XML名称空间等效：</p>
<pre><code class="prettyprint xml"><jms:annotation-driven/>

<bean id="myContainerFactory"
        class="org.springframework.jms.config.DefaultJmsListenerContainerFactory">
    <property name="connectionFactory" ref="connectionFactory"/>
    <property name="destinationResolver" ref="destinationResolver"/>
    <property name="concurrency" value="3-10"/>
</bean>
</code></pre>
<p>通常， <code>@JmsListener</code>可以直接放在方法上，也可以使用元注释间接放置。注释具有通常的选项，这些选项由<code>jms:listener</code> XML元素提供了相当长的一段时间。然而， <code>containerFactory</code>是新的，它引用了<code>JmsListenerContainerFactory</code>的名称，它等效于您在<code><jms:listener-container></code>元件。</p>
<p>如果您希望从现有配置平稳过渡，我们已向该元素添加了<code>factory-id</code>属性。如果存在该配置，则该配置将自动作为具有该名称的<code>JmsListenerContainerFactory</code> bean公开。此XML配置与上面的<code>myJmsContainerFactory</code> bean等效：</p>
<pre><code class="prettyprint xml"><jms:listener-container factory-id="myContainerFactory" 
               connection-factory="connectionFactory"
               destination-resolver="destinationResolver"
               concurrency="3-10"/>
</code></pre>
<p>由于单个容器的工厂设置很普遍，因此如果已设置或发现默认<code>containerFactory</code>则可以省略<code>containerFactory</code>属性。默认情况下，我们查找名为<code>jmsListenerContainerFactory</code>的bean。</p>
<p>可以通过实现<code>JmsListenerConfigurer</code>接口以多种方式自定义此基础结构的配置。就像我们刚刚提到的，可以显式指定要使用的默认容器工厂，但是此回调接口还允许您以编程方式注册JMS端点！</p>
<pre><code class="prettyprint java">@Configuration
@EnableJms
public class AppConfig implements JmsListenerConfigurer {

    @Override
    public void configureJmsListeners(JmsListenerEndpointRegistrar registrar) {
        registrar.setDefaultContainerFactory(defaultContainerFactory());

        SimpleJmsListenerEndpoint endpoint = new SimpleJmsListenerEndpoint();
        endpoint.setDestination("anotherQueue");
        endpoint.setMessageListener(message -> {
            // processing
        });
        registrar.registerEndpoint(endpoint);
    }

    @Bean
    public DefaultJmsListenerContainerFactory defaultContainerFactory() {
        ...
    }

</code></pre>
<p>上面的示例设置默认的<code>JmsListenerContainerFactory</code>并在<code>anotherQueue</code>上配置其他端点。<code>JmsListenerEndpoint</code>您的端点建模，并负责为该模型配置容器。在上面的示例中，我们使用了<code>SimpleJmsListenerEndpoint</code> ，它提供了实际的<code>MessageListener</code>来调用，但是您也可以构建自己的描述自定义调用机制的端点变体。<code>MethodJmsListenerEndpoint</code>是另一个示例，供所有<code>@JmsListener</code>annotation的端点使用。</p><h1><a href="#messaging-abstraction" class="anchor" name="messaging-abstraction"></a>消息传递抽象</h1>
<p>到目前为止，我们已经在端点中注入了一个简单的<code>String</code> ，但实际上它可以具有非常灵活的方法签名。让我们重写它以使用自定义标头注入<code>Order</code> ：</p>
<pre><code class="prettyprint java">@Component
public class MyService {

    @JmsListener(destination = "myQueue")
    public void processOrder(Order order,  @Header("order_type") String orderType) {
        ...
    }
}
</code></pre>
<p>这些是您可以在JMS侦听器端点中注入的主要元素：<br>*原始<code>javax.jms.Message</code>或其任何子类（当然要提供与传入消息类型匹配的消息）。<br>* <code>javax.jms.Session</code> ，例如用于发送自定义回复的Session 。<br>* <code>org.springframework.messaging.Message</code>表示传入的JMS消息。请注意，此消息同时包含自定义标头和标准标头（由<code>JmsHeaders</code>定义）。<br>* <code>@Header</code>方法参数，以提取特定的标头值，包括标准的JMS标头。<br>* <code>@Headers</code>参数，也必须可分配给<code>java.util.Map</code>以获得对所有标题的访问。<br>*不是支持的类型之一（即<code>Message</code>和<code>Session</code> ）的非注释元素被视为有效负载。您可以通过使用<code>@Payload</code>annotation参数来使其明确。您还可以通过添加额外的<code>@Validated</code>打开验证。</p>
<p>注入Spring的<code>Message</code>抽象的能力特别有用，它可以受益于存储在特定于传输的消息中的所有信息，而无需依赖于特定于传输的API。</p>
<pre><code class="prettyprint java">@JmsListener(destination = "myQueue")
public void processOrder(Message<Order> order) { ... }
</code></pre>
<p>这些功能位于所有带注释元素的封面下。可以自定义验证和转换服务，甚至可以为自定义用例添加其他方法参数解析器。以下示例设置了一个自定义<code>Validator</code>以便在调用侦听器方法之前首先使用<code>@Validated</code>annotation的有效负载进行验证：</p>
<pre><code class="prettyprint java">@Configuration
@EnableJms
public class AppConfig implements JmsListenerConfigurer {

    @Override
    public void configureJmsListeners(JmsListenerEndpointRegistrar registrar) {
        registrar.setJmsHandlerMethodFactory(myJmsHandlerMethodFactory());
    }

    @Bean
    public DefaultJmsHandlerMethodFactory myJmsHandlerMethodFactory() {
        DefaultJmsHandlerMethodFactory factory = new DefaultJmsHandlerMethodFactory();
        factory.setValidator(myValidator());
        return factory;
    }
}
</code></pre><h1><a href="#reply-management" class="anchor" name="reply-management"></a>回复管理</h1>
<p><code>MessageListenerAdapter</code>的现有支持已经允许您的方法具有非<code>void</code>返回类型。在这种情况下，调用的结果将封装在<code>javax.jms.Message</code>中指定的目的地发送任意<code>JMSReplyTo</code>原始消息的报头或在收听配置的默认目的地。现在可以使用消息抽象的<code>@SendTo</code>annotation设置默认目的地。</p>
<p>假设我们的<code>processOrder</code>方法现在应该返回<code>OrderStatus</code> ，则可以按如下所示编写它以自动发送回复：</p>
<pre><code class="prettyprint java">@JmsListener(destination = "myQueue")
@SendTo("queueOut")
public OrderStatus processOrder(Order order) {
    // order processing
    return status;
}
</code></pre>
<p>如果需要以与传输无关的方式设置其他标头，则可以返回一条<code>Message</code> ，例如：</p>
<pre><code class="prettyprint java">@JmsListener(destination = "myQueue")
@SendTo("queueOut")
public Message<OrderStatus> processOrder(Order order) {
    // order processing
    return MessageBuilder
            .withPayload(status)
            .setHeader("code", 1234)
            .build();
}
</code></pre><h1><a href="#wrapping-up" class="anchor" name="wrapping-up"></a>包起来</h1>
<p>Spring Framework 4.1将于今年7月发布，并且将在JMS领域进行一些改进：JMS侦听器方法可以简单地进行注释，并且可以使用非常灵活的方法签名。JMS侦听器现在也支持Spring 4.0中引入的消息传递抽象。</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">var disqus_shortname = 'spring-io';
      var disqus_identifier = 1529;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));</script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });</script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>