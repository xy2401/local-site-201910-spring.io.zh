<html dir="ltr" data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>利用泛型元数据</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>System.config({baseURL: "/b92013b"});</script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>System.import('app/main.js')</script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Exploiting Generics Metadata">
<meta name="twitter:description" content="<p>It is a common misconception that I hear when talking with clients that all information about generic types is erased from your Java class files. This is entirely untrue. All static generic information is maintained, and only generic information about individual instances is erased. So if I have a class <span style=" font-family:courie="="></head><body dir="ltr">Foo that implements <span style="font-family:courier">List<String></span>, then I can determine that <span style="font-family:courier">Foo</span> implements the List interface parameterised by <span style="font-family:courier">String</span> at runtime. However, if I instantiate an instance of <span style="font-family:courier">ArrayList<String></span> at runtime, I cannot take that instance and determine its concrete type parameter (I can determine that <span style="font-family:courier">ArrayList</span> requires type parameters). In this entry I’m going to show you a practical usage for some of the available generics metadata that simplifies the creation of strategy interfaces and implementations that differ by the type of object they process.
">

<meta property="og:title" content="Exploiting Generics Metadata">
<meta property="og:description" content="<p>It is a common misconception that I hear when talking with clients that all information about generic types is erased from your Java class files. This is entirely untrue. All static generic information is maintained, and only generic information about individual instances is erased. So if I have a class <span style=" font-family:courie="=">Foo that implements <span style="font-family:courier">List<String></span>, then I can determine that <span style="font-family:courier">Foo</span> implements the List interface parameterised by <span style="font-family:courier">String</span> at runtime. However, if I instantiate an instance of <span style="font-family:courier">ArrayList<String></span> at runtime, I cannot take that instance and determine its concrete type parameter (I can determine that <span style="font-family:courier">ArrayList</span> requires type parameters). In this entry I’m going to show you a practical usage for some of the available generics metadata that simplifies the creation of strategy interfaces and implementations that differ by the type of object they process.
">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2006-09-29 10:45:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">// Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }</script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">利用泛型元数据</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="null?s=20&d=mm"> <span class="author">罗伯·哈罗普</span>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2006-09-29 10:45:00.0">2006年9月29日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2006/09/29/exploiting-generics-metadata#disqus_thread" data-disqus-identifier="30">
</a></div>
</div>
</header>
<div class="blog--post"><p>在与客户交谈时，我听到一个普遍的误解，即从您的Java类文件中删除了有关泛型类型的所有信息。这是完全不正确的。所有静态通用信息均得到维护，并且仅擦除有关单个实例的通用信息。所以如果我有一个实现<span style="font-family:courier">List的</span> <span style="font-family:courier">Foo</span>类<span style="font-family:courier"><string></string></span> ，那么我可以确定<span style="font-family:courier">Foo</span>在运行时实现了<span style="font-family:courier">String设置</span>的List接口。但是，如果我实例化<span style="font-family:courier">ArrayList</span>的实例<span style="font-family:courier"><string></string></span>在运行时，我无法采用该实例并确定其具体的类型参数（我可以确定<span style="font-family:courier">ArrayList</span>需要类型参数）。在本条目中，我将向您展示一些可用的泛型元数据的实际用法，这些元数据简化了策略接口和实现的创建，这些策略接口和实现的不同之处在于它们所处理的对象类型。</p>
<p>我看到在许多应用程序中出现的一种模式是将某种策略接口与具体实现一起使用，每种实现都处理特定的输入类型。例如，考虑投资银行界的一个简单场景。任何上市公司可以发行<a href="http://www.investopedia.com/articles/03/081303.asp">企业行动</a>是带来的实际变化对他们的股票。这方面的一个关键示例是股利支付，它向所有股东每股支付一定数量的现金，股票或财产。在投资银行内部，接收这些事件的通知并计算所得的权利对于使交易账簿具有正确的股票和现金价值保持最新非常重要。</p>
<p>作为一个具体的例子，考虑拥有120万股IBM股票的BigBank。IBM决定发行每股0.02美元的股息。因此，BigBank需要接收有关股息行动的通知，并在适当的时间点更新其交易帐簿，以反映可用的额外24,000美元现金。</p>
<p>根据所执行的公司行为的类型，权利的计算将有很大的不同。例如，合并很可能会导致一家公司的股票损失而另一家公司的股票收益。</p>
<p>如果我们考虑一下这在Java应用程序中的外观，我们可以假设看到这样的例子（经过简化）：</p>
<pre><code class="prettyprint java"><br>public class CorporateActionEventProcessor {

    public void onCorporateActionEvent(CorporateActionEvent event) {
        // do we have any stock for this security?

        // if so calculate our entitlements
    }
}
</code></pre>
<p>有关事件的通知可能是通过外部机构通过多种机制传入的，然后发送到此<span style="font-family:courier">CorporateActionEventProcessor</span>类。<span style="font-family:courier">CorporateActionEvent</span>接口可以通过许多具体的类来实现：</p>
<pre><code class="prettyprint java"><br>public class DividendCorporateActionEvent implements CorporateActionEvent {

    private PayoutType payoutType;
    private BigDecimal ratioPerShare;

    // ...
}

public class MergerCorporateActionEvent implements CorporateActionEvent {

    private String currentIsin; // security we currently hold
    private String newIsin; // security we get
    private BigDecimal conversionRatio;
}
</code></pre>
<p>计算权利的过程可能由如下接口封装：</p>
<pre><code class="prettyprint java"><br>public interface EntitlementCalculator {
    void calculateEntitlement(CorporateActionEvent event);
}
</code></pre>
<p>通过此接口，我们可能会看到许多实现如下所示：</p>
<pre><code class="prettyprint java"><br>public class DividendEntitlementCalculator implements EntitlementCalculator {

    public void calculateEntitlement(CorporateActionEvent event) {
        if(event instanceof DividendCorporateActionEvent) {
            DividendCorporateActionEvent dividendEvent = (DividendCorporateActionEvent)event;
            // do some processing now
        }
    }
}
</code></pre>
<p>我们的<span style="font-family:courier">CorporateActionEventProcessor</span>可能看起来像这样：</p>
<pre><code class="prettyprint java"><br>public class CorporateActionEventProcessor {

    private Map<Class, EntitlementCalculator> entitlementCalculators = new HashMap<Class, EntitlementCalculator>();

    public CorporateActionEventProcessor() {
        this.entitlementCalculators.put(DividendCorporateActionEvent.class, new DividendEntitlementCalculator());
    }

    public void onCorporateActionEvent(CorporateActionEvent event) {
        // do we have any stock for this security?

        // if so calculate our entitlements
        EntitlementCalculator entitlementCalculator = this.entitlementCalculators.get(event.getClass());
    }
}
</code></pre>
<p>在这里，您可以看到我们维护了一个到<span style="font-family:courier">EntitlementCalculator</span>实现的<span style="font-family:courier">CorporateActionEvent</span>类型的<span style="font-family:courier">映射</span> ，并使用它来为每个<span style="font-family:courier">CorporateActionEvent</span>找到正确的<span style="font-family:courier">EntitlementCalculator</span> 。</p>
<p>回顾此示例，第一个明显的问题是<span style="font-family:courier">EntitlementCalculator.calculateEntitlement</span>的类型是仅接收<span style="font-family:courier">CorporateActionEvent，</span>从而导致类型检查并在每个实现内部进行转换。我们可以使用泛型轻松解决此问题：</p>
<pre><code class="prettyprint java"><br>public interface EntitlementCalculator<E extends CorporateActionEvent> {
    void calculateEntitlement(E event);
}

public class DividendEntitlementCalculator implements EntitlementCalculator<DividendCorporateActionEvent> {

    public void calculateEntitlement(DividendCorporateActionEvent event) {

    }
}
</code></pre>
<p>如您所见，我们引入了类型参数<span style="font-family:courier">E</span> ，该参数必将扩展<span style="font-family:courier">CorporateActionEvent</span> 。然后，我们定义<span style="font-family:courier">DividendEntitlementCalculator</span>实现<span style="font-family:courier">EntitlementCalculator <dividendcorporateactionevent></dividendcorporateactionevent></span>导致<span style="font-family:courier">E</span>是与<span style="font-family:courier">DividendCorporateActionEvent</span>替换为<span style="font-family:courier">DividendEntitlementCalculator</span>内为宜。无需键入check和cast。</p>
<p><span style="font-family:courier">CorporateActionEventProcessor</span>类继续按原样工作，但是现在存在一些重复，并且还可能出现错误。注册特定的<span style="font-family:courier">EntitlementCalculator时</span> ，即使在类定义中已经指定了它，我们仍然必须指定它处理的类型。鉴于此，可以为其无法处理的类型注册一个<span style="font-family:courier">EntitlementCalculator</span> ：</p>
<pre><code class="prettyprint java"><br>public CorporateActionEventProcessor() {
        this.entitlementCalculators.put(MergerCorporateActionEvent.class, new DividendEntitlementCalculator());
}
</code></pre>
<p>幸运的是，通过从通用接口声明中提取参数类型并将其用作键类型，可以很容易地解决此问题：</p>
<pre><code class="prettyprint java"><br>public void registerEntitlementCalculator(EntitlementCalculator calculator) {
    this.entitlementCalculators.put(extractTypeParameter(calculator.getClass()), calculator);
}
</code></pre>
<p>我们首先添加一个<span style="font-family:courier">registerEntitlementCalculator</span>方法，该方法委托<span style="font-family:courier">extractTypeParameter</span>来查找<span style="font-family:courier">EntitlementCalculator</span>类的类型参数。</p>
<pre><code class="prettyprint java"><br>private Class extractTypeParameter(Class<? extends EntitlementCalculator> calculatorType) {
    Type[] genericInterfaces = calculatorType.getGenericInterfaces();

    // find the generic interface declaration for EntitlementCalculator<E>
    ParameterizedType genericInterface = null;
    for (Type t : genericInterfaces) {
        if (t instanceof ParameterizedType) {
            ParameterizedType pt = (ParameterizedType)t;
            if (EntitlementCalculator.class.equals(pt.getRawType())) {
                genericInterface = pt;
                break;
            }
        }
    }

    if(genericInterface == null) {
        throw new IllegalArgumentException("Type '" + calculatorType
               + "' does not implement EntitlementCalculator<E>.");
    }

    return (Class)genericInterface.getActualTypeArguments()[0];
}
</code></pre>
<p>在这里，我们通过调用<span style="font-family:courier">Class.getGenericInterfaces（）</span>来获取代表<span style="font-family:courier">EntitlementCalculator</span>类型的通用接口的<span style="font-family:courier">Type []</span> 。此方法与返回<span style="font-family:courier">Class []的</span> <span style="font-family:courier">Class.getInterfaces（）</span>有很大不同。调用<span style="font-family:courier">DividendEntitlementCalculator.class.getInterfaces（）</span>返回表示<span style="font-family:courier">EntitlementCalculator</span>类型的单个<span style="font-family:courier">Class</span>实例。调用<span style="font-family:courier">DividendEntitlementCalculator.class.getGenericInterfaces（）</span>返回单个<span style="font-family:courier">ParameterizedType</span>实例，该实例代表具有类型参数<span style="font-family:courier">DividendCorporateActionEvent</span>的<span style="font-family:courier">EntitlementCalculator</span>类型。在具有通用和非通用接口的类上调用<span style="font-family:courier">getGenericInterfaces（）</span>将返回一个同时包含<span style="font-family:courier">Class</span>和<span style="font-family:courier">ParameterizedType</span>实例的数组。</p>
<p>接下来，我们遍历<span style="font-family:courier">Type []</span>并找到其“原始类型”为<span style="font-family:courier">EntitlementCalculator</span>的<span style="font-family:courier">ParameterizedType</span>实例。从中我们可以使用<span style="font-family:courier">getTypeArguments（）</span>提取<span style="font-family:courier">E</span>的类型参数，并返回第一个数组实例-我们知道在这种情况下该数组实例将始终存在。</p>
<p>调用代码可以根据需要简单地传入<span style="font-family:courier">EntitlementCalculator</span>实现：</p>
<pre><code class="prettyprint java"><br>CorporateActionEventProcessor processor = createCorporateActionEventProcessor();
processor.registerEntitlementCalculator(new DividendEntitlementCalculator());
</code></pre>
<p>现在这是一个非常不错的API，并且可以通过Spring之类的东西进一步扩展，您可以使用<span style="font-family:courier">ListableBeanFactory.getBeansOfType（）</span>来定位所有已配置的<span style="font-family:courier">EntitlementCalculator</span>实现，并自动向<span style="font-family:courier">CorporateActionEventProcessor</span>注册它们。</p>
<h2 id="whatsnext">下一步是什么？</h2><p></p><p>你们中有些人可能注意到的一种有趣情况是，完全有可能像下面这样的代码：</p>
<pre><code class="prettyprint java"><br>EntitlementCalculator calculator = new DividendEntitlementCalculator();
calculator.calculateEntitlement(new MergerCorporateActionEvent());
</code></pre>
<p>这段代码可以很好地编译，但是我们知道<span style="font-family:courier">DividendEntitlementCalculator.calculateEntitlement</span>方法仅接受<span style="font-family:courier">DividendCorporateActionEvent</span>对象。那为什么编译呢？而且，由于它可以编译运行时发生的事情？好吧，首先要回答第二个问题-Java仍然通过在运行时抛出<span style="font-family:courier">ClassCastException来</span>确保类型安全。为什么这样做有效，并回答为什么这个示例实际上可以编译的问题，我很快将写另一个条目...</p>
<h2 id="furtherreading">进一步阅读</h2>
<p><a href="https://www.amazon.com/dp/0471497584/">证券业务</a></p>
<p><a href="https://www.amazon.com/dp/0470870664">公司行动</a></p>
<p><a href="http://java.sun.com/j2se/1.5/pdf/generics-tutorial.pdf#search="java 5 generics"">Java编程语言中的泛型</a></p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">var disqus_shortname = 'spring-io';
      var disqus_identifier = 30;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));</script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });</script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>