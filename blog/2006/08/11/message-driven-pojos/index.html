<!DOCTYPE html>
<html data-code-prettify="" data-mobile-support="" data-search="">
<head>
<title>Message Driven POJOs!</title>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no" id="Viewport" name="viewport" />
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png" />
<link href="https://fonts.googleapis.com/css?family=Varela+Round|Montserrat:400,700" rel="stylesheet" type="text/css" />
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css" />
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M" name="google-site-verification" />

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css" />

<meta content="summary" name="twitter:card" />
<meta content="@springcentral" name="twitter:site" />
<meta name="twitter:title" content="Message Driven POJOs!" />
<meta name="twitter:description" content="&lt;p&gt; Of all the new Spring 2.0 features and improvements, I must admit that Message-Driven POJOs are one of my personal favorites. I have a feeling that a lot of other Spring users will feel the same way. &lt;/p&gt;
&lt;p&gt; Here I am providing a quick introduction. There is a lot more to show, and I will follow this up with other posts. For now though - this should provide you with enough information to get up and running with some truly POJO-based asynchronous JMS! I hope you are as excited about that as I am ;) &lt;/p&gt;
&lt;h3&gt;Prerequisites:&lt;/h3&gt;
" />
<meta name="twitter:creator" content="@m_f_" />
<meta name="twitter:image:src" content="https://gravatar.com/avatar/443e6ec0242c3f54001dae34374780e2?s=200" />

<meta property="og:title" content="Message Driven POJOs!" />
<meta property="og:image" content="https://gravatar.com/avatar/443e6ec0242c3f54001dae34374780e2?s=200" />
<meta property="og:description" content="&lt;p&gt; Of all the new Spring 2.0 features and improvements, I must admit that Message-Driven POJOs are one of my personal favorites. I have a feeling that a lot of other Spring users will feel the same way. &lt;/p&gt;
&lt;p&gt; Here I am providing a quick introduction. There is a lot more to show, and I will follow this up with other posts. For now though - this should provide you with enough information to get up and running with some truly POJO-based asynchronous JMS! I hope you are as excited about that as I am ;) &lt;/p&gt;
&lt;h3&gt;Prerequisites:&lt;/h3&gt;
" />
<meta content="article" property="og:type" />
<meta property="og:article:published_time" content="2006-08-11 17:01:00.0" />
</head>
<body>

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" style="display:none;visibility:hidden" width="0"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">Projects</a>
</li>
<li class="navbar-link">
<a href="/guides">Guides</a>
</li>
<li class="navbar-link active">
<a href="/blog">Blog</a>
</li>
<li class="navbar-link">
<a href="/services">Training & Certification</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form action="/search" class="form-inline form-search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search for documentation, guides, and posts..." type="text" value="" />
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form action="/search" class="form-inline form-search" method="get">
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search..." type="text" value="" />
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">
Home
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">
Projects
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">
Guides
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">
Blog
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">
Training & Certification
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>Engineering</div>
</div>
<div class="blog-category content--title">
<div>Releases</div>
</div>
<div class="blog-category content--title">
<div>News and Events</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Message Driven POJOs!</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">Engineering</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/443e6ec0242c3f54001dae34374780e2?s=20&amp;d=mm" />
<a class="author" rel="author" href="/team/mfisher">Mark Fisher</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2006-08-11 17:01:00.0">August 11, 2006</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" data-disqus-identifier="18" href="/blog/2006/08/11/message-driven-pojos#disqus_thread">
</a></div>
</div>
</header>
<div class="blog--post"><p>
Of all the new Spring 2.0 features and improvements, I must admit that Message-Driven POJOs are one of my personal favorites. I have a feeling that a lot of other Spring users will feel the same way.
</p>
<p>
Here I am providing a quick introduction. There is a lot more to show, and I will follow this up with other posts. For now though - this should provide you with enough information to get up and running with some truly POJO-based asynchronous JMS! I hope you are as excited about that as I am ;)
</p>
<h3>Prerequisites:</h3>
<p>
You will need the following JAR files on your classpath. I've also listed the versions that I am using (any spring-2.x version should be fine. I just dropped RC3 in there about 2 minutes ago in fact):
<ul>
<li>activemq-core-3.2.2.jar</li>
<li>concurrent-1.3.4.jar</li>
<li>geronimo-spec-j2ee-managment-1.0-rc4.jar</li>
<li>commmons-logging-1.0.4.jar</li>
<li>log4j-1.2.9.jar</li>
<li>jms-1.1.jar</li>
<li>spring-2.0-rc3.jar</li>
</ul>
</p>
<h3>Setup the Environment</h3>
<p>
First, we need to setup the environment. I am going to be using ActiveMQ, but the impact of changing a provider will be limited to modifications within this one file. I'm calling this file "shared-context.xml" since as you will see shortly, I am going to be importing these bean definitions for both sides of the JMS communication. Here are the "shared" bean definitions: the connection factory and two queues (one for the requests and one for replies):
</p>
<pre><code class="prettyprint xml"><br />&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
                           http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
	
    &lt;bean id=&quot;requestQueue&quot; class=&quot;org.activemq.message.ActiveMQQueue&quot;&gt;
        &lt;constructor-arg value=&quot;requestQueue&quot;/&gt;
    &lt;/bean&gt;
 
    &lt;bean id=&quot;replyQueue&quot; class=&quot;org.activemq.message.ActiveMQQueue&quot;&gt;
        &lt;constructor-arg value=&quot;replyQueue&quot;/&gt;
    &lt;/bean&gt;
 
    &lt;bean id=&quot;connectionFactory&quot; class=&quot;org.activemq.ActiveMQConnectionFactory&quot;&gt;
        &lt;property name=&quot;brokerURL&quot; value=&quot;tcp://localhost:61616&quot;/&gt;
    &lt;/bean&gt;
 
&lt;/beans&gt;
</code></pre>
<p>
As you see, I will be running ActiveMQ on tcp (I'm just running 'activemq' from the bin directory of the distribution). It is also possible to run embedded (with "vm://localhost" instead) - or you can run the main method of the org.activemq.broker.impl.Main class. If you want to grab the distribution, visit: <a href="http://www.activemq.org">http://www.activemq.org</a>.
</p>
<h3>The Example Domain</h3>
<p>
I'm keeping things intentionally simple here - the main goal is to demonstrate how the pieces fit together. One of the most important things I want to point out though is that these classes in my "domain" are POJOs. You will see no Spring or JMS dependencies at all.
</p>
<p>Ultimately, we will accept input from the user (a "name" via stdin) and this will be transformed into a "registration request" for some unspecified event. The message will be sent asynchronously, but we will have another queue to handle replies. The ReplyNotifier will then write the confirmation (or a "not confirmed" message) to stdout.
</p><p>I&rsquo;m creating all of these classes in a &ldquo;blog.mdp&rdquo; package by the way.<br />The first class is the <i>RegistrationRequest</i>:</p>
<pre><code class="prettyprint java"><br />package blog.mdp;

import java.io.Serializable;

public class RegistrationRequest implements Serializable {

    private static final long serialVersionUID = -6097635701783502292L;

    private String name;
	
    public RegistrationRequest(String name) {
        this.name = name;
    }
	
    public String getName() {
        return name;
    }
}
</code></pre><p>Next is the <i>RegistrationReply</i>:</p>
<pre><code class="prettyprint java"><br />package blog.mdp;

import java.io.Serializable;

public class RegistrationReply implements Serializable {

    private static final long serialVersionUID = -2119692510721245260L;

    private String name;
    private int confirmationId;
	
    public RegistrationReply(String name, int confirmationId) {
        this.name = name;
        this.confirmationId = confirmationId;
    }
	
    public String toString() {
        return (confirmationId &gt;= 0) 
                ? name + &quot;: Confirmed #&quot; + confirmationId 
                : name + &quot;: Not Confirmed&quot;;
    }
}
</code></pre><p>And the <i>RegistrationService</i>:</p>
<pre><code class="prettyprint java"><br />package blog.mdp;

import java.util.HashMap;
import java.util.Map;

public class RegistrationService {
	
    private Map registrations = new HashMap();
    private int counter = 100;

    public RegistrationReply processRequest(RegistrationRequest request) {
        int id = counter++;
        if (id % 5 == 0) {
            id = -1;
        }
        else {
            registrations.put(new Integer(id), request);
        }
        return new RegistrationReply(request.getName(), id);
    }
}
</code></pre><p>As you can see, this is merely providing an example. In reality, something would probably be done with the registrations map. Also, you see that 20% of registration attempts will be denied (given a -1 confirmationId) - not a very practical way to process registration requests, but it will provide some variety to the reply messages. Again, the important thing is that this service class has NO ties to Spring or JMS. Nevertheless, as you will see in just a moment, it is going to be handling the payload of messages sent via JMS. In other words, this RegistrationService <i>IS</i> the <b>Message-Driven POJO</b>.</p><p>Finally, create a simple class to log the reply messages:</p>
<pre><code class="prettyprint java"><br />package blog.mdp;

public class ReplyNotifier {

    public void notify(RegistrationReply reply) {
        System.out.println(reply);
    }
}
</code></pre>
<h3>Configure the Message-Driven POJO</h3>
<p>
Now for the most important part. How do we use Spring to configure the POJO service so that it will receive JMS Messages? The answer comes in the form of 2 bean definitions (well, 3 if you count the service itself). In this next bean definition file, notice the "container" which actually receives the message and enables the use of an asynchronous <i>listener</i>. The container needs to be aware of the <i>connectionFactory</i> and the <i>destination</i> from which it receives messages. There are multiple types of containers available, but that is beyond the scope of this blog. Read the reference document for more information: <a href="http://static.springframework.org/spring/docs/2.0-rc2/reference/jms.html#d0e22774">Message Listener Containers</a>.
</p>
<p>
The "listener" in this case is an instance of Spring's <i>MessageListenerAdapter</i>. It has a reference to the <i>delegate</i> (the POJO service) and the name of the handler method. In this case, we've also provided a <i>defaultResponseDestination</i>. For a void-returning method, you would obviously not need to do this. Also (and probably more likely in a production application), you can leave this out in favor of setting the "reply-to" property of the incoming JMS Message instead.
</p>
<p>Now that we've discussed the various players, here are the bean definitions (I've named this file "server-context.xml"):
```xml

<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans 
                           http://www.springframework.org/schema/beans/spring-beans.xsd">
<import resource="shared-context.xml" />
<bean id="registrationService" class="blog.mdp.RegistrationService" />
<bean id="listener" class="org.springframework.jms.listener.adapter.MessageListenerAdapter">
<property name="delegate" ref="registrationService" />
<property name="defaultListenerMethod" value="processRequest" />
<property name="defaultResponseDestination" ref="replyQueue" />
</bean>
<bean id="container" class="org.springframework.jms.listener.SimpleMessageListenerContainer">
<property name="connectionFactory" ref="connectionFactory" />
<property name="messageListener" ref="listener" />
<property name="destination" ref="requestQueue" />
</bean>
</beans>
```
</p><p>The last step here is to provide a bootstrap mechanism for running the service since this is a simple standalone example. I&rsquo;ve just created a trivial main method to startup an ApplicationContext with the relevant bean definitions and then block:</p>
<pre><code class="prettyprint java"><br />package blog.mdp;

import java.io.IOException;

import org.springframework.context.support.ClassPathXmlApplicationContext;

public class RegistrationServiceRunner {
	
    public static void main(String[] args) throws IOException {
        new ClassPathXmlApplicationContext(&quot;/blog/mdp/server-context.xml&quot;);
        System.in.read();
    }
}
</code></pre>
<h3>Configure the Client</h3><p>On the &ldquo;client&rdquo; side, we will send the registration requests and log the replies. First, I will list the bean definitions. After the previous section, you should understand the role of the &ldquo;container&rdquo; and &ldquo;listener&rdquo;. In this case, the <i>delegate</i> is the <i>ReplyNotifier</i> and since it has a void return type, it does not itself send replies (therefore, no &lsquo;defaultResponseDestination&rsquo; property is present). I&rsquo;ve named this file &ldquo;client-context.xml&rdquo;:</p>
<pre><code class="prettyprint xml"><br />&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
                           http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
	
    &lt;import resource=&quot;shared-context.xml&quot;/&gt;
	
    &lt;bean id=&quot;replyNotifier&quot; class=&quot;blog.mdp.ReplyNotifier&quot;/&gt;
	
    &lt;bean id=&quot;listener&quot; class=&quot;org.springframework.jms.listener.adapter.MessageListenerAdapter&quot;&gt;
        &lt;property name=&quot;delegate&quot; ref=&quot;replyNotifier&quot;/&gt;
        &lt;property name=&quot;defaultListenerMethod&quot; value=&quot;notify&quot;/&gt;
    &lt;/bean&gt;
	
    &lt;bean id=&quot;container&quot; class=&quot;org.springframework.jms.listener.SimpleMessageListenerContainer&quot;&gt;
        &lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot;/&gt;
        &lt;property name=&quot;messageListener&quot; ref=&quot;listener&quot;/&gt;
        &lt;property name=&quot;destination&quot; ref=&quot;replyQueue&quot;/&gt;
    &lt;/bean&gt;
	
    &lt;bean id=&quot;jmsTemplate&quot; class=&quot;org.springframework.jms.core.JmsTemplate&quot;&gt;
        &lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot;/&gt;
        &lt;property name=&quot;defaultDestination&quot; ref=&quot;requestQueue&quot;/&gt;
    &lt;/bean&gt;
	
&lt;/beans&gt;
</code></pre><p>There is another bean defined there - an instance of Spring&rsquo;s &ldquo;jmsTemplate&rdquo;. We will use that to send the registration request messages to its <i>defaultDestination</i>. With the simple <i>convertAndSend(..)</i> methods that Spring provides, the sending of JMS messages is trivial. I&rsquo;ve created a class that takes user input and then sends the message by using this &ldquo;jmsTemplate&rdquo;:</p>
<pre><code class="prettyprint java"><br />package blog.mdp;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.jms.core.JmsTemplate;

public class RegistrationConsole {
	
    public static void main(String[] args) throws IOException {
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;/blog/mdp/client-context.xml&quot;);
        JmsTemplate jmsTemplate = (JmsTemplate) context.getBean(&quot;jmsTemplate&quot;);
		
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));		
		
        for (;;) {
            System.out.print(&quot;To Register, Enter Name: &quot;);
            String name = reader.readLine();
            RegistrationRequest request = new RegistrationRequest(name);
            jmsTemplate.convertAndSend(request);
        }
    }
}
</code></pre>
<h3>Running the Example</h3><p>Now for the fun part. Startup the ActiveMQ broker (as briefly discussed in the &ldquo;Setup the Environment&rdquo; section). Run the main(..) method of the <i>RegistrationServiceRunner</i>. Run the main(..) method of the <i>RegistrationConsole</i>. Enter a name, and you should see a reply in that same console.</p>
<h3>Further Resources</h3><p>Hopefully, that&rsquo;s enough to give you an idea of what Spring&rsquo;s new Message-Driven POJO support is about. However, as I mentioned, there is quite a bit more involved - different container types, transaction support, configuration of consumer threading, pluggable message conversion strategies, etc. Stay tuned to the <a href="http://blog.interface21.com/main/">Interface21 Team Blog</a> for more examples and information about those features. In the meantime, you can check out the <a href="http://static.springframework.org/spring/docs/2.0-rc2/reference/jms.html">Spring Reference Documentation on JMS</a>. Also, be sure to visit the <a href="http://forum.springframework.org/forumdisplay.php?f=30">&ldquo;Remoting and JMS&rdquo; section of the Spring Support Forums</a> as you begin to explore this exciting new functionality.</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 18;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>
Back
</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">All Posts</a>
<a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">Engineering</a>
<a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">Releases</a>
<a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">News and Events</a>
<a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>Get updates from The Spring Team delivered to your inbox</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">Tools</a></li>
<li><a href="https://store.pivotal.io/">Store</a></li>
<li><a href="/blog">Newsletter</a></li>
</ul>
</div>
</div>
&copy; <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a>, Inc. All Rights Reserved.
<a href="https://pivotal.io/terms-of-use">Terms of Use</a> &bullet;
<a href="https://pivotal.io/privacy-policy">Privacy</a> &bullet;
<a href="/trademarks">Trademark Guidelines</a>
<div id="teconsent" style="display:inline-block;"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>