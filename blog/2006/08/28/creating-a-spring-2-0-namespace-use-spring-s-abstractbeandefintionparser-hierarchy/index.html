<html dir="ltr" data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>创建一个Spring 2.0命名空间？使用Spring的AbstractBeanDefintionParser层次结构。</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>System.config({baseURL: "/b92013b"});</script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>System.import('app/main.js')</script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Creating a Spring 2.0 namespace?  Use Spring's AbstractBeanDefintionParser hierarchy.">
<meta name="twitter:description" content="<p>Lately it seems like I’ve been focusing on creating Spring XML namespaces. It’s been a lot of trial and error (both on the XSD and Spring side) to get a good pattern for creating parsers. One of the biggest confusions that I ran into was the <span style=" font-family:courie="="></head><body dir="ltr">AbstractBeanDefinitionParser hierarchy. At this point it isn’t documented especially well (but there is a JIRA for it, so it’ll be fixed before GA), so I’ll give you a rundown of your choices, what they’re good for and how to use them.
<h2><span style="font-family:courier">AbstractBeanDefinitionParser</span> choices</h2>
">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/329c22b36844c1d9c698d5e9b6709dc5?s=200">

<meta property="og:title" content="Creating a Spring 2.0 namespace?  Use Spring's AbstractBeanDefintionParser hierarchy.">
<meta property="og:image" content="https://gravatar.com/avatar/329c22b36844c1d9c698d5e9b6709dc5?s=200">
<meta property="og:description" content="<p>Lately it seems like I’ve been focusing on creating Spring XML namespaces. It’s been a lot of trial and error (both on the XSD and Spring side) to get a good pattern for creating parsers. One of the biggest confusions that I ran into was the <span style=" font-family:courie="=">AbstractBeanDefinitionParser hierarchy. At this point it isn’t documented especially well (but there is a JIRA for it, so it’ll be fixed before GA), so I’ll give you a rundown of your choices, what they’re good for and how to use them.
<h2><span style="font-family:courier">AbstractBeanDefinitionParser</span> choices</h2>
">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2006-08-28 08:00:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">// Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }</script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">创建一个Spring 2.0命名空间？使用Spring的AbstractBeanDefintionParser层次结构。</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/329c22b36844c1d9c698d5e9b6709dc5?s=20&d=mm"> <a class="author" rel="author" href="/team/bhale">本·黑尔</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2006-08-28 08:00:00.0">2006年8月28日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2006/08/28/creating-a-spring-2-0-namespace-use-spring-s-abstractbeandefintionparser-hierarchy#disqus_thread" data-disqus-identifier="21">
</a></div>
</div>
</header>
<div class="blog--post"><p>最近，似乎我一直在专注于创建Spring XML名称空间。为了获得创建解析器的良好模式，已经进行了大量的尝试和错误（在XSD和Spring方面）。我遇到的最大困惑之一是<span style="font-family:courier">AbstractBeanDefinitionParser</span>层次结构。到目前为止，它的文档还不够好（但是有一个JIRA，因此它将在GA之前得到修复），因此，我将简要介绍您的选择，它们的优点以及如何选择使用它们。</p>
<h2><span style="font-family:courier">AbstractBeanDefinitionParser</span>选择</h2><p>Spring提供了三个主要的<span style="font-family:courier">BeanDefinitionParser</span> ，以帮助您解析XML名称空间。<br></p><ul><br><li><a href="#AbstractBeanDefinitionParser" style="font-family:courier">AbstractBeanDefinitionParser</a><br> <ul><br> <li><a href="#AbstractSingleBeanDefinitionParser" style="font-family:courier">AbstractSingleBeanDefinitionParser</a><br> <ul><br> <li><a href="#AbstractSimpleBeanDefinitionParser" style="font-family:courier">AbstractSimpleBeanDefinitionParser</a><br> </li></ul><br> </li></ul><br></li></ul><p></p><p>我将从最具体的地方开始，朝最一般的方向努力，以展示如何在需要时获得更多动力。如果您想跳过示例并查看摘要，请<a href="#summary">点击此处</a> 。</p><p><a name="AbstractSimpleBeanDefinitionParser"></a></p><h2 style="font-family:courier">AbstractSimpleBeanDefinitionParser</h2><br>该<span style="font-family:courier">AbstractSimpleBeanDefinitionParser</span>是的<span style="font-family:courier">AbstractBeanDefinitionParser</span> S中的最specfic。当标签上的属性与bean上的属性之间存在关联时，可以使用此类。因此，请看以下示例：<p></p>
<pre><code class="prettyprint xml"><br><util:properties location="..." />
</code></pre>
<pre><code class="prettyprint java"><br>public class PropertiesFactoryBean extends PropertiesLoaderSupport
		implements FactoryBean, InitializingBean {
    ...
    public void setLocation(Resource location) {
        this.locations = new Resource[] {location};
    }
    ...
}
</code></pre><p>您会注意到<span style="font-family:courier">util：properties</span>标记上的<span style="font-family:courier">location</span>属性与<span style="font-family:courier">PropertiesFactoryBean</span>类型上的java bean属性匹配。<span style="font-family:courier">AbstractSimpleBeanDefinitionParser</span>自动提取属性并将其映射到该属性。要获得此行为，您只需实现一个方法<span style="font-family:courier">getBeanClass（）即可</span> 。因此，此示例的实现如下所示：</p>
<pre><code class="prettyprint java"><br>public class PropertiesBeanDefinitionParser extends AbstractSimpleBeanDefinitionParser {

    protected Class getBeanClass(Element element) {
        return PropertiesFactoryBean.class;
    }
}
</code></pre><p>与所有抽象解析器一样，隐藏在幕后的框架代码采用创建的bean定义，并将其注册到应用程序上下文中。</p><p><a name="AbstractSingleBeanDefinitionParser"></a></p><h2 style="font-family:courier">AbstractSingleBeanDefinitionParser</h2><br><span style="font-family:courier">AbstractSingleBeanDefinitionParser</span>更为通用，我认为它将是最常用的抽象解析器。此类使您能够创建将在上下文中自动注册的任何单个bean定义。在这种情况下，bean定义可能不是简单的属性映射，它可能具有复杂的嵌套结构，但仅创建一个bean定义。因此，例如：<p></p>
<pre><code class="prettyprint xml"><br><tx:advice>
    <tx:attributes>
        <tx:method name="get*" read-only="false" />
    </tx:attributes>
</tx:advice>
</code></pre>
<pre><code class="prettyprint java"><br>public class TransactionInterceptor extends TransactionAspectSupport
    implements MethodInterceptor, Serializable {
    ...
    public void setTransactionAttributes(Properties transactionAttributes) {
        NameMatchTransactionAttributeSource tas = new NameMatchTransactionAttributeSource();
        tas.setProperties(transactionAttributes);
        this.transactionAttributeSource = tas;
    }
    ...
}
</code></pre><p>正如您所看到的<span style="font-family:courier">tx：advice</span>复杂的嵌套结构一样，我们前面不会看到一对一的映射。但是，使用<span style="font-family:courier">AbstractSingleBeanDefinitionParser</span>可以对DOM结构进行任意遍历，如下所示：</p>
<pre><code class="prettyprint java"><br>class TxAdviceBeanDefinitionParser extends AbstractSingleBeanDefinitionParser {
    ...
    protected void doParse(Element element, BeanDefinitionBuilder builder) {
        // Set the transaction manager property.
        builder.addPropertyReference(TxNamespaceUtils.TRANSACTION_MANAGER_PROPERTY,
            element.getAttribute(TxNamespaceUtils.TRANSACTION_MANAGER_ATTRIBUTE));

        List txAttributes = DomUtils.getChildElementsByTagName(element, ATTRIBUTES);
        if (txAttributes.size() > 1) {
            throw new IllegalStateException("Element 'attributes' is allowed at most once inside element 'advice'");
        }
        else if (txAttributes.size() == 1) {
            // Using attributes source.
            parseAttributes((Element) txAttributes.get(0), builder);
        }
        else {
            // Assume annotations source.
            Class sourceClass = TxNamespaceUtils.getAnnotationTransactionAttributeSourceClass();
            builder.addPropertyValue(TxNamespaceUtils.TRANSACTION_ATTRIBUTE_SOURCE, new RootBeanDefinition(sourceClass));
        }
    }
    ...
}
</code></pre><p>您可以在这里看到我们正在检查DOM，并基于它对bean定义做出复杂的决定。如前所述，我认为这将是进行bean定义解析的最常用的支持类之一。</p><p><a name="AbstractBeanDefinitionParser"></a></p><h2 style="font-family:courier">AbstractBeanDefinitionParser</h2><br>现在是最可定制的选择，而无需实际为您自己实现接口。基本上，这个特定的类不仅允许您创建bean定义，而且还为您提供了足够的知识来创建多个bean定义。以机智：<p></p>
<pre><code class="prettyprint xml"><br><tx:annotation-driven />
</code></pre><p>那些熟悉Spring 2.0及其新名称空间的人应该将此标记识别为一种标签，它将自动检测<span style="font-family:courier">@Transactional</span>注释并代理它们所包含的类。现在，将在<span style="font-family:courier">后台</span>创建与您在Spring 1.2.8中为<span style="font-family:courier">DefaultAutoProxyCreator</span>样式行为创建的Bean定义相同的集合。总共4颗豆。那么，这种行为的例子是什么样的呢？</p>
<pre><code class="prettyprint java"><br>class AnnotationDrivenBeanDefinitionParser extends AbstractBeanDefinitionParser {
    ...
protected BeanDefinition parseInternal(Element element, ParserContext parserContext) {

        // Register the APC if needed.
        AopNamespaceUtils.registerAutoProxyCreatorIfNecessary(parserContext);

        boolean proxyTargetClass = TRUE.equals(element.getAttribute(PROXY_TARGET_CLASS));
        if (proxyTargetClass) {
            AopNamespaceUtils.forceAutoProxyCreatorToUseClassProxying(parserContext.getRegistry());
        }

        String transactionManagerName = element.getAttribute(TxNamespaceUtils.TRANSACTION_MANAGER_ATTRIBUTE);
        Class sourceClass = TxNamespaceUtils.getAnnotationTransactionAttributeSourceClass();

        // Create the TransactionInterceptor definition
        RootBeanDefinition interceptorDefinition = new RootBeanDefinition(TransactionInterceptor.class);
        interceptorDefinition.getPropertyValues().addPropertyValue(
            TxNamespaceUtils.TRANSACTION_MANAGER_PROPERTY, new RuntimeBeanReference(transactionManagerName));
        interceptorDefinition.getPropertyValues().addPropertyValue(
            TxNamespaceUtils.TRANSACTION_ATTRIBUTE_SOURCE, new RootBeanDefinition(sourceClass));

        // Create the TransactionAttributeSourceAdvisor definition.
        RootBeanDefinition advisorDefinition = new RootBeanDefinition(TransactionAttributeSourceAdvisor.class);
        advisorDefinition.getPropertyValues().addPropertyValue(TRANSACTION_INTERCEPTOR, interceptorDefinition);
        return advisorDefinition;
    }
    ...
}
</code></pre><p>这里最大的补充是能够访问<span>ParserContext。此上下文使您能够再次将子元素委托给名称空间处理程序，并让它们的解析器创建并返回Bean定义。它实际上是我真正喜欢的功能之一。<span>ParserContext还允许您创建自己的定义，并根据需要直接注册它们。</span></span></p><p><a name="summary"></a></p><h2>那么该使用哪个呢？</h2><br>这实际上是一个非常简单的过程。如果标签上的属性与bean上的属性之间存在直接关联，请使用<span style="font-family:courier">AbstractSimpleBeanDefinitionParser</span> 。如果要创建需要进行DOM遍历的单个bean定义，请使用<span style="font-family:courier">AbstractSingleBeanDefinitionParser</span> 。如果前两个过于严格，并且您希望能够任意注册自己的bean，请使用<span style="font-family:courier">AbstractBeanDefinitionParser</span> 。最后，如果您真的喜欢自己动手，则始终可以自己直接实现<span style="font-family:courier">BeanDefinitionParser</span>接口。<p></p><p>这样就可以了，它是Bean定义解析的快速介绍。我想知道的是你们中有多少人在这样做？您为什么创建了名称空间，以及如何使用解析器层次结构？使用评论来表达您的声音。谁知道，您的经验和建议可能会成为JIRA的增强功能...</p>
<hr><p><i>上一节中更新了错字</i><br><i>更新了文本中一致的拼写错误</i></p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">var disqus_shortname = 'spring-io';
      var disqus_identifier = 21;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));</script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });</script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>