<!DOCTYPE html>
<html data-code-prettify="" data-mobile-support="" data-search="">
<head>
<title>Creating a Spring 2.0 namespace?  Use Spring&#39;s AbstractBeanDefintionParser hierarchy.</title>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no" id="Viewport" name="viewport" />
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png" />
<link href="https://fonts.googleapis.com/css?family=Varela+Round|Montserrat:400,700" rel="stylesheet" type="text/css" />
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css" />
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M" name="google-site-verification" />

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css" />

<meta content="summary" name="twitter:card" />
<meta content="@springcentral" name="twitter:site" />
<meta name="twitter:title" content="Creating a Spring 2.0 namespace?  Use Spring&#39;s AbstractBeanDefintionParser hierarchy." />
<meta name="twitter:description" content="&lt;p&gt;Lately it seems like I’ve been focusing on creating Spring XML namespaces. It’s been a lot of trial and error (both on the XSD and Spring side) to get a good pattern for creating parsers. One of the biggest confusions that I ran into was the &lt;span style=&quot;font-family:courier&quot;&gt;AbstractBeanDefinitionParser&lt;/span&gt; hierarchy. At this point it isn’t documented especially well (but there is a JIRA for it, so it’ll be fixed before GA), so I’ll give you a rundown of your choices, what they’re good for and how to use them.&lt;/p&gt;
&lt;h2&gt;&lt;span style=&quot;font-family:courier&quot;&gt;AbstractBeanDefinitionParser&lt;/span&gt; choices&lt;/h2&gt;
" />
<meta name="twitter:image:src" content="https://gravatar.com/avatar/329c22b36844c1d9c698d5e9b6709dc5?s=200" />

<meta property="og:title" content="Creating a Spring 2.0 namespace?  Use Spring&#39;s AbstractBeanDefintionParser hierarchy." />
<meta property="og:image" content="https://gravatar.com/avatar/329c22b36844c1d9c698d5e9b6709dc5?s=200" />
<meta property="og:description" content="&lt;p&gt;Lately it seems like I’ve been focusing on creating Spring XML namespaces. It’s been a lot of trial and error (both on the XSD and Spring side) to get a good pattern for creating parsers. One of the biggest confusions that I ran into was the &lt;span style=&quot;font-family:courier&quot;&gt;AbstractBeanDefinitionParser&lt;/span&gt; hierarchy. At this point it isn’t documented especially well (but there is a JIRA for it, so it’ll be fixed before GA), so I’ll give you a rundown of your choices, what they’re good for and how to use them.&lt;/p&gt;
&lt;h2&gt;&lt;span style=&quot;font-family:courier&quot;&gt;AbstractBeanDefinitionParser&lt;/span&gt; choices&lt;/h2&gt;
" />
<meta content="article" property="og:type" />
<meta property="og:article:published_time" content="2006-08-28 08:00:00.0" />
</head>
<body>

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" style="display:none;visibility:hidden" width="0"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">Projects</a>
</li>
<li class="navbar-link">
<a href="/guides">Guides</a>
</li>
<li class="navbar-link active">
<a href="/blog">Blog</a>
</li>
<li class="navbar-link">
<a href="/services">Training & Certification</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form action="/search" class="form-inline form-search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search for documentation, guides, and posts..." type="text" value="" />
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form action="/search" class="form-inline form-search" method="get">
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search..." type="text" value="" />
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">
Home
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">
Projects
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">
Guides
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">
Blog
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">
Training & Certification
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>Engineering</div>
</div>
<div class="blog-category content--title">
<div>Releases</div>
</div>
<div class="blog-category content--title">
<div>News and Events</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Creating a Spring 2.0 namespace? Use Spring&#39;s AbstractBeanDefintionParser hierarchy.</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">Engineering</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/329c22b36844c1d9c698d5e9b6709dc5?s=20&amp;d=mm" />
<a class="author" rel="author" href="/team/bhale">Ben Hale</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2006-08-28 08:00:00.0">August 28, 2006</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" data-disqus-identifier="21" href="/blog/2006/08/28/creating-a-spring-2-0-namespace-use-spring-s-abstractbeandefintionparser-hierarchy#disqus_thread">
</a></div>
</div>
</header>
<div class="blog--post"><p>Lately it seems like I&rsquo;ve been focusing on creating Spring XML namespaces. It&rsquo;s been a lot of trial and error (both on the XSD and Spring side) to get a good pattern for creating parsers. One of the biggest confusions that I ran into was the <span style="font-family:courier">AbstractBeanDefinitionParser</span> hierarchy. At this point it isn&rsquo;t documented especially well (but there is a JIRA for it, so it&rsquo;ll be fixed before GA), so I&rsquo;ll give you a rundown of your choices, what they&rsquo;re good for and how to use them.</p>
<h2><span style="font-family:courier">AbstractBeanDefinitionParser</span> choices</h2><p>There are three primary <span style="font-family:courier">BeanDefinitionParser</span>s that Spring provides to help you parse your XML namespaces.<br /><ul><br /><li><a href="#AbstractBeanDefinitionParser" style="font-family:courier">AbstractBeanDefinitionParser</a><br /> <ul><br /> <li><a href="#AbstractSingleBeanDefinitionParser" style="font-family:courier">AbstractSingleBeanDefinitionParser</a><br /> <ul><br /> <li><a href="#AbstractSimpleBeanDefinitionParser" style="font-family:courier">AbstractSimpleBeanDefinitionParser</a><br /> </ul><br /> </ul><br /></ul></p><p>I&rsquo;m going to start at the most specific and work towards the most general to show how to gain more power when you need it. If you want to skip the examples and see the summary, check <a href="#summary">here</a>.</p><p><a name="AbstractSimpleBeanDefinitionParser"></a><h2 style="font-family:courier">AbstractSimpleBeanDefinitionParser</h2><br />The <span style="font-family:courier">AbstractSimpleBeanDefinitionParser</span> is the most specfic of the <span style="font-family:courier">AbstractBeanDefinitionParser</span>s. This class is intended to be used when there is a correlation between the attributes on a tag and the properties on a bean. So take the following example:</p>
<pre><code class="prettyprint xml"><br />&lt;util:properties location=&quot;...&quot; /&gt;
</code></pre>
<pre><code class="prettyprint java"><br />public class PropertiesFactoryBean extends PropertiesLoaderSupport
		implements FactoryBean, InitializingBean {
    ...
    public void setLocation(Resource location) {
        this.locations = new Resource[] {location};
    }
    ...
}
</code></pre><p>You&rsquo;ll notice that the <span style="font-family:courier">location</span> attribute on the <span style="font-family:courier">util:properties</span> tag matches a java bean property on the <span style="font-family:courier">PropertiesFactoryBean</span> type. The <span style="font-family:courier">AbstractSimpleBeanDefinitionParser</span> automatically extracts the attribute and maps it to that property. To get this behavior, you only need to implement a single method <span style="font-family:courier">getBeanClass()</span>. So the implementation for this example looks like:</p>
<pre><code class="prettyprint java"><br />public class PropertiesBeanDefinitionParser extends AbstractSimpleBeanDefinitionParser {

    protected Class getBeanClass(Element element) {
        return PropertiesFactoryBean.class;
    }
}
</code></pre><p>As with all of the abstract parsers, the framework code hidden behind the scenes takes the bean definition that is created and registers it with the application context.</p><p><a name="AbstractSingleBeanDefinitionParser"></a><h2 style="font-family:courier"> AbstractSingleBeanDefinitionParser</h2><br />The <span style="font-family:courier">AbstractSingleBeanDefinitionParser</span> is a little more general and I think will be the most often used of the abstract parsers. This class gives you the ability to create any single bean definition which will be automatically registered in the context. In this case the bean definition might not be a simple attribute mapping, it may have a complex nested structure, but it only creates a single bean definition. So as an example:</p>
<pre><code class="prettyprint xml"><br />&lt;tx:advice&gt;
    &lt;tx:attributes&gt;
        &lt;tx:method name=&quot;get*&quot; read-only=&quot;false&quot; /&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;
</code></pre>
<pre><code class="prettyprint java"><br />public class TransactionInterceptor extends TransactionAspectSupport
    implements MethodInterceptor, Serializable {
    ...
    public void setTransactionAttributes(Properties transactionAttributes) {
        NameMatchTransactionAttributeSource tas = new NameMatchTransactionAttributeSource();
        tas.setProperties(transactionAttributes);
        this.transactionAttributeSource = tas;
    }
    ...
}
</code></pre><p>As you can see with the complex nested structure of <span style="font-family:courier">tx:advice</span> there isn&rsquo;t going to be that one to one mapping we saw earlier. However, with <span style="font-family:courier">AbstractSingleBeanDefinitionParser</span> you get to do arbitrary traversal of the DOM structure like so:</p>
<pre><code class="prettyprint java"><br />class TxAdviceBeanDefinitionParser extends AbstractSingleBeanDefinitionParser {
    ...
    protected void doParse(Element element, BeanDefinitionBuilder builder) {
        // Set the transaction manager property.
        builder.addPropertyReference(TxNamespaceUtils.TRANSACTION_MANAGER_PROPERTY,
            element.getAttribute(TxNamespaceUtils.TRANSACTION_MANAGER_ATTRIBUTE));

        List txAttributes = DomUtils.getChildElementsByTagName(element, ATTRIBUTES);
        if (txAttributes.size() &gt; 1) {
            throw new IllegalStateException(&quot;Element &#39;attributes&#39; is allowed at most once inside element &#39;advice&#39;&quot;);
        }
        else if (txAttributes.size() == 1) {
            // Using attributes source.
            parseAttributes((Element) txAttributes.get(0), builder);
        }
        else {
            // Assume annotations source.
            Class sourceClass = TxNamespaceUtils.getAnnotationTransactionAttributeSourceClass();
            builder.addPropertyValue(TxNamespaceUtils.TRANSACTION_ATTRIBUTE_SOURCE, new RootBeanDefinition(sourceClass));
        }
    }
    ...
}
</code></pre><p>You can see here we&rsquo;re examining the DOM and making complex decisions about the bean definition based on it. As I said earlier, I think this will be one of the most used support classes for doing bean definition parsing.</p><p><a name="AbstractBeanDefinitionParser"></a><h2 style="font-family:courier">AbstractBeanDefinitionParser</h2><br />Now for the most customizable choice short of actually implementing the interface for yourself. Basically this particular class not only allows you to create a bean definition, it also hands you enough stuff to create multiple bean definitions. To wit:</p>
<pre><code class="prettyprint xml"><br />&lt;tx:annotation-driven /&gt;
</code></pre><p>Those familiar with Spring 2.0 and its new namespaces should recognize this tag as being a one-liner that will automatically detect <span style="font-family:courier">@Transactional</span> annotations and proxy the classes they are contained in. Now under the hood, the same set of bean definitions that you created for a <span style="font-family:courier">DefaultAutoProxyCreator</span> style behavior in Spring 1.2.8 are created; 4 beans in total. So what does an example of this kind of behavior look like?</p>
<pre><code class="prettyprint java"><br />class AnnotationDrivenBeanDefinitionParser extends AbstractBeanDefinitionParser {
    ...
protected BeanDefinition parseInternal(Element element, ParserContext parserContext) {

        // Register the APC if needed.
        AopNamespaceUtils.registerAutoProxyCreatorIfNecessary(parserContext);

        boolean proxyTargetClass = TRUE.equals(element.getAttribute(PROXY_TARGET_CLASS));
        if (proxyTargetClass) {
            AopNamespaceUtils.forceAutoProxyCreatorToUseClassProxying(parserContext.getRegistry());
        }

        String transactionManagerName = element.getAttribute(TxNamespaceUtils.TRANSACTION_MANAGER_ATTRIBUTE);
        Class sourceClass = TxNamespaceUtils.getAnnotationTransactionAttributeSourceClass();

        // Create the TransactionInterceptor definition
        RootBeanDefinition interceptorDefinition = new RootBeanDefinition(TransactionInterceptor.class);
        interceptorDefinition.getPropertyValues().addPropertyValue(
            TxNamespaceUtils.TRANSACTION_MANAGER_PROPERTY, new RuntimeBeanReference(transactionManagerName));
        interceptorDefinition.getPropertyValues().addPropertyValue(
            TxNamespaceUtils.TRANSACTION_ATTRIBUTE_SOURCE, new RootBeanDefinition(sourceClass));

        // Create the TransactionAttributeSourceAdvisor definition.
        RootBeanDefinition advisorDefinition = new RootBeanDefinition(TransactionAttributeSourceAdvisor.class);
        advisorDefinition.getPropertyValues().addPropertyValue(TRANSACTION_INTERCEPTOR, interceptorDefinition);
        return advisorDefinition;
    }
    ...
}
</code></pre><p>The big addition here is the ability to get to the &lt;span style=&ldquo;font-family:courier&gt;ParserContext</span>. This context gives you the ability to delegate sub elements to the namespace handler again and let their parsers create and return bean definitions. It&rsquo;s actually one of the features I really like. The &lt;span style=&rdquo;font-family:courier&gt;ParserContext</span> also allows you to create your own definitions and register them directly if you want.</p><p><a name="summary"></a><h2>So which to use?</h2><br />It&rsquo;s actually a pretty easy progression. Use <span style="font-family:courier">AbstractSimpleBeanDefinitionParser</span> if there is a direct correlation between attributes on a tag and properties on a bean. Use <span style="font-family:courier">AbstractSingleBeanDefinitionParser</span> if you are creating a single bean definition that requires you to do some DOM traversal. If the first two are too constrictive and you want to be able to arbitrarily register your own beans, use <span style="font-family:courier">AbstractBeanDefinitionParser</span>. Finally if you really like going it on your own you can always directly implement the <span style="font-family:courier">BeanDefinitionParser</span> interface yourself.</p><p>So there you have it, a quick intro to bean definition parsing. What I&rsquo;d like to know is how many of you are doing this? What have you created namespaces for and how are you using the parser hierarchy? Use the comments to have your voice heard. Who knows, your experiences and suggestions may make there way into a JIRA as an enhancement&hellip;</p>
<hr /><p><i>Updated typo in last section</i><br /><i>Updated the consistent typo of Defintion in the text</i></p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 21;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>
Back
</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">All Posts</a>
<a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">Engineering</a>
<a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">Releases</a>
<a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">News and Events</a>
<a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>Get updates from The Spring Team delivered to your inbox</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">Tools</a></li>
<li><a href="https://store.pivotal.io/">Store</a></li>
<li><a href="/blog">Newsletter</a></li>
</ul>
</div>
</div>
&copy; <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a>, Inc. All Rights Reserved.
<a href="https://pivotal.io/terms-of-use">Terms of Use</a> &bullet;
<a href="https://pivotal.io/privacy-policy">Privacy</a> &bullet;
<a href="/trademarks">Trademark Guidelines</a>
<div id="teconsent" style="display:inline-block;"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>