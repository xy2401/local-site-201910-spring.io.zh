<!DOCTYPE html>
<html data-code-prettify="" data-mobile-support="" data-search="">
<head>
<title>Spring Security 3.2 M1 Highlights, Servlet 3 API Support</title>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no" id="Viewport" name="viewport" />
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png" />
<link href="https://fonts.googleapis.com/css?family=Varela+Round|Montserrat:400,700" rel="stylesheet" type="text/css" />
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css" />
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M" name="google-site-verification" />

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css" />

<meta content="summary" name="twitter:card" />
<meta content="@springcentral" name="twitter:site" />
<meta name="twitter:title" content="Spring Security 3.2 M1 Highlights, Servlet 3 API Support" />
<meta name="twitter:description" content="&lt;p&gt;Last week I &lt;a href=&quot;http://www.springsource.org/node/3766&quot;&gt;announced the release of Spring Security 3.2 M1&lt;/a&gt; that contains improved Servlet 3 support. In this post, I will introduce some of the more exciting features found in the 3.2 M1 release. Specifically, we will take a look at the following new Spring Security features:&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;a href=&quot;#concurrency&quot;&gt;Concurrency Support&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;#servlet3-api&quot;&gt;Servlet 3 API Integration&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;#servlet3-async&quot;&gt;Servlet 3 Async Support&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;#springmvc-async&quot;&gt;Spring MVC Async Integration&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;a name=&quot;concurrency&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3&gt;Concurrency Support&lt;/h3&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;You might ask &quot;What is concurrency support doing in a release that has a Servlet 3 focused theme?&quot; The reason is that the concurrency support provides a foundation for all the other features found in this release. While the concurrency support is used by the Servlet 3 integration, it can also serve as building blocks to support concurrency and Spring Security in any application. Let&#39;s take a look at Spring Security&#39;s concurrency support now.&lt;/p&gt;
" />
<meta name="twitter:creator" content="@rob_winch" />
<meta name="twitter:image:src" content="https://gravatar.com/avatar/30ed046efb35c67d4c055dab109b8933?s=200" />

<meta property="og:title" content="Spring Security 3.2 M1 Highlights, Servlet 3 API Support" />
<meta property="og:image" content="https://gravatar.com/avatar/30ed046efb35c67d4c055dab109b8933?s=200" />
<meta property="og:description" content="&lt;p&gt;Last week I &lt;a href=&quot;http://www.springsource.org/node/3766&quot;&gt;announced the release of Spring Security 3.2 M1&lt;/a&gt; that contains improved Servlet 3 support. In this post, I will introduce some of the more exciting features found in the 3.2 M1 release. Specifically, we will take a look at the following new Spring Security features:&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;a href=&quot;#concurrency&quot;&gt;Concurrency Support&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;#servlet3-api&quot;&gt;Servlet 3 API Integration&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;#servlet3-async&quot;&gt;Servlet 3 Async Support&lt;/a&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;a href=&quot;#springmvc-async&quot;&gt;Spring MVC Async Integration&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;a name=&quot;concurrency&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3&gt;Concurrency Support&lt;/h3&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;You might ask &quot;What is concurrency support doing in a release that has a Servlet 3 focused theme?&quot; The reason is that the concurrency support provides a foundation for all the other features found in this release. While the concurrency support is used by the Servlet 3 integration, it can also serve as building blocks to support concurrency and Spring Security in any application. Let&#39;s take a look at Spring Security&#39;s concurrency support now.&lt;/p&gt;
" />
<meta content="article" property="og:type" />
<meta property="og:article:published_time" content="2012-12-17 19:34:00.0" />
</head>
<body>

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" style="display:none;visibility:hidden" width="0"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">Projects</a>
</li>
<li class="navbar-link">
<a href="/guides">Guides</a>
</li>
<li class="navbar-link active">
<a href="/blog">Blog</a>
</li>
<li class="navbar-link">
<a href="/services">Training & Certification</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form action="/search" class="form-inline form-search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search for documentation, guides, and posts..." type="text" value="" />
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form action="/search" class="form-inline form-search" method="get">
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search..." type="text" value="" />
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">
Home
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">
Projects
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">
Guides
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">
Blog
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">
Training & Certification
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>Engineering</div>
</div>
<div class="blog-category content--title">
<div>Releases</div>
</div>
<div class="blog-category content--title">
<div>News and Events</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Spring Security 3.2 M1 Highlights, Servlet 3 API Support</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">Engineering</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/30ed046efb35c67d4c055dab109b8933?s=20&amp;d=mm" />
<a class="author" rel="author" href="/team/rwinch">Rob Winch</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2012-12-17 19:34:00.0">December 17, 2012</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" data-disqus-identifier="501" href="/blog/2012/12/17/spring-security-3-2-m1-highlights-servlet-3-api-support#disqus_thread">
</a></div>
</div>
</header>
<div class="blog--post"><p>Last week I <a href="http://www.springsource.org/node/3766">announced the release of Spring Security 3.2 M1</a> that contains improved Servlet 3 support. In this post, I will introduce some of the more exciting features found in the 3.2 M1 release. Specifically, we will take a look at the following new Spring Security features:</p>
<ul>
<li><a href="#concurrency">Concurrency Support</a></li>
<li><a href="#servlet3-api">Servlet 3 API Integration</a></li>
<li><a href="#servlet3-async">Servlet 3 Async Support</a></li>
<li><a href="#springmvc-async">Spring MVC Async Integration</a></li>
</ul><p><a name="concurrency"></a><br /><h3>Concurrency Support</h3></p>
<p>You might ask "What is concurrency support doing in a release that has a Servlet 3 focused theme?" The reason is that the concurrency support provides a foundation for all the other features found in this release. While the concurrency support is used by the Servlet 3 integration, it can also serve as building blocks to support concurrency and Spring Security in any application. Let's take a look at Spring Security's concurrency support now.</p>
<h4>DelegatingSecurityContextRunnable</h4>
<p>One of the most fundamental building blocks within Spring Security's concurrency support is the <code>DelegatingSecurityContextRunnable</code>. It wraps a delegate <code>Runnable</code> in order to initialize the <code>SecurityContextHolder</code> with a specified <code>SecurityContext</code> for the delegate. It then invokes the delegate <code>Runnable</code> ensuring to clear the <code>SecurityContextHolder</code> afterwards. The <code>DelegatingSecurityContextRunnable</code> looks something like this:</p>
<pre><code class="prettyprint java">public void run() {
  try {
    SecurityContextHolder.setContext(securityContext);
    delegate.run();
  } finally {
    SecurityContextHolder.clearContext();
  }
}
</code></pre>
<p>While very simple, it makes it seamless to transfer the <code>SecurityContext</code> from one <code>Thread</code> to another. This is important since, in most cases, the <code>SecurityContextHolder</code> acts on a per <code>Thread</code> basis. For example, you might have used Spring Security's <a href="http://static.springsource.org/spring-security/site/docs/3.2.x/reference/ns-config.html#ns-global-method">&lt;global-method-security&gt; support</a> to secure one of your services. You can now easily transfer the <code>SecurityContext</code> of the current <code>Thread</code> to the <code>Thread</code> that invokes the secured service. An example of how you might do this can be found below:</p>
<pre><code class="prettyprint java"><br />Runnable originalRunnable = new Runnable() {
  public void run() {
    // invoke secured service
  }
};

SecurityContext context = SecurityContextHolder.getContext();
DelegatingSecurityContextRunnable wrappedRunnable =
    new DelegatingSecurityContextRunnable(originalRunnable, context);

new Thread(wrappedRunnable).start();
</code></pre>
<p>The code above performs the following steps:</p>
<ul>
<li>Creates a <code>Runnable</code> that will be invoking our secured service. Notice that it is not aware of Spring Security</li>
<li>Obtains the <code>SecurityContext</code> that we wish to use from the <code>SecurityContextHolder</code> and initializes the <code>DelegatingSecurityContextRunnable</code></li>
<li>Use the <code>DelegatingSecurityContextRunnable</code> to create a <code>Thread</code></li>
<li>Start the <code>Thread</code> we created</li>
</ul>
<p>Since it is quite common to create a <code>DelegatingSecurityContextRunnable</code> with the <code>SecurityContext</code> from the <code>SecurityContextHolder</code> there is a shortcut constructor for it. The following code is the same as the code above:</p>
<pre><code class="prettyprint java"><br />Runnable originalRunnable = new Runnable() {
  public void run() {
    // invoke secured service
  }
};

DelegatingSecurityContextRunnable wrappedRunnable =
    new DelegatingSecurityContextRunnable(originalRunnable);

new Thread(wrappedRunnable).start();
</code></pre>
<p>The code we have is simple to use, but it still requires knowledge that we are using Spring Security. In the next section we will take a look at how we can utilize <code>DelegatingSecurityContextExecutor</code> to hide the fact that we are using Spring Security.</p>
<h4>DelegatingSecurityContextExecutor</h4>
<p>In the previous section, we found that it was easy to use the <code>DelegatingSecurityContextRunnable</code>, but it was not ideal since we had to be aware of Spring Security in order to use it. Let's take a look at how <code>DelegatingSecurityContextExecutor</code> can shield our code from any knowledge that we are using Spring Security.</p>
<p>The design of <code>DelegatingSecurityContextExecutor</code> is very similar to that of <code>DelegatingSecurityContextRunnable</code> except it accepts a delegate <a href="https://docs.oracle.com/javase/6/docs/api/java/util/concurrent/Executor.html">Executor</a> instead of a delegate <code>Runnable</code>. You can see an example of how it might be used below:</p>
<pre><code class="prettyprint java"><br />SecurityContext context = SecurityContextHolder.createEmptyContext();
Authentication authentication = 
    new UsernamePasswordAuthenticationToken(&quot;user&quot;,&quot;doesnotmatter&quot;, AuthorityUtils.createAuthorityList(&quot;ROLE_USER&quot;));
context.setAuthentication(authentication);

SimpleAsyncTaskExecutor delegateExecutor =
    new SimpleAsyncTaskExecutor();
DelegatingSecurityContextExecutor executor =
    new DelegatingSecurityContextExecutor(delegateExecutor, context);

Runnable originalRunnable = new Runnable() {
  public void run() {
    // invoke secured service
  }
};

executor.execute(originalRunnable);
</code></pre>
<p>The code performs the following steps:</p>
<ul>
<li>Creates the <code>SecurityContext</code> to be used for our <code>DelegatingSecurityContextExecutor</code>. Note that in this example we simply create the <code>SecurityContext</code> by hand. However, it does not matter where or how we get the <code>SecurityContext</code> (i.e. we could obtain it from the <code>SecurityContextHolder</code> if we wanted).</li>
<li>Creates a delegateExecutor that is in charge of executing submitted <code>Runnable</code>s</li>
<li>Finally we create a <code>DelegatingSecurityContextExecutor</code> which is in charge of wrapping any <code>Runnable</code> that is passed into the execute method with a <code>DelegatingSecurityContextRunnable</code>. It then passes the wrapped <code>Runnable</code> to the delegateExecutor. In this instance, the same <code>SecurityContext</code> will be used for every <code>Runnable</code> submitted to our <code>DelegatingSecurityContextExecutor</code>. This is nice if we are running background tasks that need to be run by a user with elevated privileges.</li>
</ul>
<p>At this point you may be asking yourself "How does this shield my code of any knowledge of Spring Security?" Instead of creating the <code>SecurityContext</code> and the <code>DelegatingSecurityContextExecutor</code> in our own code, we can inject an already initialized instance of <code>DelegatingSecurityContextExecutor</code>.</p>
<pre><code class="prettyprint java"><br />@Autowired
private Executor executor; // becomes an instance of our DelegatingSecurityContextExecutor

public void submitRunnable() {
  Runnable originalRunnable = new Runnable() {
    public void run() {
      // invoke secured service
    }
  };
  executor.execute(originalRunnable);    
}
</code></pre>
<p>Now our code is unaware that the <code>SecurityContext</code> is being propagated to the <code>Thread</code>, then the originalRunnable is executed, and then the SecurityContextHolder is cleared out. In this example, the same user is being used to execute each <code>Thread</code>. What if we wanted to use the user from <code>SecurityContextHolder</code> at the time we invoked <code>executor.execute(Runnable)</code> (i.e. the currently logged in user) to process originalRunnable? This can be done by removing the <code>SecurityContext</code> argument from our <code>DelegatingSecurityContextExecutor</code> constructor. For example:</p>
<pre><code class="prettyprint java"><br />SimpleAsyncTaskExecutor delegateExecutor = new SimpleAsyncTaskExecutor();
DelegatingSecurityContextExecutor executor =
    new DelegatingSecurityContextExecutor(delegateExecutor);
</code></pre>
<p>Now anytime <code>executor.execute(Runnable)</code> is executed the <code>SecurityContext</code> is first obtained by the <code>SecurityContextHolder</code> and then that <code>SecurityContext</code> is used to create our <code>DelegatingSecurityContextRunnable</code>. This means that we are executing our <code>Runnable</code> with the same user that was used to invoke the <code>executor.execute(Runnable)</code> code.</p>
<h4>Spring Security Concurrency Classes</h4>
<p>Refer to the Javadoc for additional integrations with both the Java concurrent APIs and the Spring Task abstractions. They are quite self explanatory once you understand the previous code.</p>
<ul>
<li><a href="http://static.springsource.org/spring-security/site/docs/3.2.x/apidocs/org/springframework/security/concurrent/DelegatingSecurityContextCallable.html">DelegatingSecurityContextCallable</a></li>
<li><a href="http://static.springsource.org/spring-security/site/docs/3.2.x/apidocs/org/springframework/security/concurrent/DelegatingSecurityContextExecutor.html">DelegatingSecurityContextExecutor</a></li>
<li><a href="http://static.springsource.org/spring-security/site/docs/3.2.x/apidocs/org/springframework/security/concurrent/DelegatingSecurityContextScheduledExecutorService.html">DelegatingSecurityContextExecutorService</a></li>
<li><a href="http://static.springsource.org/spring-security/site/docs/3.2.x/apidocs/org/springframework/security/concurrent/DelegatingSecurityContextRunnable.html">DelegatingSecurityContextRunnable</a></li>
<li><a href="http://static.springsource.org/spring-security/site/docs/3.2.x/apidocs/org/springframework/security/concurrent/DelegatingSecurityContextScheduledExecutorService.html">DelegatingSecurityContextScheduledExecutorService</a></li>
<li><a href="http://static.springsource.org/spring-security/site/docs/3.2.x/apidocs/org/springframework/security/scheduling/DelegatingSecurityContextSchedulingTaskExecutor.html">DelegatingSecurityContextSchedulingTaskExecutor</a></li>
<li><a href="http://static.springsource.org/spring-security/site/docs/3.2.x/apidocs/org/springframework/security/task/DelegatingSecurityContextAsyncTaskExecutor.html">DelegatingSecurityContextAsyncTaskExecutor</li>
<li><a href="http://static.springsource.org/spring-security/site/docs/3.2.x/apidocs/org/springframework/security/task/DelegatingSecurityContextTaskExecutor.html">DelegatingSecurityContextTaskExecutor</a></li>
</ul><p><a name="servlet3-api"></a><br /><h3>Servlet 3 API Integration</h3></p>
<p>Spring Security has supported Servlet API integration for quite some time. However, it wasn't until 3.2 M1 that it supported the new methods added in Servlet 3. In this section we will discuss each of the methods that Spring Security integrates with. If you want to see this in action, you can import Spring Security into Spring Tool Suite using the Gradle Plugin and run <a href="https://github.com/SpringSource/spring-security/tree/master/samples/servletapi">servletapi sample application</a>.</p>
<h4>HttpServletRequest.authenticate(HttpServletRequest,HttpServletResponse)</h4>
<p>Spring Security now integrates with <a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#authenticate%28javax.servlet.http.HttpServletResponse%29">HttpServletRequest.authenticate(HttpServletRequest,HttpServletResponse)</a>. In short, we can use this method to ensure that a user is authenticated. If they are not authenticated, the configured <a href="static.springsource.org/spring-security/site/docs/3.1.x/reference/technical-overview.html#tech-intro-auth-entry-point">AuthenticationEntryPoint</a> will be used to request the user to authenticate (i.e. redirect to the login page).</p>
<h4>HttpServletRequest.login(String,String)</h4>
<p>Spring Security now integrates with <a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#login%28java.lang.String,%20java.lang.String%29">HttpServletRequest.login(String,String)</a>. User's can utilize this method to authenticate a username and password with Spring Security. If authentication fails, a <code>ServletException</code> that wraps the original Spring Security <code>AuthenticationException</code> will be thrown. This means if you allow the <code>ServletException</code> to propagate Spring Security's <code>ExceptionTranslationFilter</code> will handle it for you. Alternatively, you can catch the <code>ServletException</code> and handle it yourself.</p>
<h4>HttpServletRequest.logout()</h4>
<p>Spring Security now integrates with <a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#logout%28%29">HttpServletRequest.logout()</a> by invoking the configured <code>LogoutHandler</code> implementations. Typically this means that the <code>SecurityContextHolder</code> will be cleared out, the <code>HttpSession</code> will be invalidated, any "Remember Me" authentication will be cleaned up, etc. However, the configured <code>LogoutHandler</code> implementations will vary depending on your Spring Security configuration. It is important to note that after <code>HttpServletRequest.logout()</code> has been invoked, you are still in charge of writing a response out. Typically this would involve a redirect to the welcome page.</p>
<h4>AsyncContext.start(Runnable)</h4><p><p>The <a href="https://docs.oracle.com/javaee/6/api/javax/servlet/AsyncContext.html#start%28java.lang.Runnable%29">AsynchContext.start(Runnable)</a> method that ensures your credentials will be propagated to the new <code>Thread</code>. Using Spring Security&rsquo;s newly added concurrency support, Spring Security overrides the <code>AsyncContext.start(Runnable)</code> to ensure that the current <code>SecurityContext</code> is used when processing the <code>Runnable</code>.</p><p><a name="servlet3-async"></a><br /><h3>Servlet 3 Async Support</h3></p>
<p>Spring Security now supports Servlet 3, Async requests. So how do you use it?</p>
<p>The first step is to ensure you have updated your web.xml to use the 3.0 schema as shown below:</p>
<pre><code class="prettyprint xml"><br />&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;
  version=&quot;3.0&quot;&gt;

&lt;/web-app&gt;
</code></pre>
<p>Next you need to ensure that your springSecurityFilterChain is setup for processing asynchronous requests.</p>
<pre><code class="prettyprint xml"><br />&lt;filter&gt;
  &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;
  &lt;filter-class&gt;
    org.springframework.web.filter.DelegatingFilterProxy
  &lt;/filter-class&gt;
  &lt;async-supported&gt;true&lt;/async-supported&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
  &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;
  &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;
  &lt;dispatcher&gt;ASYNC&lt;/dispatcher&gt;
&lt;/filter-mapping&gt;
</code></pre>
<p>That's it! Now Spring Security will ensure that your <code>SecurityContext</code> is propagated on asynchronous requests too.</p>
<p>So what has changed? Internal refactoring within Spring Security will ensure that your <code>SecurityContext</code> is no longer cleared out when a response was committed on another <code>Thread</code>, resulting in a user who appeared to be logged out. Additionally, you can use the Spring Security concurrency support and Spring Security's <code>AsyncContext.start(Runnable)</code> integration to assist you in processing Servlet requests.</p><p><a name="springmvc-async"></a><br /><h3>Spring MVC Async Integration</h3></p><p><div class="callout">
<div class="callout-title">Associating SecurityContext to Callable&rsquo;s</div>
<br />More technically speaking, Spring Security integrates with <a href="http://static.springsource.org/spring/docs/current/javadoc-api/org/springframework/web/context/request/async/WebAsyncManager.html">WebAsyncManager</a>. The <code>SecurityContext</code> that is used to process the <code>Callable</code> is the <code>SecurityContext</code> that exists on the <code>SecurityContextHolder</code> at the time startCallableProcessing is invoked.<br />
</div></p>
<p>As <a href="http://blog.springsource.org/author/rstoyanchev/">Rossen</a> demonstrated in a previous blog post, Spring Web MVC 3.2 has <a href="http://blog.springsource.org/2012/05/06/spring-mvc-3-2-preview-introducing-servlet-3-async-support/">excellent Servlet 3 Async Support</a>. With no additional configuration, Spring Security will automatically setup the <code>SecurityContext</code> to the <code>Thread</code> that executes a <code>Callable</code> returned by your controllers. For example, the following method will automatically have its <code>Callable</code> executed with the <code>SecurityContext</code> that was available when the <code>Callable</code> was created:</p>
<pre><code class="prettyprint java"><br />@RequestMapping(method=RequestMethod.POST)
public Callable&lt;String&gt; processUpload(final MultipartFile file) {
 
  return new Callable&lt;String&gt;() {
    public Object call() throws Exception {
      // ...
      return &quot;someView&quot;;
    }
  };
}
</code></pre><p><p>There is no automatic integration with a <code>DeferredResult</code> that is returned by controllers. This is because <code>DeferredResult</code> is processed by the users and thus there is no way of automatically integrating with it. However, you can still use <a href="#concurrency">Concurrency Support</a> to provide transparent integration with Spring Security.</p>
<h3>Feedback Please</h3>
<p>I hope this gives you a better understanding of the changes that are available in Spring Security 3.2. M1 and gets you excited for the next milestone. As a member of the community I encourage you to try out the new milestone and report any bugs/enhancements in <a href="https://jira.springsource.org/browse/SEC">JIRA</a>. This feedback is a simple, yet very important way to give back to the community!</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 501;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>
Back
</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">All Posts</a>
<a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
 <div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">Engineering</a>
<a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">Releases</a>
<a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">News and Events</a>
<a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>Get updates from The Spring Team delivered to your inbox</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">Tools</a></li>
<li><a href="https://store.pivotal.io/">Store</a></li>
<li><a href="/blog">Newsletter</a></li>
</ul>
</div>
</div>
&copy; <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a>, Inc. All Rights Reserved.
<a href="https://pivotal.io/terms-of-use">Terms of Use</a> &bullet;
<a href="https://pivotal.io/privacy-policy">Privacy</a> &bullet;
<a href="/trademarks">Trademark Guidelines</a>
<div id="teconsent" style="display:inline-block;"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>