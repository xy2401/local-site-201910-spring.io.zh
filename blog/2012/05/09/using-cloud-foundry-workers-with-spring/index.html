<html  data-code-prettify="" data-mobile-support="" data-search=""><head></head><body >﻿
<title>在Spring中使用Cloud Foundry Worker</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Using Cloud Foundry Workers with Spring">
<meta name="twitter:description" >
<meta name="twitter:creator" content="@starbuxman">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=200">

<meta property="og:title" content="Using Cloud Foundry Workers with Spring">
<meta property="og:image" content="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=200">
<meta property="og:description" >
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2012-05-09 16:33:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">在Spring中使用Cloud Foundry Worker</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=20&d=mm"> <a class="author" rel="author" href="/team/jlong">乔什·朗（Josh Long）</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2012-05-09 16:33:00.0">2012年5月9日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2012/05/09/using-cloud-foundry-workers-with-spring#disqus_thread" data-disqus-identifier="471">
</a></div>
</div>
</header>
<div class="blog--post"><p></p><p>您无疑已经阅读了<a href="http://blog.springsource.org/author/jhickey/">Jennifer Hickey</a>的精彩博客文章，其中<a href="http://blog.cloudfoundry.com/post/13481011624/cloud-foundry-improves-support-for-background-processing">介绍了Cloud Foundry工人</a> ，他们在设置<a href="http://blog.cloudfoundry.com/post/13481011636/running-resque-workers-on-cloud-foundry">Ruby Resque后台作业</a>中的应用以及<a href="http://blog.cloudfoundry.com/post/13481011979/running-workers-on-cloud-foundry-with-spring">今天的文章中介绍了Spring支持</a> 。<br></p> <h2>Spring开发人员要点</h2> <ol> <li>您需要更新您的<code>vmc</code>与<code>gem update vmc</code> 。</li> <li>Cloud Foundry工作者让您运行<code>public static void main</code>职位。也就是说，Cloud Foundry工作者基本上是一个过程，其级别低于Web应用程序，它自然地映射到许多所谓的<em>后台</em>工作。</li> <li>您需要提供Cloud Foundry将运行的命令。您可以提供<code>java</code>你想使用它的咒语，但是要发布一个shell脚本，让Cloud Foundry代为运行该shell脚本要容易得多。您提供的命令应采用<code>$JAVA_OPTS</code> ，Cloud Foundry已提供该文件以确保一致的内存使用情况和JVM设置。</li> <li>有多种方法可以自动创建Cloud Foundry可部署应用程序。如果您使用的是Maven，则<a href="http://mojo.codehaus.org/appassembler/"><code>org.codehaus.mojo:appassembler-maven-plugin</code></a>插件将帮助您创建启动脚本并打包您的<code>.jars</code>为了易于部署以及指定入口点类。</li> <li>其他一切基本相同。当你做<code>vmc push</code>在Java上<code>.jar</code>项目，Cloud Foundry将询问您该应用程序是否为独立应用程序。确认，然后它将引导您完成设置。</li> </ol> <p>因此，让我们看一下Cloud Foundry工作者可以更轻松，更自然地使用的一些通用架构和安排。我们将通过Spring Framework 以及两个周围的项目<a href="http://www.springsource.org/spring-integration">Spring Integration</a>和<a href="http://www.springsource.org/spring-batch">Spring Batch</a>来研究这些模式，这两个项目在Web应用程序之内和之外都非常流行。正如我们将看到的，这两个框架都支持去耦和改进的可组合性。我们将断开它发生<em>的时候</em> <em>会</em>发生<em>什么</em> ，我们会断开它发生<em>在哪里</em>发生<em>了什么</em> ，无论是在前端释放产能的名称。</p> <h2>我有时间表要遵守！</h2> <p>我遇到的一个常见问题是： <em>如何在Cloud Foundry上进行作业调度？</em> Cloud Foundry支持Spring应用程序，而Spring当然一直支持诸如<a href="http://quartz-scheduler.org/">Quartz</a>和Spring 3.0的企业级调度抽象。 <code><a href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/scheduling/annotation/Scheduled.html">@Scheduled</a></code>注解。 <code>@Scheduled</code>是非常好的，因为它是<em>超级</em>方便地添加到现有的应用程序。在最简单的情况下，您可以添加<code><a href="http://static.springsource.org/spring/docs/3.1.x/javadoc-api/org/springframework/scheduling/annotation/EnableScheduling.html">@EnableScheduling</a></code>到您的Java配置或<code><a href="http://blog.springsource.org/2010/01/05/task-scheduling-simplifications-in-spring-3-0/"><task:annotation-driven/></a></code>到您的XML，然后使用<code>@Scheduled</code>代码中的注释。这在企业应用程序中是很自然的事情-也许您有需要运行的分析或报告流程？一些长期运行的批处理过程？我整理了一个示例，演示了如何使用<code>@Scheduled</code>运行<a href="http://www.springsource.org/spring-batch">Spring批处理</a> <code>Job</code> 。Spring Batch作业本身是与Web服务一起使用的工作线程，该Web服务的SLA较差，因此不适合实时使用。在Spring Batch中处理工作是更安全，更干净的，它的恢复和重试功能弥补了网络中断，网络延迟等方面的不足。我将向您提供<a href="https://github.com/cloudfoundry-samples/stock-workers/tree/master/cf-workers-batch">代码示例，以供参考</a> 。将只看入口点，然后看将应用程序部署到Cloud Foundry。</p><p></p>
<pre><code class="prettyprint java"><br />// set to every 10s for testing.
@Scheduled(fixedRate = 10 * 1000)
public void runNightlyStockPriceRecorder() throws Throwable {
	JobParameters params = new JobParametersBuilder()
		.addDate(&quot;date&quot;, new Date())
		.toJobParameters();
	JobExecution jobExecution = jobLauncher.run(job, params);
	BatchStatus batchStatus = jobExecution.getStatus();
	while (batchStatus.isRunning()) {
		logger.info(&quot;Still running...&quot;);
		Thread.sleep(1000);
	}
	logger.info(String.format(&quot;Exit status: %s&quot;, jobExecution.getExitStatus().getExitCode()));
	JobInstance jobInstance = jobExecution.getJobInstance();
	logger.info(String.format(&quot;job instance Id: %d&quot;, jobInstance.getId()));
}
</code></pre><p></p><p>该方法将以指定的频率调用<code>@Scheduled</code>注释：在这种情况下，每10秒。之后<code>Job</code>已使用<code>JobLauncher</code> ，应用程序会阻塞（可以避免这种情况，但是在这种情况下，因为我们期望它可以，所以可以）。根据数据和批处理过程的类型，它可能会阻塞几分钟甚至一星期！Spring Batch是一个强大的批处理引擎，它可以安全地处理大型数据集。批处理进程通常与HTTP请求不在同一个管道中-它是决定性的，长期运行的，因此能够在Cloud Foundry中使用长期运行的工作程序是一个真正的胜利。</p><p>让我们将应用程序部署到Cloud Foundry。示例应用程序是Maven项目。要构建它们，请转到代码库的根目录并运行<code>mvn clean install</code>使用<a href="https://maven.apache.org/">Maven</a>构建工具。</p><p>假设您已经设置了<code>vmc</code>命令行工具并更新为最新版本， <a href="http://blog.cloudfoundry.com/post/13481011624/cloud-foundry-improves-support-for-background-processing">如Jennifer在第一篇文章中解释的</a> 。该应用程序附带<code>manifest.yml</code>在代码的根部。云铸造<code>manifest.yml</code>文件完全描述了应用程序希望通过平台即服务为其提供的所有内容，包括要使用的数据库，要使用的内存量等等。Cloud Foundry会读取此清单并在部署应用程序时执行它。因此，通过部署该应用程序的纯粹行为，您还将获得该应用程序需要存储示例数据以及Spring Batch为其运行时状态维护的表的PostgreSQL数据库实例。</p><p></p>
<pre><code class="prettyprint shell"><br />jlongmbp17:cf-workers-batch jlong$ vmc --path target/appassembler/ push 
Pushing application &#39;batch&#39;...
Creating Application: OK
Creating Service [stock_batch]: OK
Binding Service [stock_batch]: OK
Uploading Application:
  Checking for available resources: OK
  Processing resources: OK
  Packing application: OK
  Uploading (55K): OK   
Push Status: OK
Staging Application &#39;batch&#39;: OK                                                 
Starting Application &#39;batch&#39;: OK      
                                          
jlongmbp17:cf-workers-batch jlong$ vmc apps
+---------------------+----+---------+----------------------------------+----------------+
| Application         | #  | Health  | URLS                             | Services       |
+---------------------+----+---------+----------------------------------+----------------+
| batch               | 1  | RUNNING |                                  | stock_batch    |
...
</code></pre>
<p>计划的方法每十秒钟运行一次，因此请等待十秒钟，然后再执行下一步。接下来，我们将登录数据库以查看我们的小过程完成了什么。“Spring Batch处理”作业将使用<code>STOCKS</code>表格，然后查找其当前的定价信息，然后将该快照数据插入到<code>STOCKS_DATA</code>表。的<code>vmc tunnel</code>该命令直接在由云管理的数据库中创建隧道。我用它进入我们的PostgreSQL实例并运行查询（ <code>SELECT * FROM STOCKS_DATA</code> ） <code>STOCKS_DATA</code>表。</p>
<pre><code class="prettyprint shell"><br />jlongmbp17:cf-workers-batch jlong$ vmc tunnel stock_batch
Binding Service [stock_batch]: OK
Stopping Application &#39;caldecott&#39;: OK
Staging Application &#39;caldecott&#39;: OK                                             
Starting Application &#39;caldecott&#39;: OK                                            
Getting tunnel connection info: OK

Service connection info: 
  username : u59993cf15bc0461a1d2648f7eab27f2da15f
  password : p1be9035f3c764817809ac81f3267
  name     : d5c5a80838d7bcd79dc7eefa6c1b04d22

Starting tunnel to stock_batch on port 10002.
1: none
2: psql
Which client would you like to start?: 2
Launching &#39;psql -h localhost -p 10002 -d d5c5aefa6c1b04d2280838d7bcd79dc7e -U u59993cf15bc04817809ac861a1d2648f -w&#39;

psql (9.0.5, server 9.0.4)
Type &quot;help&quot; for help.

d5c5aefa6c1b04d2280838d7bcd79dc7e=&gt; select * from stocks_data;
 id | date_analysed | high_price | low_price | closing_price | symbol 
----+---------------+------------+-----------+---------------+--------
  1 | 2012-05-08    |        613 |     602.3 |         602.3 | GOOG
  2 | 2012-05-08    |      30.78 |     30.25 |         30.25 | MSFT
  3 | 2012-05-08    |      27.87 |     27.56 |         27.56 | ORCL
  4 | 2012-05-08    |      32.41 |     32.06 |         32.06 | ADBE
  5 | 2012-05-08    |     107.38 |       103 |           103 | VMW
...
</code></pre>
<p>有效！在我们继续之前，现在是关闭应用程序的<em>好</em>时机。每十秒钟查找一次这些库存，每次插入新记录，对您绝对没有好处！在几个小时内，该数据集可能会变得不堪重负。我建议您更改频率（请参阅注释以获取<code>cron</code>您可以在<code>@Scheduled</code>注释，该注释在每个工作日的晚上11点运行），然后执行<code>vmc --path target/appassembler/ update</code> ，或者只是停止它。</p>
<pre><code class="prettyprint shell">jlongmbp17:cf-workers-batch jlong$ vmc stop batch
</code></pre><p></p><p>因此，批处理和作业调度是Spring和Spring Batch和Cloud Foundry认真处理的两个非常常见的用例。另一个（不同但同样普遍）的用例是架构设计，以简化可伸缩性。毕竟，当您的下一个大型应用程序是<a href="https://en.wikipedia.org/w/index.php?title=Oprah_Effect&redirect=no"><em>Oprah'd</em></a>或<a href="https://en.wikipedia.org/wiki/Slashdot_effect"><code>/.’d</code></a> ？现在让我们来看一下...</p><br><h2>嘿!到达队列的后面！</h2><br><p>这有点与直观性相反，但是与单个整体应用程序相比，具有许多小型，单独聚焦组件的系统更易于扩展，因为可以独立于应用程序的其他部分扩展和调整单个工作负载。假设您有一个资源匮乏的前端Web应用程序，该应用程序不应被速度较慢，可能负担I / O的功能所困扰。使主线程与较慢的后台进程脱钩的一种简单方法是引入消息队列， <a href="http://www.rabbitmq.org">例如RabbitMQ</a> 。在消息传递中，我们谈论了<em>积极的消费者</em>模式，即工作入队，工作人员以他们能够完成的速度尽快将其出队。如果工人不能跟上新工作的进度，那么添加新工人就可以轻松解决问题： <code>vmc instances my-backend +10</code> ！每个单独的请求可能仍会花费固定的时间，但是会增加系统的整体吞吐量。</p><p>对于我们的下一个示例-与我们上一个示例几乎没有什么关系，只是它是在Cloud Foundry上使用独立工作进程的另一种方式-我们将研究构建面向消息传递的服务。我们将使用<a href="http://rabbitmq.org">RabbitMQ</a> ，这是世界一流的消息队列，可在Cloud Foundry上作为服务使用。邮件系统只是众所周知的邮箱。他们接受消息并分发消息。通过将您的<em>API</em>简化为RabbitMQ之类的消息传递代理，该代理本身是基于协议AMQP的，从而使您的应用程序尽可能地友好。消息传递系统就其本质而言也是异步的，因此尽管也支持消息/应答交换的概念，但它们并不强加于此。如果您想利用RabbitMQ与其他工作人员集成，您仍然可以向服务的用户公开一个<em>Facade</em>或<em>网关</em> ，这样，如果您不想让他们不需要了解服务的实现方式，至。我们将使用支持<a href="http://www.eaipatterns.com/">企业集成模式的</a> Spring Integration从Java接口类型构建<em>消息传递网关</em> 。</p><br> <p><br>Java</p><p>公共接口StockSymbolLookupClient {<br>StockSymbolLookup lookupSymbol（字符串符号）抛出Throwable；<br>}<br>```<br></p><p>在Spring Integration的帮助下，对该方法的调用将导致一条消息发送到RabbitMQ，在另一方面，我们的服务将使该消息出队，进行处理，然后最终将答复发送回RabbitMQ，RabbitMQ的调用者此方法将作为回复值。</p> <p>为了配置客户端，我使用了一些Spring Integration来设置网关，然后将请求转发到出站AMQP网关适配器。</p><p></p>
<pre><code class="prettyprint xml"><br />&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
	&lt;beans:beans ...&gt;
	    ...
	    &lt;gateway
	            service-interface=&quot;org.cloudfoundry.workers.stocks.integration.client.StockClientGateway&quot;
	            default-request-channel=&quot;outboundSymbolsRequests&quot;
	            default-reply-channel=&quot;outboundSymbolsReplies&quot;
	    /&gt;

	    &lt;amqp:outbound-gateway
	            request-channel=&quot;outboundSymbolsRequests&quot;
	            reply-channel=&quot;outboundSymbolsReplies&quot;
	            routing-key=&quot;tickers&quot;
	            amqp-template=&quot;amqpTemplate&quot;
	    /&gt;
	&lt;/beans:beans&gt;
</code></pre><p></p><p>我已经省略了RabbitMQ专用连接机制的详细信息（当然，所有这些都是使用<code>cloudfoundry-runtime</code> API）-请参阅<a href="https://github.com/cloudfoundry-samples/stock-workers/tree/master/cf-workers-integration-client">客户端示例</a> 。此代码段显示了重要的一点：Spring将在运行时根据<code>StockClientGateway</code><code>interface</code>我们可以注入这些代码，然后使用我们的客户端代码来调用该服务。</p><p>在服务方面，我们需要一些代码来从RabbitMQ出队消息，然后将其转发给主力马，然后将结果作为答复通过RabbitMQ传递回去。服务端，当然，我们可以独立于客户端进行扩展。您可能每个Web应用程序只有一个客户端，但是正在运行十个服务实现，这占用了您的时间并吸收了额外的需求。这是我们的服务实现的样子，再次省略了RabbitMQ特定的连接bean（ <a href="https://github.com/cloudfoundry-samples/stock-workers/tree/master/cf-workers-integration-service">请参阅示例</a> ）：</p> <p></p>
<pre><code class="prettyprint xml"><br />&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
	&lt;beans:beans ...&gt;
	    ...
	    &lt;amqp:inbound-gateway request-channel=&quot;inboundSymbolsRequests&quot;
		    queue-names=&quot;tickers&quot;
		    message-converter=&quot;mc&quot;
		    connection-factory=&quot;connectionFactory&quot;/&gt;

	    &lt;service-activator ref=&quot;client&quot; input-channel=&quot;inboundSymbolsRequests&quot; requires-reply=&quot;true&quot;/&gt;

	&lt;/beans:beans&gt;
</code></pre><p></p><p>这种方法非常强大。在我的示例中，我只是推迟了RESTful Web服务调用的微不足道的费用。但是您可能会想像用这种方式做更长的事情-图像处理，批处理作业，大型分析等。</p> <p>此示例的部署稍微复杂一些，因为有两部分。网关实现是一个简单的bean，Spring Integration将其用作消息传递系统的一种客户端代理。我们可以使用来自其他后台作业，Web应用程序或其他任何东西的网关。在我们的例子中，我们的客户端-一个Spring MVC应用程序-使用网关来调用服务。该服务提供了有趣的功能，它从已调配的RabbitMQ实例接收请求，并调用股票报价器查找bean，然后将结果通过RabbitMQ返回给请求者。我们需要首先部署服务。和以前一样，您需要通过运行来构建整个代码库<code>mvn clean install</code>从根本上讲（如果还没有的话）。然后，从<code>cf-workers-integration-service</code>文件夹，运行以下命令：</p>
<pre><code class="prettyprint shell"><br />jlongmbp17:cf-workers-integration-service jlong$ vmc --path target/appassembler/ push 
Pushing application &#39;integration-service&#39;...
Creating Application: OK
Creating Service [stock_rabbitmq]: OK
Binding Service [stock_rabbitmq]: OK
Uploading Application:
  Checking for available resources: OK
  Processing resources: OK
  Packing application: OK
  Uploading (44K): OK   
Push Status: OK
Staging Application &#39;integration-service&#39;: OK                                   
Starting Application &#39;integration-service&#39;: OK                                  
</code></pre><p></p><p>有了该服务，让我们通过从Web客户端调用一次就可以对其进行测试。返回<code>cf-workers-integration-webclient</code>目录。然后，运行与该服务相同的命令。</p>
<pre><code class="prettyprint shell">jlongmbp17:cf-workers-integration-webclient jlong$ vmc --path target/cf-workers-integration-webclient-1.0-SNAPSHOT push
Pushing application &#39;integration-webclient&#39;...
Creating Application: OK
Binding Service [stock_rabbitmq]: OK
Uploading Application:
  Checking for available resources: OK
  Processing resources: OK
  Packing application: OK
  Uploading (3K): OK   
Push Status: OK
Staging Application &#39;integration-webclient&#39;: OK                                 
Starting Application &#39;integration-webclient&#39;: OK                                                         
</code></pre><p></p><p>部署应用程序后（您可以通过运行以下命令确认两者均运行良好） <code>vmc apps</code> ）。现在，让我们打开客户端并尝试我们的服务：打开webclient应用程序的URL。在我的情况下，URL是<a href="http://integration-webclient.cloudfoundry.com/">Integration-webclient.cloudfoundry.com</a> 。它应该给您看起来像行人的形式。输入股票代码（我通过<code>VMW</code> …），然后<em>按Enter</em> 。您应该在页面上看到数据清单。</p><div style="float:right"> <img src="http://blog.springsource.org/wp-content/uploads/2012/05/stock-webclient1.png" width="600"> </div><br>如果您随后查阅<code>integration-service</code> ，您应该看到控制台输出反映的信息与您在客户端看到的信息完全相同。如果是这样，恭喜！<p></p><br><h2>从这往哪儿走</h2><p>在这一点上，您触手可及。Cloud Foundry工作者是处理HTTP请求处理管道中不自然的工作的理想场所。以我的经验，这涉及很多方面：批处理，集成和消息传递代码，分析，报告，大数据和补偿性交易，以及除HTTP之外还通过其他协议公开的系统。</p> <p></p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 471;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>