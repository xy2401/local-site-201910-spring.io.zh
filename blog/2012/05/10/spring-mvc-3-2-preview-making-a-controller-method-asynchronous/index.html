<!DOCTYPE html>
<html data-code-prettify="" data-mobile-support="" data-search="">
<head>
<title>Spring MVC 3.2 Preview: Making a Controller Method Asynchronous</title>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no" id="Viewport" name="viewport" />
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png" />
<link href="https://fonts.googleapis.com/css?family=Varela+Round|Montserrat:400,700" rel="stylesheet" type="text/css" />
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css" />
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M" name="google-site-verification" />

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css" />

<meta content="summary" name="twitter:card" />
<meta content="@springcentral" name="twitter:site" />
<meta name="twitter:title" content="Spring MVC 3.2 Preview: Making a Controller Method Asynchronous" />
<meta name="twitter:description" content="&lt;p&gt;&lt;strong&gt;&lt;em&gt;Last updated on November 5th, 2012 (Spring MVC 3.2 RC1)&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In &lt;a href=&quot;http://blog.springsource.org/2012/05/06/spring-mvc-3-2-preview-introducing-servlet-3-async-support/&quot;&gt;previous&lt;/a&gt; &lt;a href=&quot;http://blog.springsource.org/2012/05/08/spring-mvc-3-2-preview-techniques-for-real-time-updates/&quot;&gt;posts&lt;/a&gt; I introduced the Servlet 3 based async capability in Spring MVC 3.2 and discussed techniques for real-time updates. In this post I&#39;ll go into more technical details and discuss how asynchronous processing fits into the Spring MVC request lifecycle.&lt;/p&gt;
&lt;p&gt;As a quick reminder, you can make &lt;em&gt;any&lt;/em&gt; existing controller method asynchronous by changing it to return a &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/Callable.html&quot;&gt;Callable&lt;/a&gt;. For example a controller method that returns a view name, can return &lt;code&gt;Callable&amp;lt;String&amp;gt;&lt;/code&gt; instead. An &lt;code&gt;@ResponseBody&lt;/code&gt; that returns an object called &lt;code&gt;Person&lt;/code&gt; can return &lt;code&gt;Callable&amp;lt;Person&amp;gt;&lt;/code&gt; instead. And the same is true for &lt;em&gt;any&lt;/em&gt; other controller return value type.&lt;/p&gt;
" />
<meta name="twitter:creator" content="@rstoya05" />
<meta name="twitter:image:src" content="https://gravatar.com/avatar/4b12b9c0c665bc0345467c1a218ed0f7?s=200" />

<meta property="og:title" content="Spring MVC 3.2 Preview: Making a Controller Method Asynchronous" />
<meta property="og:image" content="https://gravatar.com/avatar/4b12b9c0c665bc0345467c1a218ed0f7?s=200" />
<meta property="og:description" content="&lt;p&gt;&lt;strong&gt;&lt;em&gt;Last updated on November 5th, 2012 (Spring MVC 3.2 RC1)&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In &lt;a href=&quot;http://blog.springsource.org/2012/05/06/spring-mvc-3-2-preview-introducing-servlet-3-async-support/&quot;&gt;previous&lt;/a&gt; &lt;a href=&quot;http://blog.springsource.org/2012/05/08/spring-mvc-3-2-preview-techniques-for-real-time-updates/&quot;&gt;posts&lt;/a&gt; I introduced the Servlet 3 based async capability in Spring MVC 3.2 and discussed techniques for real-time updates. In this post I&#39;ll go into more technical details and discuss how asynchronous processing fits into the Spring MVC request lifecycle.&lt;/p&gt;
&lt;p&gt;As a quick reminder, you can make &lt;em&gt;any&lt;/em&gt; existing controller method asynchronous by changing it to return a &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/Callable.html&quot;&gt;Callable&lt;/a&gt;. For example a controller method that returns a view name, can return &lt;code&gt;Callable&amp;lt;String&amp;gt;&lt;/code&gt; instead. An &lt;code&gt;@ResponseBody&lt;/code&gt; that returns an object called &lt;code&gt;Person&lt;/code&gt; can return &lt;code&gt;Callable&amp;lt;Person&amp;gt;&lt;/code&gt; instead. And the same is true for &lt;em&gt;any&lt;/em&gt; other controller return value type.&lt;/p&gt;
" />
<meta content="article" property="og:type" />
<meta property="og:article:published_time" content="2012-05-10 18:16:00.0" />
</head>
<body>

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" style="display:none;visibility:hidden" width="0"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">Projects</a>
</li>
<li class="navbar-link">
<a href="/guides">Guides</a>
</li>
<li class="navbar-link active">
<a href="/blog">Blog</a>
</li>
<li class="navbar-link">
<a href="/services">Training & Certification</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form action="/search" class="form-inline form-search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search for documentation, guides, and posts..." type="text" value="" />
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form action="/search" class="form-inline form-search" method="get">
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search..." type="text" value="" />
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">
Home
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">
Projects
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">
Guides
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">
Blog
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">
Training & Certification
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>Engineering</div>
</div>
<div class="blog-category content--title">
<div>Releases</div>
</div>
<div class="blog-category content--title">
<div>News and Events</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Spring MVC 3.2 Preview: Making a Controller Method Asynchronous</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">Engineering</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/4b12b9c0c665bc0345467c1a218ed0f7?s=20&amp;d=mm" />
<a class="author" rel="author" href="/team/rstoyanchev">Rossen Stoyanchev</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2012-05-10 18:16:00.0">May 10, 2012</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" data-disqus-identifier="470" href="/blog/2012/05/10/spring-mvc-3-2-preview-making-a-controller-method-asynchronous#disqus_thread">
</a></div>
</div>
</header>
<div class="blog--post"><p><strong><em>Last updated on November 5th, 2012 (Spring MVC 3.2 RC1)</em></strong></p>
<p>In <a href="http://blog.springsource.org/2012/05/06/spring-mvc-3-2-preview-introducing-servlet-3-async-support/">previous</a> <a href="http://blog.springsource.org/2012/05/08/spring-mvc-3-2-preview-techniques-for-real-time-updates/">posts</a> I introduced the Servlet 3 based async capability in Spring MVC 3.2 and discussed techniques for real-time updates. In this post I'll go into more technical details and discuss how asynchronous processing fits into the Spring MVC request lifecycle.</p>
<p>As a quick reminder, you can make <em>any</em> existing controller method asynchronous by changing it to return a <a href="https://docs.oracle.com/javase/6/docs/api/java/util/concurrent/Callable.html">Callable</a>. For example a controller method that returns a view name, can return <code>Callable&lt;String&gt;</code> instead. An <code>@ResponseBody</code> that returns an object called <code>Person</code> can return <code>Callable&lt;Person&gt;</code> instead. And the same is true for <em>any</em> other controller return value type.</p>
<p>A central idea is that all of what you already know about how a controller method works remains unchanged as much as possible except that the remaining processing will occur in another thread. When it comes to asynchronous execution it's important to keep things simple. As you'll see even with this seemingly simple programming model change, there is quite a bit to consider.</p>
<p>The <a href="https://github.com/SpringSource/spring-mvc-showcase">spring-mvc-showcase</a> has been updated for Spring MVC 3.2. Have a look at <a href="https://github.com/SpringSource/spring-mvc-showcase/blob/master/src/main/java/org/springframework/samples/mvc/async/CallableController.java#L13">CallableController</a>. Method annotations like <code>@ResponseBody</code> and <code>@ResponseStatus</code> apply to the return value from the <code>Callable</code> as well, as you might expect. Exceptions raised from a <code>Callable</code> are handled as if they were raised by the controller, in this case with an <code>@ExceptionHandler</code> method. And so on.</p>
<p>If you execute one of the <code>CallableController</code> methods through the "Async Requests" tab in the browser, you should see output similar to the one below:</p>
<pre><code class="prettyprint code">08:25:15 [http-bio-8080-exec-10] DispatcherServlet - DispatcherServlet with name &#39;appServlet&#39; processing GET request for [...]
08:25:15 [http-bio-8080-exec-10] RequestMappingHandlerMapping - Looking up handler method for path /async/callable/view
08:25:15 [http-bio-8080-exec-10] RequestMappingHandlerMapping - Returning handler method [...]
08:25:15 [http-bio-8080-exec-10] WebAsyncManager - Concurrent handling starting for GET [...]
08:25:15 [http-bio-8080-exec-10] DispatcherServlet - Leaving response open for concurrent processing
08:25:17 [MvcAsync1] WebAsyncManager - Concurrent result value [views/html]
08:25:17 [MvcAsync1] WebAsyncManager - Dispatching request to resume processing
08:25:17 [http-bio-8080-exec-6] DispatcherServlet - DispatcherServlet with name &#39;appServlet&#39; resumed processing GET request for [...]
08:25:17 [http-bio-8080-exec-6] RequestMappingHandlerMapping - Looking up handler method for path /async/callable/view
08:25:17 [http-bio-8080-exec-6] RequestMappingHandlerMapping - Returning handler method [...]
08:25:17 [http-bio-8080-exec-6] RequestMappingHandlerAdapter - Found concurrent result value [views/html]
08:25:17 [http-bio-8080-exec-6] DispatcherServlet - Rendering view [...] in DispatcherServlet with name &#39;appServlet&#39;
08:25:17 [http-bio-8080-exec-6] JstlView - Added model object &#39;fruit&#39; of type [java.lang.String]
08:25:17 [http-bio-8080-exec-6] JstlView - Added model object &#39;foo&#39; of type [java.lang.String]
08:25:17 [http-bio-8080-exec-6] JstlView - Forwarding to resource [/WEB-INF/views/views/html.jsp]
08:25:17 [http-bio-8080-exec-6] DispatcherServlet - Successfully completed request
</code></pre>
<p>Notice how the initial Servlet container thread exits quickly after logging a message that concurrent handling has started. That's because the controller method returned a <code>Callable</code>. A second thread -- managed by Spring MVC through an <code>AsyncTaskExecutor</code> -- invokes the <code>Callable</code> to produce a value, in this case a String-based view name, and then the request is <a href="https://docs.oracle.com/javaee/6/api/javax/servlet/AsyncContext.html#dispatch()">dispatched back</a> to the Servlet container. Finally, in a third Servlet container thread (the dispatch), processing is completed by rendering the selected view. If you look at the timestamps you'll notice a 2 second, simulated delay between when the initial thread exits and the <code>Callable</code> is ready.</p>
<p><em>Note:</em> if you are not familiar with the Servlet 3 async API, an async dispatch is similar to forwarding except a forward occurs in the same thread while a dispatch is used from an application thread to resume processing in a servlet container thread.</p><p><strong>TaskExecutor Configuration</strong></p>
<p>By default Spring MVC uses a <a href="http://static.springsource.org/spring/docs/3.1.x/javadoc-api/org/springframework/core/task/SimpleAsyncTaskExecutor.html">SimpleAsyncTaskExecutor</a> to execute <code>Callable</code> instances returned by controller methods. For production you must replace it with an <code>AsyncTaskExecutor</code> implementation configured appropriately for your environment. The MVC Java config and the MVC namespace both provide options to configure an <code>AsyncTaskExecutor</code> and async request processing in general. You can also configure the <code>RequestMappingHandlerAdapter</code> directly.</p><p><strong>Timeout Value</strong></p>
<p>If an async request does not complete processing within a certain amount of time, the Servlet container raises a timeout event and if not handled, the response is completed. You can configure the timeout value through the MVC Java config and the MVC namespace, or directly on the <code>RequestMappingHandlerAdapter</code>. If not configured, the timeout value will depend on the underlying Servlet container. On Tomcat it is 10 seconds and it starts after the initial Servlet container thread exits all the way out.</p><p><strong>MvcAsyncTask</strong></p>
<p>What if you want to customize the timeout value or the task executor for a specific controller method? For such occasions, you can <a href="https://github.com/SpringSource/spring-mvc-showcase/blob/master/src/main/java/org/springframework/samples/mvc/async/CallableController.java#L64">wrap the Callable in an instance of MvcAsyncTask</a>. The constructor of <code>MvcAsyncTask</code> accepts a timeout value and a task executor. Furthermore, it provides <code>onTimeout</code> and <code>onCompletion</code> methods that allow you to register for "timeout" and "completion" callbacks. Like "finally" in a try-catch block, "completion" always takes place when an async request completes. The "timeout" callback occurs prior to "completion" and can select an alternative value to use to complete processing as well as notify the <code>Callable</code> to stop processing.</p>
<p>The following is the sequence of events in a timeout scenario:</p>
<ol>
<li>Controller method returns a <code>Callable</code> wrapped in an <code>MvcAsyncTask</code>
<li>Spring MVC begins execution of the <code>Callable</code> in a separate thread
<li>The Servlet container thread exits (and the timeout period begins)
<li><code>MvcAsyncTask</code> is notified of a callback
<li>The callback code selects an alternative value and notifies the <code>Callable</code> to cancel processing
<li>The request is dispatched back to the container to complete processing with the alternate value
</ol>
<p>To fully understand the above scenario consider the threads involved -- the initial Servlet container thread where request processing begins, the Spring MVC managed thread where the <code>Callable</code> executes, the Servlet container thread in which the timeout event is raised, and the Servlet container thread processing the final async dispatch.</p><p><strong>Exceptions</strong></p>
<p>When an Exception is raised by a <code>Callable</code>, it is handled through the <code>HandlerExceptionResolver</code> mechanism just like exceptions raised by any other controller method. The more detailed explanation is that the exception is caught and saved, and the request is dispatched to the Servlet container where processing resumes and the <code>HandlerExceptionResolver</code> chain invoked. This also means that <code>@ExceptionHandler</code> methods will be invoked as usual.</p><p><strong>Handler Interception</strong></p>
<p>The <code>preHandle</code> method of a <code>HandlerInterceptor</code> is invoked as usual from the initial Servlet container thread. If the controller returns a <code>Callable</code> and async processing starts, there is neither a result nor is the request complete. Therefore <code>postHandle</code> and <code>afterCompletion</code> are not invoked in the initial Servlet container thread. Instead interceptors can implement <code>AsyncHandlerInterceptor</code>, a sub-interface, and the <code>afterConcurrentHandlingStarted</code> method. After the <code>Callable</code> is done and the request dispatched to the Servlet container, all methods of the <code>HandlerInterceptor</code> are invoked in the dispatched thread.</p><p><strong>Servlet Filters</strong></p>
<p>All Spring Framework Servlet filter implementations have been modified as necessary to work in asynchronous request processing. As for any other filters, some will work -- typically those that do pre-processing, and others will need to be modified -- typically those that do post-processing at the end of a request. Such filters will need to recognize when the initial Servlet container thread is being exited, making way for another thread to continue processing, and when they are invoked as part of an asynchronous dispatch to complete processing.</p>
<p>The <code>OpenSessionInViewFilter</code> and <code>OpenEntityManagerInViewFilter</code> have been updated to work transparently over the span the entire async request. However, if using <code>@Transactional</code> directly on a controller method, the transaction will complete as soon as the controller method returns and will not extend to the execution of the <code>Callable</code>. If the <code>Callable</code> needs to do transactional work it should delegate to a bean with <code>@Transactional</code> methods.</p>
<p>The <a href="https://spring.io/blog/2012/05/14/spring-mvc-3-2-preview-adding-long-polling-to-an-existing-web-application">next post</a> explores the use of <code>DeferredResult</code> for async processing by modifying an existing sample from the Spring AMQP project that reacts to AMQP messages and sends updates to the browser.</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 470;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>
Back
</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">All Posts</a>
<a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">Engineering</a>
<a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">Releases</a>
<a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">News and Events</a>
<a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>Get updates from The Spring Team delivered to your inbox</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">Tools</a></li>
<li><a href="https://store.pivotal.io/">Store</a></li>
<li><a href="/blog">Newsletter</a></li>
</ul>
</div>
</div>
&copy; <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a>, Inc. All Rights Reserved.
<a href="https://pivotal.io/terms-of-use">Terms of Use</a> &bullet;
<a href="https://pivotal.io/privacy-policy">Privacy</a> &bullet;
<a href="/trademarks">Trademark Guidelines</a>
<div id="teconsent" style="display:inline-block;"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>