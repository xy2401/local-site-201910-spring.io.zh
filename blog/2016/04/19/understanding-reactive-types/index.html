<html dir="ltr" data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>了解反应型</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>System.config({baseURL: "/b92013b"});</script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>System.import('app/main.js')</script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Understanding Reactive types">
<meta name="twitter:description" content="<p>Following previous <a href=" https:="" ="" spring.io="" blog="" 2016="" 02="" 09="" reactive-sprin="="></head><body dir="ltr">Reactive Spring and <a href="https://spring.io/blog/2016/03/11/reactor-core-3-0-becomes-a-unified-reactive-foundation-on-java-8">Reactor Core 3.0</a> blog posts, I would like to explain why Reactive types are useful and how they compare to other asynchronous types, based on what we have learned while working on the Spring Framework 5 upcoming Reactive support.
<h2><a href="#why-using-reactive-types" class="anchor" name="why-using-reactive-types"></a>Why using Reactive types?</h2>
<p>Reactive types are not intended to allow you to process your requests or data faster, in fact they will introduce a small overhead compared to regular blocking processing. Their strength lies in their capacity to serve more request concurrently, and to handle operations with latency, such as requesting data from a remote server, more efficiently. They allow you to provide a better quality of service and a predictable capacity planning by dealing natively with time and latency without consuming more resources. Unlike traditional processing that blocks the current thread while waiting a result, a Reactive API that waits costs nothing, requests only the amount of data it is able to process and bring new capabilities since it deals with stream of data, not only with individual elements one by one.</p>
">
<meta name="twitter:creator" content="@sdeleuze">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/5778521f67d80de0ee3b213e4f159a59?s=200">

<meta property="og:title" content="Understanding Reactive types">
<meta property="og:image" content="https://gravatar.com/avatar/5778521f67d80de0ee3b213e4f159a59?s=200">
<meta property="og:description" content="<p>Following previous <a href=" https:="" ="" spring.io="" blog="" 2016="" 02="" 09="" reactive-sprin="=">Reactive Spring and <a href="https://spring.io/blog/2016/03/11/reactor-core-3-0-becomes-a-unified-reactive-foundation-on-java-8">Reactor Core 3.0</a> blog posts, I would like to explain why Reactive types are useful and how they compare to other asynchronous types, based on what we have learned while working on the Spring Framework 5 upcoming Reactive support.
<h2><a href="#why-using-reactive-types" class="anchor" name="why-using-reactive-types"></a>Why using Reactive types?</h2>
<p>Reactive types are not intended to allow you to process your requests or data faster, in fact they will introduce a small overhead compared to regular blocking processing. Their strength lies in their capacity to serve more request concurrently, and to handle operations with latency, such as requesting data from a remote server, more efficiently. They allow you to provide a better quality of service and a predictable capacity planning by dealing natively with time and latency without consuming more resources. Unlike traditional processing that blocks the current thread while waiting a result, a Reactive API that waits costs nothing, requests only the amount of data it is able to process and bring new capabilities since it deals with stream of data, not only with individual elements one by one.</p>
">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2016-04-19 13:37:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">// Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }</script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">了解反应型</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/5778521f67d80de0ee3b213e4f159a59?s=20&d=mm"> <a class="author" rel="author" href="/team/sdeleuze">塞巴斯蒂安·德勒兹（SébastienDeleuze）</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2016-04-19 13:37:00.0">2016年4月19日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2016/04/19/understanding-reactive-types#disqus_thread" data-disqus-identifier="2450">
</a></div>
</div>
</header>
<div class="blog--post"><p>在先前的<a href="https://spring.io/blog/2016/02/09/reactive-spring">Reactive Spring</a>和<a href="https://spring.io/blog/2016/03/11/reactor-core-3-0-becomes-a-unified-reactive-foundation-on-java-8">Reactor Core 3.0</a>博客文章之后，我想根据我们在处理Spring Framework 5即将到来的Reactive支持时所学到的知识，来解释为什么Reactive类型很有用，以及它们与其他异步类型的比较。</p><h2><a href="#why-using-reactive-types" class="anchor" name="why-using-reactive-types"></a>为什么要使用反应型？</h2>
<p>响应类型并非旨在让您更快地处理请求或数据，实际上，与常规阻止处理相比，它们会带来较小的开销。它们的优势在于能够更有效地并发处理更多请求，并能更有效地处理具有延迟的操作，例如从远程服务器请求数据。它们通过本机处理时间和延迟，而无需消耗更多资源，从而使您能够提供更好的服务质量和可预测的容量计划。与等待结果的同时阻塞当前线程的传统处理不同，等待的Reactive API无需花费任何成本，仅请求它能够处理的数据量并带来新的功能，因为它处理数据流，而不仅仅是处理单个元素。一个。</p><h2><a href="#before-java-8" class="anchor" name="before-java-8"></a>在Java 8之前</h2>
<p>在Java 8之前，由于至少两个原因，实现异步非阻塞行为并不明显。第一个原因是基于回调的API需要冗长的匿名类，并且不容易链接。第二个原因是<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html"><code>Future</code></a>类型是异步的， <strong>但是</strong>当您尝试使用<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html#get--"><code>get()</code></a>方法获取结果时会阻塞当前线程，直到计算完成。这就是为什么Spring Framework 4.0引入了<a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/util/concurrent/ListenableFuture.html"><code>ListenableFuture</code></a> ，这是<code>Future</code>实现，它添加了非阻塞的基于回调的功能。</p><h2><a href="#lambdas-completablefuture-and-stream" class="anchor" name="lambdas-completablefuture-and-stream"></a> Lambdas，CompletableFuture和Stream</h2>
<p>然后Java 8引入了lambdas和<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html"><code>CompletableFuture</code></a> 。Lambdas允许编写简洁的回调，而<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html"><code>CompletionStage</code></a>接口和<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html"><code>CompletableFuture</code></a>类最终允许以非阻塞方式和基于推送的方式处理未来，同时提供链接此类延迟结果处理的功能。</p>
<p>Java 8还引入了<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html"><code>Stream</code></a> ， <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html"><code>Stream</code></a>旨在有效处理无需延迟或延迟很小的数据流（包括原始类型）。它是基于拉的，只能使用一次，缺少与时间相关的操作，并且可以执行并行计算，但无法指定要使用的线程池。正如<a href="https://stackoverflow.com/questions/17960656/is-it-possible-to-use-java-8-streams-api-for-asynchronous-processing/18826615#comment36545451_18826615">Brian Goetz</a>解释的那样，<br>它尚未设计为处理具有延迟的操作，例如I / O操作。这就是诸如Reactor或RxJava之类的Reactive API出现的地方。</p><h2><a href="#reactive-apis" class="anchor" name="reactive-apis"></a>反应性API</h2>
<p>诸如<a href="https://projectreactor.io/">Reactor之</a>类的<a href="https://projectreactor.io/">反应</a>性API也提供了像Java 8 Stream这样的运算符，但是它们更广泛地适用于任何流序列（不仅是Collections），并且由于使用方便，可以定义转换操作的流水线，该转换操作将应用于通过它的数据API和使用lambda。它们旨在处理同步或异步操作，并允许您对数据进行缓冲，合并，串联或应用各种转换。</p>
<p>最初，Reactive API仅设计用于处理数据流，即N个元素，例如，使用Reactor的<a href="http://projectreactor.io/core/docs/api/reactor/core/publisher/Flux.html"><code>Flux</code></a> ：</p>
<pre><code class="prettyprint java">reactiveService.getResults()
    .mergeWith(Flux.interval(100))
    .doOnNext(serviceA::someObserver)
    .map(d -> d * 2)
    .take(3)
    .onErrorResumeWith(errorHandler::fallback)
    .doAfterTerminate(serviceM::incrementTerminate)
    .consume(System.out::println);
</code></pre>
<p>但是在我们关于Spring Framework 5的工作中，很明显有必要区分1个元素或N个元素的流，这就是为什么Reactor提供<a href="http://projectreactor.io/core/docs/api/reactor/core/publisher/Mono.html"><code>Mono</code></a>类型的原因。<code>Mono</code>是<code>CompletableFuture</code>类型的Reactive等效项，并允许提供一致的API以Reactive方式处理单个和多个元素。</p>
<pre><code class="prettyprint java">Mono.any(reactiveServiceA.findRecent(time), reactiveServiceB.findRecent(time)
    .timeout(Duration.ofSeconds(3), errorHandler::fallback)
    .doOnSuccess(r -> reactiveServiceC.incrementSuccess())
    .consume(System.out::println);
</code></pre>
<p>如果您对<a href="http://projectreactor.io/core/docs/api/reactor/core/publisher/Flux.html"><code>Flux</code></a>和<a href="http://projectreactor.io/core/docs/api/reactor/core/publisher/Mono.html"><code>Mono</code></a>有更深入的了解，您会注意到这些类型实现了Reactive Streams规范中的<code>Publisher</code>接口。</p><h2><a href="#reactive-streams" class="anchor" name="reactive-streams"></a>反应流</h2>
<p>Reactor建立在<a href="http://www.reactive-streams.org">反应流</a>规范的基础上。Reactive Streams由<a href="http://www.reactive-streams.org/reactive-streams-1.0.0-javadoc/">4个简单的Java接口</a> （ <code>Publisher</code> <code>Subscriber</code> ， <code>Subscription</code> <code>Subscriber</code> ， <code>Subscription</code>和<code>Processor</code> ）， <a href="https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.0/README.md#specification">文本规范</a>和<a href="http://www.reactive-streams.org/reactive-streams-tck-1.0.0-javadoc/">TCK组成</a> 。它是每个现代Reactive库的基石，并且是互操作性所必需的。</p>
<p>反应流的核心问题是处理背压。简而言之，背压是一种机制，它允许接收器询问要从发射器接收多少数据。它允许：</p>
<ul>
<li>接收器仅在准备好处理数据时才开始接收数据</li>
<li>控制飞行中的数据量</li>
<li>有效处理慢速发射器/快速接收器或快速发射器/慢速接收器用例</li>
<li>如果请求“ <code>Long.MAX_VALUE</code></li><code>Long.MAX_VALUE</code></ul><code>Long.MAX_VALUE</code></div><code>Long.MAX_VALUE</code></div><code>Long.MAX_VALUE</code></article><code>Long.MAX_VALUE</code></div><code>Long.MAX_VALUE</code></div><code>Long.MAX_VALUE</code></div><code>Long.MAX_VALUE</code></div><code>Long.MAX_VALUE</code></body></html>