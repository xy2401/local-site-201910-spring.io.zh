<html dir="ltr" data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>使用Activiti和Spring集成进行编排工作</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>System.config({baseURL: "/b92013b"});</script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>System.import('app/main.js')</script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Orchestrating Work with Activiti and Spring Integration">
<meta name="twitter:description" class="anchor" content="<p>I received an email recently that asked about how to forward control from a wait-state in an Activiti (which is an open-source BPMN2 workflow engine from Alfresco) to a Spring Integration flow and then resume execution of the Activiti workflow process upon completion of some work in Spring Integration.</p>
<p>To really appreciate why this is useful goal, we need some background.</p>
<h2><a href=" #what-is-activit="="></head><body dir="ltr">What is Activiti
<p>Activiti is a <em>business process engine</em>. It’s basically a directed graph of nodes (states) that model the states of a complex business process. It keeps track of the progression of work described in a business process. It describe automatic- and human-based actors in a system. It also supports interrogating the business process engine to ask questions about the process instances underway: how many of them are there, which ones are stalled, etc. Business Process Management Systems (BPMS) offer many advantages, some of which are:</p>
">
<meta name="twitter:creator" content="@starbuxman">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=200">

<meta property="og:title" content="Orchestrating Work with Activiti and Spring Integration">
<meta property="og:image" content="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=200">
<meta class="anchor" name="what-is-activiti" property="og:description" content="<p>I received an email recently that asked about how to forward control from a wait-state in an Activiti (which is an open-source BPMN2 workflow engine from Alfresco) to a Spring Integration flow and then resume execution of the Activiti workflow process upon completion of some work in Spring Integration.</p>
<p>To really appreciate why this is useful goal, we need some background.</p>
<h2><a href=" #what-is-activit="=">What is Activiti
<p>Activiti is a <em>business process engine</em>. It’s basically a directed graph of nodes (states) that model the states of a complex business process. It keeps track of the progression of work described in a business process. It describe automatic- and human-based actors in a system. It also supports interrogating the business process engine to ask questions about the process instances underway: how many of them are there, which ones are stalled, etc. Business Process Management Systems (BPMS) offer many advantages, some of which are:</p>
">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2016-02-07 00:00:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">// Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }</script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">使用Activiti和Spring集成进行编排工作</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=20&d=mm"> <a class="author" rel="author" href="/team/jlong">乔什·朗（Josh Long）</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2016-02-07 00:00:00.0">2016年2月7日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2016/02/07/orchestrating-work-with-activiti-and-spring-integration#disqus_thread" data-disqus-identifier="2370">
</a></div>
</div>
</header>
<div class="blog--post"><p>我最近收到一封电子邮件，询问如何将控制从Activiti（这是Alfresco的开源BPMN2工作流引擎）中的等待状态转发到Spring Integration流，然后在完成后恢复Activiti工作流过程的执行Spring Integration中的一些工作。</p>
<p>要真正理解为什么这是有用的目标，我们需要一些背景知识。</p><h2><a href="#what-is-activiti" class="anchor" name="what-is-activiti"></a>什么是Activiti</h2>
<p>Activiti的是一个<em>业务流程引擎</em> 。它基本上是对复杂业务流程的状态进行建模的节点（状态）的有向图。它跟踪业务流程中描述的工作进度。它描述了系统中基于自动和基于人的参与者。它还支持询问业务流程引擎，以询问有关正在进行的流程实例的问题：其中有多少实例，哪些实例已停止，等等。业务流程管理系统（BPMS）具有许多优点，其中一些优点是：</p>
<ul>
<li>使用人员和服务推动更大业务需求的协作过程（想象贷款批准，法律合规，文档修订等）</li>
<li>它们支持组织中重要业务流程的审核和日记。这在监管环境中是无价的。</li>
<li>BPM引擎<em>旨在</em>处理长时间运行的进程状态，这意味着您的域模型不再需要像<code>is_enrolled</code>或<code>reset_password_date</code>这样的进程状态特定字段所<code>reset_password_date</code> 。</li>
<li>易于建模的复杂业务流程</li>
</ul>
<p>最后一点值得关注：像Activiti这样的优秀BPM引擎支持可视化业务流程建模。UML支持使用活动（步骤）和泳道（涉及满足这些步骤的代理）来直观地描述流程。当然，UML只是一个建模工具。它没有运行时语义。业务流程管理的圣杯一直是拥有一种可以由业务分析师<em>和</em>应用程序开发人员使用的建模符号。<a href="https://en.wikipedia.org/wiki/Business_Process_Model_and_Notation">BPMN 2</a>与我们为实现该目标所做的努力差不多。</p>
<p>例如，这里是一个<em>非常</em>简单的业务流程的可视模型。</p>
<img src="https://raw.githubusercontent.com/joshlong/meh/master/bpmn-model.png" width="500">
<p>这是为支持该模型而创建的标准XML标记。这种XML具有执行语义，而<em>不仅仅是</em>建模语义。</p>
<pre><code class="prettyprint xml"><?xml version="1.0" encoding="UTF-8"?>
<definitions id="definitions"
             xmlns="http://www.omg.org/spec/BPMN/20100524/MODEL"
             xmlns:activiti="http://activiti.org/bpmn"
             typeLanguage="http://www.w3.org/2001/XMLSchema"
             expressionLanguage="http://www.w3.org/1999/XPath"
             targetNamespace="http://www.activiti.org/bpmn2.0">

    <process id="asyncProcess">

        <startEvent id="start"/>

          <sequenceFlow
            id="flow1"
            sourceRef="start"
            targetRef="sigw"/>

        <serviceTask 
            id="sigw"
           name="Delegate to Spring Integration"
           activiti:delegateExpression="#{gateway}"/>

           <sequenceFlow
            id="scriptFlow"
            sourceRef="sigw"
            targetRef="confirmMovementTask"/>

        <scriptTask 
            id="confirmMovementTask"
            name="Execute script" scriptFormat="groovy">
            <script>
                println 'Moving on..'
            </script>
        </scriptTask>

          <sequenceFlow
            id="flow2"
            sourceRef="confirmMovementTask"
            targetRef="theEnd"/>

        <endEvent id="theEnd"/>

    </process>

</definitions>
</code></pre>
<p>Most analysts won’t write this XML by hand. Instead, they’ll use a modeling tool like <a href="https://www.alfresco.com/products/business-process-management" gtc:encodedoriginal="PGEgaHJlZj0iaHR0cHM6Ly93d3cuYWxmcmVzY28uY29tL3Byb2R1Y3RzL2J1c2luZXNzLXByb2Nlc3MtbWFuYWdlbWVudCI-">Alfresco’s Activiti Cloud</a>. The XML artifact, however, is round-trippable: it may be annotated by developers and then revised in the modeling tool.</p>
<p>On inspection, though, you’ll see that most of this isn’t very complicated. The process has four states:</p>
<ul>
<li><strong><code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTQ5Ij4=">startEvent</code></strong> - where the process starts</li>
<li><strong><code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTUyIj4=">serviceTask</code></strong> - invoke the Spring bean called <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTUzIj4=">gateway</code> to kick off a bit of processing in Spring Integration (more on this later!)</li>
<li><strong><code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTU2Ij4=">scriptTask</code></strong> - print out a simple confirmational message using Groovy</li>
<li><strong><code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTU5Ij4=">endEvent</code></strong> - done</li>
</ul>
<p>The ordering is explicitly spelled out by the various <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTYxIj4=">sequenceFlow</code> elements which connect the nodes.</p>
<p>Activiti is a great way to keep track of business process state, but it’s not a particularly powerful component model or integration technology. For that we need an integration framework like Spring Integration..</p><h2><a href="#what-is-spring-integration" class="anchor" name="what-is-spring-integration" gtc:encodedoriginal="PGEgaHJlZj0iI3doYXQtaXMtc3ByaW5nLWludGVncmF0aW9uIiBjbGFzcz0iYW5jaG9yIiBuYW1lPSJ3aGF0LWlzLXNwcmluZy1pbnRlZ3JhdGlvbiI-"></a>What is Spring Integration</h2>
<p>Spring Integration supports the integration of services and data across multiple otherwise incompatible systems. Conceptually, composing an integration flow is similar to composing a pipes-and-filters flow on a UNIX OS with <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTY2Ij4=">stdin</code> and <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTY3Ij4=">stdout</code>:</p>
<pre gtc:encodedoriginal="PHByZSBkYXRhLW1hcmt4PSIxNjgiPg=="><code class="prettyprint">cat input.txt |  grep ERROR | wc -l > output.txt
</code></pre>
<p>In the example, we take data from a source (the file <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTcxIj4=">input.txt</code>), pipe it to the <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTcyIj4=">grep</code> command to filter the results and keep only the lines that contain the token <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTczIj4=">ERROR</code>, and then pipe it to the <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTc0Ij4=">wc</code> utility which we to count how many lines there are. Finally, the final count is written to an output file, <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTc1Ij4=">output.txt</code>. These components - <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTc2Ij4=">cat</code>, <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTc3Ij4=">grep</code>, and <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTc4Ij4=">wc</code> - know nothing of each other. They were not designed with each other in mind. Instead, they know only how to read from <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTc5Ij4=">stdin</code> and write to <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTgwIj4=">stdout</code>. This normalization of data makes it very easy to compose complex solutions from simple atoms. In the example, the act of <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTgxIj4=">cat</code>ing a file turns data into data that any process aware of <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTgyIj4=">stdin</code> can read. It <em>adapts</em> the inbound data into the normalized format, lines of strings. At the end, the redirect (<code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTg0Ij4=">></code>) operator turns the normalized data, lines of strings, into data on the file system. It <em>adapts</em> it. The pipe (<code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTg2Ij4=">|</code>) character is used to signal that the output of one component should flow to the input of another.</p>
<p>A Spring Integration flow works the same way: data is normalized into <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTg4Ij4=">Message<T></code> instances. Each <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTg5Ij4=">Message<T></code> has a payload and headers - metadata about the payload in a <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTkwIj4=">Map<K,V></code> - that are the input and output of different messaging components. These messaging components are typically provided by Spring Integration, but it’s easy to write and use your own. There are all manner of messaging components supporting all of the <a href="http://www.enterpriseintegrationpatterns.com/" gtc:encodedoriginal="PGEgaHJlZj0iaHR0cDovL3d3dy5lbnRlcnByaXNlaW50ZWdyYXRpb25wYXR0ZXJucy5jb20vIj4=">the Enterprise Application Integration patterns</a> (filters, routers, transformers, adapters, gateways, etc.). The Spring framework <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTkyIj4=">MessageChannel</code> is a named conduit through which <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTkzIj4=">Message<T></code>s flow between messaging components. They’re pipes and, by default, they work sort of like a <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTk0Ij4=">java.util.Queue</code>. Data in, data out.</p>
<p>Spring Integration inbound adapters <em>adapt</em> data from external systems (message queues like RabbitMQ, Apache Kafka, and JMS, email, Twitter, file system mounts, IoT-devices, and a zillion other systems) into <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTk3Ij4=">Message<T></code>s. Spring Integration outbound adapters do the same, in reverse, taking <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMTk4Ij4=">Message<T></code>s and writing them to an external system (for example, as an e-mail, or a Tweet, or an Apache Kafka message).</p>
<p>Spring Integration supports <em>event-driven architectures</em> because it can help detect and then respond to events in the external world. For example, you can use Spring Integration to poll a filesystem every 10 seconds and publish a <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjAxIj4=">Message<T></code> whenever a new file appears. You can use Spring Integration to act as a listener to messages delivered to a Apache Kafka topic. The adapter handles responding to the external event and frees you from worrying too much about originating the message and lets you focus on handling the message once it arrives. It’s the integration equivalent of dependency injection! </p>
<p>Dependency injection leaves component code free of worries about resource initialization and acquisition and leaves it free to focus on writing code with those dependencies. Where did the <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjAzIj4=">javax.sql.DataSource</code> field come from? Who cares! Spring wired it in, and it may have gotten it from a Mock in a test, from JNDI in a classic application server, or from a configured Spring Boot bean. Component code remains ignorant of those details. ~15 years ago, when we first started talking about dependency injection, we would talk about the “Hollywood principal:” “don’t call me, I’ll call you!” This applies even more to Spring Integration!</p>
<p>Inbound gateways take incoming requests from external systems, process them as <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjA1Ij4=">Message<T></code>s, and send a reply. Outbound gateways take <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjA2Ij4=">Message<T></code>s, forward them to an external system, and await the response from that system. They support request and reply interactions.</p><h2><a href="#an-activiti-and-spring-integration-gateway" class="anchor" name="an-activiti-and-spring-integration-gateway" gtc:encodedoriginal="PGEgaHJlZj0iI2FuLWFjdGl2aXRpLWFuZC1zcHJpbmctaW50ZWdyYXRpb24tZ2F0ZXdheSIgY2xhc3M9ImFuY2hvciIgbmFtZT0iYW4tYWN0aXZpdGktYW5kLXNwcmluZy1pbnRlZ3JhdGlvbi1nYXRld2F5Ij4="></a>An Activiti and Spring Integration Gateway</h2>
<p>Activiti can be used to describe a complex, long-running process in terms of recorded, auditable, and predictable states, and Spring Integration can be used to, well, <em>integrate</em>! Spring Integration is where we keep the interesting Java code, and Activiti keeps track of the overarching state. This trick was useful 20 years ago and it’s useful today in the massively distributed world of microservices, too, where processing for a single request may span multiple services and nodes. It’s convenient, then, <a href="https://spring.io/blog/2015/03/08/getting-started-with-activiti-and-spring-boot" gtc:encodedoriginal="PGEgaHJlZj0iaHR0cHM6Ly9zcHJpbmcuaW8vYmxvZy8yMDE1LzAzLzA4L2dldHRpbmctc3RhcnRlZC13aXRoLWFjdGl2aXRpLWFuZC1zcHJpbmctYm9vdCI-">that Spring Boot, Spring Integration and Activiti work so well together</a>!</p>
<p>One common use case is to initiate a BPM process with Activiti and then, on entering a wait-state, delegate handling of that state to Spring Integration which can, of course, spread the work to other systems. Here’s a simple diagram illustrating the flow.</p>
<img src="https://raw.githubusercontent.com/joshlong/meh/master/activiti-and-si-interaction.jpg" width="500" gtc:encodedoriginal="PGltZyBzcmM9Imh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9qb3NobG9uZy9tZWgvbWFzdGVyL2FjdGl2aXRpLWFuZC1zaS1pbnRlcmFjdGlvbi5qcGciIHdpZHRoPSI1MDAiPg==">
<p>BPM process states can often involve human agents. For example, a workflow engine may have a state where a document is sent to a human for approval, but the reviewer is on vacation and won’t be back for weeks. It would be wasteful, not to mention dangerous, to keep a thread open with the expectation that whatever confirmation is needed to continue processing will come back within milliseconds or seconds.</p>
<p>Activiti is smart enough to pause execution, persist execution state to a database during a wait-state, and only resume upon having the process execution <em>signaled</em>. Signalling the process engine rehydrates the process and resumes execution. A simple example might be a new user enrollment business process that delegates to Spring Integration to send an email with a sign up confirmation link. It may take days for the user to click the confirmation link, but on clicking, the system should proceed with the enrollment business process.</p>
<p>In this post we’re going to look at how to initiate a BPM process that enters a wait-state and then delegates to Spring Integration to do some kind of custom processing and then, in the far flung future, resumes execution of the process.</p>
<p>We’ll setup two Spring Integration flows: one to handle requests from Activiti into Spring Integration and another that handles eventual replies and triggers the resumption of the process.</p>
<p>We’ll need something to kick off our process, so here’s a simple REST endpoint (<code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjIwIj4=">http://localhost:8080/start</code>) that launches a new process each time:</p>
<pre gtc:encodedoriginal="PHByZSBkYXRhLW1hcmt4PSIyMjEiPg=="><code class="prettyprint java">@RestController
class ProcessStartingRestController {

 @Autowired
 private ProcessEngine processEngine;

 @RequestMapping(method = RequestMethod.GET, value = "/start")
 Map<String, String> launch() {
  ProcessInstance asyncProcess = this.processEngine.getRuntimeService()
    .startProcessInstanceByKey("asyncProcess");
  return Collections.singletonMap("executionId", asyncProcess.getId());
 }
}
</code></pre>
<p>Messages will flow across two <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjI0Ij4=">MesssageChannel</code>s that we’ll create in a <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjI1Ij4=">@Configuration</code> class: <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjI2Ij4=">requests</code> and <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjI3Ij4=">replies</code>.</p>
<pre gtc:encodedoriginal="PHByZSBkYXRhLW1hcmt4PSIyMjgiPg=="><code class="prettyprint java">@Configuration
class MessageChannels {

 @Bean
 DirectChannel requests() {
  return new DirectChannel();
 }

 @Bean
 DirectChannel replies() {
  return new DirectChannel();
 }
}
</code></pre>
<p>The nice thing about using a <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjMxIj4=">@Configuration</code> class is that it is itself a Spring component and can be injected anywhere. We can dereference the channels by invoking the <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjMyIj4=">@Bean</code> provider methods directly. The alternative is to use <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjMzIj4=">@Qualifier</code> everytime we inject a reference to one of the channels, e.g.:</p>
<pre gtc:encodedoriginal="PHByZSBkYXRhLW1hcmt4PSIyMzQiPg=="><code class="prettyprint java"><br>public static final String REPLIES_CHANNEL_NAME = "replies";

@Autowired
@Qualifier(REPLIES_CHANNEL_NAME)
private MessageChannel replies;
</code></pre>
<p>Our BPMN is pretty straightforward, but we’ll use an Activiti-specific namespace attribute, <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjM4Ij4=">activiti:delegateExpression="#{gateway}"</code>, to tell Activiti to call a bean named <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjM5Ij4=">gateway</code> that’s registered in Spring. Activiti knows to do this because this application uses the Activiti auto-configuration for Spring Boot which, among many other things, exposes Spring-managed beans to the Activiti expression-language. The <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjQwIj4=">gateway</code> is an Activiti-based bean of type <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjQxIj4=">ReceiveTaskActivityBehavior</code>. Spring Boot has auto-configurations for both Spring Integration and Activiti so 90% of the tedious setup goes out the window.</p>
<p>Let’s look at our simple <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjQzIj4=">gateway</code> component, an implementation of Activiti’s <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjQ0Ij4=">ActivityBehavior</code> interface that acts as a callback where we can send a <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjQ1Ij4=">Message<T></code> into the <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjQ2Ij4=">requests</code> channel and kick off our Spring Integration flow. The important thing here is that we’ve captured the <code gtc:encodedoriginal="PGNvZGUgZGF0YS1tYXJreD0iMjQ3Ij4=">executionId</code> which we’ll need later to <em>resume</em> or <em>signal</em> the process.</p>
<pre gtc:encodedoriginal="PHByZSBkYXRhLW1hcmt4PSIyNTAiPg=="><code class="prettyprint java">@Bean
ActivityBehavior gateway(MessageChannels channels) {
  return new ReceiveTaskActivityBehavior() {

    @Override
    public void execute(ActivityExecution execution) throws Exception {

      Message<?> executionMessage = MessageBuilder
          .withPayload(execution)
          .setHeader("executionId", execution.getId())
          .build();

      channels.requests().send(executionMessage);
    }
  };
}
</code></pre>
<p><code>Message<T></code>会弹出<code>requests</code> <code>MessageChannel</code>的另一端，需要进行一些处理。在一个复杂的示例中，将请求转换为有意义的消息然后将其转发到其他系统（例如电子邮件）将是微不足道的。在这里，我们仅打印出标题，以便我们可以记录<code>executionId</code>并在以后使用。</p>
<pre><code class="prettyprint java">@Bean
IntegrationFlow requestsFlow(MessageChannels channels) {
 return IntegrationFlows.from(channels.requests())
   .handle(msg -> msg.getHeaders().entrySet()
     .forEach(e -> log.info(e.getKey() + '=' + e.getValue())))
   .get();
}
</code></pre>
<p>此时，工作流定义将被保留，并且没有活动的流程实例。我们需要以某种方式异步发出信号。我们将使用REST端点<code>http://localhost:8080/resume/{executionId}</code> 。REST很容易理解，但是实际上我们可以使用Spring Integration知道的任何来自外部系统的事件来实现这种效果。唯一要确保的是，无论外部事件如何，我们都可以通过某种方式发送<code>executionId</code> ，就像我们通过在URI中捕获它一样。</p>
<pre><code class="prettyprint java"><br>@RestController
class ProcessResumingRestController {

 @Autowired
 private MessageChannels messageChannels;

 @RequestMapping(method = RequestMethod.GET, value = "/resume/{executionId}")
 void resume(@PathVariable String executionId) {

  Message<String> build = MessageBuilder.withPayload(executionId)
    .setHeader("executionId", executionId)
    .build();

  this.messageChannels.replies().send(build);
 }
}

</code></pre>
<p>当<code>Message<T></code>流经<code>replies</code> <code>MessageChannel</code> ，它将弹出另一端，同样，需要进行一些处理。在这里，我们将使用另一个Spring Integration流，它接收传入的<code>Message<T></code>并表示该过程已恢复。一旦执行了该流程，您将看到该过程的下一步，即<code>scriptTask</code> ，评估后的单词和“继续前进”。打印到控制台。</p>
<pre><code class="prettyprint java">@Bean
IntegrationFlow repliesFlow(MessageChannels channels,
       ProcessEngine engine) {
 return IntegrationFlows.from(channels.replies())
   .handle(msg -> engine.getRuntimeService().signal(
     String.class.cast(msg.getHeaders().get("executionId"))))
   .get();
}
</code></pre><h2><a href="#next-steps" class="anchor" name="next-steps"></a>下一步</h2>
<p>我们已经介绍了很多！我们<em>同时</em>涉及到BPM引擎和集成框架来处理处理，并且我理解正确使用两者的交集是一个小众话题。这篇文章的目标是在适当的情况下充分有效地使用两者。 BPM为简单的集成增加了相当多的<a href="https://en.wikipedia.org/wiki/Cognitive_load"><em>认知负担</em></a> ，但是当业务流程描述必须对模型和业务分析师友好时，BPM会提供<em>很多</em>价值。一个普遍的误解是，一旦涉及BPM，开发人员就不得不放弃增强系统的能力。不是这样！多亏了Spring Boot和Activiti团队的辛勤工作，Activiti可以与整个Spring完美协作。</p>
<p>真正的强大功能是使用BPM来协调复杂的处理逻辑：想象一下在BPM流程中达到某个状态，然后调用Spring Batch作业，或在Spring Cloud中使用功能区负载均衡的<code>RestTemplate</code>调用REST服务，或转发<code>Message<T></code>进入Spring Cloud Data Flow流流程。Spring Cloud Data Flow是我最喜欢的数据处理方法之一，因为它建立在Spring Cloud Stream的基础上，而Spring Cloud Stream又建立在Spring Integration的基础上： <code>MessageChannel</code>一直存在！</p>
<p>该<a href="https://github.com/joshlong/activiti-examples/tree/master/async-activiti-integration">示例</a>的代码<a href="https://github.com/joshlong/activiti-examples/tree/master/async-activiti-integration">在线</a> 。</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">var disqus_shortname = 'spring-io';
      var disqus_identifier = 2370;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));</script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });</script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>