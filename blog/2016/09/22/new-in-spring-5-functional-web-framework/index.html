<html  data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>Spring 5的新功能：功能性Web框架</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="New in Spring 5: Functional Web Framework">
<meta name="twitter:description" content="<p>As mentioned yesterday in <a href=" https:="" ="" spring.io="" blog="" 2016="" 09="" 21="" spring-framework-5-0-m2-release="="></head><body >Juergen’s blog post, the second milestone of Spring Framework 5.0 introduced a new functional web framework. In this post, I will give more information about the framework. 
<p>Keep in mind the functional web framework is built on the same reactive foundation that we provided in M1 and on which we also support annotation-based (i.e. <code>@Controller</code>, <code>@RequestMapping</code>) request handling, see the <a href="https://spring.io/blog/2016/07/28/reactive-programming-with-spring-5-0-m1">M1 blog post</a> for more on that.</p>
<h1><a href="#example" class="anchor" name="example"></a>Example</h1>
<p>We start with some excerpts from our <a href="https://github.com/poutsma/web-function-sample">sample application</a>. Below is a reactive repository that exposes <code>Person</code> objects. It is quite similar to a traditional, non-reactive repository, except that it returns <code>Flux<Person></code> where you would return a <code>List<Person></code> traditionally, and <code>Mono<Person></code> where you would return a <code>Person</code>. <code>Mono<Void></code> is used as a completion signal: to indicate when the save has been completed. For more information on these Reactor types, refer to <a href="https://spring.io/blog/2016/06/13/notes-on-reactive-programming-part-ii-writing-some-code">Dave’s blog post</a>.</p>
">
<meta name="twitter:creator" content="@poutsma">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/783fefe566e832976f50aacb1b8fd949?s=200">

<meta property="og:title" content="New in Spring 5: Functional Web Framework">
<meta property="og:image" content="https://gravatar.com/avatar/783fefe566e832976f50aacb1b8fd949?s=200">
<meta property="og:description" content="<p>As mentioned yesterday in <a href=" https:="" ="" spring.io="" blog="" 2016="" 09="" 21="" spring-framework-5-0-m2-release="=">Juergen’s blog post, the second milestone of Spring Framework 5.0 introduced a new functional web framework. In this post, I will give more information about the framework. 
<p>Keep in mind the functional web framework is built on the same reactive foundation that we provided in M1 and on which we also support annotation-based (i.e. <code>@Controller</code>, <code>@RequestMapping</code>) request handling, see the <a href="https://spring.io/blog/2016/07/28/reactive-programming-with-spring-5-0-m1">M1 blog post</a> for more on that.</p>
<h1><a href="#example" class="anchor" name="example"></a>Example</h1>
<p>We start with some excerpts from our <a href="https://github.com/poutsma/web-function-sample">sample application</a>. Below is a reactive repository that exposes <code>Person</code> objects. It is quite similar to a traditional, non-reactive repository, except that it returns <code>Flux<Person></code> where you would return a <code>List<Person></code> traditionally, and <code>Mono<Person></code> where you would return a <code>Person</code>. <code>Mono<Void></code> is used as a completion signal: to indicate when the save has been completed. For more information on these Reactor types, refer to <a href="https://spring.io/blog/2016/06/13/notes-on-reactive-programming-part-ii-writing-some-code">Dave’s blog post</a>.</p>
">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2016-09-22 12:03:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Spring 5的新功能：功能性Web框架</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/783fefe566e832976f50aacb1b8fd949?s=20&d=mm"> <a class="author" rel="author" href="/team/apoutsma">Arjen Poutsma</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2016-09-22 12:03:00.0">九月22，2016</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2016/09/22/new-in-spring-5-functional-web-framework#disqus_thread" data-disqus-identifier="2626">
</a></div>
</div>
</header>
<div class="blog--post"><p>如昨天在<a href="https://spring.io/blog/2016/09/21/spring-framework-5-0-m2-released">Juergen的博客文章</a>中所述，Spring Framework 5.0的第二个里程碑引入了一个新的功能性Web框架。在这篇文章中，我将提供有关该框架的更多信息。</p>
<p>请记住，功能性Web框架建立在我们在M1中提供的相同的反应基础上，并且我们也支持基于注释的基础（即<code>@Controller</code> ， <code>@RequestMapping</code> ）请求处理，有关更多信息，请参见<a href="https://spring.io/blog/2016/07/28/reactive-programming-with-spring-5-0-m1">M1博客文章</a> 。</p><h1><a href="#example" class="anchor" name="example"></a>例</h1>
<p>我们从<a href="https://github.com/poutsma/web-function-sample">示例应用程序的</a>一些摘录开始。下面是一个反应式存储库，它公开了<code>Person</code>对象。它与传统的非反应式存储库非常相似，只不过它返回<code>Flux<Person></code>您将在哪里返回<code>List<Person></code>传统上，以及<code>Mono<Person></code>您将在哪里返回<code>Person</code> 。 <code>Mono<Void></code>用作完成信号：指示保存何时完成。有关这些Reactor类型的更多信息，请参阅<a href="https://spring.io/blog/2016/06/13/notes-on-reactive-programming-part-ii-writing-some-code">Dave的博客文章</a> 。</p>
<pre><code class="prettyprint java">public interface PersonRepository {
  Mono&lt;Person&gt; getPerson(int id);
  Flux&lt;Person&gt; allPeople();
  Mono&lt;Void&gt; savePerson(Mono&lt;Person&gt; person);
}
</code></pre>
<p>这是我们使用新的功能性Web框架公开该存储库的方式：</p>
<pre><code class="prettyprint java">RouterFunction&lt;?&gt; route = route(GET(&quot;/person/{id}&quot;),
  request -&gt; {
    Mono&lt;Person&gt; person = Mono.justOrEmpty(request.pathVariable(&quot;id&quot;))
      .map(Integer::valueOf)
      .then(repository::getPerson);
    return Response.ok().body(fromPublisher(person, Person.class));
  })
  .and(route(GET(&quot;/person&quot;),
    request -&gt; {
      Flux&lt;Person&gt; people = repository.allPeople();
      return Response.ok().body(fromPublisher(people, Person.class));
    }))
  .and(route(POST(&quot;/person&quot;),
    request -&gt; {
      Mono&lt;Person&gt; person = request.body(toMono(Person.class));
      return Response.ok().build(repository.savePerson(person));
    }));
</code></pre>
<p>这是我们如何运行它，例如在Reactor Netty中：</p>
<pre><code class="prettyprint java">HttpHandler httpHandler = RouterFunctions.toHttpHandler(route);
ReactorHttpHandlerAdapter adapter =
  new ReactorHttpHandlerAdapter(httpHandler);
HttpServer server = HttpServer.create(&quot;localhost&quot;, 8080);
server.startAndAwait(adapter);
</code></pre>
<p>最后要做的是尝试一下：</p>
<pre><code class="prettyprint sh">$ curl &#39;http://localhost:8080/person/1&#39;
{&quot;name&quot;:&quot;John Doe&quot;,&quot;age&quot;:42}
</code></pre>
<p>这里有很多要讨论的内容，所以让我们深入研究吧！</p><h1><a href="#key-components" class="anchor" name="key-components"></a>关键部件</h1>
<p>我将通过介绍其关键组件来说明该框架： <code>HandlerFunction</code> ， <code>RouterFunction</code>和<code>FilterFunction</code> 。这三个接口，以及本文中介绍的所有其他类型，可以在<a href="https://docs.spring.io/spring/docs/5.0.0.M2/javadoc-api/org/springframework/web/reactive/function/package-summary.html"><code>org.springframework.web.reactive.function</code></a>包。</p><h2><a href="#handlerfunction" class="anchor" name="handlerfunction"></a>处理函数</h2>
<p>这个新框架的起点是<strong><code>HandlerFunction<T></code></strong> ，本质上是<code>Function<Request, Response<T>></code> ，在哪里<code>Request</code>和<code>Response</code>是新定义的，不可变的接口，可为基础HTTP消息提供JDK-8友好的DSL。有一个方便的建筑商<code>Response</code>实例，与在<code>ResponseEntity</code> 。与之对应的注释<code>HandlerFunction</code>将是一种方法<code>@RequestMapping</code> 。</p>
<p>这是一个简单的“ Hello World”处理函数的示例，该函数返回状态为200且基于字符串的主体的响应：</p>
<pre><code class="prettyprint java">HandlerFunction&lt;String&gt; helloWorld =
  request -&gt; Response.ok().body(fromObject(&quot;Hello World&quot;));
</code></pre>
<p>正如我们在上面的示例中看到的那样，通过在Reactor之上构建，处理函数可以完全反应：它们接受<code>Flux</code> ， <code>Mono</code>或任何其他<a href="http://www.reactive-streams.org">反应式流</a> <code>Publisher</code>作为响应类型。</p>
<p>重要的是要注意<code>HandlerFunction</code>本身是无副作用的，因为它<em>返回</em>响应，而不是将其作为参数使用（参见<code>Servlet.service(ServletRequest,ServletResponse)</code> ，本质上是<code>BiConsumer<ServletRequest,ServletResponse></code> ）。无副作用的功能有很多好处：它们更易于<a href="https://programmers.stackexchange.com/questions/15269/why-are-side-effects-considered-evil-in-functional-programming">测试，组成和优化</a> 。</p><h2><a href="#routerfunction" class="anchor" name="routerfunction"></a>路由器功能</h2>
<p>传入的请求通过<strong><code>RouterFunction<T></code></strong> （即<code>Function<Request, Optional<HandlerFunction<T>></code> ）。路由器功能如果匹配则求值为处理程序功能。否则返回空结果。的<code>RouterFunction</code>具有与<code>@RequestMapping</code>注解。但是，有一个重要的区别：使用注释时，您的路线仅限于可通过注释值表示的内容，并且对它们的处理并不容易被覆盖；使用路由器功能，处理代码就在您眼前：您可以轻松地覆盖或替换它。</p>
<p>这是带有内联处理程序功能的路由器功能的示例。它看上去确实有些冗长，但是不必担心：我们将在下面找到缩短它的方法。</p>
<pre><code class="prettyprint java">RouterFunction&lt;String&gt; helloWorldRoute = 
  request -&gt; {
    if (request.path().equals(&quot;/hello-world&quot;)) {
      return Optional.of(r -&gt; Response.ok().body(fromObject(&quot;Hello World&quot;)));
    } else {
      return Optional.empty();
    }
  };
</code></pre>
<p>通常，您不编写完整的路由器功能，而是（静态地）导入<code>RouterFunctions.route()</code> ，这使您可以创建一个<code>RouterFunction</code>用一个<code>RequestPredicate</code> （即<code>Predicate<Request></code> ）和一个<code>HandlerFunction</code> 。如果谓词适用，则返回处理函数；否则，返回false。否则为空结果。使用<code>route</code> ，我们可以将以上内容重写为以下内容：</p>
<pre><code class="prettyprint java">RouterFunction&lt;String&gt; helloWorldRoute =
  RouterFunctions.route(request -&gt; request.path().equals(&quot;/hello-world&quot;),
    request -&gt; Response.ok().body(fromObject(&quot;Hello World&quot;)));
</code></pre>
<p>您可以（静态）导入<code>RequestPredicates.*</code>来访问常用谓词，例如基于路径，HTTP方法，内容类型等的匹配。借助它，我们可以使我们的<code>helloWorldRoute</code>更简单：</p>
<pre><code class="prettyprint java">RouterFunction&lt;String&gt; helloWorldRoute =
  RouterFunctions.route(RequestPredicates.path(&quot;/hello-world&quot;),
    request -&gt; Response.ok().body(fromObject(&quot;Hello World&quot;)));
</code></pre><h3><a href="#composing-functions" class="anchor" name="composing-functions"></a>组成功能</h3>
<p>可以将两个路由器功能组成一个新的路由器功能，该路由功能可以路由到任一处理程序功能：如果第一个功能不匹配，则对第二个功能进行评估。您可以通过调用两个路由器功能<code>RouterFunction.and()</code> ，就像这样：</p>
<pre><code class="prettyprint java">RouterFunction&lt;?&gt; route =
  route(path(&quot;/hello-world&quot;),
    request -&gt; Response.ok().body(fromObject(&quot;Hello World&quot;)))
  .and(route(path(&quot;/the-answer&quot;),
    request -&gt; Response.ok().body(fromObject(&quot;42&quot;))));
</code></pre>
<p>如果路径匹配，以上内容将以“ Hello World”响应<code>/hello-world</code> ，如果匹配则为“ 42” <code>/the-answer</code> 。如果都不匹配，则为空<code>Optional</code>返回。注意，组成的路由器功能是按顺序评估的，因此将特定功能放在通用功能之前是有意义的。</p>
<p>您还可以通过调用来组成请求谓词<code>and</code>要么<code>or</code> 。这些工作符合预期： <code>and</code>如果<em>两个</em>给定谓词都匹配，则结果谓词匹配， <code>or</code>如果<em>任一</em>谓词匹配则匹配。例如：</p>
<pre><code class="prettyprint java">RouterFunction&lt;?&gt; route =
  route(method(HttpMethod.GET).and(path(&quot;/hello-world&quot;)), 
    request -&gt; Response.ok().body(fromObject(&quot;Hello World&quot;)))
  .and(route(method(HttpMethod.GET).and(path(&quot;/the-answer&quot;)), 
    request -&gt; Response.ok().body(fromObject(&quot;42&quot;))));
</code></pre>
<p>实际上，大多数谓词都存在于<code>RequestPredicates</code>是组成！例如， <code>RequestPredicates.GET(String)</code>是由<code>RequestPredicates.method(HttpMethod)</code>和<code>RequestPredicates.path(String)</code> 。因此，我们可以将以上内容重写为：</p>
<pre><code class="prettyprint java">RouterFunction&lt;?&gt; route =
  route(GET(&quot;/hello-world&quot;),
    request -&gt; Response.ok().body(fromObject(&quot;Hello World&quot;)))
  .and(route(GET(&quot;/the-answer&quot;),
    request -&gt; Response.ok().body(fromObject(42))));
</code></pre><h3><a href="#method-references" class="anchor" name="method-references"></a>方法参考</h3>
<p>顺便说一句：到目前为止，我们已将所有处理程序函数编写为内联lambda。尽管这对于演示示例和简短示例来说很好，但由于混合了两个方面，它确实有可能变得“混乱”：请求路由和请求处理。因此，让我们看看是否可以使事情更清洁。首先，我们创建一个包含处理代码的类：</p>
<pre><code class="prettyprint java">class DemoHandler {
  public Response&lt;String&gt; helloWorld(Request request) {
    return Response.ok().body(fromObject(&quot;Hello World&quot;));
  }
  public Response&lt;String&gt; theAnswer(Request request) {
    return Response.ok().body(fromObject(&quot;42&quot;));
  }
}
</code></pre>
<p>请注意，这两种方法都具有与处理程序功能兼容的签名。这使我们可以使用<a href="https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html">方法引用</a> ：</p>
<pre><code class="prettyprint java">DemoHandler handler = new DemoHandler(); // or obtain via DI
RouterFunction&lt;?&gt; route =
  route(GET(&quot;/hello-world&quot;), handler::helloWorld)
  .and(route(GET(&quot;/the-answer&quot;), handler::theAnswer));
</code></pre><h2><a href="#filterfunction" class="anchor" name="filterfunction"></a>过滤功能</h2>
<p>路由器功能映射的路由可以通过调用进行过滤<code>RouterFunction.filter(FilterFunction<T, R>)</code> ，在哪里<code>FilterFunction<T,R></code>本质上是<code>BiFunction<Request, HandlerFunction<T>, Response<R>></code> 。handler函数参数表示链中的下一项：通常是<code>HandlerFunction</code> ，但也可以是另一个<code>FilterFunction</code>如果应用了多个过滤器。让我们在路由中添加一个日志过滤器：</p>
<pre><code class="prettyprint java">RouterFunction&lt;?&gt; route =
  route(GET(&quot;/hello-world&quot;), handler::helloWorld)
  .and(route(GET(&quot;/the-answer&quot;), handler::theAnswer))
  .filter((request, next) -&gt; {
    System.out.println(&quot;Before handler invocation: &quot; + request.path());
    Response&lt;?&gt; response = next.handle(request);
    Object body = response.body();
    System.out.println(&quot;After handler invocation: &quot; + body);
    return response;
  });
</code></pre>
<p>请注意，调用下一个处理程序是可选的。这在安全性或缓存方案中很有用（例如，调用<code>next</code>仅当用户具有足够的权限时）。</p>
<p>因为<code>route</code>是一个无限制的路由器功能，我们不知道下一个处理程序将返回什么类型的响应。这就是为什么我们最终得到一个<code>Response<?></code>在我们的过滤器中<code>Object</code>反应体。在我们的处理程序类中，两个方法都返回一个<code>Response<String></code> ，因此应该有可能<code>String</code>反应体。我们可以通过使用<code>RouterFunction.andSame()</code>代替<code>and()</code> 。这种组合方法要求参数路由器功能为同一类型。例如，我们可以使所有响应大写：</p>
<pre><code class="prettyprint java">RouterFunction&lt;String&gt; route =
  route(GET(&quot;/hello-world&quot;), handler::helloWorld)
  .andSame(route(GET(&quot;/the-answer&quot;), handler::theAnswer))
  .filter((request, next) -&gt; {
    Response&lt;String&gt; response = next.handle(request);
    String newBody = response.body().toUpperCase();
    return Response.from(response).body(fromObject(newBody));
  });
</code></pre>
<p>使用注释，可以使用<code>@ControllerAdvice</code>和/或<code>ServletFilter</code> 。</p><h2><a href="#running-a-server" class="anchor" name="running-a-server"></a>运行服务器</h2>
<p>所有这些都是好事，但是缺少一个方面：我们如何才能在HTTP服务器中实际运行这些功能？毫无疑问，答案来自调用另一个函数。您可以将路由器功能转换为<code>HttpHandler</code>通过使用<code>RouterFunctions.toHttpHandler()</code> 。的<code>HttpHandler</code>是Spring 5.0 M1中引入的一种响应式抽象：它允许您在各种响应式运行时上运行：Reactor Netty，RxNetty，Servlet 3.1+和Undertow。在示例中，我们已经展示了运行<code>route</code>在Reactor Netty中看起来像。对于Tomcat，它看起来像这样：</p>
<pre><code class="prettyprint java">HttpHandler httpHandler = RouterFunctions.toHttpHandler(route);
HttpServlet servlet = new ServletHttpHandlerAdapter(httpHandler);
Tomcat server = new Tomcat();
Context rootContext = server.addContext(&quot;&quot;,
  System.getProperty(&quot;java.io.tmpdir&quot;));
Tomcat.addServlet(rootContext, &quot;servlet&quot;, servlet);
rootContext.addServletMapping(&quot;/&quot;, &quot;servlet&quot;);
tomcatServer.start();
</code></pre>
<p>需要注意的一件事是，以上内容不依赖于Spring应用程序上下文。就像<code>JdbcTemplate</code>和其他Spring实用程序类，使用应用程序上下文是可选的：您可以在上下文中连接处理程序和路由器功能，但这不是必需的。<br>另请注意，您还可以将路由器功能转换为<code>HandlerMapping</code> ，以便它可以在<code>DispatcherHandler</code> （可能与反应性并排<code>@Controllers</code> ）。</p><h1><a href="#conclusion" class="anchor" name="conclusion"></a>结论</h1>
<p>到此结束对Spring的新功能样式Web框架的介绍。最后，我总结一下：</p>
<ul>
<li>处理函数通过返回响应来处理请求，</li>
<li>路由器功能路由到处理程序功能，并且可以与其他路由器功能组成，</li>
<li>路由器功能可以通过过滤器功能进行过滤，</li>
<li>路由器功能可以在反应式Web运行时中运行。</li>
</ul>
<p>为了给您更完整的了解，我创建了一个使用功能性Web框架的简单示例项目。您可以<a href="https://github.com/poutsma/web-function-sample">在GitHub上</a>找到该项目。</p>
<p>让我们知道您的想法！</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 2626;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>