<html dir="ltr" data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>关于反应式编程的注释第一部分：反应式环境</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>System.config({baseURL: "/b92013b"});</script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>System.import('app/main.js')</script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Notes on Reactive Programming Part I: The Reactive Landscape">
<meta name="twitter:description" content="<div class=" paragrap="="> 
 </head><body dir="ltr"><p>Reactive Programming is interesting (again) and there is a lot of noise about it at the moment, not all of which is very easy to understand for an outsider and simple enterprise Java developer, such as the author. This article (the first in a series) might help to clarify your understanding of what the fuss is about. The approach is as concrete as possible, and there is no mention of "denotational semantics". If you are looking for a more academic approach and loads of code samples in Haskell, the internet is full of them, but you probably don’t want to be here.</p> 

">
<meta name="twitter:creator" content="@david_syer">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=200">

<meta property="og:title" content="Notes on Reactive Programming Part I: The Reactive Landscape">
<meta property="og:image" content="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=200">
<meta property="og:description" content="<div class=" paragrap="="> 
 <p>Reactive Programming is interesting (again) and there is a lot of noise about it at the moment, not all of which is very easy to understand for an outsider and simple enterprise Java developer, such as the author. This article (the first in a series) might help to clarify your understanding of what the fuss is about. The approach is as concrete as possible, and there is no mention of "denotational semantics". If you are looking for a more academic approach and loads of code samples in Haskell, the internet is full of them, but you probably don’t want to be here.</p> 

">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2016-06-07 12:15:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">// Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }</script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">关于反应式编程的注释第一部分：反应式环境</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=20&d=mm"> <a class="author" rel="author" href="/team/dsyer">戴夫·瑟</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2016-06-07 12:15:00.0">2016年6月7日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2016/06/07/notes-on-reactive-programming-part-i-the-reactive-landscape#disqus_thread" data-disqus-identifier="2509">
</a></div>
</div>
</header>
<div class="blog--post"><div class="paragraph">
<p>响应式编程很有趣（再次），目前有很多杂音，对于局外人和简单的企业Java开发人员（例如作者）而言，并不是所有的内容都很容易理解。本文（系列文章的第一篇）可能有助于阐明您对这些大惊小怪的理解。该方法尽可能具体，没有提及“符号语义”。如果您正在寻找一种更具学术性的方法和Haskell中的大量代码示例，则Internet上到处都是，但是您可能不想在这里。</p>
</div>
<div class="paragraph">
<p>响应式编程通常与并发编程和高性能混为一谈，以至于很难将这些概念分开，而实际上它们在原理上是完全不同的。这不可避免地导致混乱。反应式编程也经常被称为功能性反应式编程或FRP或与功能性反应式编程（FRP）结合使用（在这里我们将二者互换使用）。有些人认为Reactive并不是什么新鲜事物，而是整天都在做的事情（大多数情况下使用JavaScript）。其他人似乎认为这是来自微软的礼物（当他们不久前发布一些C＃扩展时，微软对此给予了极大的关注）。在企业Java领域中，最近出现了一些嗡嗡声（例如，请参见<a href="http://www.reactive-streams.org/">Reactive Streams计划</a> ），并且与任何闪亮的事物和新事物一样，在何时何地以及应该何时何地存在许多容易犯的错误。使用。</p>
</div>
<div class="sect1">
<h2 id="what-is-it"><a class="anchor" href="#what-is-it"></a>它是什么？</h2>
<div class="sectionbody">
<div class="paragraph">
<p>响应式编程是一种微体系结构，涉及智能路由和事件消耗，所有这些都结合在一起以改变行为。这有点抽象，您在网上也会遇到许多其他定义。我们尝试建立一些更具体的概念，以表示反应是什么意思，或者为什么它在接下来的事情中可能很重要。</p>
</div>
<div class="paragraph">
<p>响应式编程的起源可能可以追溯到1970年代甚至更早，所以这个想法没有什么新意，但是它们确实在现代企业中引起了共鸣。在微服务兴起和多核处理器无处不在的同时，这种共鸣已经（并非偶然）到达。希望其中的一些原因将变得清楚。</p>
</div>
<div class="paragraph">
<p>以下是来自其他来源的一些有用的封装定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>The basic idea behind reactive programming is that there are certain
datatypes that represent a value "over time". Computations that
involve these changing-over-time values will themselves have values
that change over time.</pre>
</div>
</div>
<div class="paragraph">
<p>还有...</p>
</div>
<div class="listingblock">
<div class="content">
<pre>An easy way of reaching a first intuition about what it's like is to
imagine your program is a spreadsheet and all of your variables are
cells. If any of the cells in a spreadsheet change, any cells that
refer to that cell change as well. It's just the same with FRP. Now
imagine that some of the cells change on their own (or rather, are
taken from the outside world): in a GUI situation, the position of
the mouse would be a good example.</pre>
</div>
</div>
<div class="paragraph">
<p>（来自<a href="https://stackoverflow.com/questions/1028250/what-is-functional-reactive-programming">Stackoverflow的术语问题</a> ）</p>
</div>
<div class="paragraph">
<p>FRP与高性能，并发性，异步操作和无阻塞IO具有很强的亲和力。但是，从怀疑FRP与它们中的任何一个都没有关系开始可能会有所帮助。当然，在使用响应式模型时，这种顾虑可以自然地处理，通常对调用者透明。但是，就有效或有效处理这些问题而言，实际收益完全取决于所讨论的实现（因此应受到高度审查）。也有可能以同步，单线程的方式实现一个完美而又有用的FRP框架，但这在尝试使用任何新工具和库中实际上并没有帮助。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reactive-use-cases"><a class="anchor" href="#reactive-use-cases"></a>反应性用例</h2>
<div class="sectionbody">
<div class="paragraph">
<p>作为新手，最难回答的问题似乎是“这有什么用？“以下是来自企业环境的一些示例，这些示例说明了一般的使用模式：</p>
</div>
<div class="paragraph">
<p><strong>外部服务调用</strong>如今，许多后端服务都是基于REST的（即，它们通过HTTP运行），因此底层协议从根本上是阻塞和同步的。FRP的领域可能并不明显，但实际上这是一块肥沃的土地，因为此类服务的实施通常涉及调用其他服务，然后再根据首次调用的结果调用更多服务。如果要在发送下一个请求之前等待一个呼叫完成，那么会有大量的IO进行，那么可怜的客户端会在您设法收集答复之前感到沮丧。因此，优化外部服务调用，尤其是调用之间的依赖关系的复杂编排，是一件好事。FRP保证了驱动这些操作的逻辑的“可组合性”，因此对于调用服务的开发人员来说更容易编写。</p>
</div>
<div class="paragraph">
<p><strong>高度并发的消息使用者</strong>消息处理，尤其是高度并发的消息处理，是企业常见的用例。响应式框架喜欢测量微基准，并吹嘘您可以在JVM中每秒处理多少消息。结果确实是惊人的（每秒很容易获得数千万条消息），但可能有些人为-如果他们说他们正在对一个简单的“ for”循环进行基准测试，您将不会感到印象深刻。但是，我们不应该过快地注销此类工作，并且很容易看出，当绩效很重要时，所有贡献都应被感激地接受。反应模式自然适合消息处理（因为事件可以很好地转换为消息），因此，如果有一种方法可以更快地处理更多消息，则应引起注意。</p>
</div>
<div class="paragraph">
<p><strong>电子表格</strong>也许不是真正的企业用例，但企业中的每个人都可以轻松地联系到一个用例，它很好地体现了FRP的理念和实施难度。如果单元格B依赖于单元格A，并且单元格C同时依赖于单元格A和B，那么您如何传播A中的更改，确保在将任何更改事件发送到B之前更新C？如果您有一个真正的可响应框架可以构建，那么答案是“您不在乎，您只需声明依赖项”，这简而言之就是电子表格的强大功能。它还强调了FRP和简单的事件驱动编程之间的区别-将“智能”置于“智能路由”中。</p>
</div>
<div class="paragraph">
<p><strong>抽象在（A）的同步处理</strong>这更多的是一种抽象的使用案例，让误闯，我们或许应该避免领土。在此和已经提到的更具体的用例之间也存在（很多）重叠，但是希望仍然值得一些讨论。基本主张是一个熟悉的（并且是合理的）主张，即只要开发人员愿意接受额外的抽象层，他们就可以忘记所调用的代码是同步的还是异步的。由于处理异步编程需要花费宝贵的脑细胞，因此那里可能会有一些有用的想法。响应式编程不是解决此问题的唯一方法，但是FRP的一些实施者已经对此问题进行了充分的思考，以使其工具有用。</p>
</div>
<div class="paragraph">
<p>该Netflix博客提供了一些真实有用的实际用例示例： <a href="http://techblog.netflix.com/2013/02/rxjava-netflix-api.html">Netflix Tech博客：带有RxJava的Netflix API中的功能性响应</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="comparisons"><a class="anchor" href="#comparisons"></a>比较</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果您从1970年以来一直不在洞穴里生活，您将遇到其他一些与响应式编程以及人们尝试使用它解决的问题有关的概念。以下是其中一些与我个人相关的观点：</p>
</div>
<div class="paragraph">
<p><strong>Ruby Event-Machine</strong> <a href="https://github.com/eventmachine/eventmachine">Event Machine</a>是并发编程（通常涉及非阻塞IO）的抽象。Rubyists努力了很长时间才能将一种专为单线程脚本编写的语言转换为可用于编写服务器应用程序的语言，该服务器应用程序a）工作良好，b）性能良好，并且c）在负载下仍然有效。Ruby拥有线程已有很长一段时间了，但是它们使用不多且声誉不佳，因为它们并不总是性能很好。<a href="https://www.ruby-doc.org/core-1.9.3/Fiber.html">Fibers</a> （sic）是一种替代语言，现在已经无所不在（在Ruby 1.9中已被提升为该语言的核心）。Fiber编程模型有点像协程（请参见下文），其中一个本地线程用于处理大量并发请求（通常涉及IO）。编程模型本身有点抽象并且很难推理，因此大多数人都使用包装器，而事件机器是最常见的。Event Machine不一定要使用Fibers（它会抽象这些问题），但是很容易在Ruby Web应用程序中使用带有Fibers的Event Machine来查找代码示例（例如， <a href="https://www.igvita.com/2009/05/13/fibers-cooperative-scheduling-in-ruby">请参见Ilya Grigorik的本文</a>或<a href="https://github.com/igrigorik/em-http-request/blob/master/examples/fibered-http.rb">em-http中</a>的<a href="https://github.com/igrigorik/em-http-request/blob/master/examples/fibered-http.rb">纤维化示例-request</a> ）。人们经常这样做，以获得在I / O密集型应用程序中使用事件机器所带来的可伸缩性，而无需使用大量嵌套回调获得的丑陋编程模型。</p>
</div>
<div class="paragraph">
<p><strong>Actor模型</strong>类似于面向对象的编程，Actor模型是可追溯到1970年代的计算机科学的深层线程。参与者提供了对计算的抽象（与数据和行为相反），从而自然而然地允许了并发，因此从实际意义上讲，它们可以构成并发系统的基础。Actor互相发送消息，因此它们在某种意义上是反应性的，并且在将自己称为Actor或Reactive的系统之间存在很多重叠。通常，区别在于它们的实现级别（例如， <a href="http://doc.akka.io/docs/akka/current/java.html">Akka中的</a> <code>Actors</code>可以分布在各个过程中，这是该框架的显着特征）。</p>
</div>
<div class="paragraph">
<p><strong>延迟结果（未来）</strong> Java 1.5引入了一组丰富的新库，其中包括Doug Lea的“ java.util.concurrent”，其中一部分是延迟结果的概念，封装在<code>Future</code> 。这是通过异步模式进行简单抽象的一个很好的示例，而无需强制实现异步或使用任何特定的异步处理模型。正如<a href="http://techblog.netflix.com/2013/02/rxjava-netflix-api.html">Netflix的Tech Blog：带有RxJava的Netflix API中的功能性响应</a>很好地显示的那样，如果您需要并发处理一组相似的任务，但是只要它们中的任何一个希望彼此依赖或有条件地执行，则<code>Futures</code>就是很好的选择您会陷入“嵌套回调地狱”的形式。响应式编程对此提供了解决方法。</p>
</div>
<div class="paragraph">
<p>并行处理中的<strong>Map-reduce和fork-join</strong>抽象很有用，并且有许多示例可供选择。在Java世界中最近发展起来的Map-reduce和fork-join由大规模并行分布式处理（ <a href="http://research.google.com/archive/mapreduce-osdi04.pdf">MapReduce</a>和<a href="https://wiki.apache.org/hadoop/MapReduce">Hadoop</a> ）以及1.7版的JDK本身（ <a href="http://gee.cs.oswego.edu/dl/papers/fj.pdf">Fork-Join</a> ）驱动。这些是有用的抽象，但是（如延迟的结果）与FRP相比，它们是浅薄的，FRP可以用作简单并行处理的抽象，但超出了可组合性和声明性通信。</p>
</div>
<div class="paragraph">
<p><strong>协同程序</strong>一个<a href="https://en.wikipedia.org/wiki/Coroutines">“协同程序”</a>是一个“子程序”的概括-它有一个进入点和退出点（S）与子例程类似，但它退出时，将控制传递给另一个协程（不一定是调用者），和任何累积的状态会在下次调用时保留并记住。协程可以用作Actor和Streams等更高级别功能的构建块。响应式编程的目标之一是通过通信并行处理代理提供相同类型的抽象，因此协程（如果可用）是有用的构建块。协程有多种口味，其中一些比一般情况下限制性更强，但比香草子程序更具灵活性。纤维（请参阅有关事件计算机的讨论）是一种味道，而生成器（熟悉Scala和Python）是另一种味道。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reactive-programming-in-java"><a class="anchor" href="#reactive-programming-in-java"></a> Java的反应式编程</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Java不是本地支持协程的，因此它不是“反应性语言”。JVM上还有其他语言（Scala和Clojure）更本地地支持响应模型，但是Java本身直到版本9才支持。但是，Java是企业开发的强大力量，最近在JDK之上提供Reactive层已开展了很多活动。我们在这里仅对其中的几个进行简要介绍。</p>
</div>
<div class="paragraph">
<p><a href="http://www.reactive-streams.org/"><strong>反应性流</strong></a>是一种非常低级的协定，表示为少数Java接口（加上TCK），但也适用于其他语言。这些接口通过明显的背压表达了<code>Publisher</code>和<code>Subscriber</code>的基本构建块，从而形成了可互操作库的通用语言。反应性流已作为<code>java.util.concurrent.Flow</code></p><code>java.util.concurrent.Flow</code></div><code>java.util.concurrent.Flow</code></div><code>java.util.concurrent.Flow</code></div><code>java.util.concurrent.Flow</code></div><code>java.util.concurrent.Flow</code></div><code>java.util.concurrent.Flow</code></article><code>java.util.concurrent.Flow</code></div><code>java.util.concurrent.Flow</code></div><code>java.util.concurrent.Flow</code></div><code>java.util.concurrent.Flow</code></div><code>java.util.concurrent.Flow</code></body></html>