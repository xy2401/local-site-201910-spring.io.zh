<!DOCTYPE html>
<html data-code-prettify="" data-mobile-support="" data-search="">
<head>
<title>The Joy of Mustache: Server Side Templates for the JVM</title>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no" id="Viewport" name="viewport" />
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png" />
<link href="https://fonts.googleapis.com/css?family=Varela+Round|Montserrat:400,700" rel="stylesheet" type="text/css" />
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css" />
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M" name="google-site-verification" />

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css" />

<meta content="summary" name="twitter:card" />
<meta content="@springcentral" name="twitter:site" />
<meta name="twitter:title" content="The Joy of Mustache: Server Side Templates for the JVM" />
<meta name="twitter:description" content="&lt;div class=&quot;paragraph&quot;&gt; 
 &lt;p&gt;I don’t do much server-side templating, but when I do…​ well frankly, I tend to forget things. Every template language has its strengths and weaknesses, and they all have syntax to remember, and more frequently to forget. Recently I completed some work on the old &lt;a href=&quot;https://github.com/spring-projects/spring-petclinic&quot;&gt;Spring Petclinic&lt;/a&gt;, converting it to use &lt;a href=&quot;http://www.thymeleaf.org/&quot;&gt;Thymeleaf&lt;/a&gt; in the view layer, and re-organizing the code to be a bit more &quot;modern&quot;. I enjoyed working with Thymeleaf 3, and found it a pleasant experience, but had to spend a lot of time scanning documentation and samples. Then I had another little project that needed some templates, and I remembered my fondness for &lt;a href=&quot;http://mustache.github.com&quot;&gt;Mustache&lt;/a&gt;, which we added to Spring Boot back in version 1.2, and which plays an important role in the excellent &lt;a href=&quot;https://github.com/spring-projects/spring-restdocs&quot;&gt;Spring REST Docs&lt;/a&gt; tool. I added &lt;code&gt;spring-boot-starter-mustache&lt;/code&gt; to my new project, and was up and running within seconds.&lt;/p&gt; 
&lt;/div&gt;
" />
<meta name="twitter:creator" content="@david_syer" />
<meta name="twitter:image:src" content="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=200" />

<meta property="og:title" content="The Joy of Mustache: Server Side Templates for the JVM" />
<meta property="og:image" content="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=200" />
<meta property="og:description" content="&lt;div class=&quot;paragraph&quot;&gt; 
 &lt;p&gt;I don’t do much server-side templating, but when I do…​ well frankly, I tend to forget things. Every template language has its strengths and weaknesses, and they all have syntax to remember, and more frequently to forget. Recently I completed some work on the old &lt;a href=&quot;https://github.com/spring-projects/spring-petclinic&quot;&gt;Spring Petclinic&lt;/a&gt;, converting it to use &lt;a href=&quot;http://www.thymeleaf.org/&quot;&gt;Thymeleaf&lt;/a&gt; in the view layer, and re-organizing the code to be a bit more &quot;modern&quot;. I enjoyed working with Thymeleaf 3, and found it a pleasant experience, but had to spend a lot of time scanning documentation and samples. Then I had another little project that needed some templates, and I remembered my fondness for &lt;a href=&quot;http://mustache.github.com&quot;&gt;Mustache&lt;/a&gt;, which we added to Spring Boot back in version 1.2, and which plays an important role in the excellent &lt;a href=&quot;https://github.com/spring-projects/spring-restdocs&quot;&gt;Spring REST Docs&lt;/a&gt; tool. I added &lt;code&gt;spring-boot-starter-mustache&lt;/code&gt; to my new project, and was up and running within seconds.&lt;/p&gt; 
&lt;/div&gt;
" />
<meta content="article" property="og:type" />
<meta property="og:article:published_time" content="2016-11-21 10:46:00.0" />
</head>
<body>

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" style="display:none;visibility:hidden" width="0"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">Projects</a>
</li>
<li class="navbar-link">
<a href="/guides">Guides</a>
</li>
<li class="navbar-link active">
<a href="/blog">Blog</a>
</li>
<li class="navbar-link">
<a href="/services">Training & Certification</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form action="/search" class="form-inline form-search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search for documentation, guides, and posts..." type="text" value="" />
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form action="/search" class="form-inline form-search" method="get">
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search..." type="text" value="" />
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">
Home
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">
Projects
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">
Guides
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">
Blog
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">
Training & Certification
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>Engineering</div>
</div>
<div class="blog-category content--title">
<div>Releases</div>
</div>
<div class="blog-category content--title">
<div>News and Events</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">The Joy of Mustache: Server Side Templates for the JVM</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">Engineering</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=20&amp;d=mm" />
<a class="author" rel="author" href="/team/dsyer">Dave Syer</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2016-11-21 10:46:00.0">November 21, 2016</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" data-disqus-identifier="2701" href="/blog/2016/11/21/the-joy-of-mustache-server-side-templates-for-the-jvm#disqus_thread">
</a></div>
</div>
</header>
<div class="blog--post"><div class="paragraph">
<p>I don&#8217;t do much server-side templating, but when I do&#8230;&#8203; well frankly,
I tend to forget things. Every template language has its strengths and
weaknesses, and they all have syntax to remember, and more frequently
to forget. Recently I completed some work on the old
<a href="https://github.com/spring-projects/spring-petclinic">Spring Petclinic</a>,
converting it to use <a href="http://www.thymeleaf.org/">Thymeleaf</a> in the view
layer, and re-organizing the code to be a bit more "modern". I enjoyed
working with Thymeleaf 3, and found it a pleasant experience, but had
to spend a lot of time scanning documentation and samples. Then I had
another little project that needed some templates, and I remembered my
fondness for <a href="https://mustache.github.com">Mustache</a>, which we added to
Spring Boot back in version 1.2, and which plays an important role in
the excellent
<a href="https://github.com/spring-projects/spring-restdocs">Spring REST
Docs</a> tool. I added <code>spring-boot-starter-mustache</code> to my new project, and
was up and running within seconds.</p>
</div>
<div class="paragraph">
<p>I want to show you what a neat little tool
<a href="https://github.com/samskivert/jmustache">JMustache</a> is for server side
rendering of HTML (or anything else in plain text come to that). I
always liked <a href="https://mustache.github.com/">Mustache</a> because of its
simplicity - it&#8217;s "just enough" templating - and you really couldn&#8217;t
wish for a cleaner, leaner, more lightweight library than this one, if
you have to render templates in the JVM. There is one jar file with no
dependencies, and it adds 78kb to your classpath, which isn&#8217;t going to
hurt anyone, and will put a smile on many faces. It has very few
features, which is excellent for people who can&#8217;t remember syntax, and
the manual is short, comprehensive, readable, and useful.</p>
</div>
<div class="paragraph">
<p>If you carry on reading, as we build up a sample application, you will
see how to build HTML pages with Mustache, rendering static and
dynamic content, building forms and menus, and abstracting the layout
of the pages into separate components. The simplicity of Mustache
shines through, and guides you to put logic in Java, keeping the
templates as clean as possible. As a sidebar you will see how to
secure an application with a custom login form in a slightly unusual
but interesting way.</p>
</div>
<div class="sect1">
<h2 id="sample-code"><a class="anchor" href="#sample-code"></a>Sample Code</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There is some sample code following the text in
<a href="https://github.com/dsyer/mustache-sample">GitHub</a>. It is a tiny Spring
MVC application, also using Spring Security. If you want to see it
develop in stages along with the text, you can use some tags:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>"base" is a starting point with a working application</p>
</li>
<li>
<p>"includes" creates a re-usable layout using a header and a footer</p>
</li>
<li>
<p>"layout" is a slightly more advanced implementation using a Mustache
lambda</p>
</li>
<li>
<p>"menus" adds some more UI elements using more Spring Boot and
Mustache features</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>At every stage you can checkout the tag and run the app. There is a
Maven wrapper in the root of the project, so you can build and run it
from the command line, e.g.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>$ git clone https://github.com/dsyer/mustache-sample
$ cd mustache-sample
$ git checkout base
$ ./mvnw spring-boot:run</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead of running from the command line you can import the project
into your favourite IDE and run the main method in the
<code>DemoApplication</code>.</p>
</div>
<div class="paragraph">
<p>The app runs on <a href="http://localhost:8080" class="bare">http://localhost:8080</a>, and you can authenticate with
any username and password (even empty!). There are no real features in
the sample app, but it does have login and logout and a home page, to
provide some hooks to show the templating features.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="getting-started"><a class="anchor" href="#getting-started"></a>Getting Started</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://projects.spring.io/spring-boot/">Spring Boot</a> has
autoconfiguration support for JMustache, so it is easy to get up and
running with a Spring MVC application. You could generate a project
from the <a href="https://start.spring.io">Spring Initializr</a>, and ask it for
<code>spring-boot-starter-mustache</code>.</p>
</div>
<div class="paragraph">
<p>Spring Boot automatically configures a <code>ViewResolver</code> for JMustache,
so you can implement a home page by providing a controller that
returns a view name, e.g.</p>
</div>
<div class="listingblock">
<div class="title">HomeController.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Controller
class HomeController {
  @GetMapping("/")
  String home() {
    return "index";
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>With this controller, when the user visits the home page ("/") Spring
will render a template at <code>classpath:/templates/index.html</code>, which
means in the directory <code>src/main/resources/templates</code> in your
project. For example you could drop this in and confirm that it works:</p>
</div>
<div class="listingblock">
<div class="title">index.html</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;!doctype html&gt;
&lt;html lang="en"&gt;
  &lt;body&gt;
    &lt;h1&gt;Demo&lt;/h1&gt;
    &lt;div&gt;Hello World&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="make-the-application-secure"><a class="anchor" href="#make-the-application-secure"></a>Make the Application Secure</h3>
<div class="paragraph">
<p>There&#8217;s no dynamic (templated) content there yet. Let&#8217;s make the app
secure and add a login form, at which point you will need the dynamic
content. So add <code>spring-cloud-starter-security</code> to your dependencies
and the home page will be automatically protected. Suppose you
want to have a login form at "/login", so you&#8217;ll need the controller:</p>
</div>
<div class="listingblock">
<div class="title">LoginController.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@Controller
@RequestMapping("/login")
class LoginController {

	@GetMapping
	public String form() {
		return "login";
	}

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You will also need some basic security configuration, which you can
add as a method in the main application, if you extend a base class
from Spring Security:</p>
</div>
<div class="listingblock">
<div class="title">DemoApplication.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@SpringBootApplication
public class DemoApplication extends WebSecurityConfigurerAdapter {

  @Override
  protected void configure(HttpSecurity http) throws Exception {
    http.authorizeRequests()
          .antMatchers("/login", "/error").permitAll()
          .antMatchers("/**").authenticated()
        .and().exceptionHandling()
          .authenticationEntryPoint(new LoginUrlAuthenticationEntryPoint("/login"));
  }

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
this is a slightly unconventional configuration for form login,
because it isn&#8217;t using the built-in <code>formLogin()</code>, which would
automatically add the authentication entry point. If that&#8217;s
distracting then skip the next section and just add <code>.formLogin()</code> to
your configuration instead of the <code>exceptionHandling()</code> above
(everything after the <code>.and()</code>)
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="custom-authentication-processing-with-spring-mvc"><a class="anchor" href="#custom-authentication-processing-with-spring-mvc"></a>Custom Authentication Processing with Spring MVC</h3>
<div class="paragraph">
<p>Spring Security implements form login (and everything else really)
using a <code>Filter</code>, so that&#8217;s what you would get with the built in
<code>formLogin()</code> configuration. Just to make things interesting, you are
going to do the authentication in a Spring MVC handler, enabling you
to add some custom logic, and MVC is easier to work with than
filters.</p>
</div>
<div class="paragraph">
<p>So let&#8217;s extend the <code>LoginController</code> with a method to handle
username/password authentication (it is easy to extend to more
complicated logic). The main thing it needs to do is validate the
input and if it is a real user, populate the <code>SecurityContext</code>:</p>
</div>
<div class="listingblock">
<div class="title">LoginController.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@PostMapping
public void authenticate(@RequestParam Map&lt;String, String&gt; map) throws Exception {
  Authentication result = new UsernamePasswordAuthenticationToken(
      map.get("username"), "N/A",
      AuthorityUtils.commaSeparatedStringToAuthorityList("ROLE_USER"));
  SecurityContextHolder.getContext().setAuthentication(result);
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
In this simple example there is only a "happy path" - all users are
authenticated. Obviously this is not a very secure authentication
process, and you would want to throw an <code>AuthenticationException</code>,
e.g. <code>BadCredentialsException</code>, in a real controller. The exception
would be handled by Spring Security.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To mimic the behaviour of the built-in Spring Security login form, you
also need to be able to redirect to a "saved request" that the user
tried to access before login. Spring Security has an
<code>AuthenticationSuccessHandler</code> abstraction for that, and a simple
implementation that knows about the saved request. So the
<code>authenticate</code> method can use that (it needs the servlet request and
response, which you can add those as method parameters, and Spring MVC
will inject them):</p>
</div>
<div class="listingblock">
<div class="title">LoginController.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">private AuthenticationSuccessHandler handler = new SavedRequestAwareAuthenticationSuccessHandler();

@PostMapping
public void authenticate(@RequestParam Map&lt;String, String&gt; map,
    HttpServletRequest request, HttpServletResponse response) throws Exception {
  // ... authenticate user from request parameters
  handler.onAuthenticationSuccess(request, response, result);
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="the-login-form"><a class="anchor" href="#the-login-form"></a>The Login Form</h3>
<div class="paragraph">
<p>Now you are ready to accept authentication requests, you need a form for
users to fill in and submit. The <code>LoginController</code> renders the "login"
template, so you need to add a "login.html" to your templates
folder. For example:</p>
</div>
<div class="listingblock">
<div class="title">login.html</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;
  &lt;h1&gt;Login&lt;/h1&gt;
  &lt;form action="/login" method="post"&gt;                            <b class="conum">(1)</b>
    &lt;label for="username"&gt;Username:&lt;/label&gt;
    &lt;input type="text" name="username" /&gt;                         <b class="conum">(2)</b>
    &lt;label for="password"&gt;Password:&lt;/label&gt;
    &lt;input type="password" name="password" /&gt;                     <b class="conum">(3)</b>
    &lt;input type="hidden" name="_csrf" value="{{_csrf.token}}" /&gt;  <b class="conum">(4)</b>
    &lt;button type="submit" class="btn btn-primary"&gt;Submit&lt;/button&gt;
  &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>a form, with a submit button to send the contents to "POST /login"</p>
</li>
<li>
<p>username field input</p>
</li>
<li>
<p>password field input</p>
</li>
<li>
<p>CSRF token, in the format required by Spring Security.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The CSRF token is your first piece of dynamic content, and it shows
you how Mustache works, and incidentally why it is called
"Mustache". Variables from the "context" (in this case the Spring MVC
model object) can be rendered using double braces, or "mustaches"
(<code>{{</code> and <code>}}</code>). JMustache also navigates the object graph inside
variables, so <code>_csrf.token</code> resolves as the "token" property of the
"_csrf" object.</p>
</div>
<div class="paragraph">
<p>Spring Security puts the "_csrf" object into request attributes. To
get it copied to the MVC model you need a setting in your
<code>application.properties</code>:</p>
</div>
<div class="listingblock">
<div class="title">application.properties</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-properties" data-lang="properties">spring.mustache.expose-request-attributes=true</code></pre>
</div>
</div>
<div class="paragraph">
<p>With all that in place, you should find that on visiting the
application in a browser will first redirect to "/login". Because of
the weak (non-existent) authentication logic in your handler, you can
put anything you like in the form and submit it to see the home page.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
in the sample app we have some stylesheets imported via webjars
to make the app look a little bit nicer, but they don&#8217;t add anything
to the functionality.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The sample code has a "base" tag which is an application with all the
features we have seen so far.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="layout-abstractions-using-includes"><a class="anchor" href="#layout-abstractions-using-includes"></a>Layout Abstractions: Using Includes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are only 2 pages in our application, but even with such a small
code base there is going to be a quite a bit of duplication in the
HTML. It is useful to extract some common elements of all pages into
re-usable templates. One way to do this is with "includes". So we
could extract the top matter and bottom matter into "header.html":</p>
</div>
<div class="listingblock">
<div class="title">header.html</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>and "footer.html"</p>
</div>
<div class="listingblock">
<div class="title">footer.html</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>(These are intentionally trivial examples. In a real app they would
probably have a lot of stylesheets, scripts, and meta tags.)</p>
</div>
<div class="paragraph">
<p>With those templates we can re-write the home page:</p>
</div>
<div class="listingblock">
<div class="title">index.html</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">{{&gt;header}}
    &lt;h1&gt;Demo&lt;/h1&gt;
    &lt;div&gt;Hello World&lt;/div&gt;
{{&gt;footer}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and the login form would look similar (just the body of the HTML). In
these examples you can see the Mustache syntax for "includes", which
is a bit like a variable, but with an extra "&gt;" in the opening
tag. The name of the template is resolved in the same way as the view
templates (so "footer" is mapped to "footer.html" in the "templates"
directory).</p>
</div>
<div class="sect2">
<h3 id="natural-templates"><a class="anchor" href="#natural-templates"></a>"Natural" Templates</h3>
<div class="paragraph">
<p>Some people like to use HTML templates that render on their own and
can be viewed in a browser. It&#8217;s kind of neat to be able to edit the
templates and be able to see the result independent of any server or
application logic. Mustache isn&#8217;t a perfect language for such
"natural" templates, but it does have one feature that you can use to
get something approximating it. That feature is "comments".</p>
</div>
<div class="paragraph">
<p>So, for example, you could add a static header and footer to your home
page template, so that it renders in the browser (almost) as if it was
in the application. Just surround the static content with Mustache
comment tags (<code>{{!</code> and <code>}}</code>). For example:</p>
</div>
<div class="listingblock">
<div class="title">index.html</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">{{!
&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;
}}
{{&gt;header}}
    &lt;h1&gt;Demo&lt;/h1&gt;
    &lt;div&gt;Hello World&lt;/div&gt;
{{&gt;footer}}
{{!
&lt;/body&gt;
&lt;/html&gt;
}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The browser will still render the Mustache tags as literal braces, but
you can squint and ignore those, and the rest of the content will be
layed out exactly as it would be in the application. Obviously, with
such basic content there isn&#8217;t a huge benefit, but when the content is
more complex and has styling and scripts it might make more sense.</p>
</div>
<div class="paragraph">
<p>The sample code has a tag in GitHub called "includes", which is an
application with all the features we have seen so far.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="layout-abstractions-using-a-lambda"><a class="anchor" href="#layout-abstractions-using-a-lambda"></a>Layout Abstractions: Using a Lambda</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Some people will be perfectly happy with a header and a footer in
separate templates, but others will moan. To be honest it does feel a
little awkward to be laying out hierarchical content (HTML), and be
forced to break elements (like the <code>&lt;body&gt;</code> tag in the sample) across
multiple files. It would be nicer if we could control the layout in a
single file, something like this:</p>
</div>
<div class="listingblock">
<div class="title">layout.html</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;body&gt;
  {{{layout.body}}}
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>and then somehow generate the "body" content in our home page and
login page.</p>
</div>
<div class="paragraph">
<p>Mustache allows you to insert generic "executable" content into your
templates. This is a really powerful feature, and you can use it to
extract the layout into its own template, as well as to do other
things that involve a bit of logic. The syntax for that is a generic
Mustache tag that resolves to something executable. The home
page would look something like this:</p>
</div>
<div class="listingblock">
<div class="title">index.html</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">{{#layout}}
    &lt;h1&gt;Demo&lt;/h1&gt;
    &lt;div&gt;Hello World&lt;/div&gt;\
{{/layout}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To make this work you first need an object called "layout" of type
<code>Mustache.Lambda</code> in our MVC model. You could do this in your
controller methods, or (better) use a <code>@ControllerAdvice</code> to add model
attributes to all views. For example:</p>
</div>
<div class="listingblock">
<div class="title">LayoutAdvice.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@ControllerAdvice
class LayoutAdvice {

  @ModelAttribute("layout")
  public Mustache.Lambda layout() {
    return new Layout();
  }

}

class Layout implements Mustache.Lambda {
  String body;
  @Override
  public void execute(Fragment frag, Writer out) throws IOException {
    body = frag.execute();
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that the "layout" attribute renders its body using
<code>Fragment.execute()</code> and assigns it to a property called "body", which
can be referenced as a variable in Mustache. The "layout.html"
template already contains the code to pull in the body,
<code>{{{layout.body}}}</code>, so all that remains is to actually render the
layout (so far we have only rendered the body). We can do this, in a
first pass, by importing the layout explicitly into the home
page:</p>
</div>
<div class="listingblock">
<div class="title">index.html</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">{{#layout}}
    &lt;h1&gt;Demo&lt;/h1&gt;
    &lt;div&gt;Hello World&lt;/div&gt;\
{{/layout}}
{{&gt;layout}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Do the same with the login template:</p>
</div>
<div class="listingblock">
<div class="title">login.html</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">{{#layout}}
  &lt;h1&gt;Login&lt;/h1&gt;
  &lt;form action="/login" method="post"&gt;
    &lt;label for="username"&gt;Username:&lt;/label&gt;
    &lt;input type="text" name="username" /&gt;
    &lt;label for="password"&gt;Password:&lt;/label&gt;
    &lt;input type="password" name="password" /&gt;
    &lt;input type="hidden" name="_csrf" value="{{_csrf.token}}" /&gt;
    &lt;button type="submit" class="btn btn-primary"&gt;Submit&lt;/button&gt;
  &lt;/form&gt;
{{/layout}}
{{&gt;layout}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and you are good to go. Everything works, and the app shows the login page and home page with the same layout.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
you might have noticed the triple mustaches (<code>{{{</code> and <code>}}}</code>) in
the "layout.html". This is a JMustache feature: all content is escaped
by default, but this content is going to be rendered twice, so we only
need it escaped the first time, so we use triple mustaches.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="rendering-the-layout-in-the-lambda"><a class="anchor" href="#rendering-the-layout-in-the-lambda"></a>Rendering the Layout in the Lambda</h3>
<div class="paragraph">
<p>To remove the need for the explicit <code>{{&gt;layout}}</code> include in every
page that uses <code>{{#layout}}</code>, you can do that part inside the
lambda. You&#8217;ll need a reference to the Mustache compiler, and then you
just need to compile a template which includes the layout and execute
it:</p>
</div>
<div class="listingblock">
<div class="title">Layout.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">class Layout implements Mustache.Lambda {

  String body;

  private Compiler compiler;

  public Layout(Compiler compiler) {
    this.compiler = compiler;
  }

  @Override
  public void execute(Fragment frag, Writer out) throws IOException {
    body = frag.execute();
    compiler.compile("{{&gt;layout}}").execute(frag.context(), out);
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The compiler is wired into the <code>Layout</code> in its constructor, and it can
be injected into the controller advice using <code>@Autowired</code>:</p>
</div>
<div class="listingblock">
<div class="title">LayoutAdvice.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@ControllerAdvice
class LayoutAdvice {
	private final Mustache.Compiler compiler;

	@Autowired
	public LayoutAdvice(Compiler compiler) {
		this.compiler = compiler;
	}

	@ModelAttribute("layout")
	public Mustache.Lambda layout(Map&lt;String, Object&gt; model) {
		return new Layout(compiler);
	}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s it. You can remove the include from the view
templates. E.g. this works for the home page:</p>
</div>
<div class="listingblock">
<div class="title">index.html</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">{{#layout}}
    &lt;h1&gt;Demo&lt;/h1&gt;
    &lt;div&gt;Hello World&lt;/div&gt;\
{{/layout}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The last line of the old version of the template has effectively been
moved into the <code>Layout</code> lambda.</p>
</div>
</div>
<div class="sect2">
<h3 id="more-dynamic-content"><a class="anchor" href="#more-dynamic-content"></a>More Dynamic Content</h3>
<div class="paragraph">
<p>It&#8217;s quite common for layout templates like the one that we are
developing to have content that varies between uses. For instance you
might want the "title" on the home page to be different to that on the
login page, but it is part of the HTML header, not the body, so
logically it is part of the layout. Let&#8217;s make that explicit, by
adding the title to the header of the layout:</p>
</div>
<div class="listingblock">
<div class="title">layout.html</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;title&gt;{{{layout.title}}}&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  {{{layout.body}}}
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a strong hint about how you can implement this feature: the
layout has a new property called "title", and you can give it a
default value in the class declaration:</p>
</div>
<div class="listingblock">
<div class="title">Layout.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">class Layout implements Mustache.Lambda {

  String body;

  String title = "Demo Application";

  ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, all that remains is to populate that property. Logically, setting
the title is part of the page view, not the layout, so you&#8217;d like to
set it in the same place you declare the rest of the page
content. Other template languages have "parameterised fragments", but
Mustache is too minimalistic for that. The minimalism is a feature,
and actually it leads to quite an elegant solution to this
problem.</p>
</div>
<div class="paragraph">
<p>All you have is tags, so you might want to do something like this:</p>
</div>
<div class="listingblock">
<div class="title">index.html</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">{{#layout}}{{#title}}Home Page{{/title}}
    &lt;h1&gt;Demo&lt;/h1&gt;
    &lt;div&gt;Hello World&lt;/div&gt;\
{{/layout}}</code></pre>
</div>
</div>
<div class="paragraph">
<p>That looks like it might work. All you need to do is provide a lambda
to capture the title. In the layout advice you can do this:</p>
</div>
<div class="listingblock">
<div class="title">LayoutAdvice.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@ControllerAdvice
class LayoutAdvice {

  ...

  @ModelAttribute("title")
  public Mustache.Lambda defaults(@ModelAttribute Layout layout) {
    return (frag, out) -&gt; {
      layout.title = frag.execute();
    };
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>and as long as the call to <code>{{#title}}</code> is nested inside the call to
<code>{{#layout}}</code> everything will work out just fine. You cleaned up your
templates and moved a tiny piece of logic to Java, where it belongs.</p>
</div>
<div class="paragraph">
<p>The sample code is tagged with "layout" at this point, if you want to
check it out and compare notes.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="logout-menus-and-spring-boot-configuration"><a class="anchor" href="#logout-menus-and-spring-boot-configuration"></a>Logout: Menus and Spring Boot Configuration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can load a home page and log into your application using a
form. The user can&#8217;t yet log out, so you probably want to add that
feature, ideally as a link on all pages, so that makes it part of the
layout. To show how that works, let&#8217;s add a generic, declarative menu
bar to the application, and make one part of it a logout button.</p>
</div>
<div class="paragraph">
<p>The logout link is actually pretty easy. We only need a form with the
CSRF token and a link to submit it, e.g:</p>
</div>
<div class="listingblock">
<div class="title">layout.html</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;title&gt;{{{layout.title}}}&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;form id="logout" action="/logout" method="post"&gt;
    &lt;input type="hidden" name="_csrf" value="{{_csrf.token}}" /&gt;
    &lt;button type="submit" class="btn btn-primary"&gt;Logout&lt;/button&gt;
  &lt;/form&gt;
  {{{layout.body}}}
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>That already should work. But lets incorporate the logout into a more
generic set of menu links. A list of elements in HTML can be
represented as a <code>&lt;ul/&gt;</code> with nested <code>&lt;li/&gt;</code>, so the menus for your
application can be rendered that way. In Mustache you do iteration
just like lambdas, using a tag, so let&#8217;s invent a new one called
<code>{{#menus}}</code>:</p>
</div>
<div class="listingblock">
<div class="title">layout.html</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;title&gt;{{{layout.title}}}&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;ul class="nav nav-pills" role="tablist"&gt;
    {{#menus}}&lt;li&gt;&lt;a href="{{path}}"&gt;{{name}}&lt;/a&gt;&lt;/li&gt;{{/menus}}
    &lt;li&gt;&lt;a href="#" onclick="document.getElementById('#logout').submit()"&gt;Logout&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
  {{{layout.body}}}
  &lt;form id="logout" action="/logout" method="post"&gt;
    &lt;input type="hidden" name="_csrf" value="{{_csrf.token}}" /&gt;
  &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that inside the <code>{{#menus}}</code> tag we pull out variables, "name"
and "path" using the normal Mustache syntax.</p>
</div>
<div class="paragraph">
<p>Now you have to define the tag in your controller advice (or
equivalently in the controllers), so that "menus" resolves to an
iterable:</p>
</div>
<div class="listingblock">
<div class="title">LayoutAdvice.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@ModelAttribute("menus")
public Iterable&lt;Menu&gt; menus() {
  return application.getMenus();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>So this new code introduced a <code>Menu</code> type that contains the static
content for each menu in the UI. The layout calls for "name" and
"path", so you need those properties:</p>
</div>
<div class="listingblock">
<div class="title">Menu.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">class Menu {
  private String name;
  private String path;
  // ... getters and setters
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the layout advice above the menus came from an <code>application</code>
object. That wasn&#8217;t strictly necessary: you could have declared the
list of menus inline in the <code>menus()</code> method, but extracting it into
another object gives us the chance to use a nice Spring Boot feature,
where we can declare the menus in a config file in a compact format.</p>
</div>
<div class="paragraph">
<p>So now you need to create the <code>Application</code> object to hold the menus,
and inject it into the layout advice:</p>
</div>
<div class="listingblock">
<div class="title">Layout.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">private Application application;

@Autowired
public LayoutAdvice(Compiler compiler, Application application) {
  this.compiler = compiler;
  this.application = application;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>where in <code>Application</code> you have something like this</p>
</div>
<div class="listingblock">
<div class="title">Application.java</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-html" data-lang="html">@Component
@ConfigurationProperties("app")
class Application {
  private List&lt;Menu&gt; menus = new ArrayList&lt;&gt;();
  // .. getters and setters
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@ConfigurationProperties</code> tells Spring Boot to bind to this bean
from the environment. Switching from <code>application.properties</code> to
<code>application.yml</code> you could create a "Home" and a "Login" menu like
this:</p>
</div>
<div class="listingblock">
<div class="title">application.yml</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-yaml" data-lang="yaml">app.menus:
  - name: Home
    path: /
  - name: Login
    path: /login</code></pre>
</div>
</div>
<div class="paragraph">
<p>With this in place, the "layout.html" that you already defined now has
all it needs to work.</p>
</div>
<div class="paragraph">
<p>The sample code is tagged with "menus" at this point in github, if you
want to check it out and compare notes. It&#8217;s also the final state, so
it&#8217;s the same code in master, possibly with bug fixes and updates to
libraries. I hope you enjoy using Mustache as much as I do.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="footnote"><a class="anchor" href="#footnote"></a>Footnote</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The sample has one or two extra features on top of the code in the
text. One of which is that the "active" menu is rendered differently
to the others using a CSS style. For that to work, you need to add a
flag to the <code>Menu</code> and reset it in the layout advice. The logic is
natural and easy to add to the advice. Another is that the title for
the page is part of the menu definition instead of being a separate
lambda.</p>
</div>
</div>
</div></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 2701;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>
Back
</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">All Posts</a>
<a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">Engineering</a>
<a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">Releases</a>
<a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">News and Events</a>
<a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>Get updates from The Spring Team delivered to your inbox</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">Tools</a></li>
<li><a href="https://store.pivotal.io/">Store</a></li>
<li><a href="/blog">Newsletter</a></li>
</ul>
</div>
</div>
&copy; <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a>, Inc. All Rights Reserved.
<a href="https://pivotal.io/terms-of-use">Terms of Use</a> &bullet;
<a href="https://pivotal.io/privacy-policy">Privacy</a> &bullet;
<a href="/trademarks">Trademark Guidelines</a>
<div id="teconsent" style="display:inline-block;"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>