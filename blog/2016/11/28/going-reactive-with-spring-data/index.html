<html  data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>对Spring Data做出反应</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Going reactive with Spring Data">
<meta name="twitter:description" content="<div class=" paragrap="="> 
 </head><body ><p>Last weeks' <a href="https://spring.io/blog/2016/11/23/first-milestone-of-next-generation-spring-data-released">Spring Data Kay M1</a> is the first release ever that comes with support for reactive data access. Its initial set of supported stores — MongoDB, Apache Cassandra and Redis — all ship reactive drivers already, which made them very natural candidates for such a prototype. Let’s take a more detailed look at the new programming model and the APIs that make up that support.</p> 

<div class="sect1"> 
 <h2 id="reactive-repositories"><a class="anchor" href="#reactive-repositories"></a>Reactive Repositories</h2> 
 <div class="sectionbody"> 
  <div class="paragraph"> 
   <p>The repositories programming model is the most high-level abstraction Spring Data users usually deal with. They’re usually comprised of a set of CRUD methods defined in a Spring Data provided interface and domain-specific query methods. Here’s what a reactive Spring Data repository definition would look like:</p> 
  </div> 
  <div class="exampleblock"> 
   <div class="content"> 
    <div class="listingblock"> 
     <div class="content"> 
      <pre class="prettyprint highlight"><code class="language-java" data-lang="java">public interface ReactivePersonRepository
  extends ReactiveCrudRepository<Person, String> {

  Flux<Person> findByLastname(Mono<String> lastname);

  @Query("{ 'firstname': ?0, 'lastname': ?1}")
  Mono<Person> findByFirstnameAndLastname(String firstname, String lastname);
}</code></pre> 
     </div> 
    </div> 
   </div> 
  </div> 
  <div class="paragraph"> 
   <p>As you can see, there’s not too much difference to what you’re used to. However, in contrast to the traditional repository interfaces, a reactive repository uses reactive types as return types and can do so for parameter types, too. The CRUD methods in the newly introduced <code>ReactiveCrudRepository</code>, of course make use of these types, too.</p> 
  </div> 
  <div class="paragraph"> 
   <p>By default, reactive repositories use <a href="https://projectreactor.io">Project Reactor</a> types but other reactive libraries can also be used. We provide a custom repository base interface (e.g. <code>RxJava2CrudRepository</code>) for those and also automatically adapt the types as needed for query methods, e.g RxJava’s <code>Observable</code> and <code>Single</code>. The rest basically stays the same. Note, however, that the current milestone does not support pagination yet and you of course have to have the necessary reactive libraries on the classpath to activate support for a particular library.</p> 
  </div> 
  <div class="sect2"> 
   <h3 id="reactive-configuration"><a class="anchor" href="#reactive-configuration"></a>Activating reactive Spring Data</h3> 
   <div class="paragraph"> 
    <p>Similarly to what we have in the blocking world, the support for reactive Spring Data is activated through an <code>@Enable…</code> annotation alongside some infrastructure setup:</p> 
   </div> 
   <div class="exampleblock"> 
    <div class="content"> 
     <div class="listingblock"> 
      <div class="content"> 
       <pre class="prettyprint highlight"><code class="language-java" data-lang="java">@EnableReactiveMongoRepositories
public class AppConfig extends AbstractReactiveMongoConfiguration {

  @Bean
  public MongoClient mongoClient() {
    return MongoClients.create();
  }

  @Override
  protected String getDatabaseName() {
    return "reactive";
  }
}</code></pre> 
      </div> 
     </div> 
    </div> 
   </div> 
   <div class="paragraph"> 
    <p>See how we use a different base class for the infrastructure configuration, as we need to make use of the MongoDB async driver.</p> 
   </div> 
  </div> 
 </div> 
</div>
">
<meta name="twitter:creator" content="@mp911de">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/6494a9d91e9ffef9adc8253257f1b35e?s=200">

<meta property="og:title" content="Going reactive with Spring Data">
<meta property="og:image" content="https://gravatar.com/avatar/6494a9d91e9ffef9adc8253257f1b35e?s=200">
<meta property="og:description" content="<div class=" paragrap="="> 
 <p>Last weeks' <a href="https://spring.io/blog/2016/11/23/first-milestone-of-next-generation-spring-data-released">Spring Data Kay M1</a> is the first release ever that comes with support for reactive data access. Its initial set of supported stores — MongoDB, Apache Cassandra and Redis — all ship reactive drivers already, which made them very natural candidates for such a prototype. Let’s take a more detailed look at the new programming model and the APIs that make up that support.</p> 

<div class="sect1"> 
 <h2 id="reactive-repositories"><a class="anchor" href="#reactive-repositories"></a>Reactive Repositories</h2> 
 <div class="sectionbody"> 
  <div class="paragraph"> 
   <p>The repositories programming model is the most high-level abstraction Spring Data users usually deal with. They’re usually comprised of a set of CRUD methods defined in a Spring Data provided interface and domain-specific query methods. Here’s what a reactive Spring Data repository definition would look like:</p> 
  </div> 
  <div class="exampleblock"> 
   <div class="content"> 
    <div class="listingblock"> 
     <div class="content"> 
      <pre class="prettyprint highlight"><code class="language-java" data-lang="java">public interface ReactivePersonRepository
  extends ReactiveCrudRepository<Person, String> {

  Flux<Person> findByLastname(Mono<String> lastname);

  @Query("{ 'firstname': ?0, 'lastname': ?1}")
  Mono<Person> findByFirstnameAndLastname(String firstname, String lastname);
}</code></pre> 
     </div> 
    </div> 
   </div> 
  </div> 
  <div class="paragraph"> 
   <p>As you can see, there’s not too much difference to what you’re used to. However, in contrast to the traditional repository interfaces, a reactive repository uses reactive types as return types and can do so for parameter types, too. The CRUD methods in the newly introduced <code>ReactiveCrudRepository</code>, of course make use of these types, too.</p> 
  </div> 
  <div class="paragraph"> 
   <p>By default, reactive repositories use <a href="https://projectreactor.io">Project Reactor</a> types but other reactive libraries can also be used. We provide a custom repository base interface (e.g. <code>RxJava2CrudRepository</code>) for those and also automatically adapt the types as needed for query methods, e.g RxJava’s <code>Observable</code> and <code>Single</code>. The rest basically stays the same. Note, however, that the current milestone does not support pagination yet and you of course have to have the necessary reactive libraries on the classpath to activate support for a particular library.</p> 
  </div> 
  <div class="sect2"> 
   <h3 id="reactive-configuration"><a class="anchor" href="#reactive-configuration"></a>Activating reactive Spring Data</h3> 
   <div class="paragraph"> 
    <p>Similarly to what we have in the blocking world, the support for reactive Spring Data is activated through an <code>@Enable…</code> annotation alongside some infrastructure setup:</p> 
   </div> 
   <div class="exampleblock"> 
    <div class="content"> 
     <div class="listingblock"> 
      <div class="content"> 
       <pre class="prettyprint highlight"><code class="language-java" data-lang="java">@EnableReactiveMongoRepositories
public class AppConfig extends AbstractReactiveMongoConfiguration {

  @Bean
  public MongoClient mongoClient() {
    return MongoClients.create();
  }

  @Override
  protected String getDatabaseName() {
    return "reactive";
  }
}</code></pre> 
      </div> 
     </div> 
    </div> 
   </div> 
   <div class="paragraph"> 
    <p>See how we use a different base class for the infrastructure configuration, as we need to make use of the MongoDB async driver.</p> 
   </div> 
  </div> 
 </div> 
</div>
">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2016-11-28 17:01:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">对Spring Data做出反应</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/6494a9d91e9ffef9adc8253257f1b35e?s=20&d=mm"> <a class="author" rel="author" href="/team/mp911de">马克·帕鲁奇</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2016-11-28 17:01:00.0">2016年11月28日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2016/11/28/going-reactive-with-spring-data#disqus_thread" data-disqus-identifier="2681">
</a></div>
</div>
</header>
<div class="blog--post"><div class="paragraph">
<p>上周的<a href="https://spring.io/blog/2016/11/23/first-milestone-of-next-generation-spring-data-released">Spring Data Kay M1</a>是支持响应数据访问的第一个版本。它最初支持的存储集-MongoDB，Apache Cassandra和Redis-都已经发布了反应性驱动程序，这使它们成为此类原型的自然候选者。让我们更详细地研究新的编程模型和构成该支持的API。</p>
</div>
<div class="sect1">
<h2 id="reactive-repositories"><a class="anchor" href="#reactive-repositories"></a>反应库</h2>
<div class="sectionbody">
<div class="paragraph">
<p>存储库编程模型是Spring Data用户通常处理的最高级抽象。它们通常由Spring Data提供的接口中定义的一组CRUD方法和特定于域的查询方法组成。这是反应式Spring Data存储库定义的样子：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public interface ReactivePersonRepository
  extends ReactiveCrudRepository<Person, String> {

  Flux<Person> findByLastname(Mono<String> lastname);

  @Query("{ 'firstname': ?0, 'lastname': ?1}")
  Mono<Person> findByFirstnameAndLastname(String firstname, String lastname);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如您所见，与您以前的习惯并没有太大区别。但是，与传统的存储库接口相比，反应式存储库使用反应式类型作为返回类型，并且也可以对参数类型进行操作。新引入的CRUD方法<code>ReactiveCrudRepository</code> ，当然也可以使用这些类型。</p>
</div>
<div class="paragraph">
<p>默认情况下，反应式存储库使用<a href="https://projectreactor.io">Project Reactor</a>类型，但也可以使用其他反应式库。我们提供了一个自定义的信息库基础界面（例如<code>RxJava2CrudRepository</code> ），并根据查询方法（例如RxJava的<code>Observable</code>和<code>Single</code> 。其余基本上保持不变。但是请注意，当前里程碑尚不支持分页，并且您当然必须在类路径上具有必需的反应式库才能激活对特定库的支持。</p>
</div>
<div class="sect2">
<h3 id="reactive-configuration"><a class="anchor" href="#reactive-configuration"></a>激活反应式Spring数据</h3>
<div class="paragraph">
<p>与阻塞世界一样，对响应式Spring Data的支持通过以下方式激活： <code>@Enable…</code>注释以及一些基础架构设置：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@EnableReactiveMongoRepositories
public class AppConfig extends AbstractReactiveMongoConfiguration {

  @Bean
  public MongoClient mongoClient() {
    return MongoClients.create();
  }

  @Override
  protected String getDatabaseName() {
    return "reactive";
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>了解我们如何使用其他基类进行基础结构配置，因为我们需要使用MongoDB异步驱动程序。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="using-reactive-repositories"><a class="anchor" href="#using-reactive-repositories"></a>使用反应库</h2>
<div class="sectionbody">
<div class="paragraph">
<p>现在可以像阻塞存储库一样使用该存储库，除了现在可以以反应方式完成结果的处理：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@RestController
class PersonController {

  private final PersonRepository people;

  public PersonController(PersonRepository people) {
    this.people = people;
  }

  @GetMapping("/people")
  Flux<String> namesByLastname(@RequestParam Mono<String> lastname) {

    Flux<Person> result = repository.findByLastname(lastname);
    return result.map(it -> it.getFullName());
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>看看我们如何转发Spring Web Reactive提供的反应式参数，将其通过管道传递到存储库中，并获取<code>Flux</code>然后依次以反应方式处理执行结果。通常，反应式查询方法遵循与已知存储库相同的查询创建思想。传递给查询方法的参数可以是简单的（例如， <code>String</code> ） 包裹 （ <code>Optional<String></code> ， <code>Stream<String></code> ）或反应式包装的参数（ <code>Mono<String></code> ， <code>Flux<String></code> ）。如果您使用反应性包装器作为参数类型，则该实现会将实际的查询创建和执行推迟到实际的预订之前。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reactive-templates"><a class="anchor" href="#reactive-templates"></a>反应性模板</h2>
<div class="sectionbody">
<div class="paragraph">
<p>正如传统存储库基于传统模板实现一样，反应式存储库是建立在反应式模板之上的。阻止模板API中可用的大多数操作在反应模板中都有对应的内容。我们将把阻塞世界的更多功能移植到反应性模板API中，但是其中一些操作根本无法通过反应性驱动程序获得（或者），或者在反应性世界中没有任何意义。</p>
</div>
<div class="paragraph">
<p>这是摘录<code>ReactiveMongoOperations</code>来自Spring Data MongoDB。它由<code>ReactiveMongoTemplate</code>并使用<a href="http://projectreactor.io/">Project Reactor</a>的反应类型，例如<code>Mono</code>和<code>Flux</code>包装响应。某些方法还接受反应式类型，以将数据流式传输到数据存储中。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public interface ReactiveMongoOperations {

  // …

  /**
   * Map the results of an ad-hoc query on the specified collection to a
   * single instance of an object of the specified type.
   */
  <T> Mono<T> findOne(Query query, Class<T> entityClass);

  /**
   * Map the results of an ad-hoc query on the collection for the entity
   * class to a List of the specified type.
   */
  <T> Flux<T> find(Query query, Class<T> entityClass);

  /**
   * Insert the object into the specified collection.
   */
  <T> Mono<T> insert(T objectToSave, String collectionName);

  /**
   * Insert the object into the collection for the entity type of the object
   * to save.
   */
  <T> Mono<T> insert(Mono<? extends T> objectToSave);

  // …
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意，所有方法都遵循反应式执行模型，在调用时不执行任何合并任何I / O的操作，而仅在预订返回值时执行。</p>
</div>
<div class="paragraph">
<p>让我们通过模板插入一些数据：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Flux<Person> flux = Flux.just(new Person("Walter", "White"),
  new Person("Skyler", "White"),
  new Person("Saul", "Goodman"),
  new Person("Jesse", "Pinkman"));

template.insertAll(flux).subscribe();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>一些方法-如<code>insertAll(…)</code> —接受反应类型，以将传入的数据异步流式传输到您的MongoDB数据库中，例如来自<code>Flux</code>在Spring Web Reactive控制器中收到的消息，该控制器将通过Jackson异步映射JSON数组：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">@PostMapping("/people")
Flux<People> namesByLastname(@RequestBody Flux<Person> people) {

  return template.insertAll(people);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如您所见，存储库和模板API均允许您以反应性，非阻塞方式描述请求处理。也就是说，让我们更深入地了解Redis对响应数据访问的支持。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reactive-connections-with-spring-data-redis"><a class="anchor" href="#reactive-connections-with-spring-data-redis"></a>使用Spring Data Redis进行反应式连接</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Data Redis在连接级别上提供了最初的响应式支持，目前仅在<a href="https://github.com/mp911de/lettuce">Lettuce上</a> ，因为它是唯一支持响应式数据访问的Redis驱动程序。由于Redis通常在较低的抽象级别上使用，因此Kay M1版本从该较低级别的反应式抽象开始。的<code>LettuceConnectionFactory</code>允许访问<code>ReactiveRedisConnection</code>依次提供对Redis命令的响应版本的访问</p>
</div>
<div class="paragraph">
<p>与操作员的功能链接创建了以响应方式访问Redis数据的链。同样，所有I / O都是异步的。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">ReactiveKeyCommands keyCommands = connection.keyCommands();
keyCommands.randomKey()
  .flatMap(keyCommands::type)
  .flatMap(System.out::println)
  .subscribe();</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此代码获取一个随机密钥并打印其数据类型。不存在的随机密钥完成为空<code>Mono</code> 。</p>
</div>
<div class="paragraph">
<p>响应式Redis命令有两种形式：接受纯参数和接受命令发布者。命令发布者发出特定的Redis命令以将数据流式传输到Redis中。执行命令后，每个发出的命令都会发出命令响应。</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">public interface ReactiveStringCommands {

  // …

  Mono<Boolean> set(ByteBuffer key, ByteBuffer value);

  Flux<BooleanResponse<SetCommand>> set(Publisher<SetCommand> commands);

  // …
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用了传统的Spring Data Redis <code>byte[]</code>在其阻塞API上交换数据。一种<code>byte[]</code>如果缓冲区等中的数据可用，则强制数据复制<code>ByteBuffer</code>或Netty的<code>ByteBuf</code> 。响应式支持与有效利用资源息息相关，因此我们决定公开接受和返回方法<code>ByteBuffer</code> 。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="summary"><a class="anchor" href="#summary"></a>摘要</h2>
<div class="sectionbody">
<div class="paragraph">
<p>我希望这篇博客文章向您介绍了Kay附带的各种抽象级别的响应式功能。您可以在示例存储库中找到所有示例的可执行示例。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/spring-projects/spring-data-examples/tree/master/mongodb/reactive">MongoDB的反应性示例</a></p>
</li>
<li>
<p><a href="https://github.com/spring-projects/spring-data-examples/tree/master/cassandra/reactive">Cassandra的反应示例</a></p>
</li>
<li>
<p><a href="https://github.com/spring-projects/spring-data-examples/tree/master/redis/reactive">Redis的反应示例</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我们期待在2017年1月发布另一个里程碑版本，然后再寻求候选版本。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="related-content"><a class="anchor" href="#related-content"></a>相关内容</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="https://spring.io/blog/2016/06/07/notes-on-reactive-programming-part-i-the-reactive-landscape">关于反应式编程的注释第一部分：反应式环境</a></p>
</li>
<li>
<p><a href="https://spring.io/blog/2016/06/13/notes-on-reactive-programming-part-ii-writing-some-code">关于反应式编程的注释第二部分：编写一些代码</a></p>
</li>
<li>
<p><a href="https://spring.io/blog/2016/07/20/notes-on-reactive-programming-part-iii-a-simple-http-server-application">关于反应式编程的说明第三部分：简单的HTTP Server应用程序</a></p>
</li>
<li>
<p><a href="https://spring.io/blog/2016/09/27/ready-your-java-8-reactive-apps-now-reactor-3-0-ga-is-out">立即准备您的Java 8 Reactive应用程序，Reactor 3.0 GA即将发布！</a></p>
</li>
</ul>
</div>
</div>
</div></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 2681;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>