<html dir="ltr" data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>Spring Framework 3.0 RC1发布</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>System.config({baseURL: "/b92013b"});</script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>System.import('app/main.js')</script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Spring Framework 3.0 RC1 released">
<meta name="twitter:description" content="<p>I’m pleased to announce that we recently released the first Spring 3.0 release candidate (<a href=" http:="" ="" www.springsource.com="" downloa="="></head><body dir="ltr">download page). This release completes the key Spring 3.0 feature set. You certainly remember the original Spring 3.0 themes REST and EL; in the meantime, we have been expanding the list significantly:
<ul> 
 <li><p><strong>Fully Java 5 based</strong>: This is the first Spring generation which requires Java 5 or above, with Java 5 syntax used in the entire Spring API as well as in the entire implementation codebase. For example, the BeanFactory API returns generically typed bean instances wherever possible, and ApplicationListeners may declare a specific event type using generics now. For a comparison: In Spring 2.5, the actual Spring core was still JDK 1.4 compatible, while a lot of higher-level functionality was built on Java 5.</p></li> 
 <li><p><strong>Spring expression language (SpEL):</strong> a core expression parser for use in bean definitions, allowing for references to nested bean structures (e.g. properties of other beans) as well as to environmental data structures (e.g. system property values) through a common #{…} syntax in property values. This also serves as a foundation for various expression-based features across the Spring project portfolio.</p></li> 
 <li><p><strong>Extended support for annotation-based components:</strong> now with the notion of configuration classes and annotated factory methods - the key Java configuration capabilities of the Spring JavaConfig project are finally available in Spring proper! Spring also allows for injecting configuration values through @Value expressions now, referring to configuration settings via dynamic #{…} expressions or static ${…} placeholders. </p></li> 
 <li><p><strong>Powerful stereotype model:</strong> allows for creating ‘shortcut’ annotations through the use of meta-annotations, e.g. for default scopes and default transactional characteristics on custom stereotypes. Imagine a custom @MyService annotation indicating @Service, @Scope(“request”) and @Transactional(readOnly=true) through a single annotation. This is the Don’t Repeat Yourself principle applied to the use of component annotations!</p></li> 
 <li><p><strong>Standardized dependency injection annotations:</strong> Spring 3.0 comes with early support for the <a href="http://www.jcp.org/en/jsr/summary?id=330">JSR-330 specification for Dependency Injection in Java</a> - annotation-driven injection via <em>javax.inject.Inject</em> and its associated qualifier and provider model, as an alternative to Spring’s own @Autowired and co. Note that JSR-330 has not been finalized yet; we will be completing Spring’s <em>javax.inject</em> support as the specification itself matures.</p></li> 
 <li><p><strong>Declarative model validation based on constraint annotations:</strong> Spring-style setup of a <a href="http://www.jcp.org/en/jsr/summary?id=303">JSR-303 Bean Validation</a> provider (such as Hibernate Validator 4.0). Comes with an annotation-driven validation option in Spring MVC, exposing a unified view on constraint violations through Spring’s binding result facility. Note that JSR-303 is near-final but not quite final yet; we will be tracking its ongoing evolution up until GA.</p></li> 
 <li><p><strong>Enhanced binding and formatting facilities:</strong> stateless Converter and Formatter SPIs as an alternative to standard PropertyEditors, with full Spring container and Spring MVC integration. Separates between converting (core type coercion) and formatting (rendering to and parsing from localized String values). Formatting may be driven by annotations in a style similar to the use of JSR-303 constraint annotations.</p></li> 
 <li><p><strong>Comprehensive REST support:</strong> native REST capabilities in Spring MVC, such as REST-style request mappings, URI variable extraction through @PathVariable parameters, and view resolution driven by content negotiation. Think about this as Spring MVC 2.5 with first-class REST capabilities built in now - while still focusing on the MVC approach. Client-side REST support is available in the form of a RestTemplate class.</p></li> 
 <li><p><strong>Object/XML Mapping (OXM):</strong> as known from Spring Web Services, now in Spring Framework core. Marshalling and Unmarshaller abstractions with out-of-the-box support for JAXB 2, Castor, etc. Comes with integration options for XML payload support in Spring MVC and Spring JMS.</p></li> 
 <li><p><strong>Portlet 2.0 support:</strong> Spring MVC fully supports Portlet 2.0 environments and Portlet 2.0’s new event and resource request model. Includes specialized mapping facilities for typical portlet request characteristics: @ActionMapping, @RenderMapping, @ResourceMapping, @EventMapping.</p></li> 
 <li><p><strong>Next-generation scheduling capabilities:</strong> new TaskScheduler and Trigger mechanisms with first-class cron support, aligned with Spring’s TaskExecutor mechanism. Spring 3.0 comes with a convenient task namespace and also supports @Async and @Scheduled annotations now. This can be executed on top of native thread pools or server-managed thread pools, with support for all major Java EE application servers.</p></li> 
 <li><p><strong>Last but not least, early support for Java EE 6:</strong> Spring 3.0 already supports the use of JSF 2.0 and JPA 2.0 in a Spring environment, in addition to JSR-303 and JSR-330 support. Further Java EE 6 related specifications such as Servlet 3.0 will be fully supported as they become available in concrete products; this is scheduled for the Spring 3.1/3.2 timeframe.</p></li> 
</ul>
">
<meta name="twitter:creator" content="@springjuergen">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/ba9686d8c567aabedc1b7f8b6a7fb3d6?s=200">

<meta property="og:title" content="Spring Framework 3.0 RC1 released">
<meta property="og:image" content="https://gravatar.com/avatar/ba9686d8c567aabedc1b7f8b6a7fb3d6?s=200">
<meta property="og:description" content="<p>I’m pleased to announce that we recently released the first Spring 3.0 release candidate (<a href=" http:="" ="" www.springsource.com="" downloa="=">download page). This release completes the key Spring 3.0 feature set. You certainly remember the original Spring 3.0 themes REST and EL; in the meantime, we have been expanding the list significantly:
<ul> 
 <li><p><strong>Fully Java 5 based</strong>: This is the first Spring generation which requires Java 5 or above, with Java 5 syntax used in the entire Spring API as well as in the entire implementation codebase. For example, the BeanFactory API returns generically typed bean instances wherever possible, and ApplicationListeners may declare a specific event type using generics now. For a comparison: In Spring 2.5, the actual Spring core was still JDK 1.4 compatible, while a lot of higher-level functionality was built on Java 5.</p></li> 
 <li><p><strong>Spring expression language (SpEL):</strong> a core expression parser for use in bean definitions, allowing for references to nested bean structures (e.g. properties of other beans) as well as to environmental data structures (e.g. system property values) through a common #{…} syntax in property values. This also serves as a foundation for various expression-based features across the Spring project portfolio.</p></li> 
 <li><p><strong>Extended support for annotation-based components:</strong> now with the notion of configuration classes and annotated factory methods - the key Java configuration capabilities of the Spring JavaConfig project are finally available in Spring proper! Spring also allows for injecting configuration values through @Value expressions now, referring to configuration settings via dynamic #{…} expressions or static ${…} placeholders. </p></li> 
 <li><p><strong>Powerful stereotype model:</strong> allows for creating ‘shortcut’ annotations through the use of meta-annotations, e.g. for default scopes and default transactional characteristics on custom stereotypes. Imagine a custom @MyService annotation indicating @Service, @Scope(“request”) and @Transactional(readOnly=true) through a single annotation. This is the Don’t Repeat Yourself principle applied to the use of component annotations!</p></li> 
 <li><p><strong>Standardized dependency injection annotations:</strong> Spring 3.0 comes with early support for the <a href="http://www.jcp.org/en/jsr/summary?id=330">JSR-330 specification for Dependency Injection in Java</a> - annotation-driven injection via <em>javax.inject.Inject</em> and its associated qualifier and provider model, as an alternative to Spring’s own @Autowired and co. Note that JSR-330 has not been finalized yet; we will be completing Spring’s <em>javax.inject</em> support as the specification itself matures.</p></li> 
 <li><p><strong>Declarative model validation based on constraint annotations:</strong> Spring-style setup of a <a href="http://www.jcp.org/en/jsr/summary?id=303">JSR-303 Bean Validation</a> provider (such as Hibernate Validator 4.0). Comes with an annotation-driven validation option in Spring MVC, exposing a unified view on constraint violations through Spring’s binding result facility. Note that JSR-303 is near-final but not quite final yet; we will be tracking its ongoing evolution up until GA.</p></li> 
 <li><p><strong>Enhanced binding and formatting facilities:</strong> stateless Converter and Formatter SPIs as an alternative to standard PropertyEditors, with full Spring container and Spring MVC integration. Separates between converting (core type coercion) and formatting (rendering to and parsing from localized String values). Formatting may be driven by annotations in a style similar to the use of JSR-303 constraint annotations.</p></li> 
 <li><p><strong>Comprehensive REST support:</strong> native REST capabilities in Spring MVC, such as REST-style request mappings, URI variable extraction through @PathVariable parameters, and view resolution driven by content negotiation. Think about this as Spring MVC 2.5 with first-class REST capabilities built in now - while still focusing on the MVC approach. Client-side REST support is available in the form of a RestTemplate class.</p></li> 
 <li><p><strong>Object/XML Mapping (OXM):</strong> as known from Spring Web Services, now in Spring Framework core. Marshalling and Unmarshaller abstractions with out-of-the-box support for JAXB 2, Castor, etc. Comes with integration options for XML payload support in Spring MVC and Spring JMS.</p></li> 
 <li><p><strong>Portlet 2.0 support:</strong> Spring MVC fully supports Portlet 2.0 environments and Portlet 2.0’s new event and resource request model. Includes specialized mapping facilities for typical portlet request characteristics: @ActionMapping, @RenderMapping, @ResourceMapping, @EventMapping.</p></li> 
 <li><p><strong>Next-generation scheduling capabilities:</strong> new TaskScheduler and Trigger mechanisms with first-class cron support, aligned with Spring’s TaskExecutor mechanism. Spring 3.0 comes with a convenient task namespace and also supports @Async and @Scheduled annotations now. This can be executed on top of native thread pools or server-managed thread pools, with support for all major Java EE application servers.</p></li> 
 <li><p><strong>Last but not least, early support for Java EE 6:</strong> Spring 3.0 already supports the use of JSF 2.0 and JPA 2.0 in a Spring environment, in addition to JSR-303 and JSR-330 support. Further Java EE 6 related specifications such as Servlet 3.0 will be fully supported as they become available in concrete products; this is scheduled for the Spring 3.1/3.2 timeframe.</p></li> 
</ul>
">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2009-09-29 17:01:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">// Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }</script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Spring Framework 3.0 RC1发布</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/ba9686d8c567aabedc1b7f8b6a7fb3d6?s=20&d=mm"> <a class="author" rel="author" href="/team/jhoeller">于尔根·霍勒（Juergen Hoeller）</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2009-09-29 17:01:00.0">2009年9月29日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2009/09/29/spring-framework-3-0-rc1-released#disqus_thread" data-disqus-identifier="271">
</a></div>
</div>
</header>
<div class="blog--post"><p>我很高兴地宣布，我们最近发布了第一个Spring 3.0候选版本（ <a href="http://www.springsource.com/download">下载页面</a> ）。这个版本完善了关键的Spring 3.0功能集。您肯定还记得原始的Spring 3.0主题REST和EL。同时，我们一直在大幅扩展该列表：</p>
<ul>
<li><p><strong>完全基于Java 5</strong> ：这是第一代需要Java 5或更高版本的Spring，并且在整个Spring API以及整个实现代码库中都使用Java 5语法。例如，BeanFactory API尽可能返回泛型类型的Bean实例，并且ApplicationListeners现在可以使用泛型声明特定的事件类型。进行比较：在Spring 2.5中，实际的Spring核心仍然与JDK 1.4兼容，而许多更高级别的功能都是基于Java 5构建的。</p></li>
<li><p><strong>Spring表达式语言（SpEL）：</strong>一种用于bean定义的核心表达式解析器，允许通过通用的＃{…引用嵌套的bean结构（例如，其他bean的属性）以及环境数据结构（例如，系统属性值）。属性值中的语法。这也为整个Spring项目组合中各种基于表达式的功能奠定了基础。</p></li>
<li><p><strong>对基于注释的组件的扩展支持：</strong>现在有了配置类和带注释的工厂方法的概念-Spring JavaConfig项目的关键Java配置功能终于可以在Spring中使用了！Spring还允许现在通过@Value表达式注入配置值，通过动态＃{…}表达式或静态$ {…}占位符引用配置设置。</p></li>
<li><p><strong>强大的刻板模式：</strong>允许通过使用元注释，例如默认范围创建“快捷方式”注释和定制定型默认的事务特性。想象一个自定义的@MyServiceannotation，它通过单个annotation指示@ Service，@ Scope（“ request”）和@Transactional（readOnly = true）。这是应用于组件注释的“不要重复自己”原则！</p></li>
<li><p><strong>标准化的依赖项注入注释：</strong> Spring 3.0早期支持<a href="https://www.jcp.org/en/jsr/summary?id=330">Java中的依赖项注入JSR-330规范</a> -通过<em>javax.inject进行注释驱动的注入<em>。Inject</em>及其相关的限定符和提供者模型，作为Spring自己的@Autowired和co的替代方法。请注意，JSR-330尚未完成；随着规范本身的成熟，我们将完成Spring的<em>javax.inject</em>支持。</em></p></li><em>
<li><p><strong>基于约束注释的声明性模型验证：</strong> <a href="https://www.jcp.org/en/jsr/summary?id=303">JSR-303 Bean验证</a>提供程序的春季样式设置（例如Hibernate Validator 4.0）。Spring MVC中带有注释驱动的验证选项，可通过Spring的绑定结果工具公开有关约束违规的统一视图。请注意，JSR-303即将完成，但尚未最终确定。在GA之前，我们将一直跟踪其持续发展。</p></li>
<li><p><strong>增强的绑定和格式化功能：</strong>无状态的Converter和Formatter SPI作为标准PropertyEditor的替代品，具有完整的Spring容器和Spring MVC集成。在转换（核心类型强制）和格式化（渲染到本地String值并从中解析）之间进行分隔。格式可以由注释驱动，其样式类似于使用JSR-303约束注释。</p></li>
<li><p><strong>全面的REST支持：</strong> Spring MVC中的本机REST功能，例如REST样式的请求映射，通过@PathVariable参数的URI变量提取以及由内容协商驱动的视图解析。可以将其视为具有内置的一流REST功能的Spring MVC 2.5，同时仍将重点放在MVC方法上。客户端REST支持以RestTemplate类的形式提供。</p></li>
<li><p><strong>对象/ XML映射（OXM）：</strong>从Spring Web Services已知，现在处于Spring Framework核心。具有对JAXB 2，Castor等的开箱即用支持的Marshalling和Unmarshaller抽象。在Spring MVC和Spring JMS中带有XML有效负载支持的集成选项。</p></li>
<li><p><strong>Portlet 2.0支持：</strong> Spring MVC完全支持Portlet 2.0环境以及Portlet 2.0的新事件和资源请求模型。包括针对典型portlet请求特征的专用映射工具：@ ActionMapping，@ RenderMapping，@ ResourceMapping，@ EventMapping。</p></li>
<li><p><strong>下一代调度功能：</strong>具有一流cron支持的新TaskScheduler和Trigger机制，与Spring的TaskExecutor机制保持一致。Spring 3.0附带了一个方便的任务名称空间，现在还支持@Async和@Scheduledannotation。这可以在本机线程池或服务器管理的线程池之上执行，并支持所有主要的Java EE应用程序服务器。</p></li>
<li><p><strong>最后但并非最不重要的一点是，</strong>除了对JSR-303和JSR-330的支持之外， <strong>对Java EE 6的早期支持：</strong> Spring 3.0已经支持在Spring环境中使用JSF 2.0和JPA 2.0。当它们在具体产品中可用时，将进一步支持与Java EE 6相关的其他规范，例如Servlet 3.0。计划在Spring 3.1 / 3.2的时间范围内进行。</p></li>
</em></ul><p><em>在RC1版本中特别重要的是上述“ 3-0”规范<strong>JSR-330</strong>和<strong>JSR-303</strong> ；我们将在后续帖子中详细介绍Spring对这些规范的支持。目前，请查看有关<a href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/ch03s09.html#beans-autowired-annotation">基于注释的配置</a>的修订版和有关<a href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/ch05s07.html">声明式验证</a>的新章节。您可能还对Spring的新格式化功能感兴趣： <a href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/ch05s06.html#ui-format-Formatted-Annotation">注释驱动的字段格式化</a> 。</em></p><p><em>PS：在RC1中设置的关键功能之上，我们正在考虑对即将推出的3.0 RC2进行一些较小的增强：例如，使用Spring MVC进行格式化和验证设置的Web名称空间。 3.0 RC2计划于10月中旬发布；它的主要重点是兼容性改进以及运行时优化。敬请关注！</em></p></div><em>
</em></div><em>
<section id="disqus_thread"></section>
<script type="text/javascript">var disqus_shortname = 'spring-io';
      var disqus_identifier = 271;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));</script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</em></article><em>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });</script>
</div>
</div>
</aside>
</em></div><em>
</em></div><em>
</em></div><em>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
 <li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</em></div><em>
</em></body></html>