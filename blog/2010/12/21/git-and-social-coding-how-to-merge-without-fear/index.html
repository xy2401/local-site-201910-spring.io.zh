<html  data-code-prettify="" data-mobile-support="" data-search=""><head></head><body >﻿
<title>Git和社交编码：如何在没有恐惧的情况下合并</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Git and Social Coding: How to Merge Without Fear">
<meta name="twitter:creator" content="@david_syer" http:="" ="" blog.springsource.com="" 2010="" 12="" 21="" social-coding-in-spring-projects="" ="=">blog on this site by Keith Donald.
" > <meta>
<meta name="twitter:image:src" content="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=200">

<meta property="og:title" content="Git and Social Coding: How to Merge Without Fear">
<meta property="og:image" content="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=200">
<meta property="og:type" content="article" http:="" ="" blog.springsource.com="" 2010="" 12="" 21="" social-coding-in-spring-projects="" ="=">blog on this site by Keith Donald.
" > <meta>
<meta property="og:article:published_time" content="2010-12-21 10:29:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Git和社交编码：如何在没有恐惧的情况下合并</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/ae671230e3a1c2a0eefa7604990084f1?s=20&d=mm"> <a class="author" rel="author" href="/team/dsyer">戴夫·瑟</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2010-12-21 10:29:00.0">2010年12月21日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2010/12/21/git-and-social-coding-how-to-merge-without-fear#disqus_thread" data-disqus-identifier="384">
</a></div>
</div>
</header>
<div class="blog--post"><p>Git非常适合社交编码和社区对开源项目的贡献：贡献者可以轻松地尝试代码，并且可能会有成千上万的人在不危害现有用户的情况下进行分叉和尝试。本文通过Git命令行提供了一些示例，这些示例可能有助于增强您对该过程的信心：如何获取，提取和合并，以及如何避免错误。如果您对社交编码过程本身以及如何为Spring项目做出贡献感兴趣，请查看<a href="http://blog.springsource.com/2010/12/21/social-coding-in-spring-projects/">Keith Donald在此站点上的</a>另一个<a href="http://blog.springsource.com/2010/12/21/social-coding-in-spring-projects/">博客</a> 。</p><p><a href="https://github.com/grails">Grails</a>在Github上已经有一段时间了，并且在社区贡献方面拥有丰富的经验，因此SpringSource的其他一些项目也开始在那里迁移。一些迁移项目是新的（例如<a href="https://github.com/SpringSource/spring-amqp">Spring AMQP</a> ），一些已经建立并已经从SVN迁移（例如<a href="https://github.com/SpringSource/spring-batch">Spring Batch</a> ）。在SpringSource托管的Gitorious实例上还有一些Spring项目，例如<a href="http://git.springsource.org/spring-integration">Spring Integration</a> 。在Github和Gitorious上，社交编码过程略有不同，但是底层的Git操作是相同的，这就是我们在此处介绍的内容。希望在阅读本文并可能通过示例工作之后，您将受到启发，尝试新模型并为Spring项目做出贡献。Git很有趣，并且对于这种开发具有一些强大的功能。</p><p>如果您从未使用过Git，则可能不是开始学习的地方。如果您是从SVN迁移到Git的，并且对出现问题时的信心不足，或者您想摆脱那些令人烦恼的“ <code>Merged branch ‘master’…</code> ”日志消息，并保持它的美观和线性，这就是地方。如果您在社交编码网站上注册并希望将更改纳入您最喜欢的开源项目，那么本文将使您对此充满信心，但您仍应阅读编码宿主的有关分叉和合并的文档。希望那一切都会有意义。</p><p>本文为您介绍了一些与Git和多个用户一起使用的简单但常见的场景。我们从两个用户共享一个存储库开始，并显示他们可能会遇到的陷阱以及自救的技巧。然后，我们转到一个社交编码示例，其中仍然有两个用户，但是现在也有两个远程存储库。正如我们将看到的，这在开源项目中很常见，并且从变更管理的角度来看有一些好处。</p>
<h2>起源</h2><p>我们将首先建立一个简单的存储库以用于一些示例。以下是一些Git命令行操作，您可以从任何UN * X shell中进行操作，然后是Git索引的草图，以显示提交和分支的布局方式：</p>
<pre>$ mkdir test; cd test; touch foo.txt bar.txt
$ git init .
$ git add .
$ git status
To be added
$ git commit -m "Initial"
[master (root-commit) 5f1191e] initial
 2 files changed, 2 insertions(+), 0 deletions(-)
 create mode 100644 bar.txt
 create mode 100644 foo.txt
$ git checkout -b feature
$ echo bar > bar.txt
$ git commit -am "change bar"
$ git checkout master
$ echo foo > foo.txt
$ git commit -am "change foo
</pre>
<div style="border-width:1px;border-style:solid;background:#eeeeee">
<pre>A - B (master)
  \
    C (feature)
</pre>
</div><p>简单的布局，但足够有趣。有3个提交（我们在图中省略了提交消息）和两个独立的分支。分支经过精心设计，没有冲突-它们包含对不同文件的更改。如果您正在研究命令行示例，并且还想查看索引树，请使用Git UI工具（我曾经<code>gitk –all</code>我相信所有平台都可以使用该功能）。</p><p>最后要做的是准备此存储库以进行克隆：</p>
<pre>$ git checkout HEAD~1 
</pre><p>我们特意使用了参考<code>HEAD~1</code>而不是分支名称，以便原点带有分离的HEAD。如果您习惯了远程存储库工作流程，这将是有道理的，因为我们在本地伪造了远程存储库，并且远程存储库通常是“裸机”（没有签出的分支）。的<code>HEAD~1</code> reference的意思是“退后一步，但不要将新的HEAD分配给任何分支”，这使得以后可以将更改从克隆推送到存储库。</p>
<h2>鲍勃克隆并跟踪分支</h2><p>鲍勃（Bob）是我们存储库的第一个用户。这是他的终端和他本地存储库中的索引布局：</p>
<pre>$ git clone test bob
$ cd bob
$ git checkout --track origin/feature
</pre>
<div style="border-width:1px;border-style:solid;background:#eeeeee">
<pre>A - B (master,origin/master)
  \
    C (feature,origin/feature)
</pre>
</div><p>Bob知道功能分支是试验性的，但是现在已经过测试，因此他希望将其转移到母版中以包含在下一个版本中。但是，如果他从此处合并，则会出现非线性混乱（尽管事实是不存在冲突）：</p>
<pre>$ git merge master
Merge made by recursive.
 foo.txt |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)
</pre>
<div style="border-width:1px;border-style:solid;background:#eeeeee">
<pre>A - B (master,origin/master) - D (feature) "Merge branch 'master' into feature"
  \                           /
    C (origin/feature) ------
</pre>
</div><p>鲍勃讨厌这个。历史是非线性的，因此很难看到所有更改的来源，这也给他留下了可怕的自动生成的提交消息“ Merge branch'master'...”。（他将要素合并到主要素上还是将主要素合并到要素上，这都没有关系，结果是具有相同祖先和相同子提交的相同结构，但是自动生成的消息略有不同。）从这里开始推送是合法的，但最终他会看到所有人都可以看到的丑陋历史，以及不那么有用的自动生成的评论。</p><p>鲍勃不要惊慌！他仍然可以恢复到原始索引，因为他还没有执行任何操作：</p>
<pre>$ git reset --hard origin/feature
</pre>
<div style="border-width:1px;border-style:solid;background:#eeeeee">
<pre>A - B (master,origin/master)
  \
    C (feature,origin/feature)
</pre>
</div><p>他可以从那里坐下来等别人解决问题。简随之而来...</p><p>（请注意，并非所有人都认同Bob的观点，不必要的非线性历史记录和没有新更改的自动生成的提交日志是一件坏事。实际上，有些人“放心”有并行发展的迹象。他们通常不使用rebase，而是喜欢使用简单的合并合并方法与Git进行协作。）</p>
<h2>简·克隆另一个副本并进行本地变基</h2><p>Jane还是具有对测试存储库的写访问权的开发人员。她比鲍勃（Bob）大胆，因此决定需要进行调整以使历史保持线性：</p>
<pre>$ git clone test jane
$ cd jane
$ git checkout --track origin/feature
$ git rebase master
</pre>
<div style="border-width:1px;border-style:solid;background:#eeeeee">
<pre>A - B (master,origin/master) - D (feature)
  \
    C (origin/feature)
</pre>
</div><p>（请注意，Jane可以通过与Bob开始相同的路线来实现相同的结果-合并主服务器，然后再进行rebase具有相同的端点，因为rebase足够聪明，可以意识到它可以节省一些重复并且不显示中间状态不含任何新更改。）</p><p>现在一切看起来都不错，但是git不允许将其推回原点，因为该功能有所不同：</p>
<pre>$ git push
To file:///path/to/test
 ! [rejected]        feature -> feature (non-fast-forward)
error: failed to push some refs to 'file:///path/to/test'
To prevent you from losing history, non-fast-forward updates were rejected
Merge the remote changes before pushing again.  See the 'Note about
fast-forwards' section of 'git push --help' for details.
</pre><p>如果Jane接受了提示并从此处合并，她真的会后悔。重新设置的结果实际上只能是OK * ish *-它具有重复的提交（ <code>C</code>和<code>D</code>具有相同的日志消息，并且在您对它们进行修改时具有相同的更改），因此合并不会很漂亮。Git只会照她说的去做，合并是合法的，但是效果是<br>*非线性历史<br>*自动生成的提交消息<br>*重复提交消息（每个祖先分支一个）<br>结果如下：</p>
<pre>$ git merge origin/feature 
Merge made by recursive.
</pre>
<div style="border-width:1px;border-style:solid;background:#eeeeee">
<pre>A - B (master,origin/master) - D "change bar" - E (feature) "Merge branch 'master' into feature"
  \                                            /
    C (origin/feature) "change bar" ----------
</pre>
</div><p>她仅对源代码进行了两次更改，但结果是索引中有5次提交。糟透了。要还原，她可以使用与以前相同的技巧，除了现在她想重置为（D）的提交处没有命名分支。她可以添加一个，也可以使用UI工具<code>gitk</code>擅长此操作），或使用相对参考：</p>
<pre>$ git reset --hard HEAD~1
</pre>
<div style="border-width:1px;border-style:solid;background:#eeeeee">
<pre>A - B (master,origin/master) - D (feature)
  \
    C (origin/feature)
</pre>
</div><p>Git手册中所有警告您的不友好的事情就是强行推动。简尝试一下：</p>
<pre>$ git push --force
</pre>
<div style="border-width:1px;border-style:solid;background:#eeeeee">
<pre>A - B (master,origin/master) - D (feature,origin/feature)
</pre>
</div><p>现在更像它！进行了两次更改和三个提交（更改的任一侧），并且线性历史很好，没有令人不快的提交消息。那么为什么要做这样一件坏事呢？让我们再看看不幸的朋友鲍勃。</p>
<h2>鲍勃现在可能陷入困境</h2><p>如果他没有修改“功能”分支，他会没事的：</p>
<pre>$ git checkout master
$ git pull
remote: Counting objects: 5, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 0 (delta 0)
Unpacking objects: 100% (3/3), done.
From file:///path/to/test
 + 4b223e2...4db65c2 feature       -> origin/feature  (forced update)
Already up-to-date.
</pre>
<div style="border-width:1px;border-style:solid;background:#eeeeee">
<pre>A - B (master,origin/master) - D (origin/feature)
  \
    C (feature)
</pre>
</div><p>这里看起来有些丑陋，但是Git将所有内容组合在一起。鲍勃（Bob）看到简（或某人）强制更新了他正在跟踪的远程分支，因此他的本地分支没有因他的过错而分叉。他对此可能有些不满，但是在这种情况下，这是无害的，因为他没有对自己的本地分支机构进行任何更改，因此他可以重置自己的分支机构：</p>
<pre>$ git checkout feature
Switched to branch 'feature'
Your branch and 'origin/feature' have diverged,
and have 1 and 2 different commit(s) each, respectively.
$ git reset --hard origin/feature
</pre>
<div style="border-width:1px;border-style:solid;background:#eeeeee">
<pre>A - B (master,origin/master) - D (feature,origin/feature)
</pre>
</div><p>大家都开心！因此在某些情况下可以强制执行。特别是，对于“主要”项目的分支工作的人来说，这是可以接受的，这在社交编码中经常出现（例如在Github中）。让我们更详细地研究该用例。</p>
<h2>叉子和社会编码</h2><p>Git预期的有用功能之一就是它可以用作分布式存储库-您不必采用SVN和较旧系统常见的单一来源方法。当您从公共开源项目中派生，然后要求项目的所有者合并对主存储库的某些更改时，分布式功能会大量使用，但不会广泛使用。</p><p>因此，我们假设有一个很酷的开源项目，名为<code>main</code> （由Mary拥有），而Bob则从项目主页上对其进行分叉。他获得了一个新的存储库，其中包含了Git索引的精确副本。 <code>main</code>存储库，他可以随意调用它（他选择<code>bob-main</code>以帮助我们保持直率）。Git部分微不足道-实际上，他只是在克隆<code>main</code> ，将原点参考移动到服务器上自己空间中的新位置，然后将更改推回去。社交编码应用程序在后台处理了所有这些问题，并向鲍勃建议鲍勃克隆他的新远程分叉。</p><p>所以现在我们有一个<code>main</code>资料库（这是Mary的血统，而不是Bob的血统），以及<code>bob-main</code>相同的存储库。让我们从一个提交开始就保持简单（因此，请从第一个示例中获取原点创建配方，并在第一次提交后停止）：</p>
<div style="border-width:1px;border-style:solid;background:#eeeeee">
<pre>A (master)
</pre>
</div><p>Mary的本地副本以相同的Bob开头，它们都看起来像这样：</p>
<div style="border-width:1px;border-style:solid;background:#eeeeee">
<pre>A (master,origin/master)
</pre>
</div><p>但是它们的来源引用是不同的。对于玛丽：</p>
<pre>$ git remote -v
origin	<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="2f48465b6f47405c5b">[email&#160;protected]</a>:/mary/main (fetch)
origin	<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="63040a17230b0c1017">[email&#160;protected]</a>:/mary/main (push)
</pre><p>对于鲍勃：</p>
<pre>$ git remote -v
origin	<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="2f48465b6f47405c5b">[email&#160;protected]</a>:/bob/bob-main (fetch)
origin	<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="f0979984b0989f8384">[email&#160;protected]</a>:/bob/bob-main (push)
</pre><p>通常，玛丽不会获得推送到Bob的存储库的权限，反之亦然。</p>
<h3>鲍勃添加功能</h3><p>鲍勃对主项目有一个很好的主意，因此他创建了自己的功能分支并开始编码，并在此处结束：</p>
<pre>$ git checkout -b feature
$ echo foo >> foo.txt
$ git commit -am "change foo"
</pre>
<div style="border-width:1px;border-style:solid;background:#eeeeee">
<pre>A(master,origin/master) - C (feature)
</pre>
</div><p>他对此感到满意，因此将其推回自己的血统</p>
<pre>$ git push origin feature
</pre>
<div style="border-width:1px;border-style:solid;background:#eeeeee">
<pre>A(master,origin/master) - C (feature,origin/feature)
</pre>
</div><p>注意Bob如何将所有更改保存在分支上。这不是强制性的，但是正如我们稍后将要看到的那样，它使跟踪与<code>main</code>存储库（即使到目前为止Bob都没有显式连接）。Github上的用户文档实际上并不推荐这种方法，但是您可能会发现它很有用。</p>
<h3>玛丽做了些改变</h3><p>玛丽是项目的所有者，她可以随时随地推动其主分支。所以她这样做：</p>
<pre>$ echo bar >> bar.txt
$ git commit -am "change bar"
$ git push
</pre>
<div style="border-width:1px;border-style:solid;background:#eeeeee">
<pre>A - B (master,origin/master)
</pre>
</div>
<h3>鲍勃发送请求请求</h3><p>现在，鲍勃要求玛丽合并他的更改。玛丽遵循社交编码网站上的友善指示，并拉下鲍勃的更改以进行查看</p>
<pre>$ git checkout -b bob master
$ git pull https://host/bob/bob-main feature
</pre>
<div style="border-width:1px;border-style:solid;background:#eeeeee">
<pre>A - B (master,origin/master) - D (bob) "Merge branch 'feature' of '...bob-main' into bob"
  \                           /
    C  ----------------------
</pre>
</div><p>玛丽立即看到鲍勃与主人背道而驰。她该干什么？</p>
<h3>备选方案1：无强制推送</h3><p>在这种情况下，如果没有冲突，可能会非常简单。她决定花一些时间清理历史，以防万一。这与Bob在先前的单一来源示例中使用的过程相同。</p>
<pre>$ git reset --hard HEAD~1
$ git rebase master
</pre>
<div style="border-width:1px;border-style:solid;background:#eeeeee">
<pre>A - B (master,origin/master) - C (bob)
</pre>
</div><p>那里没有问题，历史再次是线性的。玛丽只需要用她的主要项目来完成更改：</p>
<pre>$ git checkout master
$ git merge bob
$ git push
$ git branch -D bob
</pre>
<div style="border-width:1px;border-style:solid;background:#eeeeee">
<pre>A - B - C (master,origin/master)
</pre>
</div><p>她删除了当地分支机构<code>bob</code>最后在那里，因为它不再标记任何重要内容，并且它也没有跟踪远程分支，因此她也不必处理该引用。</p>
<h3>选择2：强制推入叉子</h3><p>如果上面的重新设置失败了，或者Mary只是认为，如果Bob想要合并他的更改，那么使历史线性化的责任就在他身上，她可以要求他重新建立自己的主人。她通过漂亮的社交编码网站向他发送了一条消息，然后重置了她的本地副本：</p>
<pre>$ git checkout master
$ git branch -D bob
$ git prune
</pre>
<div style="border-width:1px;border-style:solid;background:#eeeeee">
<pre>A - B (master,origin/master)
</pre>
</div><p>现在鲍勃开始工作了。他仍在功能分支上，因此</p>
<pre>$ git remote add main https://host/mary/main
$ git fetch main
</pre>
<div style="border-width:1px;border-style:solid;background:#eeeeee">
<pre>A (master,origin/master) - B (main/master)
 \
  C (feature,origin/feature)
</pre>
</div><p>因此，现在他对主存储库具有只读引用，并为其指定了别名，这样他就可以通过Mary的工作快速了解数据。（别名是可选的，但是它将帮助他保持最新状态，并一目了然地看到他的主人相对于玛丽的主人。）首先，他使他的主人与主要的主人保持一致</p>
<pre>$ git checkout master
$ git merge main/master
$ git push
</pre>
<div style="border-width:1px;border-style:solid;background:#eeeeee">
<pre>A - B (master,origin/master,main/master)
 \
  C (feature,origin/feature)
</pre>
</div><p>在这里，我们看到了在功能分支上工作的好处：如果没有本地更改，将主服务器与主存储库合并总是很简单的（主服务器永远不会领先于主服务器/主服务器）。现在，他尝试进行玛丽要求的重新设置：</p>
<pre>$ git checkout feature
$ git rebase master
</pre>
<div style="border-width:1px;border-style:solid;background:#eeeeee">
<pre>A - B (master,origin/master,main/master) - D (feature)
 \
  C (origin/feature)
</pre>
</div><p>鲍勃（Bob）看到了历史，就随心所欲，因此将其推送到他的远程存储库中：</p>
<pre>$ git push --force
</pre>
<div style="border-width:1px;border-style:solid;background:#eeeeee">
<pre>A - B (master,origin/master,main/master) - D (feature,origin/feature)
</pre>
</div><p>Bob在这里发挥了与Jane在上一个示例中相同的技巧-他强行推动了本地分支以保持线性历史记录。</p><p>Bob和Mary是成年人，并且Bob的存储库中存在功能分支的唯一原因是锚定拉取请求，因此其他任何人都不太可能跟踪该分支。如果有人正在跟踪该分支，则可能会带来不便，如果在该分支上标记了公开发布，则可能会带来极大不便。Bob决定冒险，因为在这个示例中，Bob是唯一拥有对其存储库的写访问权的人，并且他对没有人使用他的分支机构进行发布充满信心，因此在此示例中，这根本没有风险。</p>
<h2>结论</h2><p>除非有微小的变化，否则合并贡献的过程并不简单，但是Git确实减轻了很多麻烦，而且一旦掌握了它就很容易。该示例中的关键点是Git是以一种特定的样式使用的，并且有一些约束和约定使它变得更容易：Bob和Mary的存储库是只读的，而Bob实际上是唯一拥有写操作的人。允许使用他的叉子，所以他根本不介意玛丽要他强行推向那里。到目前为止，这并不是Git唯一使开源开发人员感兴趣的功能，但是它可以解释我们为什么有些人转向<a href="https://github.com/">Github</a>这样的网站还有很长的路要走。</p></div>
</div>
<section id="disqus_thread"></section>
<script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 384;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>