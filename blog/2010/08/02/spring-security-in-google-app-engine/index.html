<!DOCTYPE html>
<html data-code-prettify="" data-mobile-support="" data-search="">
<head>
<title>Spring Security in Google App Engine</title>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no" id="Viewport" name="viewport" />
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png" />
<link href="https://fonts.googleapis.com/css?family=Varela+Round|Montserrat:400,700" rel="stylesheet" type="text/css" />
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css" />
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M" name="google-site-verification" />

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css" />

<meta content="summary" name="twitter:card" />
<meta content="@springcentral" name="twitter:site" />
<meta name="twitter:title" content="Spring Security in Google App Engine" />
<meta name="twitter:description" content="&lt;p&gt;Spring Security is well-known for being highly customizable, so for my first attempt at working with Google App Engine, I decided to create a simple application which would explore the use of GAE features by implementing some core Spring Security interfaces. In this article we’ll see how to:&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
 &lt;br&gt; 
 &lt;li&gt;Authenticate using Google Accounts.&lt;/li&gt;
 &lt;br&gt; 
 &lt;li&gt;Implement “on-demand” authentication when a user accesses a secured resource.&lt;/li&gt;
 &lt;br&gt; 
 &lt;li&gt;Supplement the information from Google Accounts with application-specific roles.&lt;/li&gt;
 &lt;br&gt; 
 &lt;li&gt;Store user account data in an App Engine datastore using the native API.&lt;/li&gt;
 &lt;br&gt; 
 &lt;li&gt;Setup access-control restrictions based on the roles assigned to users.&lt;/li&gt;
 &lt;br&gt; 
 &lt;li&gt;Disable the accounts of specific users to prevent access.&lt;/li&gt;
 &lt;br&gt;
&lt;/ul&gt;
" />
<meta name="twitter:creator" content="@tekul" />
<meta name="twitter:image:src" content="https://gravatar.com/avatar/91c15183d9efc15c30ff1e65f084314d?s=200" />

<meta property="og:title" content="Spring Security in Google App Engine" />
<meta property="og:image" content="https://gravatar.com/avatar/91c15183d9efc15c30ff1e65f084314d?s=200" />
<meta property="og:description" content="&lt;p&gt;Spring Security is well-known for being highly customizable, so for my first attempt at working with Google App Engine, I decided to create a simple application which would explore the use of GAE features by implementing some core Spring Security interfaces. In this article we’ll see how to:&lt;br&gt;&lt;/p&gt;
&lt;ul&gt;
 &lt;br&gt; 
 &lt;li&gt;Authenticate using Google Accounts.&lt;/li&gt;
 &lt;br&gt; 
 &lt;li&gt;Implement “on-demand” authentication when a user accesses a secured resource.&lt;/li&gt;
 &lt;br&gt; 
 &lt;li&gt;Supplement the information from Google Accounts with application-specific roles.&lt;/li&gt;
 &lt;br&gt; 
 &lt;li&gt;Store user account data in an App Engine datastore using the native API.&lt;/li&gt;
 &lt;br&gt; 
 &lt;li&gt;Setup access-control restrictions based on the roles assigned to users.&lt;/li&gt;
 &lt;br&gt; 
 &lt;li&gt;Disable the accounts of specific users to prevent access.&lt;/li&gt;
 &lt;br&gt;
&lt;/ul&gt;
" />
<meta content="article" property="og:type" />
<meta property="og:article:published_time" content="2010-08-02 09:58:00.0" />
</head>
<body>

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" style="display:none;visibility:hidden" width="0"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">Projects</a>
</li>
<li class="navbar-link">
<a href="/guides">Guides</a>
</li>
<li class="navbar-link active">
<a href="/blog">Blog</a>
</li>
<li class="navbar-link">
<a href="/services">Training & Certification</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form action="/search" class="form-inline form-search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search for documentation, guides, and posts..." type="text" value="" />
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form action="/search" class="form-inline form-search" method="get">
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search..." type="text" value="" />
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">
Home
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">
Projects
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">
Guides
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">
Blog
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">
Training & Certification
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>Engineering</div>
</div>
<div class="blog-category content--title">
<div>Releases</div>
</div>
<div class="blog-category content--title">
<div>News and Events</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Spring Security in Google App Engine</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">Engineering</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/91c15183d9efc15c30ff1e65f084314d?s=20&amp;d=mm" />
<span class="author">Luke Taylor</span>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2010-08-02 09:58:00.0">August 02, 2010</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" data-disqus-identifier="343" href="/blog/2010/08/02/spring-security-in-google-app-engine#disqus_thread">
</a></div>
</div>
</header>
<div class="blog--post"><p>Spring Security is well-known for being highly customizable, so for my first attempt at working with Google App Engine, I decided to create a simple application which would explore the use of GAE features by implementing some core Spring Security interfaces. In this article we&rsquo;ll see how to:<br /><ul><br /> <li>Authenticate using Google Accounts.</li><br /> <li>Implement &ldquo;on-demand&rdquo; authentication when a user accesses a secured resource.</li><br /> <li>Supplement the information from Google Accounts with application-specific roles.</li><br /> <li>Store user account data in an App Engine datastore using the native API.</li><br /> <li>Setup access-control restrictions based on the roles assigned to users.</li><br /> <li>Disable the accounts of specific users to prevent access.</li><br /></ul></p><p>You should already be familiar with deploying applications to GAE. It doesn&rsquo;t take long to get a basic application up and running and you&rsquo;ll find lots of guidance on this on the <a href="https://code.google.com/appengine">GAE website</a>.</p>
<h3>Sample Application</h3><p>The application is very simple and is built using Spring MVC. There is a welcome page deployed at the application root, and you can progress to a &ldquo;home page&rdquo;, but only after authenticating and registering with the application. You can try out a version deployed in GAE <a href="https://gaespringsec.appspot.com/">here</a>.</p><p>The registered users are stored as GAE datastore entities. On first authenticating, new users are redirected to a registration page where they can enter their name. Once registered, user accounts can be flagged as &ldquo;disabled&rdquo; in the datastore and the user won&rsquo;t be allowed to use the app, even though they have authenticated through GAE.</p>
<h3>Spring Security Background</h3><p>We&rsquo;re assuming that you&rsquo;re already familiar with Spring Security&rsquo;s namespace configuration and ideally have some knowledge of the core interfaces and how they interact. The basics are covered in the <a href="http://static.springsource.org/spring-security/site/docs/3.1.x/reference/technical-overview.html">Technical Overview</a> chapter of the reference manual. If you&rsquo;re also familiar with the internals of Spring Security, you&rsquo;ll know that web authentication mechanisms such as form-based login are implemented using a servlet <tt>Filter</tt> and an <tt>AuthenticationEntryPoint</tt>. The <tt>AuthenticationEntryPoint</tt> drives the authentication process when an anonymous user tries to access a secured resource and the filter extracts authentication information from a subsequent request (such as the submission of a login form), authenticates the user and builds a security context for the user&rsquo;s session. </p><p>The filter delegates the authentication decision to the <tt>AuthenticationManager</tt> which is configured with a list of <tt>AuthenticationProvider</tt> beans, any one of which may authenticate the user, or raise an exception if the authentication fails.</p><p>In the case of a form-based login, the <tt>AuthenticationEntryPoint</tt> simply redirects the user to the login page. The authentication filter (<tt>UsernamePasswordAuthenticationFilter</tt> in this case) extracts the username and password from the submitted POST request. They are stored in an <tt>Authentication</tt> object and passed to an <tt>AuthenticationProvider</tt> which will typically compare the user&rsquo;s password with one stored in a database or LDAP server.</p><p>That&rsquo;s the basic interaction between the components. How might this apply to a GAE application?</p>
<h2>Google Accounts Authentication</h2><p>Of course, there&rsquo;s nothing to stop you deploying a standard Spring Security application in GAE (without JDBC support, of course), but what if you want to make use of the API which GAE provides to allow users to authenticate via their usual Google login? This is actually very simple and most of the work is handled by GAE&rsquo;s <a href="https://code.google.com/appengine/docs/java/javadoc/com/google/appengine/api/users/UserService.html">UserService</a>, which has a method for generating an external login URL. You provide a destination which the user will be returned to once they&rsquo;ve authenticated, allowing them to continue using the application. We could use this to render a login link in a web page, but we can also redirect directly to it in a custom <tt>AuthenticationEntryPoint</tt>:</p>
<pre><code class="prettyprint java"><br />import com.google.appengine.api.users.UserService;
import com.google.appengine.api.users.UserServiceFactory;

public class GoogleAccountsAuthenticationEntryPoint implements AuthenticationEntryPoint {
  public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)
      throws IOException, ServletException {
    UserService userService = UserServiceFactory.getUserService();

    response.sendRedirect(userService.createLoginURL(request.getRequestURI()));
  }
}
</code></pre><p>If we add this to our configuration, using the specific hook that the Spring Security namespace provides for this purpose, we have something like this:</p>
<pre><code class="prettyprint xml"><br />&lt;b:beans xmlns=&quot;http://www.springframework.org/schema/security&quot;
        xmlns:b=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
        http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security-3.1.xsd&quot;&gt;

    &lt;http use-expressions=&quot;true&quot; entry-point-ref=&quot;gaeEntryPoint&quot;&gt;
        &lt;intercept-url pattern=&quot;/&quot; access=&quot;permitAll&quot; /&gt;
        &lt;intercept-url pattern=&quot;/**&quot; access=&quot;hasRole(&#39;USER&#39;)&quot; /&gt;
    &lt;/http&gt;

    &lt;b:bean id=&quot;gaeEntryPoint&quot; class=&quot;samples.gae.security.GoogleAccountsAuthenticationEntryPoint&quot; /&gt;
    ...
&lt;/b:beans&gt;
</code></pre><p>Here we&rsquo;ve configured all URLs to require the &ldquo;USER&rdquo; role, except for the webapp root. The user will be redirected to the Google Accounts login screen when they first attempt to access any other page:<br /><p style="text-align: center;"><img class="aligncenter" style="border: 1px solid lightgray;" src="http://blog.springsource.com/wp-content/uploads/2010/07/gaelogin.jpg" alt="Google App Engine login page" width="609" height="520" align="center" /></p><br />We now need to add the filter bean which will set up the security context when the user is redirected back to our site by GAE logging in to Google Accounts. Here&rsquo;s the authentication filter code:</p>
<pre><code class="prettyprint java"><br />public class GaeAuthenticationFilter extends GenericFilterBean {
  private static final String REGISTRATION_URL = &quot;/register.htm&quot;;
  private AuthenticationDetailsSource ads = new WebAuthenticationDetailsSource();
  private AuthenticationManager authenticationManager;
  private AuthenticationFailureHandler failureHandler = new SimpleUrlAuthenticationFailureHandler();

  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    Authentication authentication = SecurityContextHolder.getContext().getAuthentication();

    if (authentication == null) {
      // User isn&#39;t authenticated. Check if there is a Google Accounts user
      User googleUser = UserServiceFactory.getUserService().getCurrentUser();

      if (googleUser != null) {
        // User has returned after authenticating through GAE. Need to authenticate to Spring Security.
        PreAuthenticatedAuthenticationToken token = new PreAuthenticatedAuthenticationToken(googleUser, null);
        token.setDetails(ads.buildDetails(request));

        try {
          authentication = authenticationManager.authenticate(token);
          // Setup the security context
          SecurityContextHolder.getContext().setAuthentication(authentication);
          // Send new users to the registration page.
          if (authentication.getAuthorities().contains(AppRole.NEW_USER)) {
            ((HttpServletResponse) response).sendRedirect(REGISTRATION_URL);
              return;
          }
        } catch (AuthenticationException e) {
         // Authentication information was rejected by the authentication manager
          failureHandler.onAuthenticationFailure((HttpServletRequest)request, (HttpServletResponse)response, e);
          return;
        }
      }
    }

    chain.doFilter(request, response);
  }

  public void setAuthenticationManager(AuthenticationManager authenticationManager) {
    this.authenticationManager = authenticationManager;
  }

  public void setFailureHandler(AuthenticationFailureHandler failureHandler) {
    this.failureHandler = failureHandler;
  }
}
</code></pre><p>We&rsquo;ve implemented the filter from scratch, making it simpler to understand and avoiding the complication of inheriting from existing classes. If a user is currently unauthenticated (from Spring Security&rsquo;s perspective), the filter checks for the existence of a GAE user (again making use of the GAE <tt>UserService</tt>). If one is found, then it packages it up in a suitable authentication token object (Spring Security&rsquo;s <tt>PreAuthenticatedAuthenticationToken</tt> is used here for convenience) and passes it to the <tt>AuthenticationManager</tt> to be authenticated by Spring Security. New users are redirected to the registration page at this point.</p>
<h4>Custom Authentication Provider</h4><p>In this scenario, we are not authenticating the user in the traditional sense of determining whether they are who they claim to be. Google accounts has already taken care of that. We are only interested in checking whether the user is a valid user from the application&rsquo;s perspective. The situation is similar to using Spring Security with a single sign-on system such as CAS or OpenID. The authentication provider needs to check the user&rsquo;s account status and load any other information (such as application-specific roles). In our sample, we also have the concept of an &ldquo;unregistered&rdquo; user who hasn&rsquo;t used the application before. If the user is unknown to the application, they will be assigned a temporary &ldquo;NEW_USER&rdquo; role, which will only allow them access to the registration URL. Once registered, they are assigned the &ldquo;USER&rdquo; role.</p><p>The <tt>AuthenticationProvider</tt> implementation interacts with a <tt>UserRegistry</tt> to store and retrieve <tt>GaeUser</tt> objects (both specific to this sample):</p>
<pre><code class="prettyprint java"><br />public interface UserRegistry {
  GaeUser findUser(String userId);
  void registerUser(GaeUser newUser);
  void removeUser(String userId);
}
</code></pre>
<pre><code class="prettyprint java"><br />public class GaeUser implements Serializable {
  private final String userId;
  private final String email;
  private final String nickname;
  private final String forename;
  private final String surname;
  private final Set&lt;AppRole&gt; authorities;
  private final boolean enabled;

// Constructors and accessors omitted
...
</code></pre><p>The <tt>userId</tt> is the unique ID assigned by Google Accounts. Email and nickname are also obtained from the GAE user. Forename and surname are entered in the registration form. The enabled flag is set to &ldquo;true&rdquo; unless it is modified directly through the GAE datastore administration console. <tt>AppRole</tt> is an implementation of Spring Security&rsquo;s <tt>GrantedAuthority</tt> as an enum:</p>
<pre><code class="prettyprint java"><br />public enum AppRole implements GrantedAuthority {
    ADMIN (0),
    NEW_USER (1),
    USER (2);

    private int bit;

    AppRole(int bit) {
        this.bit = bit;
    }

    public String getAuthority() {
        return toString();
    }
}
</code></pre><p>The roles are assigned as described above. The <tt>AuthenticationProvider</tt> then looks like this:</p>
<pre><code class="prettyprint java"><br />public class GoogleAccountsAuthenticationProvider implements AuthenticationProvider {
    private UserRegistry userRegistry;

    public Authentication authenticate(Authentication authentication) throws AuthenticationException {
        User googleUser = (User) authentication.getPrincipal();

        GaeUser user = userRegistry.findUser(googleUser.getUserId());

        if (user == null) {
            // User not in registry. Needs to register
            user = new GaeUser(googleUser.getUserId(), googleUser.getNickname(), googleUser.getEmail());
        }

        if (!user.isEnabled()) {
            throw new DisabledException(&quot;Account is disabled&quot;);
        }

        return new GaeUserAuthentication(user, authentication.getDetails());
    }

    public final boolean supports(Class&lt;?&gt; authentication) {
        return PreAuthenticatedAuthenticationToken.class.isAssignableFrom(authentication);
    }

    public void setUserRegistry(UserRegistry userRegistry) {
        this.userRegistry = userRegistry;
    }
}
</code></pre><p>The <tt>GaeUserAuthentication</tt> class is a very simple implementation of Spring Security&rsquo;s <tt>Authentication</tt> interface, which takes the <tt>GaeUser</tt> object as the principal.<br />If you&rsquo;ve customized Spring Security a bit before, you might be wondering why we haven&rsquo;t implemented a <tt>UserDetailsService</tt> at any point here and why the principal isn&rsquo;t a <tt>UserDetails</tt> instance. The simple answer is that you don&rsquo;t have to — Spring Security doesn&rsquo;t generally mind what the type of the object is and here we&rsquo;ve chosen to implement the <tt>AuthenticationProvider</tt> interface directly as the simplest option.</p>
<h3>GAE Datasource User Registry</h3><p>We now need an implementation of the <tt>UserRegistry</tt> which uses GAE&rsquo;s datastore.</p>
<pre><code class="prettyprint java"><br />import com.google.appengine.api.datastore.*;
import org.springframework.security.core.GrantedAuthority;
import samples.gae.security.AppRole;
import java.util.*;

public class GaeDatastoreUserRegistry implements UserRegistry {
    private static final String USER_TYPE = &quot;GaeUser&quot;;
    private static final String USER_FORENAME = &quot;forename&quot;;
    private static final String USER_SURNAME = &quot;surname&quot;;
    private static final String USER_NICKNAME = &quot;nickname&quot;;
    private static final String USER_EMAIL = &quot;email&quot;;
    private static final String USER_ENABLED = &quot;enabled&quot;;
    private static final String USER_AUTHORITIES = &quot;authorities&quot;;

    public GaeUser findUser(String userId) {
        Key key = KeyFactory.createKey(USER_TYPE, userId);
        DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();

        try {
            Entity user = datastore.get(key);

            long binaryAuthorities = (Long)user.getProperty(USER_AUTHORITIES);
            Set&lt;AppRole&gt; roles = EnumSet.noneOf(AppRole.class);

            for (AppRole r : AppRole.values()) {
                if ((binaryAuthorities &amp; (1 &lt;&lt; r.getBit())) != 0) {
                    roles.add(r);
                }
            }

            GaeUser gaeUser = new GaeUser(
                    user.getKey().getName(),
                    (String)user.getProperty(USER_NICKNAME),
                    (String)user.getProperty(USER_EMAIL),
                    (String)user.getProperty(USER_FORENAME),
                    (String)user.getProperty(USER_SURNAME),
                    roles,
                    (Boolean)user.getProperty(USER_ENABLED));

            return gaeUser;

        } catch (EntityNotFoundException e) {
            logger.debug(userId + &quot; not found in datastore&quot;);
            return null;
        }
    }

    public void registerUser(GaeUser newUser) {
        Key key = KeyFactory.createKey(USER_TYPE, newUser.getUserId());
        Entity user = new Entity(key);
        user.setProperty(USER_EMAIL, newUser.getEmail());
        user.setProperty(USER_NICKNAME, newUser.getNickname());
        user.setProperty(USER_FORENAME, newUser.getForename());
        user.setProperty(USER_SURNAME, newUser.getSurname());
        user.setUnindexedProperty(USER_ENABLED, newUser.isEnabled());

        Collection&lt;? extends GrantedAuthority&gt; roles = newUser.getAuthorities();

        long binaryAuthorities = 0;

        for (GrantedAuthority r : roles) {
            binaryAuthorities |= 1 &lt;&lt; ((AppRole)r).getBit();
        }

        user.setUnindexedProperty(USER_AUTHORITIES, binaryAuthorities);

        DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();
        datastore.put(user);
    }

    public void removeUser(String userId) {
        DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();
        Key key = KeyFactory.createKey(USER_TYPE, userId);

        datastore.delete(key);
    }
}
</code></pre><p>As, we&rsquo;ve already mentioned, the sample uses an enum for the application roles. The roles (authorities) assigned to a user are stored as an <tt>EnumSet</tt>. <tt>EnumSet</tt>s are very resource efficient and a user&rsquo;s roles can be stored as a single <tt>long</tt> value, allowing for a simpler interaction with the datastore API. We&rsquo;ve assigned a separate &ldquo;bit&rdquo; property to each role for this purpose.</p>
<h3>User Registration</h3><p>The user registration controller contains the following method which handles the submission of the registration form.</p>
<pre><code class="prettyprint java"><br />    @Autowired
    private UserRegistry registry;

    @RequestMapping(method = RequestMethod.POST)
    public String register(@Valid RegistrationForm form, BindingResult result) {
        if (result.hasErrors()) {
            return null;
        }

        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        GaeUser currentUser = (GaeUser)authentication.getPrincipal();
        Set&lt;AppRole&gt; roles = EnumSet.of(AppRole.USER);

        if (UserServiceFactory.getUserService().isUserAdmin()) {
            roles.add(AppRole.ADMIN);
        }

        GaeUser user = new GaeUser(currentUser.getUserId(), currentUser.getNickname(), currentUser.getEmail(),
                form.getForename(), form.getSurname(), roles, true);

        registry.registerUser(user);

        // Update the context with the full authentication
        SecurityContextHolder.getContext().setAuthentication(new GaeUserAuthentication(user, authentication.getDetails()));

        return &quot;redirect:/home.htm&quot;;
    }
</code></pre><p>The user is created with the supplied forename and surname and a new set of roles is created. This may also include the &ldquo;ADMIN&rdquo; role if GAE indicates that the current user is an administrator for the application. This is then stored in the user registry and the security context is populated with an updated <tt>Authentication</tt> object to make sure that Spring Security is aware of the new role information and applies its access-control constrainst accordingly.</p>
<h2>Final Application Configuration</h2><p>The security application context now looks like this:</p>
<pre><code class="prettyprint xml"><br />    &lt;http use-expressions=&quot;true&quot; entry-point-ref=&quot;gaeEntryPoint&quot;&gt;
        &lt;intercept-url pattern=&quot;/&quot; access=&quot;permitAll&quot; /&gt;
        &lt;intercept-url pattern=&quot;/register.htm*&quot; access=&quot;hasRole(&#39;NEW_USER&#39;)&quot; /&gt;
        &lt;intercept-url pattern=&quot;/**&quot; access=&quot;hasRole(&#39;USER&#39;)&quot; /&gt;
        &lt;custom-filter position=&quot;PRE_AUTH_FILTER&quot; ref=&quot;gaeFilter&quot; /&gt;
    &lt;/http&gt;

    &lt;b:bean id=&quot;gaeEntryPoint&quot; class=&quot;samples.gae.security.GoogleAccountsAuthenticationEntryPoint&quot; /&gt;

    &lt;b:bean id=&quot;gaeFilter&quot; class=&quot;samples.gae.security.GaeAuthenticationFilter&quot;&gt;
        &lt;b:property name=&quot;authenticationManager&quot; ref=&quot;authenticationManager&quot;/&gt;
    &lt;/b:bean&gt;

    &lt;authentication-manager alias=&quot;authenticationManager&quot;&gt;
        &lt;authentication-provider ref=&quot;gaeAuthenticationProvider&quot;/&gt;
    &lt;/authentication-manager&gt;

    &lt;b:bean id=&quot;gaeAuthenticationProvider&quot; class=&quot;samples.gae.security.GoogleAccountsAuthenticationProvider&quot;&gt;
        &lt;b:property name=&quot;userRegistry&quot; ref=&quot;userRegistry&quot; /&gt;
    &lt;/b:bean&gt;

    &lt;b:bean id=&quot;userRegistry&quot; class=&quot;samples.gae.users.GaeDatastoreUserRegistry&quot; /&gt;
</code></pre><p>You can see we&rsquo;ve inserted our filter using the <tt>custom-filter</tt> namespace element, declared the provider and user registry and wired them all up. We&rsquo;ve also added a URL for the registration controller, which is accessible to new users.</p>
<h2>Conclusion</h2><p>Spring Security has shown over the years that it is flexible enough to add value in many different scenarios and deployment within Google App Engine is no exception. It&rsquo;s also worth remembering that implementing some of the interfaces yourself (as we&rsquo;ve done here) is often a better approach than trying to use an existing class that doesn&rsquo;t quite fit. You may end up with a cleaner solution which better matches your requirements.</p><p>The focus here has been on how to use the Google App Engine APIs from within a Spring Security-enabled application. We haven&rsquo;t covered all the other details of how the application works, but I&rsquo;d encourage you to have a look at the code and see for yourself. If you&rsquo;re a GAE expert then suggestions for improvement are always welcome!</p><p>The sample code is already in the 3.1 codebase, so you can check it out from <a href="http://static.springsource.org/spring-security/site/build.html">our git repository</a>. A first milestone of Spring Security 3.1 should also be released later this month.</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 343;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>
Back
</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">All Posts</a>
<a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">Engineering</a>
<a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">Releases</a>
<a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">News and Events</a>
<a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>Get updates from The Spring Team delivered to your inbox</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">Tools</a></li>
<li><a href="https://store.pivotal.io/">Store</a></li>
<li><a href="/blog">Newsletter</a></li>
</ul>
</div>
</div>
&copy; <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a>, Inc. All Rights Reserved.
<a href="https://pivotal.io/terms-of-use">Terms of Use</a> &bullet;
<a href="https://pivotal.io/privacy-policy">Privacy</a> &bullet;
<a href="/trademarks">Trademark Guidelines</a>
<div id="teconsent" style="display:inline-block;"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>