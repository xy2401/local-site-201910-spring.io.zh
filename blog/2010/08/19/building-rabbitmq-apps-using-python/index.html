<html  data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>使用Python构建RabbitMQ应用</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Building RabbitMQ apps using Python">
<meta name="twitter:description" >
<meta name="twitter:creator" content="@gregturn">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/43e9a9d63f7f4f9891c9fcd592b89cfa?s=200">

<meta property="og:title" content="Building RabbitMQ apps using Python">
<meta property="og:image" content="https://gravatar.com/avatar/43e9a9d63f7f4f9891c9fcd592b89cfa?s=200">
<meta property="og:description" >
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2010-08-19 15:15:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">使用Python构建RabbitMQ应用</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/43e9a9d63f7f4f9891c9fcd592b89cfa?s=20&d=mm"> <a class="author" rel="author" href="/team/gturnquist">格雷格·特恩奎斯特</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2010-08-19 15:15:00.0">2010年8月19日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2010/08/19/building-rabbitmq-apps-using-python#disqus_thread" data-disqus-identifier="350">
</a></div>
</div>
</header>
<div class="blog--post"><p><a href="https://rabbitmq.com">RabbitMQ</a>是基于<a href="http://blog.springsource.com/2010/06/14/understanding-amqp-the-protocol-used-by-rabbitmq/">高级消息队列协议（AMQP）</a>的功能强大的消息代理。由于AMQP规范具有中立性，因此很容易从包括Python在内的许多平台进行连接。在此博客条目中，我们将：<br></p><ul><br> <li>创建一个简单的股票报价器Python应用程序</li><br> <li>创建一个决定何时买卖的经纪人Python应用程序。</li><br> <li>将<a href="https://github.com/tonyg/pika">pika</a> （由RabbitMQ团队创建的AMQP库）与<a href="https://code.google.com/p/py-amqplib/">py-amqplib进行比较</a> 。</li><br></ul><br>您可以在以下位置找到此博客的所有源代码。 <a href="https://github.com/gregturn/amqp-demo"></a> <a href="https://github.com/gregturn/amqp-demo">http://github.com/gregturn/amqp-demo</a> 。假设您已经根据<a href="https://www.rabbitmq.com/install.html">平台说明</a>安装了RabbitMQ并启动了它。就个人而言，我可以在Mac OS X机器（雪豹）上运行它。<p></p><p>顺便说说：<br></p><blockquote>此博客条目中编写的代码仅用于演示目的。不要依靠这些算法获得财务建议。</blockquote><br>顺便说一句，让我们编写一些代码！<br><h2>建立股票行情</h2><br>消息传递解决方案的一个很好的例子是股票报价系统。证券交易所向经纪人发布消息，指示股票名称，价格和时间。<p></p>
<pre><code class="prettyprint python">import pickle
import random
import time

class Ticker(object):
    def __init__(self, publisher, qname):
        self.publisher = publisher

        # This quickly creates four random stock symbols
        chars = range(ord(&quot;A&quot;), ord(&quot;Z&quot;)+1)
        def random_letter(): return chr(random.choice(chars))
        self.stock_symbols = [random_letter()+random_letter()+random_letter() for i in range(4)]

        self.last_quote = {}
        self.counter = 0
        self.time_format = &quot;%a, %d %b %Y %H:%M:%S +0000&quot;
        self.qname = qname

    def get_quote(self):
        symbol = random.choice(self.stock_symbols)
        if symbol in self.last_quote:
            previous_quote = self.last_quote[symbol]
            new_quote = random.uniform(0.9*previous_quote, 1.1*previous_quote)
            if abs(new_quote) - 0 &lt; 1.0:
                new_quote = 1.0
            self.last_quote[symbol] = new_quote
        else:
            new_quote = random.uniform(10.0, 250.0)
            self.last_quote[symbol] = new_quote
        self.counter += 1
        return (symbol, self.last_quote[symbol], time.gmtime(), self.counter)

    def monitor(self):
        while True:
            quote = self.get_quote()
            print(&quot;New quote is %s&quot; % str(quote))
            self.publisher.publish(pickle.dumps((quote[0], quote[1], time.strftime(self.time_format, quote[2]), quote[3])), routing_key=&quot;&quot;)
            secs = random.uniform(0.1, 0.5)
            #print(&quot;Sleeping %s seconds...&quot; % secs)
            time.sleep(secs)
</code></pre><p>该应用程序随机创建四个股票代号，然后开始创建报价。它首先选择一个介于10.0和250.0之间的随机值，然后继续在先前价格的90％和110％之间随机调整价格。然后，它在0.1至0.5秒之间随机等待，然后勾选下一个报价。该代码设计的一个重要部分是，向AMQP经纪人发布已与股票行情分离。相反，它期望在构建时注入发布者服务。</p><p>重要的是要注意，我们正在使用pickle序列化我们的股票报价数据元组。在AMQP中，消息的主体只是一系列字节。存储的内容及其序列化方式不是规范的一部分，而是必须在发送方和接收方之间达成一致。在我们的情况下，发布者和订阅者都同意包含腌制元组。<br></p><h2>创建AMQP服务</h2><br>下一步是创建我们的AMQP客户服务。其目的是使我们可以轻松地通过发布或使用事件来正确隔离与AMQP服务器的通话。<p></p>
<pre><code class="prettyprint python">from amqplib import client_0_8 as amqp

class PyAmqpLibPublisher(object):
    def __init__(self, exchange_name):
        self.exchange_name = exchange_name
        self.queue_exists = False

    def publish(self, message, routing_key):
        conn = amqp.Connection(host=&quot;127.0.0.1&quot;, userid=&quot;guest&quot;, password=&quot;guest&quot;, virtual_host=&quot;/&quot;, insist=False)

        ch = conn.channel()

        ch.exchange_declare(exchange=self.exchange_name, type=&quot;fanout&quot;, durable=False, auto_delete=False)

        msg = amqp.Message(message)
        msg.properties[&quot;content_type&quot;] = &quot;text/plain&quot;
        msg.properties[&quot;delivery_mode&quot;] = 2
        ch.basic_publish(exchange=self.exchange_name,
                         routing_key=routing_key,
                         msg=msg)
        ch.close()
        conn.close()
</code></pre><p>这里要注意的重要一点是，声明的交换类型为“扇出”。这意味着绑定到它的每个队列都将收到消息的副本，而无需在代理端进行昂贵的处理。</p><p>您可能想知道正文的content_type为什么是“ text / plain”，因为它是序列化的消息。这是因为Python的pickle库以ASCII装甲格式编码数据，该格式可以用任何工具查看，而不会引起奇怪的行为。<br></p><h2>低买高卖</h2><br>一些简单，明智的建议是在价格低时购买，然后在价格高时出售。在这里，我们将看一个简单的客户，该客户订阅股票报价，收集价格的历史趋势，以确定下一个价格是在低端还是高端，然后决定买卖。<p></p>
<pre><code class="prettyprint python">import pickle
import random
import uuid

class Buyer(object):
    def __init__(self, client, qname, trend=5):
        self.holdings = {}
        self.cash = 100000.0
        self.history = {}
        self.qname = qname
        self.client = client
        self.trend = trend
        self.qname = uuid.uuid4().hex

    def decide_whether_to_buy_or_sell(self, quote):
        symbol, price, date, counter = quote
        #print &quot;Thinking about whether to buy or sell %s at %s&quot; % (symbol, price)

        if symbol not in self.history:
            self.history[symbol] = [price]
        else:
            self.history[symbol].append(price)

        if len(self.history[symbol]) &gt;= self.trend:
            price_low = min(self.history[symbol][-self.trend:])
            price_max = max(self.history[symbol][-self.trend:])
            price_avg = sum(self.history[symbol][-self.trend:])/self.trend
            #print &quot;Recent history of %s is %s&quot; % (symbol, self.history[symbol][-self.trend:])
        else:
            price_low, price_max, price_avg = (-1, -1, -1)
            print &quot;%s quotes until we start deciding whether to buy or sell %s&quot; % (self.trend - len(self.history[symbol]), symbol)
            #print &quot;Recent history of %s is %s&quot; % (symbol, self.history[symbol])

        if price_low == -1: return

        #print &quot;Trending minimum/avg/max of %s is %s-%s-%s&quot; % (symbol, price_low, price_avg, price_max)
        #for symbol in self.holdings.keys():
        #    print &quot;self.history[symbol][-1] = %s&quot; % self.history[symbol][-1]
        #    print &quot;self.holdings[symbol][0] = %s&quot; % self.holdings[symbol][0]
        #    print &quot;Value of %s is %s&quot; % (symbol, float(self.holdings[symbol][0])*self.history[symbol][-1])
        value = sum([self.holdings[symbol][0]*self.history[symbol][-1] for symbol in self.holdings.keys()])
        print &quot;Net worth is %s + %s = %s&quot; % (self.cash, value, self.cash + value)

        if symbol not in self.holdings:
            if price &lt; 1.01*price_low:
                shares_to_buy = random.choice([10, 15, 20, 25, 30])
                print &quot;I don&#39;t own any %s yet, and the price is below the trending minimum of %s so I&#39;m buying %s shares.&quot; % (symbol, price_low, shares_to_buy)
                cost = shares_to_buy * price
                print &quot;Cost is %s, cash is %s&quot; % (cost, self.cash)
                if cost &lt; self.cash:
                    self.holdings[symbol] = (shares_to_buy, price, cost)
                    self.cash -= cost
                    print &quot;Cash is now %s&quot; % self.cash
                else:
                    print &quot;Unfortunately, I don&#39;t have enough cash at this time.&quot;
        else:
            if price &gt; self.holdings[symbol][1] and price &gt; 0.99*price_max:
                print &quot;+++++++ Price of %s is higher than my holdings, so I&#39;m going to sell!&quot; % symbol
                sale_value = self.holdings[symbol][0] * price
                print &quot;Sale value is %s&quot; % sale_value
                print &quot;Holdings value is %s&quot; % self.holdings[symbol][2]
                print &quot;Total net is %s&quot; % (sale_value - self.holdings[symbol][2])
                self.cash += sale_value
                print &quot;Cash is now %s&quot; % self.cash
                del self.holdings[symbol]

    def handle_pyamqplib_delivery(self, msg):
        self.handle(msg.delivery_info[&quot;channel&quot;], msg.delivery_info[&quot;delivery_tag&quot;], msg.body)

    def handle(self, ch, delivery_tag, body):
        quote = pickle.loads(body)
        #print &quot;New price for %s =&gt; %s at %s&quot; % quote
        ch.basic_ack(delivery_tag = delivery_tag)
        print &quot;Received message %s&quot; % quote[3]
        self.decide_whether_to_buy_or_sell(quote)

    def monitor(self):
        self.client.monitor(self.qname, self.handle_pyamqplib_delivery)
</code></pre><p>该客户的买卖策略与从RabbitMQ接收消息的机制完全隔离。<br></p><ol><br> <li><strong>显示器</strong>是开始聆听新股票报价的主要动力。它将<strong>handle_pyamqplib_delivery</strong>注册为回调方法，以在每次新报价到达时调用。</li><br> <li><strong>handle_pyamqplib_delivery</strong>提取消息的重要部分并交给他们<strong>处理</strong> 。插入此额外方法调用的原因是为了支持将py-amqplib与pika交换出去，我们将在后面介绍。</li><br> <li><strong>句柄</strong>使消息的不透明主体脱颖而出，与经纪人确认通道上消息的接收，然后触发有关决定是否买卖的算法。</li><br> <li><strong>define_whether_to_buy_or_sell</strong>拆分股票报价的元组，然后将价格添加到其股票代码历史记录中。它可以在做出决定之前收集最少数量的报价。你不是吗然后，它计算趋势的最小和最大，如果价格相对接近最小，则买入。但是，如果它已经有股票，那么它会等待价格上涨到其最初支付的价格之上。发生这种情况时，它就会出售。</li><br></ol><br>缺少的部分是<strong>self.client.monitor</strong>函数。 <strong>self.client</strong>是我们之前编码的AMQP服务的挂钩，我们需要一种将队列绑定到交换以接收消息的方法。需要将以下功能添加到<strong>PyAmqpLibPublisher</strong> 。<p></p>
<pre><code class="prettyprint python">    def monitor(self, qname, callback):
        conn = amqp.Connection(host=&quot;127.0.0.1&quot;, userid=&quot;guest&quot;, password=&quot;guest&quot;)

        ch = conn.channel()

        if not self.queue_exists:
            ch.queue_declare(queue=qname, durable=False, exclusive=False, auto_delete=False)
            ch.queue_bind(queue=qname, exchange=self.exchange_name)
            print &quot;Binding queue %s to exchange %s&quot; % (qname, self.exchange_name)
            #ch.queue_bind(queue=qname, exchange=self.exchange_name, routing_key=qname)
            self.queue_exists = True

        ch.basic_consume(callback=callback, queue=qname)

        while True:
            ch.wait()
        print &#39;Close reason:&#39;, conn.connection_close
</code></pre><p>这显示了连接到RabbitMQ代理，声明队列，将其绑定到扇出交换机并注册回调的基本模式。</p><p>但是，让我们不要全神贯注于如何使该算法更好地选择赢家和输家。相反，让我们认识到，这使得任何金融公司都可以通过创建唯一的队列，绑定到股票系统的扇出交易所，然后编写自己的算法来进行财务决策，来轻松订购股票报价。<br></p><h2>用pika取代py-amqplib</h2><br>AMQP是写得很好的规范。它包含XML格式，支持自动生成客户端库的功能。这意味着按照规范编码的库很容易换出，并根据其实现的优点进行选择。在Python社区中流行的库是<a href="https://code.google.com/p/py-amqplib/">py-amqplib</a> 。正如其项目站点上所指出的那样，它的局限性之一是它阻止并且当前不提供并发。皮卡同时提供。<p></p><p>重要的一点是，从py-amqplib迁移到pika实际上很容易。基于AMQP的方法是相同的，基本概念也相同。让我们看一下使用pika编写另一种AMQP服务。</p>
<pre><code class="prettyprint python">import pika

class PikaPublisher(object):
    def __init__(self, exchange_name):
        self.exchange_name = exchange_name
        self.queue_exists = False

    def publish(self, message, routing_key):
        conn = pika.AsyncoreConnection(pika.ConnectionParameters(
                &#39;127.0.0.1&#39;,
                credentials=pika.PlainCredentials(&#39;guest&#39;, &#39;guest&#39;)))

        ch = conn.channel()

        ch.exchange_declare(exchange=self.exchange_name, type=&quot;fanout&quot;, durable=False, auto_delete=False)

        ch.basic_publish(exchange=self.exchange_name,
                         routing_key=routing_key,
                         body=message,
                         properties=pika.BasicProperties(
                                content_type = &quot;text/plain&quot;,
                                delivery_mode = 2, # persistent
                                ),
                         block_on_flow_control = True)
        ch.close()
        conn.close()

    def monitor(self, qname, callback):
        conn = pika.AsyncoreConnection(pika.ConnectionParameters(
                &#39;127.0.0.1&#39;,
                credentials=pika.PlainCredentials(&#39;guest&#39;, &#39;guest&#39;)))

        ch = conn.channel()

        if not self.queue_exists:
            ch.queue_declare(queue=qname, durable=False, exclusive=False, auto_delete=False)
            ch.queue_bind(queue=qname, exchange=self.exchange_name)
            print &quot;Binding queue %s to exchange %s&quot; % (qname, self.exchange_name)
            #ch.queue_bind(queue=qname, exchange=self.exchange_name, routing_key=qname)
            self.queue_exists = True

        ch.basic_consume(callback, queue=qname)

        pika.asyncore_loop()
        print &#39;Close reason:&#39;, conn.connection_close
</code></pre><p>这与前面显示的其他服务非常相似。创建连接略有不同，但是包含相同的数据，例如<strong>代理的</strong>主机， <strong>用户名</strong>和<strong>密码</strong> 。 <strong>basic_publish</strong>稍有不同，因为消息及其属性放在方法调用中。 py-amqplib以略有不同的结构声明整个消息及其属性，然后将其作为一个参数传递给basic_publish。关于规范的好事是知道所有重要部分都在两个库中。</p><p>与py-amqplib相比，pika支持不同的等待机制。 py-amqplib有一个阻塞等待，而pika提供了一种阻塞机制以及一种使用<a href="https://docs.python.org/library/asyncore.html">Python的asyncore实用程序</a>进行异步操作的机制。我们可以在以后有关RabbitMQ和Python的博客条目中进行探讨。</p><p>这两个库之间的回调方法签名略有不同。我们需要更新我们的经纪客户以适当地处理它。</p>
<pre><code class="prettyprint python">    def handle_pyamqplib_delivery(self, msg):
        self.handle(msg.delivery_info[&quot;channel&quot;], msg.delivery_info[&quot;delivery_tag&quot;], msg.body)
</code></pre><p>将此与pika的回调方法签名进行比较。 <span style="font-family:Consolas,Monaco,'Courier New',Courier,monospace;line-height:18px;font-size:12px;white-space:pre"> </span></p>
<pre><code class="prettyprint python">    def handle_pika_delivery(self, ch, method, header, body):
        self.handle(ch, delivery_tag, body)
</code></pre><p>他们非常接近。重要的部分在那里。区别是基于以下事实：pika拆分了消息的各个部分，而py-amqplib将其全部合并到一个类中。这就是为什么在回调方法和提取消息正文的实际方法之间存在解耦的原因。通过提取必要的部分，可以在这两个库之间切换而无需重写我们的买卖算法。<br></p><h2>运行的东西</h2><br>使用所有这些代码，我们需要运行东西。编写启动脚本并旋转起来很容易。<p></p>
<pre><code class="prettyprint python">########################################
# To run this demo using py-amqplib,
# uncomment this block, and  comment out
# the next block.
########################################

#from amqplib_client import *
#publisher = PyAmqpLibPublisher(exchange_name=&quot;my_exchange&quot;)

########################################
# To run this demo using pika,
# uncomment this block, and comment out
# the previous block
########################################

from pika_client import *
publisher = PikaPublisher(exchange_name=&quot;my_exchange&quot;)

########################################
# This part doesn&#39;t have to change
########################################

from ticker_system import *
ticker = Ticker(publisher, &quot;&quot;)
ticker.monitor()
</code></pre><p>可以在运行我们的股票行情自动收录系统的py-amqplib或pika版本之间切换此运行程序。现在我们只需要经纪人服务即可。</p>
<pre><code class="prettyprint python">########################################
# To run this demo using py-amqplib,
# uncomment this block, and  comment out
# the next block.
########################################

#from amqplib_client import *
#publisher = PyAmqpLibPublisher(exchange_name=&quot;my_exchange&quot;)

########################################
# To run this demo using pika,
# uncomment this block, and comment out
# the previous block
########################################

from pika_client import *
publisher = PikaPublisher(exchange_name=&quot;my_exchange&quot;)

########################################
# This part doesn&#39;t have to change
########################################

from buy_low_sell_high import *
buyer = Buyer(publisher, &quot;&quot;, trend=25)
print &quot;Buyer = %s&quot; % id(buyer)
buyer.monitor()
</code></pre><p>在以后的博客文章中，我们可以使用pythonic DI容器来娱乐运行相同的代码。<br><strong> </strong><br></p><h2><strong>一个好的规格提供了很好的选择</strong></h2><br>AMQP规范使您不仅可以根据技术优点来轻松选择库。通过将AMQP的机制从生成报价以及解析报价的逻辑中分离出来，很容易换出py-amqplib和pika。核心方法名称相同。有几个参数是相同的。但更重要的是：架构概念是相同的。现在，关于选择哪个库的选择不仅可以包括技术优点，还可以包括客户支持，规范合规性，同步与异步支持以及可用性等内容。<p></p><p><span style="font-family:Georgia,'Times New Roman','Bitstream Charter',Times,serif;font-size:small"><span style="line-height:19px;white-space:normal"> </span></span></p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 350;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>