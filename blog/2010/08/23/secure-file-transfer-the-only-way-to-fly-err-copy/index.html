<html  data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>（安全）文件传输，这是快速复制错误的唯一方法</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="(Secure) File Transfer, the Only Way to Fly…err Copy">
<meta name="twitter:description" >
<meta name="twitter:creator" content="@starbuxman">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=200">

<meta property="og:title" content="(Secure) File Transfer, the Only Way to Fly…err Copy">
<meta property="og:image" content="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=200">
<meta property="og:description" >
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2010-08-23 07:06:00.0">



<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">（安全）文件传输，这是快速复制错误的唯一方法</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=20&d=mm"> <a class="author" rel="author" href="/team/jlong">乔什·朗（Josh Long）</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2010-08-23 07:06:00.0">2010年8月23日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2010/08/23/secure-file-transfer-the-only-way-to-fly-err-copy#disqus_thread" data-disqus-identifier="351">
</a></div>
</div>
</header>
<div class="blog--post"><p>有很多方法可以给猫皮。如今，许多应用程序都依靠消息传递（AMQP，JMS）来弥合不同系统与数据之间的鸿沟。其他人则依赖RPC（通常是Web服务或REST）。但是，对于许多应用程序来说，文件传输是一种生活方式！支持它的方式有几种，但最常见的三种方式是使用共享的安装或文件夹，使用FTP服务器，以及-为了更安全的交换-使用SSH（或SFTP）。虽然众所周知，Spring一直为消息传递（JMS，AMQP）和RPC（提供太多的远程处理选项！）提供了一流的支持，但许多人可能会对<a href="http://www.springsource.org/spring-integration">Spring提供的</a>强大的文件传输选项感到惊讶<a href="http://www.springsource.org/spring-integration">整合项目</a>了。在本文中，我将基于即将到来的Spring Integration 2.0框架中提供的一些令人兴奋的支持来构建，这些支持使您可以在新文件到达时挂入事件，还可以将文件发送到远程端点，例如FTP或SFTP服务器，或共享安装。</p><p>我们将使用一对熟悉的Java类-一个用于产生出站数据，另一个用于接收入站数据，因为它们用于SFTP，FTP或普通文件系统是无关紧要的。所有适配器均可提供<code>java.io.File</code>对象作为入站有效负载，我们可以发送File或String或<code>byte[]</code>到远程系统。首先，让我们看一下我们的标准客户端。在Spring Integration中，将响应入站消息而进行逻辑处理的类称为“服务激活器”。您只需配置一个<code><service-activator></code>元素并告诉它您要使用哪个bean处理<code>Message</code> 。它将遵循几种不同的启发式方法，以帮助您解决分配消息的方法。在这里，我们只是对其进行显式注释。因此，这是我们在整个帖子中将使用的客户端代码：</p>
<pre><code class="prettyprint java">import org.springframework.integration.annotation.*;
import org.springframework.stereotype.Component;
import java.io.File;
import java.util.Map;

@Component
public class InboundFileProcessor {

    @ServiceActivator
    public void onNewFileArrival(
            @Headers Map&amp;lt;String, Object&amp;gt; headers,
            @Payload File file) {

        System.out.printf(&quot;A new file has arrived deposited into &quot; +
                          &quot;the accounting folder at the absolute &quot; +
                          &quot;path %s \n&quot;, file.getAbsolutePath());

        System.out.println(&quot;The headers are:&quot;);
        for (String k : headers.keySet())
            System.out.println(String.format(&quot;%s=%s&quot;, k, headers.get(k)));

    }
}
</code></pre><p>并且，以下是我们将用于合成数据的代码，这些数据最终将作为文件存储在文件系统中：</p>
<pre><code class="prettyprint java">import org.springframework.integration.annotation.Header;
import org.springframework.integration.aop.Publisher;
import org.springframework.integration.file.FileHeaders;
import org.springframework.stereotype.Component;

@Component
public class OutboundFileProducer {

    @Publisher(channel = &quot;outboundFiles&quot;)
    public String writeReportToDisk (
             @Header(&quot;customerId&quot;) long customerId,
             @Header(FileHeaders.FILENAME) String fileName    ) {
        return String.format(&quot;this is a message tailor made for customer # %s&quot;, customerId);
    }

}
</code></pre><p>最后一个例子展示了我在Spring Integation中确实最喜欢的功能之一，并且实际上在总体上来说是Spring：界面透明性。的<code>OutboundFileProducer</code>类定义了一个方法，并带有<code>@Publisher</code>注解。的<code>@Publisher</code>注释告诉Spring Integration将方法调用的返回值转发到通道上（这里我们通过注释将其命名为- <code>outboundFiles</code> ）。这与您注入了<code>org.springframework.integration.MessageChannel</code>直接实例并发送了一个<code>Message</code>直接在上面。除了，现在所有的东西都隐藏在一个干净的POJO中！任何人都可以自行决定注入此bean-这是我们的秘密，当他们调用该方法时，会将返回值写入到<code>File</code>要激活此功能，我们安装一个Spring <code>BeanPostProcessor</code>在我们的 Spring 环境中。Bean后处理器机制使您可以轻松地在Spring上下文中扫描Bean，并在适当情况下扩展其定义。在这种情况下，我们将添加带有注释的bean <code>@Publisher</code> 。安装<code>BeanPostProcessor</code>就像实例化它一样简单：<br></p><pre class="brush: xml;">&lt;beans:bean class=&ldquo;org.springframework.integration.aop.PublisherAnnotationBeanPostProcessor&rdquo;/&gt;</pre><br>现在，我可以创建一个客户端来注入这个bean（或直接从上下文访问它）并像使用其他任何服务一样使用它：<p></p>
<pre><code class="prettyprint java">@Autowired
private OutboundFileProducer outboundFileProducer ; 

 // ... 

outboundFileProducer.writeReportToDisk(1L, &quot;1.txt&quot;) ;
</code></pre><p>最后，在我所有的Spring环境中，我将打开<code><context:component-scan … /></code>让Java代码发挥最大作用<br>讨论并处理业务逻辑。我使用XML的唯一地方是描述全局集成解决方案的流程和配置。<br></p><h2>文件系统</h2><br>首选-共享挂载-非常普遍。建立这样的解决方案的方法越来越多。大多数操作系统都有一种机制，可让您在文件到达时接收通知。Win32 / .NET会显示Windows的钩子，在Linux上，有许多机制，例如在内核级别进行inotify。在Java平台上，Java 7计划在NIO.2程序包中包含WatchService。但是，与此同时，您需要编写执行目录轮询，保持状态并分派事件的代码。听起来不是很刺激，不是吗？请注意，我们将讨论的所有适配器都需要某种轮询。轮询效果很好，但是您需要进行一些校准。首先，除非适当地屏蔽了文件，否则很有可能对目录的扫描将拾取仍在写入的文件。通常，系统会将文件存放在某个挂载上，然后写入文件，然后以与适配器上的正则表达式掩码匹配的方式对其进行重命名：这可确保适配器在完成之前不会“看到”文件。<p></p><p>在这里，Spring Integration可以提供很多帮助-使您摆脱所有目录轮询代码的束缚，并使您可以编写对您重要的逻辑。如果您以前使用过Spring Integration，那么您就会知道从外部系统接收事件就像插入适配器一样简单，然后让适配器告诉您什么时候值得做出反应。设置很简单：监视文件文件夹中是否有新文件，并且当新文件到达并且（可选）符合某些条件时，Spring Integration会转发一个文件。 <code>Message</code>具有有效载荷<code>java.io.File</code>对已添加文件的引用。</p><p>您可以使用<code>file:inbound-channel-adapter</code>以此目的。适配器以固定的时间间隔监视目录（由目录配置<code>poller</code>元素），然后发布一个<code>Message</code>当检测到新文件时。让我们看看如何在Spring Integration中配置它：</p>
<pre><code class="prettyprint xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;beans:beans ... xmlns:file=&quot;http://www.springframework.org/schema/integration/file&quot; &gt;
    &lt;context:component-scan base-package=&quot;org.springframework.integration.examples.filetransfer.core&quot;/&gt;

    &lt;file:inbound-channel-adapter channel=&quot;inboundFiles&quot;
                                  auto-create-directory=&quot;true&quot;
                                  filename-pattern=&quot;.*?csv&quot;
                                  directory=&quot;#{systemProperties[&#39;user.home&#39;]}/accounting&quot;&gt;
        &lt;poller fixed-rate=&quot;10000&quot;/&gt;
    &lt;/file:inbound-channel-adapter&gt;

    &lt;channel id=&quot;inboundFiles&quot;/&gt;

    &lt;service-activator input-channel=&quot;inboundFiles&quot; ref=&quot;inboundFileProcessor&quot;/&gt;

&lt;/beans:beans&gt;
</code></pre><p>我认为这些选项很容易解释。的<code>filename-pattern</code>是一个正则表达式，将根据目录中的每个文件名进行评估。如果文件名与正则表达式匹配，则将对其进行处理。适配器标记内的poller元素告诉适配器每10,000毫秒（或10秒）重新检查目录。当然，目录属性使您可以指定要监视的目录，并且通道描述在适配器找到某些内容时将转发消息的命名通道。在此示例中，与所有后续示例一样，我们将其转发消息到连接到<code><service-activator></code>元件。服务激活器只是您提供的Java代码，当新消息到达时，Spring Integration将调用它们。在那里您可以做任何您想做的事情。</p><p>写入文件系统挂载完全是另一回事。更简单！<br></p><pre class="brush:xml">&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?&gt;</p><p>&lt;beans:beans &hellip; xmlns:file=&ldquo;<a href="http://www.springframework.org/schema/integration/file">http://www.springframework.org/schema/integration/file</a>&rdquo; &gt;</p>
<pre><code class="prettyprint">&amp;lt;context:component-scan base-package=&quot;org.springframework.integration.examples.filetransfer.core&quot;/&amp;gt;
&amp;lt;beans:bean class=&quot;org.springframework.integration.aop.PublisherAnnotationBeanPostProcessor&quot;/&amp;gt;

&amp;lt;channel id=&quot;outboundFiles&quot;/&amp;gt;

&amp;lt;file:outbound-channel-adapter
        channel=&quot;outboundFiles&quot;
        auto-create-directory=&quot;true&quot;
        directory=&quot;#{systemProperties[&#39;user.home&#39;]}/Desktop/sales&quot;/&amp;gt;
</code></pre><p></beans:beans></p></pre><br>在此示例中，我们描述了一个命名通道和一个出站适配器。回想一下，出站通道是从我们之前创建的Publisher类中引用的。在所有情况下，示例都会将消息放入频道（ <code>outboundFiles</code> ），当您调用该方法时<code>writeReportToDisk</code> ，这些消息将一直传播，直到它们到达出站适配器为止。调用方法时<code>writeReportToDisk</code> ，返回值（字符串）用作a的有效负载<code>Message</code> ，并用注释的两个方法参数<code>@Header</code>元素作为标题添加到<code>Message.</code>的<code>@Header</code>谁的钥匙是<code>FileHeaders.FILENAME</code>用于告诉outbound-adapter在配置的目录中写入文件时使用什么文件名。如果我们没有指定它，它将基于一个<code>UUID</code>为了我们。很漂亮吧？<br><h2>FTP（文件传输协议）</h2><br>FTP是一种非常常见的文件存储方式。FTP支持基本身份验证，因此它不是最安全的协议。它无处不在：所有操作系统都有免费的客户端，实际上，很多非技术人员都知道如何使用它，这使之成为在系统与客户之间集成和启用文件共享的好方法。要在Spring Integration中使用FTP适配器，您需要告诉它如何连接到FTP服务器， <em>并且</em>需要告诉它在入站场景中要将文件下载到本地系统上的位置。<p></p><p>让我们看一下配置Spring Integration以便从远程FTP服务器接收新文件。<br></p><pre class="brush:xml;">&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?&gt;<br />&lt;beans &hellip; xmlns:ftp=&quot;<a href="http://www.springframework.org/schema/integration/ftp" &gt">http://www.springframework.org/schema/integration/ftp"&gt</a>;</p>
<pre><code class="prettyprint">&amp;lt;context:component-scan base-package=&quot;org.springframework.integration.examples.filetransfer.core&quot;/&amp;gt;
&amp;lt;context:property-placeholder location=&quot;file://${user.home}/Desktop/ftp.properties&quot; ignore-unresolvable=&quot;true&quot;/&amp;gt;

&amp;lt;ftp:inbound-channel-adapter
        remote-directory=&quot;${ftp.remotedir}&quot;
        channel=&quot;ftpIn&quot;
        auto-create-directories=&quot;true&quot;
        host=&quot;${ftp.host}&quot;
        auto-delete-remote-files-on-sync=&quot;false&quot;
        username=&quot;${ftp.username}&quot; password=&quot;${ftp.password}&quot;
        port=&quot;2222&quot;
        client-mode=&quot;passive-local-data-connection-mode&quot;
        filename-pattern=&quot;.*?jpg&quot;
        local-working-directory=&quot;#{systemProperties[&#39;user.home&#39;]}/received_ftp_files&quot;
        &amp;gt;
    &amp;lt;int:poller fixed-rate=&quot;10000&quot;/&amp;gt;
&amp;lt;/ftp:inbound-channel-adapter&amp;gt;

&amp;lt;int:channel id=&quot;ftpIn&quot;/&amp;gt;

&amp;lt;int:service-activator input-channel=&quot;ftpIn&quot; ref=&quot;inboundFileProcessor&quot;/&amp;gt;
</code></pre><p></beans></p></pre><br>您会看到有很多选择！他们中的大多数人都是-可选-但很高兴知道他们在那里。此适配器将下载与<code>filename-pattern</code>指定，然后将它们作为<code>Message</code>与一个<code>java.io.File</code>和以前一样。这就是为什么我们能够简单地重用先前的<code>inboundFileProcessor</code> bean 。如果要进一步控制下载和不下载的内容，请考虑使用文件名模式来指定掩码。请注意，这里存在很多控制，包括对连接模式的控制以及是否应在文件交付时删除源文件。<p></p><p>出站适配器看起来与我们为文件支持配置的出站适配器看起来非常相似。执行此操作后，它将封送进入其中的有效负载的内容，然后将这些内容存储在FTP服务器上。目前，有预先建立的封送处理支持<code>String,</code>一种<code>byte[],</code>和一个<code>java.io.File</code>宾语。<br></p><pre class="brush: xml;">&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?&gt;<br />&lt;beans &hellip; xmlns:ftp=&quot;<a href="http://www.springframework.org/schema/integration/ftp" &gt">http://www.springframework.org/schema/integration/ftp"&gt</a>;</p>
<pre><code class="prettyprint">&amp;lt;context:component-scan base-package=&quot;org.springframework.integration.examples.filetransfer.core&quot;/&amp;gt;
&amp;lt;context:property-placeholder location=&quot;file://${user.home}/Desktop/ftp.properties&quot; ignore-unresolvable=&quot;true&quot;/&amp;gt;

&amp;lt;int:channel id=&quot;outboundFiles&quot;/&amp;gt;

&amp;lt;ftp:outbound-channel-adapter
        remote-directory=&quot;${ftp.remotedir}&quot;
        channel=&quot;outboundFiles&quot;
        host=&quot;${ftp.host}&quot;
        username=&quot;${ftp.username}&quot; password=&quot;${ftp.password}&quot; port=&quot;2222&quot;
        client-mode=&quot;passive-local-data-connection-mode&quot;
        /&amp;gt;
</code></pre><p></beans></p></pre><br>与出站文件适配器一样，我们正在生成要使用我们的内容存储的内容<code>OutboundFileProducer</code>课，所以不需要复习。剩下的就是通道的配置和适配器本身，它规定了您希望看到的所有规定：服务器配置和有效负载存放到的远程目录。<p></p><p>继续…。<br></p><h2>SSH文件传输协议（或安全文件传输协议）</h2><br>最后，我们到达SFTP适配器。可以说，这是3个适配器中配置最复杂的一个，但它也是最容易测试的适配器之一。 SFTP通常可在您具有SSH访问权限的任何地方使用，尽管严格来讲，它并不局限于此。SFTP不是通过SSH的FTP，而是完全不同的协议。它通常比SCP更为普遍和一致，说明了SCP可以解释的许多事情。SFTP本身是一个相对简单的协议，因为它对它通过其进行通信的连接做出了许多假设：除其他事项外，它还假设：<br>知道客户端用户的身份，正在通过安全通道进行，并且已经进行身份验证。它是由设计SSH2的同一工作组设计的，并且可以很好地用作SSH2子系统。可以想象您可以在SSH1服务器上运行SFTP。由于SFTP在提供身份验证机制的SSH之上工作，因此它支持相同的身份验证选项，包括用户名，密码和/或公用密钥（它们本身可能还具有密码）。如果您运行的是相对较新的OpenSSH版本（它本身可在AIX，HP-UX，Iris，Linux，Cygwin，Mac OSX，Solaris，SNI，Digital Unix / Tru64 / OSF，NeXT（！），SCO和更多），则您可能已经安装了该程序并可以继续进行。换句话说，找到比支持某种形式的SFTP的计算机要比支持可以挂载的文件系统的计算机更容易。看，我告诉过你它很容易测试！<p></p><p>要开始使用入站适配器，只需复制并粘贴FTP适配器，将所有出现的FTP重命名为SFTP，适当地更改相关的配置值（端口，主机…），删除客户端模式选项，然后您就可以完成！当然还有其他选择-许多其他选择可让您限定身份验证机制；例如，公共密钥或用户名。这是一个熟悉的示例：<br></p><pre class="brush:xml;">&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?&gt;<br />&lt;beans &hellip; xmlns:sftp=&quot;<a href="http://www.springframework.org/schema/integration/sftp" &gt">http://www.springframework.org/schema/integration/sftp"&gt</a>;</p>
<pre><code class="prettyprint">&amp;lt;context:component-scan base-package=&quot;org.springframework.integration.examples.filetransfer.core&quot;/&amp;gt;
&amp;lt;context:property-placeholder location=&quot;file://${user.home}/Desktop/sftp.properties&quot; ignore-unresolvable=&quot;true&quot;/&amp;gt;

&amp;lt;sftp:inbound-channel-adapter
        remote-directory=&quot;${sftp.remotedir}&quot;
        channel=&quot;sftpIn&quot;
        auto-create-directories=&quot;true&quot;
        host=&quot;${sftp.host}&quot;
        auto-delete-remote-files-on-sync=&quot;false&quot;
        username=&quot;${sftp.username}&quot;
        password=&quot;${sftp.password}&quot;
        filename-pattern=&quot;.*?jpg&quot;
        local-working-directory=&quot;#{systemProperties[&#39;user.home&#39;]}/received_sftp_files&quot;
        &amp;gt;
    &amp;lt;int:poller fixed-rate=&quot;10000&quot;/&amp;gt;
&amp;lt;/sftp:inbound-channel-adapter&amp;gt;

&amp;lt;int:channel id=&quot;sftpIn&quot;/&amp;gt;

&amp;lt;int:service-activator input-channel=&quot;sftpIn&quot; ref=&quot;inboundFileProcessor&quot;/&amp;gt;
</code></pre><p></beans></p></pre><br>很方便，是吗？规则与前面的示例相同：您的客户端代码将被传递给<code>java.io.File</code>您认为可以处理的实例。SFTP出站适配器将设置取整：<br><pre class="brush:xml">&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?&gt;<br />&lt;beans xmlns:sftp=&quot;<a href="http://www.springframework.org/schema/integration/sftp" &gt">http://www.springframework.org/schema/integration/sftp"&gt</a>;</p>
<pre><code class="prettyprint">&amp;lt;context:component-scan base-package=&quot;org.springframework.integration.examples.filetransfer.core&quot;/&amp;gt;
&amp;lt;context:property-placeholder location=&quot;file://${user.home}/Desktop/sftp.properties&quot; ignore-unresolvable=&quot;true&quot;/&amp;gt;

&amp;lt;int:channel id=&quot;outboundFiles&quot;/&amp;gt;

&amp;lt;sftp:outbound-channel-adapter
        remote-directory=&quot;${sftp.remotedir}&quot;
        channel=&quot;outboundFiles&quot;
        host=&quot;${sftp.host}&quot;
        username=&quot;${sftp.username}&quot;
        password=&quot;${sftp.password}&quot;
/&amp;gt;
</code></pre><p></beans></p></pre><br><h2>然后去哪儿？</h2><br>考虑哪些类型的问题通常是面向文件的，或者本质上是<em>面向批处理的</em> ，这很有用。Spring Integration在通知您世界中的有趣事件方面做得非常出色（“新文件已放入文件夹！”）和整合数据； Spring Integration是实现事件驱动架构的好方法。但是，具有一百万行的文件不是<em>事件。</em> Spring Integration在框架中没有用于处理大型批处理文件有效负载的内置工具-这是<a href="http://static.springsource.org/spring-batch/">Spring Batch</a>的工作<a href="http://static.springsource.org/spring-batch/">。</a> 因此，请考虑一种利用Spring Integration来检测文件可用性的方法，然后再启动一个Spring Batch任务。对于Spring Batch，没有什么太大的工作。Spring Batch可以帮助您将数百万条记录的文件分解为事件大小的记录，而这些记录是Spring Integration所需要的。我喜欢将这两个框架看作是由事件驱动的，数据紧张的坏事组成的精致芭蕾舞中交织的舞者！<br><h2>摘要</h2><br>在本文中，我们讨论了Spring Integration中文件传输适配器的广泛领域，这些问题使使用直接文件系统挂载，FTP和SFTP的基于文件的集成繁琐的工作变得异常愉快。<p></p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 351;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>