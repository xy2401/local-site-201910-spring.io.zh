<!DOCTYPE html>
<html data-code-prettify="" data-mobile-support="" data-search="">
<head>
<title>(Secure) File Transfer, the Only Way to Fly…err Copy</title>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no" id="Viewport" name="viewport" />
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png" />
<link href="https://fonts.googleapis.com/css?family=Varela+Round|Montserrat:400,700" rel="stylesheet" type="text/css" />
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css" />
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M" name="google-site-verification" />

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css" />

<meta content="summary" name="twitter:card" />
<meta content="@springcentral" name="twitter:site" />
<meta name="twitter:title" content="(Secure) File Transfer, the Only Way to Fly…err Copy" />
<meta name="twitter:description" content="&lt;p&gt;There are many ways to skin a cat. Many applications today rely on messaging (AMQP, JMS) to bridge the gap between disparate systems and data. Others rely on RPC (typically web-services, or REST). For a great many applications, however, file transfer is very much a way of life! There are several common ways of supporting it, but three of the most common are using a shared mount or folder, using a FTP server, and - for more secure exchanges - using SSH (or SFTP). While it’s common knowledge that Spring has always provided first-class support for messaging (JMS, AMQP) and RPC (there are far too many remoting options to list!), many might be surprised at the many robust options for file transfer that the &lt;a href=&quot;http://www.springsource.org/spring-integration&quot;&gt;Spring Integration project&lt;/a&gt; has. In this post, I’ll be building against some of the exciting support found in the upcoming Spring Integration 2.0 framework that lets you hook into events when new files arrive and also to send files to remote endpoints like an FTP or SFTP server, or a shared mount.&lt;/p&gt;
" />
<meta name="twitter:creator" content="@starbuxman" />
<meta name="twitter:image:src" content="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=200" />

<meta property="og:title" content="(Secure) File Transfer, the Only Way to Fly…err Copy" />
<meta property="og:image" content="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=200" />
<meta property="og:description" content="&lt;p&gt;There are many ways to skin a cat. Many applications today rely on messaging (AMQP, JMS) to bridge the gap between disparate systems and data. Others rely on RPC (typically web-services, or REST). For a great many applications, however, file transfer is very much a way of life! There are several common ways of supporting it, but three of the most common are using a shared mount or folder, using a FTP server, and - for more secure exchanges - using SSH (or SFTP). While it’s common knowledge that Spring has always provided first-class support for messaging (JMS, AMQP) and RPC (there are far too many remoting options to list!), many might be surprised at the many robust options for file transfer that the &lt;a href=&quot;http://www.springsource.org/spring-integration&quot;&gt;Spring Integration project&lt;/a&gt; has. In this post, I’ll be building against some of the exciting support found in the upcoming Spring Integration 2.0 framework that lets you hook into events when new files arrive and also to send files to remote endpoints like an FTP or SFTP server, or a shared mount.&lt;/p&gt;
" />
<meta content="article" property="og:type" />
<meta property="og:article:published_time" content="2010-08-23 07:06:00.0" />
</head>
<body>

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" style="display:none;visibility:hidden" width="0"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">Projects</a>
</li>
<li class="navbar-link">
<a href="/guides">Guides</a>
</li>
<li class="navbar-link active">
<a href="/blog">Blog</a>
</li>
<li class="navbar-link">
<a href="/services">Training & Certification</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form action="/search" class="form-inline form-search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search for documentation, guides, and posts..." type="text" value="" />
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form action="/search" class="form-inline form-search" method="get">
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search..." type="text" value="" />
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">
Home
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">
Projects
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">
Guides
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">
Blog
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">
Training & Certification
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>Engineering</div>
</div>
<div class="blog-category content--title">
<div>Releases</div>
</div>
<div class="blog-category content--title">
<div>News and Events</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">(Secure) File Transfer, the Only Way to Fly…err Copy</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">Engineering</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=20&amp;d=mm" />
<a class="author" rel="author" href="/team/jlong">Josh Long</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2010-08-23 07:06:00.0">August 23, 2010</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" data-disqus-identifier="351" href="/blog/2010/08/23/secure-file-transfer-the-only-way-to-fly-err-copy#disqus_thread">
</a></div>
</div>
</header>
<div class="blog--post"><p>There are many ways to skin a cat. Many applications today rely on messaging (AMQP, JMS) to bridge the gap between disparate systems and data. Others rely on RPC (typically web-services, or REST). For a great many applications, however, file transfer is very much a way of life! There are several common ways of supporting it, but three of the most common are using a shared mount or folder, using a FTP server, and - for more secure exchanges - using SSH (or SFTP). While it&rsquo;s common knowledge that Spring has always provided first-class support for messaging (JMS, AMQP) and RPC (there are far too many remoting options to list!), many might be surprised at the many robust options for file transfer that the <a href="http://www.springsource.org/spring-integration">Spring Integration project</a> has. In this post, I&rsquo;ll be building against some of the exciting support found in the upcoming Spring Integration 2.0 framework that lets you hook into events when new files arrive and also to send files to remote endpoints like an FTP or SFTP server, or a shared mount.</p><p>We&rsquo;ll use a familiar pair of Java classes - one to produce outbound data, and another to receive inbound data, be they used for SFTP, FTP, or plain ol&rsquo; file systems is irrelevant. All the adapters deliver <code>java.io.File</code> objects as their inbound payload, and we can send File&rsquo;s or Strings or <code>byte[]</code>s to the remote systems. First, let&rsquo;s look at our standard client. In Spring Integration, classes that do logic in response to inbound messages are called &ldquo;service activators.&rdquo; You simply configure a <code>&lt;service-activator&gt;</code> element and tell it which bean you want to use to handle the <code>Message</code>. It&rsquo;ll follow a few different heuristics to help you out in resolving which method to dispatch the Message. Here, we&rsquo;re just annotating it explicitly. Thus, here&rsquo;s the client code we&rsquo;ll use throughout the post:</p>
<pre><code class="prettyprint java">import org.springframework.integration.annotation.*;
import org.springframework.stereotype.Component;
import java.io.File;
import java.util.Map;

@Component
public class InboundFileProcessor {

    @ServiceActivator
    public void onNewFileArrival(
            @Headers Map&amp;lt;String, Object&amp;gt; headers,
            @Payload File file) {

        System.out.printf(&quot;A new file has arrived deposited into &quot; +
                          &quot;the accounting folder at the absolute &quot; +
                          &quot;path %s \n&quot;, file.getAbsolutePath());

        System.out.println(&quot;The headers are:&quot;);
        for (String k : headers.keySet())
            System.out.println(String.format(&quot;%s=%s&quot;, k, headers.get(k)));

    }
}
</code></pre><p>And, here&rsquo;s the code we&rsquo;ll use to synthesize data to ultimately be stored on a file system as a file:</p>
<pre><code class="prettyprint java">import org.springframework.integration.annotation.Header;
import org.springframework.integration.aop.Publisher;
import org.springframework.integration.file.FileHeaders;
import org.springframework.stereotype.Component;

@Component
public class OutboundFileProducer {

    @Publisher(channel = &quot;outboundFiles&quot;)
    public String writeReportToDisk (
             @Header(&quot;customerId&quot;) long customerId,
             @Header(FileHeaders.FILENAME) String fileName    ) {
        return String.format(&quot;this is a message tailor made for customer # %s&quot;, customerId);
    }

}
</code></pre><p>This last one is an example of one of my absolute favorite features in Spring Integation and indeed Spring in general: interface transparency. The <code>OutboundFileProducer</code> class defines a method annotated with a <code>@Publisher</code> annotation. The <code>@Publisher</code> annotation tells Spring Integration to forward the return value of this method invocation onto a channel (here we&rsquo;ve named it through the annotation - <code>outboundFiles</code>). This is the same as if you had injected a <code>org.springframework.integration.MessageChannel</code> instance directly and sent a <code>Message</code> on it directly. Except, now it&rsquo;s all hidden behind a nice clean POJO! Anybody can inject this bean at their discretion - it&rsquo;ll be our secret that when they invoke the method the return value is being written to a <code>File</code> somewhere :-) To activate this feature, we install a Spring <code>BeanPostProcessor</code> in our Spring context. The bean post processor mechanism lets you easily scan the Spring context for beans and - where appropriate - augment their definitions. In this case we&rsquo;re augmenting beans annotated with <code>@Publisher</code>. Installing the <code>BeanPostProcessor</code> is as simple as instantiating it:<br /><pre class="brush: xml;">&lt;beans:bean class=&ldquo;org.springframework.integration.aop.PublisherAnnotationBeanPostProcessor&rdquo;/&gt;</pre><br />Now, I can create a client that injects this bean (or simply access it from the context) and use it like I might any other service:</p>
<pre><code class="prettyprint java">@Autowired
private OutboundFileProducer outboundFileProducer ; 

 // ... 

outboundFileProducer.writeReportToDisk(1L, &quot;1.txt&quot;) ;
</code></pre><p>Finally, in all my Spring contexts, I&rsquo;ll turn on <code>&lt;context:component-scan &hellip; /&gt;</code> to let the Java code do most<br />of the talking and handle the business logic. The only places where I&rsquo;ve used XML are in describing the global integration solution&rsquo;s flow and configuration.<br /><h2>File System</h2><br />The first choice - a shared mount - is incredibly common. There are increasingly more ways to build a solution like this. Most Operating Systems have a mechanism that lets you receive notifications when files have arrived. Win32 / .NET surfaces hooks for Windows, and on Linux there are numerous mechanisms like inotify at the kernel level. On the Java platform, Java 7 is slated to include a WatchService in the NIO.2 package. In the meantime, however, you need to write code that does directory polling, keeps state, and then dispatches events. Doesn&rsquo;t sound very exciting, does it? Note that all of the adapters we&rsquo;ll discuss require polling of some sort. Polling works well enough, but requires some amount of calibration on your part. First it&rsquo;s entirely possible that a scan of a directory will pickup a file that&rsquo;s still being written to, unless you mask the file appropriately. Typically a system will deposit a file on some mount, write it and then rename it in such a way that it will match a regular expression mask on the adapter: this guarantees that the adapter won&rsquo;t &ldquo;see&rdquo; the file before it is done.</p><p>Here, Spring Integration helps quite a bit - sparing you from all the directory polling code and freeing you to write the logic that is important to you. If you&rsquo;ve used Spring Integration before, then you know that receiving events from external systems is as easy as plugging in an adapter and then letting the adapter tell you when something is worth reacting to. The setup is simple: a folder of files is monitored for new files and when a new file arrives and (optionally) matches some criteria, Spring Integration forwards a <code>Message</code> having as its payload a <code>java.io.File</code> reference to the file that&rsquo;s been added.</p><p>You can use the <code>file:inbound-channel-adapter</code> for this purpose. The adapter monitors a directory at a fixed interval (as configured by a <code>poller</code> element) and then publishes a <code>Message</code> when a new File has been detected. Let&rsquo;s look at how we&rsquo;d configure this in Spring Integration:</p>
<pre><code class="prettyprint xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

&lt;beans:beans ... xmlns:file=&quot;http://www.springframework.org/schema/integration/file&quot; &gt;
    &lt;context:component-scan base-package=&quot;org.springframework.integration.examples.filetransfer.core&quot;/&gt;

    &lt;file:inbound-channel-adapter channel=&quot;inboundFiles&quot;
                                  auto-create-directory=&quot;true&quot;
                                  filename-pattern=&quot;.*?csv&quot;
                                  directory=&quot;#{systemProperties[&#39;user.home&#39;]}/accounting&quot;&gt;
        &lt;poller fixed-rate=&quot;10000&quot;/&gt;
    &lt;/file:inbound-channel-adapter&gt;

    &lt;channel id=&quot;inboundFiles&quot;/&gt;

    &lt;service-activator input-channel=&quot;inboundFiles&quot; ref=&quot;inboundFileProcessor&quot;/&gt;

&lt;/beans:beans&gt;
</code></pre><p>The options are pretty self explanatory, I think. The <code>filename-pattern</code> is a regular expression that will be evaluated against every file name in the directory. If the file name matches the regular expression, then it will processed. The poller element inside the adapter&rsquo;s tags tell the adapter to recheck the directory every 10,000 milliseconds, or 10 seconds. The directory attribute lets you specify the directory to be monitored, of course, and the channel describes on what named channel to forward messages when the adapter finds something. In this example, as with all subsequent examples, we&rsquo;ll have it forward the message to a named channel that&rsquo;s hooked up to a <code>&lt;service-activator&gt;</code> element. Service activators are simply Java code that you provide and that Spring Integration will call when new messages arrive. There you may do anything you&rsquo;d like.</p><p>Writing to a file system mount is another story entirely; it&rsquo;s easier!<br /><pre class="brush:xml">&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?&gt;</p><p>&lt;beans:beans &hellip; xmlns:file=&ldquo;<a href="http://www.springframework.org/schema/integration/file">http://www.springframework.org/schema/integration/file</a>&rdquo; &gt;</p>
<pre><code class="prettyprint">&amp;lt;context:component-scan base-package=&quot;org.springframework.integration.examples.filetransfer.core&quot;/&amp;gt;
&amp;lt;beans:bean class=&quot;org.springframework.integration.aop.PublisherAnnotationBeanPostProcessor&quot;/&amp;gt;

&amp;lt;channel id=&quot;outboundFiles&quot;/&amp;gt;

&amp;lt;file:outbound-channel-adapter
        channel=&quot;outboundFiles&quot;
        auto-create-directory=&quot;true&quot;
        directory=&quot;#{systemProperties[&#39;user.home&#39;]}/Desktop/sales&quot;/&amp;gt;
</code></pre><p>&lt;/beans:beans&gt;</pre><br />In this example, we&rsquo;ve described a named channel and an outbound adapter. Recall that the outbound channel is referenced from the Publisher class we created earlier. In all case examples, it will put a Message onto the channel (<code>outboundFiles</code>) when you invoke the method <code>writeReportToDisk</code>, and those messages will travel until they hit the outbound adapter. When you invoke the method <code>writeReportToDisk</code>, the return value (a String) is used as the payload for a <code>Message</code>, and the two method parameters annotated with <code>@Header</code> elements are added as headers to the <code>Message.</code> The <code>@Header</code> whose key is <code>FileHeaders.FILENAME</code> is used to tell the outbound-adapter what file name to use when writing it in the configured directory. If we hadn&rsquo;t specified it, it would have synthesized one based on a <code>UUID</code> for us. Pretty slick right?<br /><h2>FTP (File Transfer Protocol)</h2><br />FTP&rsquo;s a very common way of storing files. FTP supports basic authentication, so it is not the most secure of protocols. It is ubiquitous: there are free clients for all operating systems, and indeed many people who are not necessarily technical will know how to work with it, This makes it a good way of integrating and enabling file sharing between your system and your customers. To use the FTP adapters in Spring Integration, you need to tell it how to connect to your FTP server, <em>and</em> you need to tell it where you want the files downloaded to on your local system in the inbound scenario.</p><p>Let&rsquo;s look at configuring Spring Integration to receive new files from a remote FTP server.<br /><pre class="brush:xml;">&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?&gt;<br />&lt;beans &hellip; xmlns:ftp=&quot;<a href="http://www.springframework.org/schema/integration/ftp" &gt">http://www.springframework.org/schema/integration/ftp"&gt</a>;</p>
<pre><code class="prettyprint">&amp;lt;context:component-scan base-package=&quot;org.springframework.integration.examples.filetransfer.core&quot;/&amp;gt;
&amp;lt;context:property-placeholder location=&quot;file://${user.home}/Desktop/ftp.properties&quot; ignore-unresolvable=&quot;true&quot;/&amp;gt;

&amp;lt;ftp:inbound-channel-adapter
        remote-directory=&quot;${ftp.remotedir}&quot;
        channel=&quot;ftpIn&quot;
        auto-create-directories=&quot;true&quot;
        host=&quot;${ftp.host}&quot;
        auto-delete-remote-files-on-sync=&quot;false&quot;
        username=&quot;${ftp.username}&quot; password=&quot;${ftp.password}&quot;
        port=&quot;2222&quot;
        client-mode=&quot;passive-local-data-connection-mode&quot;
        filename-pattern=&quot;.*?jpg&quot;
        local-working-directory=&quot;#{systemProperties[&#39;user.home&#39;]}/received_ftp_files&quot;
        &amp;gt;
    &amp;lt;int:poller fixed-rate=&quot;10000&quot;/&amp;gt;
&amp;lt;/ftp:inbound-channel-adapter&amp;gt;

&amp;lt;int:channel id=&quot;ftpIn&quot;/&amp;gt;

&amp;lt;int:service-activator input-channel=&quot;ftpIn&quot; ref=&quot;inboundFileProcessor&quot;/&amp;gt;
</code></pre><p>&lt;/beans&gt;</pre><br />You can see there are a lot of options! Most of them are just that -optional - but it&rsquo;s nice to know that they&rsquo;re there. This adapter will download files that match the <code>filename-pattern</code> specified and then deliver them as a <code>Message</code> with a <code>java.io.File</code> as a payload, just as before. This is why we are able to simply reuse the previous <code>inboundFileProcessor</code> bean. If you want additional control over what does and does not get downloaded, consider using the filename-pattern to specify a mask. Note that there&rsquo;s quite a bit of control surfaced here, including control over the connection mode and whether or not the source files should be deleted on delivery of the File.</p><p>The outbound adapter will look eerily similar to the outbound adapter we configured for the File support. When this is executed, it will the marshal the contents of the payload that&rsquo;s coming into it and then store those contents on the FTP server. Currently there is prebuilt support for marshaling a <code>String,</code> a <code>byte[],</code> and a <code>java.io.File</code> object.<br /><pre class="brush: xml;">&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?&gt;<br />&lt;beans &hellip; xmlns:ftp=&quot;<a href="http://www.springframework.org/schema/integration/ftp" &gt">http://www.springframework.org/schema/integration/ftp"&gt</a>;</p>
<pre><code class="prettyprint">&amp;lt;context:component-scan base-package=&quot;org.springframework.integration.examples.filetransfer.core&quot;/&amp;gt;
&amp;lt;context:property-placeholder location=&quot;file://${user.home}/Desktop/ftp.properties&quot; ignore-unresolvable=&quot;true&quot;/&amp;gt;

&amp;lt;int:channel id=&quot;outboundFiles&quot;/&amp;gt;

&amp;lt;ftp:outbound-channel-adapter
        remote-directory=&quot;${ftp.remotedir}&quot;
        channel=&quot;outboundFiles&quot;
        host=&quot;${ftp.host}&quot;
        username=&quot;${ftp.username}&quot; password=&quot;${ftp.password}&quot; port=&quot;2222&quot;
        client-mode=&quot;passive-local-data-connection-mode&quot;
        /&amp;gt;
</code></pre><p>&lt;/beans&gt;</pre><br />As with the outbound file adapter, we are producing content to be stored using our <code>OutboundFileProducer</code> class, so there&rsquo;s no need to review that. All that&rsquo;s left then is the configuration for the channel and the adapter itself which stipulates all the things you&rsquo;d expect to see stipulated: the server configuration and the remote directory into which the payload&rsquo;s deposited.</p><p>Moving on&hellip;.<br /><h2>SSH File Transfer Protocol (or, Secure File Transfer Protocol)</h2><br />Finally, we reach the SFTP adapter. This is arguably the most complicated of the 3 adapters to configure, but it&rsquo;s one of the easiest to test. SFTP usually works anywhere you have SSH access, though it is not strictly speaking limited to that. SFTP is not FTP over SSH, but a completely different protocol. It is generally more ubiquitous and consistent than SCP, specifying many things that SCP leaves up to interpretation. SFTP itself is a relatively spartan protocol because it makes a lot of assumptions about the connection over which it communicates: it assumes - among other things -<br />that the client user&rsquo;s identity is known, that it&rsquo;s being conducted over a secure channel and that authentication has occurred. It was designed by the same working group that designed SSH2, and works well as an SSH2 subsystem; it is conceivable that you could run SFTP on an SSH1 server. Because SFTP works on top of SSH which provides the authentication mechanism, it supports the same authentication options including user names, passwords, and / or and public keys (which themselves might optionally have a password). If you&rsquo;re running a relatively recent version of OpenSSH (which itself runs on AIX, HP-UX, Iris, Linux, Cygwin, Mac OSX, Solaris, SNI, Digital Unix/Tru64/OSF, NeXT (!), SCO, and more), then you likely already have this installed and can proceed. Put another way, it is easier to find a computer than could support some form of SFTP than a computer that could support a file system you could mount. See, I told you it&rsquo;d be easy to test!</p><p>To get started with an inbound adapter, simply copy and paste the FTP adapter, rename all occurrences of FTP to SFTP, change the relevant configuration values as appropriate (port, host&hellip;), drop the client-mode option, and then you&rsquo;re done! There are of course other options - lots of other options to let you qualify your authentication mechanism; a public key or username, for example. Here&rsquo;s a familiar example:<br /><pre class="brush:xml;">&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?&gt;<br />&lt;beans &hellip; xmlns:sftp=&quot;<a href="http://www.springframework.org/schema/integration/sftp" &gt">http://www.springframework.org/schema/integration/sftp"&gt</a>;</p>
<pre><code class="prettyprint">&amp;lt;context:component-scan base-package=&quot;org.springframework.integration.examples.filetransfer.core&quot;/&amp;gt;
&amp;lt;context:property-placeholder location=&quot;file://${user.home}/Desktop/sftp.properties&quot; ignore-unresolvable=&quot;true&quot;/&amp;gt;

&amp;lt;sftp:inbound-channel-adapter
        remote-directory=&quot;${sftp.remotedir}&quot;
        channel=&quot;sftpIn&quot;
        auto-create-directories=&quot;true&quot;
        host=&quot;${sftp.host}&quot;
        auto-delete-remote-files-on-sync=&quot;false&quot;
        username=&quot;${sftp.username}&quot;
        password=&quot;${sftp.password}&quot;
        filename-pattern=&quot;.*?jpg&quot;
        local-working-directory=&quot;#{systemProperties[&#39;user.home&#39;]}/received_sftp_files&quot;
        &amp;gt;
    &amp;lt;int:poller fixed-rate=&quot;10000&quot;/&amp;gt;
&amp;lt;/sftp:inbound-channel-adapter&amp;gt;

&amp;lt;int:channel id=&quot;sftpIn&quot;/&amp;gt;

&amp;lt;int:service-activator input-channel=&quot;sftpIn&quot; ref=&quot;inboundFileProcessor&quot;/&amp;gt;
</code></pre><p>&lt;/beans&gt;</pre><br />Pretty handy, eh? The rules are the same as the previous examples: your client code will be delivered a <code>java.io.File</code> instance which you can process anyway you see fit. The SFTP outbound adapter rounds out the set:<br /><pre class="brush:xml">&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?&gt;<br />&lt;beans xmlns:sftp=&quot;<a href="http://www.springframework.org/schema/integration/sftp" &gt">http://www.springframework.org/schema/integration/sftp"&gt</a>;</p>
<pre><code class="prettyprint">&amp;lt;context:component-scan base-package=&quot;org.springframework.integration.examples.filetransfer.core&quot;/&amp;gt;
&amp;lt;context:property-placeholder location=&quot;file://${user.home}/Desktop/sftp.properties&quot; ignore-unresolvable=&quot;true&quot;/&amp;gt;

&amp;lt;int:channel id=&quot;outboundFiles&quot;/&amp;gt;

&amp;lt;sftp:outbound-channel-adapter
        remote-directory=&quot;${sftp.remotedir}&quot;
        channel=&quot;outboundFiles&quot;
        host=&quot;${sftp.host}&quot;
        username=&quot;${sftp.username}&quot;
        password=&quot;${sftp.password}&quot;
/&amp;gt;
</code></pre><p>&lt;/beans&gt;</pre><br /><h2>Where to go from Here?</h2><br />It&rsquo;s useful to think about what kinds of problems are typically file-oriented, or <em>batch-oriented</em> in nature. Spring Integration does a fantastic job at notifying you of interesting events in your world (&ldquo;new file placed in folder!&rdquo;) and integrating data; Spring Integration is a great way to achieve an event driven architecture. A file with a million rows, however, is not an <em>event.</em> Spring Integration has no inbuilt facilities for processing large batch file payloads in the framework - that is a job for <a href="http://static.springsource.org/spring-batch/">Spring Batch.</a> So consider an approach that leverages Spring Integration to detect the availability of a file for the genesis of a job, and then kick off a Spring Batch job. There&rsquo;s no job too big for Spring Batch. Spring Batch can help you decompose your million-record file into event-sized records that Spring Integration is happier processing. I like to think of the two frameworks as interweaving dancers in a delicate ballet of event-driven, data crunching badassery!<br /><h2>Summary</h2><br />In this post we&rsquo;ve talked about the wide world of file transfer adapters in Spring Integration that make downright pleasant the chore of file-based integration using a straight file-system mount, FTP and SFTP.</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 351;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>
Back
</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">All Posts</a>
<a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">Engineering</a>
<a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">Releases</a>
<a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">News and Events</a>
<a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>Get updates from The Spring Team delivered to your inbox</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">Tools</a></li>
<li><a href="https://store.pivotal.io/">Store</a></li>
<li><a href="/blog">Newsletter</a></li>
</ul>
</div>
</div>
&copy; <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a>, Inc. All Rights Reserved.
<a href="https://pivotal.io/terms-of-use">Terms of Use</a> &bullet;
<a href="https://pivotal.io/privacy-policy">Privacy</a> &bullet;
<a href="/trademarks">Trademark Guidelines</a>
<div id="teconsent" style="display:inline-block;"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>