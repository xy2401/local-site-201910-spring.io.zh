<!DOCTYPE html>
<html data-code-prettify="" data-mobile-support="" data-search="">
<head>
<title>Simplified Spring Security with Grails</title>
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no" id="Viewport" name="viewport" />
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png" />
<link href="https://fonts.googleapis.com/css?family=Varela+Round|Montserrat:400,700" rel="stylesheet" type="text/css" />
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css" />
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M" name="google-site-verification" />

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css" />

<meta content="summary" name="twitter:card" />
<meta content="@springcentral" name="twitter:site" />
<meta name="twitter:title" content="Simplified Spring Security with Grails" />
<meta name="twitter:description" content="&lt;p&gt;Spring Security is a powerful library for securing your applications that comes with a bewildering number of options. Based on Spring, it can be readily integrated into a Grails application. But why not save the hassle and use the &lt;a href=&quot;http://grails.org/plugin/spring-security-core&quot;&gt;new improved Grails plugin&lt;/a&gt;?&lt;/p&gt;
&lt;p&gt;The plugin has gone through several evolutionary stages that started with the Acegi plugin. Its most recent incarnation is a complete rewrite for Spring Security 3 and Spring 3. One of the results of this is that the plugin will only work with Grails 1.2.2 and above. Another significant change is that there is no longer just one Spring Security plugin: some features have been broken out into optional plugins. So now you only include the features you need in your application.&lt;/p&gt;
" />

<meta property="og:title" content="Simplified Spring Security with Grails" />
<meta property="og:description" content="&lt;p&gt;Spring Security is a powerful library for securing your applications that comes with a bewildering number of options. Based on Spring, it can be readily integrated into a Grails application. But why not save the hassle and use the &lt;a href=&quot;http://grails.org/plugin/spring-security-core&quot;&gt;new improved Grails plugin&lt;/a&gt;?&lt;/p&gt;
&lt;p&gt;The plugin has gone through several evolutionary stages that started with the Acegi plugin. Its most recent incarnation is a complete rewrite for Spring Security 3 and Spring 3. One of the results of this is that the plugin will only work with Grails 1.2.2 and above. Another significant change is that there is no longer just one Spring Security plugin: some features have been broken out into optional plugins. So now you only include the features you need in your application.&lt;/p&gt;
" />
<meta content="article" property="og:type" />
<meta property="og:article:published_time" content="2010-08-11 11:17:00.0" />
</head>
<body>

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" style="display:none;visibility:hidden" width="0"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">Projects</a>
</li>
<li class="navbar-link">
<a href="/guides">Guides</a>
</li>
<li class="navbar-link active">
<a href="/blog">Blog</a>
</li>
<li class="navbar-link">
<a href="/services">Training & Certification</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form action="/search" class="form-inline form-search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search for documentation, guides, and posts..." type="text" value="" />
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form action="/search" class="form-inline form-search" method="get">
<button class="search-form--submit" type="submit"><i class="icon-search"></i></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="Search..." type="text" value="" />
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">
Home
 <i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">
Projects
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">
Guides
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">
Blog
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">
Training & Certification
<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>Engineering</div>
</div>
<div class="blog-category content--title">
<div>Releases</div>
</div>
<div class="blog-category content--title">
<div>News and Events</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">Simplified Spring Security with Grails</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">Engineering</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="null?s=20&amp;d=mm" />
<span class="author">Peter Ledbrook</span>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2010-08-11 11:17:00.0">August 11, 2010</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" data-disqus-identifier="348" href="/blog/2010/08/11/simplified-spring-security-with-grails#disqus_thread">
</a></div>
</div>
</header>
<div class="blog--post"><p>Spring Security is a powerful library for securing your applications that comes with a bewildering number of options. Based on Spring, it can be readily integrated into a Grails application. But why not save the hassle and use the <a href="http://grails.org/plugin/spring-security-core">new improved Grails plugin</a>?</p><p>The plugin has gone through several evolutionary stages that started with the Acegi plugin. Its most recent incarnation is a complete rewrite for Spring Security 3 and Spring 3. One of the results of this is that the plugin will only work with Grails 1.2.2 and above. Another significant change is that there is no longer just one Spring Security plugin: some features have been broken out into optional plugins. So now you only include the features you need in your application.</p><p>So what do the plugins give you? The core provides the basics necessary for access control in an easy-to-use package based on users and roles. In fact, many applications won&rsquo;t need any other plugin than the core one. For those who do need something extra, here is a list of the other plugins in the family:</p>
<ul>
<li><a href="http://grails.org/plugin/spring-security-openid">OpenID</a> - authentication using <a href="https://openid.net/">OpenID</a></li>
<li><a href="http://grails.org/plugin/spring-security-ldap">LDAP</a> - authentication against LDAP servers</li>
<li><a href="http://grails.org/plugin/spring-security-cas">CAS</a> - single sign-on using <a href="https://www.apereo.org/">CAS</a></li>
<li><a href="http://grails.org/plugin/spring-security-acl">ACLs</a> - access control via Spring Security's ACLs</li>
<li><a href="http://grails.org/plugin/spring-security-ui">UI</a> - user interface for user and role managment, plus other features</li>
</ul><p>In this article I&rsquo;ll show you how to secure a Grails application from scratch using the new core plugin.</p><p><b>Update</b> This article now has two companion screencasts:</p>
<table>
<tr>
<td>[caption id="attachment_5509" align="center" width="250" caption="Spring Security Plugin Introduction"]<a href="https://www.youtube.com/watch?v=auwML_bsUEE"><img src="http://blog.springsource.com/wp-content/uploads/2010/08/front-slides-for-spring-security-cast-1-thumbnail.png" alt="" title="Spring Security Plugin screencast 1" width="200" height="150" class="wp-image-5509" /></a>[/caption]</td>
<td>[caption id="attachment_5510" align="center" width="250" caption="Spring Security Plugin - AJAX"]<a href="https://www.youtube.com/watch?v=H_mGgZddXx8"><img src="http://blog.springsource.com/wp-content/uploads/2010/08/front-slides-for-spring-security-cast-2-thumbnail.png" alt="" title="Spring Security Plugin screencast 2" width="200" height="150" class="wp-image-5510" /></a>[/caption]</td>
</tr>
</table>
<h2>Setup</h2><p>As with most plugins, your first step will be to install the Spring Security plugin. Of course, you&rsquo;ll need a project to install it into and for this article I <a href="https://people.apache.org/~pledbrook/hubbub.zip">have provided</a> a simple Twitter-clone called Hubbub (based on the sample application from Grails in Action). You can also get the finished project from <a href="https://people.apache.org/~pledbrook/hubbub-finished.zip">here</a>.</p><p>So, from within your project, run:<br /><pre><br /> grails install-plugin spring-security-core<br /></pre></p><p>If you look at the output generated by the plugin installation, you will see that it provides a couple of commands. The most important of these is <tt>s2-quickstart</tt>, which will help you get up and running with the minimum of fuss. It generates both the basic domain classes you need to store user information and the controllers that handle authentication.</p><p>Before you run the command, you may need to make a decision. If you already have a &lsquo;user&rsquo; domain class, you will have to decide how to integrate it with the one generated by the plugin. One option is to replace the existing domain class and simply apply your customisations to the replacement. The other approach consists of making your own domain class extend the plugin&rsquo;s one.</p><p>Which is better? I prefer the latter because it allows you to easily update the generated user domain class if its template ever changes. It also means you don&rsquo;t overly pollute your domain model with Spring Security specifics. On the downside, you have to deal with domain class inheritance, although the cost is pretty minimal.</p><p>For Hubbub, we&rsquo;ll make the user domain class extend the generated one, which means we should use domain class names that don&rsquo;t conflict with the existing ones:<br /><pre><br /> grails s2-quickstart org.example SecUser SecRole<br /></pre></p><p>This will create three domain classes for us:<br /><ul><br /><li><tt>org.example.SecUser</tt></li><br /><li><tt>org.example.SecRole</tt></li><br /><li><tt>org.example.SecUserSecRole</tt> - links users to roles</li><br /></ul><br />and two controllers:<br /><ul><br /><li><tt>LoginController</tt></li><br /><li><tt>LogoutController</tt></li><br /></ul><br />plus their associated views. In just two commands, we have everything we need to start securing our application!</p><p>The sample application does need one more change: its URL mappings mean that the login and logout controllers can&rsquo;t be reached. That&rsquo;s simple enough to fix by adding the following two lines to <tt>UrlMappings.groovy</tt>:</p>
<pre><code class="prettyprint groovy">&quot;/login/$action?&quot;(controller: &quot;login&quot;)
&quot;/logout/$action?&quot;(controller: &quot;logout&quot;)
</code></pre><p>If you don&rsquo;t make the change, the login page will generate a 404 error! Now let&rsquo;s get down to the business of protecting the application.</p>
<h2>Adding access control</h2><p>The whole point of this exercise is to limit access to certain parts of the application. For web applications this most commonly means protecting particular pages, or more specifically URLs. In the case of Hubbub, we have the following requirements:</p>
<ul>
<li>The home page is accessible to everyone - <tt>/</tt></li>
<li>Only known users can see the posts for a particular user - <tt>/person/&lt;username></tt></li>
<li>Only users with a 'user' role should be able to access their own timeline - <tt>/timeline</tt></li>
<li>Same goes for following another user - <tt>/post/followAjax</tt></li>
<li>Only fully authenticated users with the 'user' role should be able to post a new message - <tt>/post/addPostAjax</tt></li>
</ul><p>With the Spring Security plugin this is trivial to achieve, although you do have to make a decision on which of three mechanisms to use. You can take a controller-centric approach and annotate the actions; work with static URL rules in <tt>Config.groovy</tt>; or define runtime rules in the database using request maps.</p>
<h3>Annotations</h3><p>For a controller-centric approach, you can&rsquo;t beat the <tt>@Secured</tt> annotation provided by the plugin. In it&rsquo;s simplest incarnation, you pass it a list of basic rules that define who can access the corresponding action. Here, I apply Hubbub&rsquo;s access control rules via annotations on the post controller:</p>
<pre><code class="prettyprint groovy">package org.example

import grails.plugins.springsecurity.Secured

class PostController {
    ...
    @Secured([&#39;ROLE_USER&#39;])
    def followAjax = { ... }

    @Secured([&#39;ROLE_USER&#39;, &#39;IS_AUTHENTICATED_FULLY&#39;])
    def addPostAjax = { ... }

    def global = { ... }

    @Secured([&#39;ROLE_USER&#39;])
    def timeline = { ... }

    @Secured([&#39;IS_AUTHENTICATED_REMEMBERED&#39;])
    def personal = { ... }
}
</code></pre><p>The <tt>IS_AUTHENTICATED_*</tt> rules are built into Spring Security, but <tt>ROLE_USER</tt> is a role that must exist in the database - something we have yet to do. Also, if you specify more than one rule in the list, then the current user normally only has to satisfy one of them - as is explained in the user guide. <tt>IS_AUTHENTICATED_FULLY</tt> is a special case: if specified, it must be satisfied <em>in addition</em> to the other rules in the list.</p><p>The built-in rules are as follows:<br /><ul><br /><li>IS_AUTHENTICATED_ANONYMOUSLY - anyone has access; no need for the user to log in</li><br /><li>IS_AUTHENTICATED_REMEMBERED - only known users that have logged in or are remembered from a previous session are allowed access</li><br /><li>IS_AUTHENTICATED_FULLY - users must log in to gain access, even if they checked &ldquo;remember me&rdquo; last time</li><br /></ul><br />The first two of these distinguish between known and unknown users, where known users are ones that have an entry in the &lsquo;user&rsquo; database table. The last is typically applied in cases where the user is accessing particularly sensitive information, such as bank account or credit card data. After all, someone else could be accessing your application using the &ldquo;remember me&rdquo; cookie from the previous user.</p><p>You can also apply the annotation to the controller class itself, which results in all actions inheriting the rules defined by it. If an action has its own annotation, that overrides the class-level one. The annotation isn&rsquo;t just limited to a list of rules like this either: take a look at the <a href="https://burtbeckwith.github.com/grails-spring-security-core/docs/manual/guide/5%20Configuring%20Request%20Mappings%20to%20Secure%20URLs.html#5.4 Using Expressions to Create Descriptive, Fine-Grained Rules">user guide</a> to see how to use expressions to provide greater control over the rules.</p>
<h3>Static URL rules</h3><p>If annotations aren&rsquo;t your thing, you can define access control rules via a static map in <tt>Config.groovy</tt>. If you like to keep your rules in one place, it&rsquo;s ideal. Here is how you would define Hubbub&rsquo;s rules using this mechanism:</p>
<pre><code class="prettyprint groovy">import grails.plugins.springsecurity.SecurityConfigType
...
grails.plugins.springsecurity.securityConfigType = SecurityConfigType.InterceptUrlMap
grails.plugins.springsecurity.interceptUrlMap = [
    &#39;/timeline&#39;:         [&#39;ROLE_USER&#39;],
    &#39;/person/*&#39;:         [&#39;IS_AUTHENTICATED_REMEMBERED&#39;],
    &#39;/post/followAjax&#39;:  [&#39;ROLE_USER&#39;],
    &#39;/post/addPostAjax&#39;: [&#39;ROLE_USER&#39;, &#39;IS_AUTHENTICATED_FULLY&#39;],
    &#39;/**&#39;:               [&#39;IS_AUTHENTICATED_ANONYMOUSLY&#39;]
]
</code></pre><p>Notice how the most general rule comes last? That&rsquo;s because order is important: Spring Security iterates through the rules and applies the <em>first one that matches the current URL</em>. So if the &lsquo;/**&rsquo; rule came first, your application would effectively be unprotected since all URLs would be matched to it. Also notice that you have to explicitly tell the plugin to use the map via the <tt>grails.plugins.springsecurity.securityConfigType</tt> settings.</p>
<h3>Dynamic request maps</h3><p>Do you want to update URL rules at runtime without restarting the application? If that&rsquo;s the case, you&rsquo;ll probably want to use request maps, which are basically URL rules stored in the database. To enable this mechanism, add the following to <tt>Config.groovy</tt>:</p>
<pre><code class="prettyprint groovy">import grails.plugins.springsecurity.SecurityConfigType
...
grails.plugins.springsecurity.securityConfigType = SecurityConfigType.Requestmap
</code></pre><p>All you then have to do is create instances of the <tt>Requestmap</tt> domain class, for example in <tt>BootStrap.groovy</tt>:</p>
<pre><code class="prettyprint groovy">new Requestmap(url: &#39;/timeline&#39;, configAttribute: &#39;ROLE_USER&#39;).save()
new Requestmap(url: &#39;/person/*&#39;, configAttribute: &#39;IS_AUTHENTICATED_REMEMBERED&#39;).save()
new Requestmap(url: &#39;/post/followAjax&#39;, configAttribute: &#39;ROLE_USER&#39;).save()
new Requestmap(url: &#39;/post/addPostAjax&#39;, configAttribute: &#39;ROLE_USER,IS_AUTHENTICATED_FULLY&#39;).save()
new Requestmap(url: &#39;/**&#39;, configAttribute: &#39;IS_AUTHENTICATED_ANONYMOUSLY&#39;).save()
</code></pre><p>Of course, there is a performance cost to this approach since it involves the database, but it is minimised through the use of caching. Take a look at the <a href="https://burtbeckwith.github.com/grails-spring-security-core/docs/manual/guide/5%20Configuring%20Request%20Mappings%20to%20Secure%20URLs.html#5.3 Requestmap Instances Stored in the Database">user guide</a> for more information on this. Also, you don&rsquo;t have to worry about the order of the rules in this case because the plugin picks the most specific URL pattern that matches the current URL.</p><p>Which of these approaches should you use? It depends on how your application is set up and how you think about access control. Annotations make sense where rules apply on a per-controller basis and controllers have distinct URLs. If you tend to group controllers under a single URL, like <tt>/admin/</tt> or you simply like to keep all your rules in one place, then you&rsquo;re probably better off with the static rules defined in <tt>Config.groovy</tt>. The third mechanism, request maps, only make sense if you want to add, change, or remove rules at runtime. A classic example where you might want to do this is in a CMS application, where URLs themselves are defined dynamically.</p><p>Whichever approach you take, once the rules are implemented your application <em>is</em> protected. For example, if you try to access the <tt>/timeline</tt> page in Hubbub at this point, you will be redirected to the standard login page:</p><p><a href="http://blog.springsource.com/wp-content/uploads/2010/08/spring-security-login-page.png"><img src="http://blog.springsource.com/wp-content/uploads/2010/08/spring-security-login-page.png" alt="" title="spring-security-login-page" width="786" height="491" class="aligncenter size-full wp-image-5396" /></a></p><p>Great! But who are you going to log in as? How are users going to log out? Protecting your pages is only the first step. You also need to make sure that you have the relevant security data (users and roles) and a user interface that&rsquo;s security aware.</p>
<h2>Next steps</h2><p>With the access control in place, you need to look at the user experience. Do you really want users clicking on links that they don&rsquo;t have access to? What about those roles you are using in the access control? When do they get created? Let&rsquo;s answer those questions now.</p>
<h3>Security data</h3><p>Some applications only care whether a user is known or not and in such cases you don&rsquo;t need to worry about roles because the <tt>IS_AUTHENTICATED_*</tt> rules are sufficient. But if your application needs more control over who has access to what, you will need roles. These are typically defined early in the life of the application and correspond to unchanging reference data. That makes <tt>BootStrap</tt> the ideal place to create them. For Hubbub, we add &lsquo;user&rsquo; and &lsquo;admin&rsquo; roles like so:</p>
<pre><code class="prettyprint groovy">import org.example.SecRole

class BootStrap {
    def init = {
        ...
        def userRole = SecRole.findByAuthority(&#39;ROLE_USER&#39;) ?: new SecRole(authority: &#39;ROLE_USER&#39;).save(failOnError: true)
        def adminRole = SecRole.findByAuthority(&#39;ROLE_ADMIN&#39;) ?: new SecRole(authority: &#39;ROLE_ADMIN&#39;).save(failOnError: true)
        ...
    }
}
</code></pre><p>Of course, if the data already exists we don&rsquo;t want to recreate it, hence why we use <tt>findByAuthority()</tt>.</p><p>Adding users is almost as straightforward, but there are a couple of requirements that you need to bear in mind. First, the generated &lsquo;user&rsquo; domain class has an <tt>enabled</tt> property that is <tt>false</tt> by default. If you don&rsquo;t explicitly initialise it to <tt>true</tt> the corresponding user won&rsquo;t be able to log in. Second, passwords are rarely stored in the database as plain text, so you will need to encode them first using an appropriate digest algorithm.</p><p>Fortunately, the plugin provides a useful service to help here: <tt>SpringSecurityService</tt>. Let&rsquo;s say we want to create an &lsquo;admin&rsquo; user in Hubbub&rsquo;s <tt>BootStrap</tt>. The code would look something like this:</p>
<pre><code class="prettyprint groovy">import org.example.*

class BootStrap {
    def springSecurityService

    def init = {
        ...
        def adminUser = SecUser.findByUsername(&#39;admin&#39;) ?: new SecUser(
                username: &#39;admin&#39;,
                password: springSecurityService.encodePassword(&#39;admin&#39;),
                enabled: true).save(failOnError: true)

        if (!adminUser.authorities.contains(adminRole)) {
            SecUserSecRole.create adminUser, adminRole
        }
        ...
    }
}
</code></pre><p>We simply inject the security service into <tt>BootStrap</tt> and then use its <tt>encodePassword()</tt> method to convert the plain text password to its hash. This approach works particularly well when you decide to change the digest algorithm you use, because the service will encode passwords using the same algorithm as the one used when comparing them for authentication. In other words, the above code stays the same no matter what algorithm is used.</p><p><ins datetime="2011-08-17T09:06:35+00:00"><b>Update</b> As of version 1.2 of the Spring Security Core plugin, the generated <tt>User</tt> class automatically encodes the password when an instance is saved. Hence you no longer need to explicitly use <tt>SpringSecurityService.encodePassword()</tt></ins></p><p>Once the user is created, we check whether it has the &lsquo;admin&rsquo; role and if it doesn&rsquo;t, we assign the role to the user. We do this by way of the generated <tt>SecUserSecRole</tt> class and its <tt>create()</tt> method.</p><p>With the security data in place, and the knowledge of how to create it on demand where necessary, it&rsquo;s time to make the user interface aware of authentication, users, and roles.</p>
<h3>The user interface</h3><p>There are two aspects of the UI I want to look at here: displaying information specific to the user and making sure that the user can only see what he&rsquo;s allowed to. The first of these boils down to one question: how do we get the &lsquo;user&rsquo; domain instance for the currently logged in user? Consider Hubbub&rsquo;s timeline page, which displays all the posts of the people that the current user is following:</p>
<pre><code class="prettyprint groovy">class PostController {
    def springSecurityService
    ...
    @Secured([&#39;ROLE_USER&#39;])
    def timeline = {
        def user = SecUser.get(springSecurityService.principal.id)

        def posts = []
        if (user.following) {
            posts = Post.withCriteria {
                &#39;in&#39;(&quot;user&quot;, user.following)
                order(&quot;createdOn&quot;, &quot;desc&quot;)
            }
        }
        [ posts: posts, postCount: posts.size() ]
    }
    ...
}
</code></pre><p>As you can see, all we need to do is inject the security service again and use it to get hold of the principal. Unless you have created a custom version of the <tt>UserDetailsService</tt> (don&rsquo;t worry if you haven&rsquo;t come across this before), the principal will be an instance of <tt> org.codehaus.groovy.grails.plugins.springsecurity.GrailsUser</tt> whose <tt>id</tt> property contains the ID of the corresponding &lsquo;user&rsquo; domain instance.</p><p>One thing you need to be aware of: if the current user is authenticated anonymously, i.e. he hasn&rsquo;t logged in and isn&rsquo;t remembered, the <tt>principal</tt> property will return a string instead. So if an action can be accessed by an unauthenticated user, make sure you check the type of the principal before using it!</p><p>What about ensuring users can only see what they are supposed to? For that, the plugin provides a rich set of GSP tags in the <tt>sec</tt> namespace. Let&rsquo;s say we want to add a couple of navigation links to Hubbub, but we only want to display one of them when the user isn&rsquo;t logged in and the other only if the user has the <tt>ROLE_USER</tt> role:</p>
<pre><code class="prettyprint html">&lt;sec:ifNotLoggedIn&gt;
  &lt;g:link controller=&quot;login&quot; action=&quot;auth&quot;&gt;Login&lt;/g:link&gt;
&lt;/sec:ifNotLoggedIn&gt;
&lt;sec:ifAllGranted roles=&quot;ROLE_USER&quot;&gt;
  &lt;g:link class=&quot;create&quot; controller=&quot;post&quot; action=&quot;timeline&quot;&gt;My Timeline&lt;/g:link&gt;
&lt;/sec:ifAllGranted&gt;
</code></pre><p>The markup inside the <tt>&lt;sec:if*&gt;</tt> tags will only be rendered to the page if the condition is satisfied. The plugin provides several other similar tags that all behave in a consistent fashion. See the <a href="https://burtbeckwith.github.com/grails-spring-security-core/docs/manual/guide/6%20Helper%20Classes.html#6.1 SecurityTagLib">user guide</a> for more information.</p><p>The above example also shows you how to create a link to the login page. Allowing the user to log out is similarly straightforward. Hubbub provides a side panel that displays amongst other things the name of the logged in user and a link to sign out:</p>
<pre><code class="prettyprint html">&lt;sec:username /&gt; (&lt;g:link controller=&quot;logout&quot;&gt;sign out&lt;/g:link&gt;)
</code></pre><p>Easy! The combination of these tags and the security service should be more than sufficient to integrate your user interface with Spring Security. Just remember to keep your user interface elements in sync with your access control rules: you don&rsquo;t want bits of UI visible that result in an &ldquo;unauthorised user&rdquo; error.</p><p>I&rsquo;ve now covered all the basic elements of the Spring Security plugin, but there are still two features that will affect a large number of users: AJAX requests and custom login forms.</p>
<h2>The last pieces of the puzzle</h2><p>How many web applications <em>don&rsquo;t</em> use AJAX to some degree now? And how many really want to use the stock login form for their application? It&rsquo;s fine for internal use, but I wouldn&rsquo;t recommend it for anything that&rsquo;s customer facing. Let&rsquo;s start with AJAX.</p>
<h3>Securing AJAX requests</h3><p>Dynamic user interfaces based on AJAX bring a new set of problems to access control. It&rsquo;s very easy to deal with a standard request that requires authentication: simply redirect the user to the login page and then redirect them back to the target page if the authentication is successful. But such a redirect doesn&rsquo;t work well with AJAX. So what do you do?</p><p>The plugin gives you a way to deal with AJAX request differently to normal ones. When an AJAX request requires authentication, Spring Security redirects to the <tt>authAjax</tt> action in <tt>LoginController</tt> rather than <tt>auth</tt>. But wait, that&rsquo;s still a redirect right? Yes, but you can implement the <tt>authAjax</tt> to send an error status or render JSON - basically anything that the client Javascript code can handle.</p><p>Unfortunately, the <tt>LoginController</tt> provided by the plugin doesn&rsquo;t implement <tt>authAjax</tt> at this time, so you will have to do add it yourself:</p>
<pre><code class="prettyprint groovy">import javax.servlet.http.HttpServletResponse

class LoginController {
    ...
    def authAjax = {
        response.sendError HttpServletResponse.SC_UNAUTHORIZED
    }
    ...
}
</code></pre><p>This is a very simple implementation that returns a 401 HTTP status code. How do we deal with such a response? That depends on what you use to implement AJAX in the browser. The example Hubbub application uses adaptive AJAX tags, so I&rsquo;ll use that to demonstrate the kind of thing you can do. This is part of the GSP template that is used for posting new messages:</p>
<pre><code class="prettyprint html">&lt;g:form action=&quot;ajaxAdd&quot;&gt;
    &lt;g:textArea id=&#39;postContent&#39; name=&quot;content&quot; rows=&quot;3&quot; cols=&quot;50&quot; onkeydown=&quot;updateCounter()&quot; /&gt;&lt;br/&gt;
    &lt;g:submitToRemote value=&quot;Post&quot;
                 url=&quot;[controller: &#39;post&#39;, action: &#39;addPostAjax&#39;]&quot;
                 update=&quot;[success: &#39;firstPost&#39;]&quot;
                 onSuccess=&quot;clearPost(e)&quot;
                 onLoading=&quot;showSpinner(true)&quot;
                 onComplete=&quot;showSpinner(false)&quot;
                 on401=&quot;showLogin();&quot;/&gt;
&lt;/g:form&gt;
</code></pre><p>As you can see, it has an <tt>on401</tt> attribute that specifies a bit of Javascript that should be executed when the AJAX submission returns a 401 status code. That bit of Javascript can, for example, display a dynamic, client-side login form for the user to authenticate with. Hubbub uses the client-side code provided in the plugin&rsquo;s <a href="https://burtbeckwith.github.com/grails-spring-security-core/docs/manual/guide/9%20Authentication.html#9.4 Ajax Authentication">user guide</a> to do just that.</p><p><b>Note</b> Version 1.1 of the plugin will come with a default implementation of the <tt>authAjax</tt> action.</p><p>You can also customise the <tt>ajaxSuccess</tt> and <tt>ajaxDenied</tt> actions to send back whatever response you want. As you can see, the server-side AJAX handling is simple and easy to customise. The real work has to be done in the client code.</p>
<h3>Custom login forms</h3><p>It&rsquo;s no longer fashionable to dedicate an entire page to the login form. These days applications are more likely to have a content-rich home page with a discrete login form located somewhere on it, perhaps only made visible by some Javascript magic. It&rsquo;s easy enough to provide your own dedicated login page (simply edit the <tt>auth</tt> action in <tt>LoginController</tt> and its associated GSP view to your heart&rsquo;s content), but what about a login panel?</p><p>It&rsquo;s not as hard as you might think. First of all, you need to decide where users should be redirected to when authentication is required. As you&rsquo;ve probably gathered, this is <tt>/login/auth</tt> by default. Changing that default is as easy as adding a setting to <tt>Config.groovy</tt>:</p>
<pre><code class="prettyprint groovy">grails.plugins.springsecurity.auth.loginFormUrl = &#39;/&#39;
</code></pre><p>This line tells the plugin to redirect to the home page whenever authentication is required. All you then need to do is add a login panel to the home page. Here&rsquo;s an example GSP form that might go in such a panel:</p>
<pre><code class="prettyprint html">&lt;form method=&quot;POST&quot; action=&quot;${resource(file: &#39;j_spring_security_check&#39;)}&quot;&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;td&gt;Username:&lt;/td&gt;&lt;td&gt;&lt;g:textField name=&quot;j_username&quot;/&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Password:&lt;/td&gt;&lt;td&gt;&lt;input name=&quot;j_password&quot; type=&quot;password&quot;/&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td colspan=&quot;2&quot;&gt;&lt;g:submitButton name=&quot;login&quot; value=&quot;Login&quot;/&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td colspan=&quot;2&quot;&gt;try &quot;glen&quot; or &quot;peter&quot; with &quot;password&quot;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;				
&lt;/form&gt;
</code></pre><p>The key points here are:<br /><ol><br /><li>the form must use the POST method;</li><br /><li>the form must be submitted to &lt;context&gt;/j_spring_security_check;</li><br /><li>the username field must have the name &lsquo;j_username&rsquo;;</li><br /><li>the password field must have the name &lsquo;j_password&rsquo;; and</li><br /><li>any &ldquo;remember me&rdquo; field must have the name &rsquo;_spring_security_remember_me&rsquo;.</li><br /></ol><br />As long as these requirements are satisfied, the login form will work perfectly. Well, not quite perfectly. If an authentication attempt fails via your login form, you will find yourself redirected back to the old login page. Fortunately, this is quickly rectified by adding another configuration setting:</p>
<pre><code class="prettyprint groovy">grails.plugins.springsecurity.failureHandler.defaultFailureUrl = &#39;/&#39;
</code></pre><p>And that&rsquo;s all you need for a fully functioning login form! There are plenty of other options available to fine tune the behaviour, but you now have the basics on which to build.</p><p>This article has really only scratched the surface of the Spring Security plugin. I haven&rsquo;t mentioned HTTP Basic and Digest Authentication, events, salted passwords and more. That doesn&rsquo;t even include the other plugins that provide extra features such as alternative authentication mechanisms and access control lists (ACLs). But what you have read so far will enable you to get a fully working access control system up and running in no time. You will then be able to extend and customise as the need arises, knowing that Spring Security has more features than you will probably ever need.</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 348;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">comments powered by <span class="logo-disqus">Disqus</span></a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>
Back
</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">All Posts</a>
<a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">Engineering</a>
<a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">Releases</a>
<a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">News and Events</a>
<a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>Get updates from The Spring Team delivered to your inbox</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">Team</a></li>
<li><a href="/tools">Tools</a></li>
<li><a href="https://store.pivotal.io/">Store</a></li>
<li><a href="/blog">Newsletter</a></li>
</ul>
</div>
</div>
&copy; <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a>, Inc. All Rights Reserved.
<a href="https://pivotal.io/terms-of-use">Terms of Use</a> &bullet;
<a href="https://pivotal.io/privacy-policy">Privacy</a> &bullet;
<a href="/trademarks">Trademark Guidelines</a>
<div id="teconsent" style="display:inline-block;"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>