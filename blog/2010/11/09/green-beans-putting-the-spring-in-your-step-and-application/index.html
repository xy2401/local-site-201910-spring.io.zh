<html  data-code-prettify="" data-mobile-support="" data-search=""><head>
<title>绿豆：让春天步入正轨（和应用程序）</title>
<meta id="Viewport" name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, minimum-scale=1, user-scalable=no">
<link rel="shortcut icon" type="image/x-icon" href="/img/favicon-ca31b78daf0dd9a106bbf3c6d87d4ec7.png">
<link href="asset?aid=0" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/main-bc256dba5f9d253d6425441ccfb82576.css">
<script src="/jspm_packages/system-eccc019329febb5a1b06bde008ca5614.js"></script>
<script>
    System.config({baseURL: "/b92013b"});
  </script>
<script src="/config-5a675c9cddea3a5f55b71416e67d47d6.js"></script>
<script>
      System.import('app/main.js')
  </script>
<meta name="google-site-verification" content="7qGntFPD9lWAVCtUu5U77v4l68PsTHf6xpzgjQv2j2M">

<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-KZM7GF6');</script>

<link href="/css/blog-92993c3ec6808bded45b277c18d7d621.css" rel="stylesheet" type="text/css">

<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@springcentral">
<meta name="twitter:title" content="Green Beans: Putting the Spring in Your Step (and Application)">
<meta name="twitter:description" content="<p>The Spring framework emerged as a de-facto standard in 2003 and has been helping people build bigger, better applications with cleaner code ever since. In this post, we will discuss the options available to you for configuring an application using the Spring component model. We will grow a simple application from the simplest form and rework it to take advantage of some of the many simplifying features in the Spring framework that have made it, and continue to make it, the de-facto standard for applications today.</p>
">
<meta name="twitter:creator" content="@starbuxman">
<meta name="twitter:image:src" content="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=200">

<meta property="og:title" content="Green Beans: Putting the Spring in Your Step (and Application)">
<meta property="og:image" content="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=200">
<meta property="og:description" content="<p>The Spring framework emerged as a de-facto standard in 2003 and has been helping people build bigger, better applications with cleaner code ever since. In this post, we will discuss the options available to you for configuring an application using the Spring component model. We will grow a simple application from the simplest form and rework it to take advantage of some of the many simplifying features in the Spring framework that have made it, and continue to make it, the de-facto standard for applications today.</p>
">
<meta content="article" property="og:type">
<meta property="og:article:published_time" content="2010-11-09 21:31:00.0">
</head>
<body >

<noscript><iframe height="0" src="https://www.googletagmanager.com/ns.html?id=GTM-KZM7GF6" width="0" style="display:none"></iframe></noscript>

<script type="text/javascript">
    // Work around Google font rendering issues in webkit browsers on Windows 7
    if (navigator.userAgent.indexOf("NT 6.1") != -1) {
      document.body.style.WebkitTextStroke = "0.5px";
    }
  </script>
<div class="viewport">
<header class="navbar header--navbar desktop-only">
<div class="navbar-inner">
<div class="container-fluid">
<div class="spring-logo--container">
<a class="spring-logo" href="/"><span></span></a>
</div>
<ul class="nav pull-right">
<li class="navbar-link">
<a href="/projects">专案</a>
</li>
<li class="navbar-link">
<a href="/guides">导游</a>
</li>
<li class="navbar-link active">
<a href="/blog">博客</a>
</li>
<li class="navbar-link">
<a href="/services">培训与认证</a>
</li>
<li class="navbar-link nav-search js-nav-search">
<a>
<i class="icon-search navbar-search--icon js-search-input-open"></i>
<span class="search-input-close js-search-input-close">
<i class="icon-remove"></i>
</span>
</a>
</li>
</ul>
</div>
</div>
<div class="search-dropdown--container js-search-dropdown">
<div class="container-fluid">
<div class="search-form--container">
<form class="form-inline form-search" action="/search" method="get">
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索文档，指南和帖子..." type="text" value="">
<button class="search-form--submit" type="submit"></button>
</form>
</div>
</div>
</div>
</header>
<div>
<div class="mobile-navigation--wrapper mobile-only">
<div class="navigation-drawer--container">
<div class="mobile-search--container">
<form class="form-inline form-search" action="/search" method="get">
<button class="search-form--submit" type="submit"></button>
<input class="search-query search-form--form js-search-input" name="q" placeholder="搜索..." type="text" value="">
</form>
</div>
<div class="navigation-item-list">
<div class="navbar-link">
<a href="/">家<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/projects">专案<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/guides">导游<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link active">
<a href="/blog">博客<i class="icon-chevron-right pull-right"></i>
</a>
</div>
<div class="navbar-link">
<a href="/services">培训与认证<i class="icon-chevron-right pull-right"></i>
</a>
</div>
</div>
</div>
<div class="mobile-nav">
<div class="nav-icon js-open-nav-drawer">
<i class="icon-reorder"></i>
</div>
<div class="header-center-icon">
<a href="/">
<div class="icon icon-spring-logo-mobile"></div>
</a>
</div>
</div>
</div>
</div>
<div class="header--container"></div>
<div class="container-fluid"></div>
<div></div>
<div class="container-fluid">
<div class="main-body--wrapper">
<div class="row-fluid blog--wrapper">
<article class="span8 mobile-left-pane" id="content">
<header class="desktop-only">
<div class="blog-category active content--title">
<div>工程</div>
</div>
<div class="blog-category content--title">
<div>发布</div>
</div>
<div class="blog-category content--title">
<div>新闻与活动</div>
</div>
</header>
<div class="blog--container">
<header>
<h1 class="blog--title">绿豆：让春天步入正轨（和应用程序）</h1>
<div class="meta-data--container">
<div class="meta-data--item desktop-only">
<div class="meta-data--icon icon blog-icon engineering"></div>
<a class="category">工程</a>
</div>
<div class="meta-data--item">
<img class="meta-data--icon" src="https://gravatar.com/avatar/fb22593caf24e4bb4c98d467cdd247e6?s=20&d=mm"> <a class="author" rel="author" href="/team/jlong">乔什·朗（Josh Long）</a>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon calendar"></div>
<time class="date" pubdate="" datetime="2010-11-09 21:31:00.0">2010年11月9日</time>
</div>
<div class="meta-data--item">
<div class="meta-data--icon icon blog-icon comments"></div>
<a class="comments" href="/blog/2010/11/09/green-beans-putting-the-spring-in-your-step-and-application#disqus_thread" data-disqus-identifier="373">
</a></div>
</div>
</header>
<div class="blog--post"><p>Spring框架于2003年成为事实上的标准，从那时起，它一直在帮助人们使用更干净的代码构建更大，更好的应用程序。在本文中，我们将讨论可用于使用Spring组件模型配置应用程序的选项。我们将以最简单的形式生成一个简单的应用程序，并对其进行重新处理，以利用Spring框架中许多简化的功能所带来的优势，并将继续使其成为当今应用程序的实际标准。</p><p>现代的企业Java应用程序具有许多协作对象，这些对象可以协同工作以进一步实现目标，通常具有内在的商业价值。即使在简单的情况下，该对象图也很深。以服务的简单情况为例（也许是一项支持处理客户数据的服务？）想要与数据库对话。这样的服务需要一个数据源，并可能需要某种便利库，以方便通过JDBC，JPA，JDO，NoSQL选项等进行数据库访问。在这样的图中，试图根据需要简单地创建对象是很诱人的，在其使用地点。在这样的系统中，对象构造或获取的知识遍布使用它们的bean中。如果-与数据库一样<code>javax.sql.DataSource</code> -在多个地方都需要该对象，那么将所有对象都放置在一个地方然后共享新创建的实例就更干净了。这具有将易于出错和易失性的配置信息保存在易于更改的位置的优势（例如，在开发和生产环境中更改数据库凭据时）。</p><p>这是人们使用Spring的主要原因之一-因为Spring使人们能够集中描述这些协作对象。从Spring的最早版本开始，就有一个XML文件用于描述对象图。在早期（大约在2003年），此文件使用DTD，但今天使用XML模式。这是我们以Spring的XML格式描述的示例服务。随着我们的进行，我们将删除越来越多的XML配置。每<code>bean</code>元素描述了将要创建的对象，并为其指定了<code>id</code> 。每<code>property</code>元素描述了对象的setter方法以及应提供的值。Spring应用程序容器会为您调用这些设置器。</p>
<pre><code class="prettyprint xml"><br />&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot; id=&quot;ds&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;org.h2.Driver&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:h2:~/cs&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;sa&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot; id=&quot;jdbcTemplate&quot;&gt;
      &lt;constructor-arg ref=&quot;ds&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean class=&quot;org.springframework.samples.DatabaseCustomerService&quot; id=&quot;databaseCustomerService&quot;&gt;
        &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean class=&quot;org.springframework.samples.CustomerClient&quot; id=&quot;client&quot;&gt;
        &lt;property name=&quot;customerService&quot; ref=&quot;databaseCustomerService&quot;/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre><p>简单吧？令人高兴的是，我们可以针对没有特定实现知识的接口编写代码。在上面的示例中，我们实例化了一个<code>DriverManagerDataSource</code>并将其传递给<code>JdbcTemplate</code>通过使用<code>ref</code>属性。 <code>ref</code>告诉Spring框架您想将引用传递给在同一容器中配置的另一个bean。同样，在我们的示例中，我们传递了对<code>CustomerClient</code>实例，但在消耗性Java代码中，我们针对<code>CustomerService</code>接口，而不是特定类型<code>DatabaseCustomerService</code> 。</p><p>这种简单的设置为我们提供了很多间接性和灵活性。现在，对象的创建和构造已移至Spring配置，我们可以在Spring配置中隐藏真正复杂的设置，而使我们的代码更明智。隐藏复杂构造逻辑的一种常见方法是通过工厂模式。如果要构造许多需要一起使用的对象，或者要在创建对象时考虑很多不同的因素，则工厂模式特别有用。本质上，您正在做的事情是提供一种比任何一个类的构造函数自然都更强大的描述对象创建的方法。Spring明确支持此模式。如果配置的Bean实现了<code>org.springframework.beans.factory.FactoryBean
<t></t></code>界面<code>getObject()</code>接口上的方法将被调用，结果将是Spring上下文中可用的对象。Spring框架本身广泛使用了这种做法，以提供方便的方法来以可重用的方式构造复杂的对象图。</p><p>在我们的示例中，我们使用一个称为H2的嵌入式数据库，它是一个功能强大的内存Java数据库。通常，嵌入式数据库用于开发环境中。一种常见的做法是在开发中使用嵌入式数据库来快速测试和重置数据集。通常，这还需要从SQL脚本加载数据以引导嵌入式数据库。Spring框架提供了显式支持，用于配置嵌入式数据源，然后根据脚本评估脚本。 <code>javax.sql.DataSource</code> 。</p>
<div style="border:1px solid black;padding:10px"><strong>Spring 3.1中的特定于环境的Bean-在Spring</strong>框架的下一个迭代中，我们将介绍对<em>特定</em>于<em>环境的</em> Bean的支持。特定于环境的Bean提供了一种更直接的方式，可以根据某些环境切换是否正确来将Bean“打开”。这在一些定义明确的场景中很有用，在这种场景中，bean的配置在不同的环境中会发生巨大变化。这里的示例-在测试中使用嵌入式数据库，但另一个<code>javax.sql.DataSource</code>在生产中就是这样一种情况。当然，还有其他一些方法可以使用Spring 3.0或更早的版本来实现相同的灵活性，包括<code>FactoryBean</code>和<code>PropertyPlaceHolderConfigurer</code> s。</div><p>回顾前面的示例，我们可以声明我们的<code>javax.sql.DataSource</code>叫<code>ds</code>像这样，改为：</p>
<pre><code class="prettyprint xml">    &lt;bean id=&quot;ds&quot; class=&quot;org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseFactoryBean&quot;&gt;
        &lt;property name=&quot;databaseType&quot; value=&quot;H2&quot;/&gt;
        &lt;property name=&quot;databasePopulator&quot;&gt;
            &lt;bean class=&quot;org.springframework.jdbc.datasource.init.ResourceDatabasePopulator&quot;&gt;
                &lt;property name=&quot;scripts&quot; value=&quot;setup.sql&quot;/&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
    &lt;/bean&gt; 
</code></pre><p>这个<code>FactoryBean</code>负责读取任何SQL脚本（我只指定了一个名为<code>setup.sql</code>在这里，尽管您可以指定任意数量（用逗号分隔），然后将它们加载到数据库中，然后返回<code>javax.sql.DataSource</code>以简单，方便的方式实例化。</p><p>我们已经看到了强大的拳头<code>FactoryBean</code>可以打包。精心设计<code>FactoryBean</code>将显示最有可能在设置对象中有用的选项，并且在运行时还将提供有关各种选项的无效配置的反馈。但是，通过XML模式提供的验证，XML可以在设计时提供更多指导。这就是Spring框架长期支持使用基于XML模式的名称空间的原因，该名称空间描述了实现更多反馈和简化的功能。让我们回顾一下嵌入式数据库示例。Spring框架提供了一个用于配置嵌入式数据源的名称空间。要在Spring中使用名称空间，您只需限定名称空间并添加对<code>schemaLocation</code>元件。经过修改以支持JDBC XML名称空间的先前的Spring配置文件如下所示：</p>
<pre><code class="prettyprint xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans  http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd&quot;&gt;
  &lt;!-- ...  same as before ... --&gt;
&lt;/beans&gt;
</code></pre><p>通过此声明，可以在任何现代IDE的XML自动完成功能中提出名称空间中的限定元素。安装此程序后，我们现在可以用更简洁的内容替换以前的声明。</p>
<pre><code class="prettyprint xml">   &lt;jdbc:embedded-database id=&quot;ds&quot; type=&quot;H2&quot;&gt;
        &lt;jdbc:script location=&quot;classpath:setup.sql&quot;/&gt;
   &lt;/jdbc:embedded-database&gt;
</code></pre><p>从功能上讲，它等效于前面的示例：它创建一个嵌入式数据库，并在启动嵌入式数据库时评估脚本的内容。它创建一个类型的对象<code>javax.sql.DataSource</code> ，就像以前一样。我们已经轻松地将嵌入式数据库简化为实质。看来我们的工作已经完成，我们可以继续前进，对吗？好吧，不完全是。我们仍然可以做更多的事情来删除配置。此处显示的某些代码是我们编写的自定义代码。如果我们愿意为代码添加注释，那么我们可以让Spring找出适合我们的事情，而不必明确地将其拼写出来。为此，我们需要将上下文名称空间添加到文件中并启用组件扫描。组件扫描将扫描带有特定注释的bean，然后自动注册它们。同样，将处理在类本身上发现的注释。这是修订的XML文件，其中包含适当的XML名称空间。</p>
<pre><code class="prettyprint xml"><br />&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
 	  xsi:schemaLocation=&quot;... http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:component-scan base-package=&quot;org.springframework.samples&quot;/&gt;
    &lt;!-- ...  same as before ... --&gt;
&lt;/beans&gt;
</code></pre><p>我们在中注释的所有bean <code>org.springframework.samples</code>与Spring框架一起打包<code>@Component</code>注释将被拾取并与上下文一起注册为bean，就像我们使用来配置它们一样<code>bean</code> XML中的元素。我们已经注释了<code>DatabaseCustomerService</code>和<code>CustomerClient</code>与类<code>@Component</code> ，这使我们可以删除等效项<code>bean</code> XML配置中那些bean的元素。组件扫描非常方便，因为尽管分散了配置，但Spring承担了很多繁重的工作。</p><p>我们知道这个bean依赖于<code>JdbcTemplate</code> 。的<code>JdbcTemplate</code>已在上下文中配置。由于仅配置了一个，因此我们可以使用<code>@Autowired,</code>它告诉Spring按类型解析依赖关系并将其注入。如果在上下文中配置了多个实例，则在这种情况下将引发错误。</p>
<div style="border:1px solid black;padding:10px"><strong>依赖关系解析的注释-</strong>有很多方法可以告诉Spring要在之上和之后注入哪个bean <code>@Autowired</code> 。您可以使用JSR 330支持的注释，例如<a href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/htmlsingle/spring-framework-reference.html#beans-autowired-annotation" target="_blank"><code>@javax.inject.Inject</code></a>或JSR 250 <a href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/htmlsingle/spring-framework-reference.html#beans-resource-annotation" target="_blank"><code>@javax.annotation.Resource</code></a>或Spring的<a href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/htmlsingle/spring-framework-reference.html#new-feature-java-config" target="_blank"><code>@Value</code></a>注解。</div>
<pre><code class="prettyprint java">package org.springframework.samples;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

import java.sql.ResultSet;
import java.sql.SQLException;

@Component
public class DatabaseCustomerService implements CustomerService {
    private JdbcTemplate jdbcTemplate;
    private RowMapper&lt;Customer&gt; customerRowMapper = new CustomerRowMapper();

    public Customer getCustomerById(long id) {
        return jdbcTemplate.queryForObject(
            &quot;select * from CUSTOMERS where ID = ?&quot;, this.customerRowMapper, id);
    }

    @Autowired
    public void setJdbcTemplate( JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    class CustomerRowMapper implements RowMapper&lt;Customer&gt; {
        public Customer mapRow(ResultSet resultSet, int i)  throws SQLException {
            String fn = resultSet.getString(&quot;FIRST_NAME&quot;);
            String ln = resultSet.getString(&quot;LAST_NAME&quot;);
            String email = resultSet.getString(&quot;EMAIL&quot;);
            long id = resultSet.getInt(&quot;ID&quot;);
            return new Customer(id, fn, ln, email);
        }
    }
}
</code></pre><p>最后一类是利用<code>CustomerService</code>实例。我们像以前一样使用<code>@Component</code>注解。它需要参考<code>CustomerService</code>实例就像<code>DatabaseCustomerService</code>实例需要引用<code>JdbcTemplate</code> 。所以，我们用我们的老朋友<code>@Autowired</code> 。</p>
<pre><code class="prettyprint java">package org.springframework.samples;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.support.GenericXmlApplicationContext;
import org.springframework.stereotype.Component;

@Component
public class CustomerClient {
	private CustomerService customerService ;

	@Autowired
	public void setCustomerService(CustomerService customerService) {
		this.customerService = customerService;
	}

	public void printCustomerInformation ( long customerId ) {
		Customer customer = this.customerService.getCustomerById( customerId );
		System.out.println( customer ) ;
	}
}
</code></pre><p>我们修改后的XML文件大大减轻了我们的麻烦：</p>
<pre><code class="prettyprint xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:component-scan base-package=&quot;org.springframework.samples&quot;/&gt;

    &lt;jdbc:embedded-database id=&quot;ds&quot; type=&quot;H2&quot;&gt;
        &lt;jdbc:script location=&quot;classpath:setup.sql&quot;/&gt;
    &lt;/jdbc:embedded-database&gt;

    &lt;bean class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot; id=&quot;jdbcTemplate&quot;&gt;
        &lt;constructor-arg ref=&quot;ds&quot;/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</code></pre><p>我们使用了名称空间支持来简化配置嵌入式系统的工作。 <code>javax.sql.DataSource</code>实例。我们已经使用组件扫描来让Spring自动注册<code>DatabaseCustomerService</code>和<code>CustomerClient</code>豆给我们。看起来情况不错，但我们仍在使用XML来描述<code>JdbcTemplate</code>我们可以用Java更容易地描述它。在这种情况下，XML并不是比常规Java更具吸引力的解决方案。它仅提供奇偶校验。如果我们可以将组件扫描用于<code>JdbcTemplate</code>实例也是如此。但是，组件扫描仅适用于带注释的Bean。 <code>@Component</code> 。由于我们无法添加<code>@Component</code>对于我们可能没有源代码的第三方类的注释，对于<code>JdbcTemplate</code>实例。</p><p>Spring提供了Java配置支持，使您可以直接使用Java描述和配置bean。Java配置选项提供了两全其美的优点：它允许您配置任何类，即使您没有源代码的类（如使用XML Configuration选项），并且它仍然以Java为中心，因此可从所有类型安全中受益Java语言（以及Java IDE中可用的重构工具）。</p><p>Java配置处理在上下文中注册的bean，并查找带有注释的方法<code>@Bean</code>并调用它们。方法调用的结果作为一个bean向应用程序上下文注册，就像使用XML配置对象一样。 Bean的类型是返回对象的类型， <code>id</code>从方法名称中获取。由于配置是由该方法中的Java代码提供的，因此您可以进行任何设置方式，就像<code>FactoryBean</code>让你做。人们经常选择Java配置选项，因为它使您可以将Bean配置保留在一个或两个众所周知的中央类中。XML配置和Java配置都提供了一种集中描述您的应用程序的方法。</p><p>就像其他任何类一样，配置类是Spring bean。适用于常规Spring Bean的所有规则均适用于配置Bean，但带有注释的方法除外<code>@Bean</code> 。Spring将通过组件扫描来获取您的配置类。如果要在配置类中使用其他bean（例如， <code>javax.sql.DataSource</code>之前使用XML名称空间配置的实例），那么您就可以使用所有常规选项来获取它们，包括<code>@Autowired.</code> 。让我们来看一下示例的配置类。</p>
<pre><code class="prettyprint java"><br />package org.springframework.samples;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.stereotype.Component;
import org.springframework.jdbc.core.JdbcTemplate;

import javax.sql.DataSource;

@Configuration
public class CustomerConfiguration {

	@Autowired private DataSource dataSource;

	@Bean
	public JdbcTemplate jdbcTemplate() {
		return new JdbcTemplate(this.dataSource);
	}
}
</code></pre><p>该类使用<code>@Autowired</code>获得对嵌入式数据源的引用。这与先前示例中使用的方式类似，不同之处在于，这里我们在专用字段变量（而不是setter方法）上使用批注。Spring框架将在类的构造函数，字段变量或setter方法上使用注释。最后，我们有一个注释为<code>@Bean.</code>此方法提供了<code>JdbcTemplate</code>实例，这意味着我们可以从文件中删除XML配置。我们不在这里，但是您可以定义多个<code>@Bean</code>定义类中的方法，它们可以通过相互调用来相互引用。如果一种方法带有注释<code>@Bean</code>调用另一个，返回值将是一个新创建的对象，或者-如果已经创建了bean-已经在上下文中注册的bean。在上面的课程中，我们还有一个<code>@Configuration</code>类上的注释。这个注释告诉Spring将此类视为专门用于配置的特殊类型的组件。本质上，此bean受益于与在Spring上下文中注册的任何bean相同的所有服务， <em>并且</em>已对其应用了额外的服务以启用Java配置。要使用Java配置，请确保在类路径上具有CGLIB库。</p><p>最终的修订XML文件如下所示：</p>
<pre><code class="prettyprint xml"><br />&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:component-scan base-package=&quot;org.springframework.samples&quot;/&gt;

    &lt;jdbc:embedded-database id=&quot;ds&quot; type=&quot;H2&quot;&gt;
        &lt;jdbc:script location=&quot;classpath:setup.sql&quot;/&gt;
    &lt;/jdbc:embedded-database&gt;   

&lt;/beans&gt;
</code></pre><p>在本文中，我们通过Spring的依赖注入功能追踪了您可以遵循的步骤，以使代码库更简洁，更友好。尽管我们谈论的奇妙技术提供了比其他任何方式都更高的灵活性和更多功能，但重要的是要记住，这种令人难以置信的支持已经存在了至少4年。多数情况持续了许多年。人们将这些片段用作其应用程序的基础已经很久了。依赖注入和控制反转仅仅是开始。Spring框架在此处建立的组件模型的基础上，为大量不断增长的用例提供了许多简化库。</p><p>在Spring之上构建应用程序时，可以将自己与应用程序所部署到的Web服务器，应用程序服务器和云环境的锁定隔离开来，同时最大程度地提高对基础平台的投资回报。</p></div>
</div>
<section id="disqus_thread"></section>
<script type="text/javascript">
      var disqus_shortname = 'spring-io';
      var disqus_identifier = 373;

      (function(disqus_shortname, document) {
        injectScript('//' + disqus_shortname + '.disqus.com/embed.js');
        injectScript('//' + disqus_shortname + '.disqus.com/count.js');

        function injectScript(url) {
          var s = document.createElement('script');
          s.async = true;
          s.src = url;
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(s);
        }

      }(disqus_shortname, document));
    </script>
<noscript>请启用JavaScript以查看<a href="http://disqus.com/?ref_noscript">由Disqus提供</a>的<a href="http://disqus.com/?ref_noscript">评论。</a></noscript>
<a class="dsq-brlink" href="https://disqus.com">由<span class="logo-disqus">Disqus</span>提供动力的评论</a>
<div class="mobile-only">
<p><a href="/blog">
<i class="icon-chevron-left"></i>背部</a></p>
</div>
</article>
<aside class="span4 mobile-right-pane" id="sidebar">
<div>
<ul class="right-pane-widget--container secondary-nav with-icon">
<li class="blog-category">
<div class="icon blog-icon all-posts"></div>
<a href="/blog">所有帖子</a> <a class="pull-right" href="/blog.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category active">
<div class="icon blog-icon engineering"></div>
<a href="/blog/category/engineering">工程</a> <a class="pull-right" href="/blog/category/engineering.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon releases"></div>
<a href="/blog/category/releases">发布</a> <a class="pull-right" href="/blog/category/releases.atom"><i class="icon-rss"></i></a>
</li>
<li class="blog-category">
<div class="icon blog-icon news-and-events"></div>
<a href="/blog/category/news">新闻与活动</a> <a class="pull-right" href="/blog/category/news.atom"><i class="icon-rss"></i></a>
</li>
</ul>
<ul class="social-btn--container">
<a class="social-btn twitter" href="https://twitter.com/springcentral"></a>

<a class="social-btn linkedin" href="https://www.linkedin.com/groups/46964"></a>
<a class="social-btn youtube" href="/videos"></a>
</ul>
<div id="blog-sidebar-newsletter">
<p>将The Spring Team的更新发送到您的收件箱</p>
<script src="https://app-sj05.marketo.com/js/forms2/js/forms2.min.js"></script>
<form id="mktoForm_4723"></form>
<script>
        MktoForms2.loadForm("https://app-sj05.marketo.com", "625-IUJ-009", 4723, function(form){
          form.onSuccess(function(values, followUpUrl) {
            form.getFormElem().html("<p>Thank you!</p>");
            return false;
          });
        });
      </script>
</div>
</div>
</aside>
</div>
</div>
</div>
<footer class="footer">
<div class="container-fluid">
<div class="row-fluid">
<div class="span12">
<div class="navbar">
<div class="container">
<ul class="nav">
<li><a href="/team">球队</a></li>
<li><a href="/tools">工具类</a></li>
<li><a href="https://store.pivotal.io/">商店</a></li>
<li><a href="/blog">通讯</a></li>
</ul>
</div>
</div>© <span>2019</span> <a href="https://www.pivotal.io/">Pivotal Software</a> ，Inc.保留所有权利。
<a href="https://pivotal.io/terms-of-use">使用条款</a> • <a href="https://pivotal.io/privacy-policy">隐私</a> • <a href="/trademarks">商标准则</a>
<div id="teconsent" style="display:inline-block"></div>
</div>
</div>
</div>
</footer>
<div id="scrim"></div>
</div>
</body></html>